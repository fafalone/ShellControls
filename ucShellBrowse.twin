[ FormDesignerId ("8CE9DEA3-CF96-4344-87A8-3F6F9ECBBD42") ]
[ ClassId ("64B7FBF6-FCB5-470D-A624-EB45FDD4A7A0") ]
[ COMControl ]
Public Class ucShellBrowse
Option Explicit


Private Const mVersionStr = "ucShellBrowse 11.3"
Private Const mVersionApp = "ucShellBrowse"
Private Const mVersionMjr = 11
Private Const mVersionMnr = 3
#Region "README"
' ********************************************************************************
' *                                                                              *
' * ucShellBrowse v11.3 - twinBASIC Version - x84/x64 compatible ***BETA***      *
' * Shell Browser Control                                                        *
' *                                                                              *
' * Released: January 19th, 2023                                                 *
' *                                                                              *
' * Author: Jon Johnson (aka fafalone).                                          *
' * (c) 2017-2023                                                                *
' *                                                                              *
' ********************************************************************************
'
'Special thanks to the others whose code forms part of this control,
'either directly or via me porting it:
'-Paul Caton/LaVolpe, for the self-subclass/callback code.
'-Charles P.V. for the ListView subitem ratings stars and progressbar.
'-Timo Kunze for some undocumented ListView functions.
'-Krool for some Font properties and the LVBKIMAGE functionality.
'-JoshT for the file writing class the logger is based on.
'-All the icons are from various freeware sources or from Windows,
' from imageres.dll/shell32.dll, none were made by me.
'-Thanks to The_trick for showing how to encode those icons as binary
' data in a bitmap, allowing them to be stored on the form instead of
' in a resource file.
'
'This control is self-contained. You do not need any other files in
'your project for code, and just the one TLB reference for the IDE if
'using the control as a .ctl-- not needed if used as an ocx (unless
'you want to use any method/event with a shell interface as a param).
'A manifest is strongly advised; see below.
'
'For questions, comments, and bug reports, stop by the project thread:
'http://www.vbforums.com/showthread.php?854147
'You can also e-mail fafalone at gmail
'
'--------------------------------------ABOUT--------------------------------------
'This UserControl covers the full spectrum of needs for browsing the
'Windows Shell. At the very simplest, it provides a visually updated
'replacement for the built-in VB controls File, Dir, and Drive ListBox.
'Any of those can be replicated individually or combined. At the other
'end, this control can replicate a full-blown Explorer window, with all
'of its features and more, including previews, properties, search, etc.
'The extreme flexibility provides those options and everything else in
'between. The enhancements go way beyond Explorer as well, keep reading
'for the full feature list, or just dive right into the Properties list,
'a lot of work has been put into making everything easy to use.
'
'This is a stand-alone control without dependencies apart from a single
'TLB reference, and only in the IDE when you're using it as a .ctl; you
'can also use it as an ocx (with no need for a TLB anywhere).
'If you prefer a TreeView for folder navigation rather than a dropdown,
'this project is fully compatible with my ucShellTree project:
'http://www.vbforums.com/showthread.php?862137
'
'----------------------------------REQUIREMENTS-----------------------------------
'-Windows Vista or newer*
'-tlb v4.62 or higher.
'      -Not needed for compiled .exe whether ocx or ctl is used.
'      -Still needed for OCX version if you need to respond to events with
'       IShellItem/IShellItemArray (for the IDE, the tlb doesn't need to be
'       redistributed with the compiled exe under any circumstance).
'
'STRONGLY RECOMMENDED: Common Controls 6.0 - The control does work without
'    this, but some features are missing/degraded. Group mode, tile view,
'    thumbnail view, and footer items are all unavailable. When renaming,
'    the extension can't be excluded by default.
'    CC6.0 are added via a Manifest. If you're not familiar with program
'    manifests, see http://www.vbforums.com/showthread.php?845909
'    The Demo Project in \Demo contains a manifest.
'
'
'* - This control is specifically intended to showcase new features only
'    possible with APIs and interfaces first introduced in Vista; so the
'    requirement isn't there just because of some little thing, and it's
'    not reasonably possible to maintain compatibility with XP.
'    HOWEVER, this control is inspired by Brad Martinez' VBExplorer and
'    EnumDeskVB, which are shell browsers designed on and for Windows XP
'    or earlier. "Brad's VB-32 Programs and Samples" has long since
'    disappeared into the ether, but I have a full site archive and can
'    send you VBExplorer, EnumDeskVB, and anything else from there, if
'    you like the idea of a manually built shell browser, but absolutely
'    have to support Windows 95-Windows XP. Just shoot me an e-mail or PM.
'
'--------------------------------Note on High DPI---------------------------------
' You may ignore this section if you don't have Zoom set on your monitor.
'    This control supports high DPI scaling, but uses an API, one
'    that can't be avoided (TrackPopupMenu) that has serious issues. If
'    your monitor is scaled, and DPI scaling is off in the control, the
'    menu will pop up in the right place a few times, then in the wrong
'    place, way off the control, with no way to predict this behavior.
'    So it is strongly recommended that if you plan on using this control
'    on scaled monitors, you either use a manifest with dpiAware=true,
'    which the download contains in resDemo.res, or without that type
'    of manifest but in the 'Compatibility' tab in your EXE properties,
'    select 'Disable display scaling on high DPI settings, which for some
'    reason enables the controls scaling the same as dpiAware=true.
'
'----------------------------------KEY FEATURES-----------------------------------
'-Functions as any of the VB file controls: Files Only, Folders Only,
' (the dropdown), and restricting that to Drives Only.
'-Full Unicode support
'-Icons, display names, and properties are identical to what a user
' sees in Explorer. Includes overlay icons for things like shares
' or links; supports custom ones like used by DropBox or Github.
'-Full navigation tree from the desktop-- virtual objects that are
' part of the file system, such as Computer or Libraries, are able
' to be used normally, and the selections real file system path is
' resolved and returned.
'-Support for several different view modes: Large icon, small icon,
' list, details, tiles, contents, and thumbnails.
'-Images and all types with a registered preview handler can be
' previewed in a frame
'-'Group by' is fully implemented; can group for extended properties
'-Right click brings up the standard shell context menu
'-Sort is supported for all columns and uses the same API that is
' used by Explorer, so order is identical
'-Details pane like Explorer to show some file details in the view; also
' supports editing fields where possible
'-Supports rename-in-place
'-Supports both dragging out and receiving dropped files, complete
' with the file icons you see in Explorer (includes drag/drop entirely
' within the control).
'-All column headers found in Explorer are available
'-Ability to show/hide by default the main columns (name is always
' shown but size,type,datemod (on by default) +datecreated,dateaccessed
' can be toggled
'-The Back/Up/View control box can be shown or hidden; this combined with
' the columns option allows you to create a more compact look if needed
'-There's substantial interaction with the host form, informing your program
' of selection change, clicks, double clicks/enter press, directory change,
' renames, and file drops. These events provide both full paths and references
' to the file(s) IShellItem(Array) interfaces
'-The startup path can be customized and is remembered. The current path can
' be manually changed through a .BrowserPath property.
'-Custom draw is used to show encrypted files in green and compressed files in
' blue to be consistent with Explorer (this can also be forced on or forced off)
'-A footer bar can be added to the file list (like in Explorer search results).
'-Explorer-style tool tips show details about the selected item; the properties
' shown depend on the file type, loading the same ones as Explorer does.
'-Start a search of the current directory and subdirectories.
'-Opens certain internet locations that Explorer can open. For example, you can
' set an ftp:// URL as the BrowserPath or CustomRoot, and the ftp site will
' successfully load.
'
'-----------------------------KEYBOARD SHORTCUT LIST------------------------------
'Per the issue in 6.2 regarding shortcuts, I'm going to put a complete simplified
'list of all the shortcuts the ListView uses, to more easily avoid conflict.
'If you wish to disable any of these, they're found in ucWndProc.
'To disable all at once, see the User Options section below this changelog.
'-F2 : Initiate rename (label edit) on currently focused file
'-F5 : Refresh
'-Bkspc : Navigate to parent folder
'-Alt+Up : Navigate to parent folder
'-Alt+Left : Open previous location from history
'-Alt+Right : Open next location in history
'-Esc : Clear selection
'-Del : Delete to Recycle Bin
'-Shift+Del : Permanently delete
'-Ctrl+A : Select All
'-Ctrl+C : Copy file(s) to clipboard
'-Alt+D : Set focus on the directory dropdown (if present)
'-Ctrl+F : Set focus on the search box (if present)
'-Ctrl+Shift+N : Create New Folder
'-Ctrl+X : Cut selected file(s)
'-Ctrl+V : Paste any files in the clipboard to the current folder
'-Alt+P : Toggle the Preview Frame
'-Ctrl+Shift+P : Display ucShellBrowse version information and OS/ComCtl info
'-ContextKey : Display the Shell Context Menu, if the menu enabled
'--
'-Ctrl+Y : Redo (if available; generally does not work)
'-Ctrl+Z : Undo (if available; generally does not work)
'-------------------------------End of shortcuts list-----------------------------
'
'-----------------------------Using Custom Icon Mode------------------------------
'Version 9.3 introduced an option to supply custom icons for each file.
'This is the SB_VIEW_CUSTOM member of the View Modes.
'
'The CustomIconsEnabled option sets whether this mode appears in the View Menu.
'You can of course set the mode to SB_VIEW_CUSTOM in your control Properties or
'though code and not have this or any option to switch view modes. If it is in
'the menu, it uses the caption from CustomIconsCaption.
'
'Set the size the custom icons will be in the CustomIconsSize property. This value
'will be multiplied by the DPI zoom factor, the final value will be reported when
'the control asks for the icons.
'
'Next, when the control needs an image (which could be during the folder load, or
'later when it's scrolled into view, depending on mode), it raises the event
'QueryCustomIcon. This event supplies a number of details about the file (this
'includes a reference to the pidl, it's not a copy so don't free it), and a value
'indicating the size the control is using, which is the value from CustomIconsSize
'multiplied by the DPI zoom. The next two params are what you set to a handle for
'your image. You only need to specify either an HBITMAP or an HICON, not both, if
'both are set it uses the HICON. The last argument indicates whether to free the
'image with DestroyIcon/DeleteObject after it's added.
'
'Finally, if a file with an overlay, such as a link, is encountered, the event
'QueryCustomIconOverlay is raised. Do not set a return value to use the system
'overlay for that index, set it to 0 to not use one, or supply your own, again as
'either an HBITMAP or HICON with the size specified by the cxy argument.
'
'NOTE: This may be unstable in the IDE, but works fine when compiled.
'---------------------------------------------------------------------------------
'
'------------------------------------CHANGELOG------------------------------------
'
'New in v11.3
'
'-Added option to apply filter to ComboBox; a FilterDropdown event has been
' added, defaulting to show all.
'
'-The initial width of the Select Columns popup is now scaled to DPI.
'
'-In the Select Columns popup, when advanced mode was enabled you could sort the
' columns; but this did not keep the default columns at the top. They will now
' remain there at the top. This behavior can be disabled with the
' bPreserveDefColFirstInColSort UserOption.
'
'-Default text of 'Ready' or number of files selected is now restored after the
' status message resets after moving off a menu tip.
'
'-Added dbg_IncludeName to include control name (Ambient.DisplayName), useful for
' forms with multiple browser controls.
'
'-(Bug fix) In the search popup, the Clear button didn't clear the search text
'           when present there instead of the toolbar (it won't clear the one
'           in the toolbar by design).
'
'-(Bug fix) Some locations besides This PC have improperly implemented Category
'           objects. They would expose a Category Provider, supply a Default
'           Category, then cause an error when queried for the ICategorizer
'           object, resulting in nothing being loaded.
'           Microsoft has deliberately broken 3rd party compatibility in this
'           instance in order to prevent competition for Explorer, as even when
'           you worked around this, it will not supply the proper column data
'           for all items; only for a random smattering of them.
'           So I fixed the fatal error and you can load locations like the new
'           Quick Access folder, but you can't group by the special properties
'           of the items within.
'
'-(Bug fix) pvCreateDetailPaneBkg had a hard coded English string; switched to
'           appropriate constant from localization section (existed already).
'
'-(Bug fix) ThumbnailSize property would continuously increase if dpi awareness
'           was enabled for the IDE.
'
'
'New in v11.2 (Released 18 Jun 2022)
'
'-Added SearchAutoGroup to automatically group search results. The default is to
' group them by folder, but you can change that via the szAutoGroupSearchCat
' User Option.
'
'-In addition to below specific bug identified, added a more robust system of
' ensuring duplicates are not added by receiving duplicate ShellNotify messages.
'
'-SelectedFiles (Let) and FileSetCheck are no longer case sensitive.
'
'-Now use Unicode-aware width calculations in Details Pane.
'
'-(Bug fix) In Computer/This PC, for some Windows versions removing a USB device
'           then plugging it back in could result in duplicate entries.
'           Also improved entry remover to better handle these.
'
'-(Bug fix) SelectedFileSet ignored bDeselectOthers flag.
'
'-(Bug fix) The control improperly reported the Windows version due to Microsoft
'           breaking most version functions to require a manifest specifying 10
'           compatibility or else it deliberately reports Windows 8. This didn't
'           impact functionality as the only version-restricted features were
'           Vista+ to run at all, and Windows 8+ for some Bookmarks folders.
'
'-(Bug fix) Since version 9.4, pressing enter in the Search Box accidentally
'           had the code to use the legacy search enabled. That would be conducted
'           first, then the new search would be conducted. This doubled (at least)
'           the search time and created a duplicate folder.
'
'-(Demo)    The Demo manifest, with the preferred settings, has been updated to
'           include compatibility flags, trust info, and newer dpi awareness.
'
'New in v11.1 (Released 02 Feb 2022)
'
'-Provided some advanced item data access. zz_ExportSelectedItemFullData and
' zz_ExportItemFullDataByPos export the full internal item data structure.
' How to use these:
'   Step 1: Copy type definitions for UCSBFile, UCSBF_ColLink, and ColumnCache
'           to the calling form/module.
'   Step 2: Declare a UCSBFile variable, and 3 Long's to be passed as arguments
'           for the function: One to receive the memory pointer, and array
'           bounds for the LinkCols and ExtColData arrays in UCSBFile.
'   Step 3: Redim UCSBFile.LinkCols(nLinkCol) and UCSBFile.ExtColData(nExtColData)
'   Step 4: CopyMemory to UCSBFile from ByVal pData (only if function returns >0!)
'   Step 5: You *must* zero out the structure with ZeroMemory before the procedure
'           exits, otherwise it will free the strings and objects, likely causing
'           a crash when the control tries to access them again.
'  Note: As Step 5 might suggest, you must treat the structure as read-only.
'        Attempting to change values could result in instability or crashing.
'        This access is not meant for casual use; unless you really know the ins
'        and outs of passing structures like this you're better off just adding
'        an export for the fields you need.
'
'
'-Also added InvokeKeyPress to invoke a key press on the ListView by code. Has
' options for Shift/Control/Alt and whether to raise the ListKeyDown event.
'
'-CustomColor event now includes dwState argument that passes the CDIS_* values
' in NMLVCUSTOMDRAW.iStateId.
' ***EVENT PROTOTYPES ON YOUR FORMS MUST BE UPDATED!***
'
'-Set the ListView LabelEdit edit box length limit to MAX_PATH, to avoid an error
' when attempting rename.
'
'-(Bug fix) In high performance mode, showing hidden would also show superhidden
'           as the FILE_ATTRIBUTE_SYSTEM attribute wasn't checked.
'
'-(Bug fix) SelectedFile(Let) and SetSelectedFile selected the wrong file.
'
'-(Bug fix) If FileExtensions was set to AlwaysShow, drive names in This PC would
'           not be displayed at all, and some virtual items displayed GUIDs.
'
'-(Bug fix) When switching into some view modes without ComCtl6, an "Invalid
'           Window Handle" error would be displayed.
'
'
'
'New in v11.0 (Released 25 Jan 2022)
'
'
'-Added option ExplorerStyleSelection. Makes the ListView work like Explorer; if
' in Details View with Multiselect enabled, you can start a marquee to select
' multiple files by dragging in the whitespace of the Name column, rather than
' need to go off to the side. Enabled by default.
' Note: Does not work in Windows Vista.
' Note: This is an undocumented ListView feature. As such, it may be dropped from
'       future versions of Windows. However, it's confirmed to be working in
'       Windows 10, and it will simply stay with the old selection style if the
'       call fails, it will not break the control.
'
'-Added ClearSelection method to deselect all items.
'
'-Added new public SelectedFileSet sub with more options; allows select/deselect,
' separate option for focus, option to deselect all others, and ensure visible.
' SelectedFile (Let) wasn't changed since optional arguments aren't allowed and
' adding non-optional ones would break people's existing code.
'
'-SelectedFile (Let) is no longer case sensitive, since filenames are not.
'
'-New SetSelectedItemsEx function that provides a far more robust way of selecting
' files. Supports wildcards for selecting many. Options:
'   bDeselectPrev - Clears any existing selection.
'
'   nMaxMatches - If sName contains wildcards, specifies maximum matches.
'                 0 = unlimited. Does not override Multiselect; so if Multiselect
'                 is False, any value larger than 1 is invalid.
'
'   iSelectType - Match sName against Files only, Folders only, or both.
'
'   bEnsureVisible - Scrolls the selected item into view. If multiple selections
'                    made, applied to the first match.
'   bCaseSensitive - Applies both with and without wildcards.
'
'   bZipIsFile - 0: Follow BrowseZip setting, 1: Always folder, 2: Always file
'
'   Returns files selected. Note: First match receives focus.
'
'
'-(Bug fix) High performance mode was broken on Windows 10.
'
'-(Bug fix) On some special editions of Windows 10, including LTSC, special folders
'           are not included, causing the Bookmarks menu to not show due to a bug
'           in handling errors generating that submenu.
'
'-(Bug fix) Some FILETIME and RECT types weren't explicitly defined, leading to
'           naming conflict errors in certain scenarios.
'
'-(Bug fix) On some versions of Windows 10, Special folders in This PC were grouped
'           with the drives.
'
'-(Bug fix) On Windows 10, some Security Zone icons failed to load.
'
'-(Bug fix) Keyboard focus never went to ucTreeView when on a form w/ ucShellBrowse.
'
'-(Bug fix) The arrow keys wouldn't work on the first click of the ListView.
'
'
'
'
'New in v10.0 R4 (Released 29 Apr 2021)
'
'-Updated GetPropertyDisplayString snd GetPropertyKeyDisplayString to handle arrays
' in the manual fallback handler for properties without an IPropertyDescription.
'
'-(Bug fix) When the StatusBar and/or DetailsPane was enabled, resizing the control
'           below a certain point caused the ListView to stop resizing, forcing the
'           bar and pane onto it, causing graphical glitches. This was related to
'           the fix put in place to stop crashes from resizing a thicker border too
'           low; that code fired when it shouldn't.
'
'New in v10.0 R3 (Released 29 Apr 2021)
'
'-(Bug fix) The minimum height for the control was being enforced, but was not
'           appropriate for DirOnly/DriveOnly/DirOnlyCtl, which left a big chunk
'           of blank space under the control that might cover up other objects on
'           your form.
'
'New in v10.0 R2 (Released 28 Apr 2021)
'
'-(Bug fix) If the Search Box was enabled, but the mode set to FilesOnly, then you
'           changed to Dir+Files or other mode with the top bar, the Search Box
'           did not become visible along with everything else.
'
'
'New in v10.0 (Released 24 Apr 2021) - Also partially released as 9.6 R3/9.7.
'   Numerous features have been added throughout the day, and after I point I just
'   pulled the project entire.
'   After that, I took my time and conducted an extensive review of every Property
'   and public method, and resolved numerous additional bugs.
'   With that and some additional features, it's time for a Major Version change.
'
'
'-Changing the Combo Type to DropdownList then back had ComboCanEdit set to false
' which could be confusing if it had been true before. Added checks to obviate the
' need for doing that.
'
'-For the ComboType DropdownList, added arrow key functionality. Down arrow opens
' the dropdown, then arrow keys move up/down and enter navigates to the currently
' highlighted folder. For the standard Dropdown type, the control automatically
' opens the folder above/below with the arrow keys; there's no way to drop down
' the list like the other mode.
'
'-Changed the default SearchBoxWidth from 115 to 140.
'
'-Now loads a larger icon for the Security Zone icon when m_ScaleX > 1. Previously,
' the icon was always 16x16 and therefore *extremely* tiny.
'
'-Spaced out the columns in the Details Pane a bit and added the yDetailSpacer
' User Option to easily customization this column spacing factor. Minimum=18.
'
'-Autocomplete by default shows a popup results list now.
'
'-FilesOnly and FoldersOnly now refresh the view to apply the change.
'
'-The InfoTipsLimitForHPF property replaces the bLimitInfoTipsInHighPerfMode
' User Option. Don't use QITIPF_USESLOWTIP or QITIPF_LINKUSETARGET in HighPerf
' mode. Mainly affects showing Size/Files/Folders on folder tips.
'
'-(Bug fix) Unfortunately there were still outstanding issues with the ComboBox.
'           The tab loop didn't work at all in DropdownList mode. The tab cycle
'           would get stuck in the ListView.
'
'-(Bug fix) Changing ShowSecurityZone during runtime resulted in multiple bad
'           status panels being added.
'
'-(Bug fix) If the startup view was Md/L/XL Icon or Thumbnails, Custom Shortcut
'           Overlay will not load, and the system default is used.
'
'-(Bug fix) The Security Zone panel didn't autoresize; some zones may have been
'           truncated.
'
'-(Bug fix) The Search Box was having sizing issues. It's not tenable to have its
'           font be the main font and not the FileControls Font (like the Combo);
'           it would be cut off at high DPI even though it was explicitly set to
'           the correct text height. So it's now set to that font.
'
'-(Bug fix) VB .TextWidth/.TextHeight calls do not support Unicode, so some control
'           characters common to PropertyStore strings, which are hidden/are not
'           graphical characters, would be replaced by ?, and formatted strings
'           could have 4+ of these, throwing off the width calculation by including
'           4 characters that are never rendered.
'           This affected the spacing in the Details Pane, primarily because 4 of
'           them are included in strings formatted as a Date.
'
'-(Bug fix) The Bookmark, View, and History menus could not be displayed in
'           DirOnlyWithControls mode, due to the ListView being the parent. The
'           UserControl hWnd is used instead *only if the ListView is not present*
'           avoiding losing the status tips yet again...
'
'-(Bug fix) The 'Thicker' border on the ListView causes too many problems if it's
'           allowed to just resize the ListView, so resizing is blocked. On the
'           whole control, the 'Thicker' border allowed resizing the control to
'           smaller than cxMinUC/cyMinUC, including down to 0 which would then go
'           on to crash/freeze the control and app.
'
'-(Bug fix) While the font applied to controls was limited, some fonts are slightly
'           larger at the same size and this could cause the Column Filter checkbox,
'           Column OK/Cancel buttons to not be wide enough and cut text off.
'
'-(Bug fix) This same issue applied to the Search Options popup. Items were resized
'           to accomdate a larger font that's still within the control font size max.
'
'-(Bug fix) When some items have properties written, Windows does this ridiculous
'           thing with a long sequence of creating several temp files and a bunch of
'           renames. The Notify handler can't make sense of them, and tmp files wound
'           up being added, and the original file with the wrong icon and sometimes
'           type, even when absolutely everything to set those seemed correct.
'           It's now flagged to ignore everything until it gets the last message in
'           the sequence, or an update that indicates only UPDATEITEM fired.
'
'-(Bug fix) SpecialFoldersInBookmarks was not being applied to the Bookmarks menu
'           when it's part of the View Menu from a ListView background click.
'
'-(Bug fix) In HighPerformanceMode, attributes weren't stored with the item, breaking
'           among other things, dimming hidden file icons.
'
'-(Bug fix) Even when AllowRename was True, a label edit could not be initiated to
'           rename a file. In versions before that became the behavior, you could
'           start a label edit, but clicking on the edit box ended the labeledit,
'           and arrows did not work. There were a bunch of extra SetFocusAPI calls
'           causing this from before IPAO.
'
'-(Bug fix) When navigating back to the Custom Folder after adding it earlier, it
'           would not load the associated custom column set, instead loading it
'           just used the current column set.
'
'-(Bug fix) ShowAltDataStreams was not listing the size and was listing the type as
'           File folder instead of "(Alternate data stream)"
'
'-(Bug fix) The description for GroupCollapseGroups was the opposite of what was
'           actually done.
'
'-(Bug fix) The GroupStartCollapsed option, when group based on Name, only had the
'           first group collapsed instead of all of them.
'
'-(Bug fix) SetFocusOnFiles had stopped working at some point.
'
'-(Bug fix) The Properties window has a GroupMode entry visible, but the control
'           was not grouping by in on startup.
'           Note: Only SBGB_Name, SBGB_Size, SBGB_Type, and SBGB_DateModified are
'                 supported on startup.
'
'-(Bug fix) When using ItemFilterFolder, shortcuts to folders would always be added
'           in regular load mode regardless of whether they were a match or not.
'
'-(Bug fix) The New Folder menu item and InvokeNewFolder sub would both create a
'           new folder, but would either never initiate or immediately cancel the
'           label edit to start the rename operation. Further, InvokeNewFolder
'           would add it to the bottom of the list without scrolling to it.
'
'
'*********************************************************************************
'See changelog.txt in the zip for earlier version history.
'*********************************************************************************
#End Region


#Region "UserOptions"
'******************************USER OPTIONS :: ADVANCED SETTINGS FOR CONTROL BEHAVIOR******************************
'
'The following items are user constants and settings meant for users of this control to fine tune how parts of the
'control work. Be careful changing things and remember the default values; there's no error or sanity checks.
'

Private Const cxyMediumIcons As Long = 48& 'Default: 48. The icon size for Medium Icon View
Private Const cxyLargeIcons As Long = 96&  'Default: 96. ..for Large Icon view
Private Const cxyXLIcons As Long = 171&    'Default: 171. NOTE: These values are multipled by zoom
Private Const nSelUpdateMillisecs As Long = 100& 'Default: 100. Timer duration for additional items to be selected after the first one
                                                 'is, so that everything is updated all at once (prevents delay for multisel)
                                                 'MUST BE A MULTIPLE OF 10
Private Const nFilterChangeInterval As Long = -1& 'Default: -1. Similar to above. Buffers HDN_FILTERCHANGE so it doesn't update after every
                                                   'single keypress if the user is actively typing. -1 = use system default.
Private Const cxMinForCtlBoxHide As Long = 85& 'Default: 85. If the Control Box is visible, once the control gets to a certain
                                               'min width, it's automatically (but temporarily) hidden to maintain
                                               'the directory combo while allowing a smaller width
Private cyMaxDetailPane As Long 'This is set in UserControl_Init because it should be pegged to DPI
Private cyMinDetailPane As Long 'Minimum height for the Details Pane; there's little room to make it smaller. UserControl_Initialize
                                            'without rendering/functionality getting screwy. 41 = 32 for unscaled icon + 9 border
Private Const cxMinListView As Long = 45& 'Default: 45. Same as above but for ListView. Will be multipled by scale factor.
Private Const cyMinListView As Long = 35& 'Default: 35.
Private Const cyMinCombo As Long = 45 'Default: 45.
Private Const cxMinColWin As Long = 220& 'Default: 220. Min width for the Choose Columns popup window; includes 20px for border
Private Const cyMinColWin As Long = 100& 'Default: 100. Min height for the Choose Columns popup window
Private Const cxMinUC As Long = 185& 'Default: 185&. Overall UC min width
Private Const cyMinUC As Long = 185& 'Default: 185&. and height.
Private Const cyMinUCD As Long = 32& 'Default: 32&. Directory only/Drive only/Dir+Ctl only
Private Const cxMaxProp As Long = 200& 'Default: 200. The maximum width of an edit control in the Details Pane (will be *scale_x).
Private Const cxMinProp As Long = 50&  'Default:  50. The minimum width of an edit control in the Details Pane (will be *scale_x).
Private Const yDetailSpacer As Long = 40& 'Default: 40. Minimum: 18. How far apart to space colums in the Details Pane.
Private Const nLimitPointSizeForButtons As Long = 10 'Default: 10. Limit the font point size for the buttons in the ListControlBox (up, view..)
Private Const bColLVInheritFont As Boolean = True 'Default: True. Apply the same font to the Column ListView as the main ListView.
Private Const nMaxBookmarks As Long = 48& 'Default: 48. The number of items that can be saved and shown in the Bookmarks menu
Private Const bStatusBarInheritCtlBkColor As Boolean = True 'Default: True. Set the StatusBar background color to the UserControl background color.
                                                            'Not a regular option since it only works when Common Controls 6 are not loaded.
Private Const bSearchOptionsInheritBkColor As Boolean = True 'Default: True. This is generally applicable.
Private Const bColumnSelectInheritBkColor As Boolean = True 'Default: True. Inherit both control colors and ListView colors
Private Const bSearchOptionsPersist As Boolean = False 'Default: False. Keep the Search Options box open after clicking search.
Private Const bDisableRatingStars As Boolean = False 'Default: False. Disable the Rating Stars subitem graphics even if the images are available.
Private Const bDisableProgressItems As Boolean = False 'Default: False. Disable drawing a progress bar for the Percent Used column in Computer (and if ever applicable anywhere else)
Private Const bDisableHyperlinkItems As Boolean = False 'Default: False. Properties like Help Link, Support Link, and others are URLs. You can disable showing (one of) them as links.
Private Const bHideContentViewMenuItem As Boolean = False 'Default: False. On the View Menu, 'Contents' doesn't work all that great. You may want to hide it.
Private Const bUseCustomShortcutOverlay As Boolean = True 'Default: True. If the user has replaced the default overlay, use that instead.
Private Const nManualLinkIconLoadingMode As Long = 1& 'Default: 1. 0=Always disabled, 1=Enabled for links to folders only, 2=Always enabled
Private Const bForceAddPercentFull As Boolean = True  'Default: True. In Explorer, the Percent Full bar is shown by default in Computer, but it's not reported
                                                                     'as such. Since we have a fancy progress bar subitem now, add it back in.
Private Const lPercentFullWarningThreshold As Long = 90 'Default: 90. The percentage at which the Used Space progress bar is drawn red instead of blue (between 0 and 100)
Private Const bAutoGroupCategories As Boolean = True  'Default: True. Some folders, like Computer, have a special category grouping that's based on ICategoryProvider instead
                                                      'of one of the Details Columns. If this special grouping is detected, grouping by it is automatically enabled.
                                                      'If you disable this option, the special 'Category' entry for this will still appear in 'Group By' on the View Menu.
Private Const szAutoGroupSearchCat As String = "System.ItemFolderPathDisplayNarrow" 'Default: System.ItemFolderPathDisplayNarrow. Use this column for SearchAutoGroup.
                                                                                    'Note: Case sensitive. If not already present you must first add it.
Private Const dpiAutoScaleFont As Boolean = True 'Default: True. Can't decide whether this rule should always be applied or not; enable it to slightly increase
                                                 'the font size at higher DPIs (scaled based on current DPI vs 96 DPI and rounded up)
Private Const bExtendedThumbsLimitToMedia As Boolean = False 'Default: False. Extended thumbnails are now handled using the IThumbnailProvider or IThumbnailCache interfaces; this option
                                                             'will limit those methods to only PERCEIVED_TYPE_VIDEO/AUDIO files instead of trying it on all files before
                                                             'proceeding with the old methods.
Private Const bUseThumbProvAndCacheWhenNotExtended As Boolean = False 'Default: False. Use the new interfaces when not in Extended Thumbnails mode, only for non-media files.
Private Const bGroupViewUseIconsForType As Boolean = True 'Default: True. Use the generic icon for that file type to add an icon in the Group Header when grouped by Type.
Private Const bDisableAllKeyboardShortcuts As Boolean = False 'Default: False. Obviously you can disable on a case-by-case or even total basis by editing the LVN_KEYDOWN
                                                            ' in ucWndProc, but why not make it easy by providing a total toggle here. Keypress events
                                                            ' will still be raised.
Private Const bLimitHideIconViewToLogical As Boolean = True 'Default: True. Set to False to allow switching into Large Icon, Tile, etc, views when HideIcons is True (makes little sense).
Private Const lFolderLoadFileUpdateCount As Long = 277& 'Default: 73. When loading a folder, the first 30 files are loaded, and then to speed things up, the display isn't updated until
                                                       'finished, but a status update is sent in a given interval, which you can specify here. Must be a prime number since
                                                       'it looks for count Mod interval = 0.
Private Const bEnableColumnAdvancedMode = True 'Default: True. Enable the 'Advanced mode' option for the Column Select, where the full property system list is added along with system names
                                               '  in order to be able to select a bunch of columns like GPS that don't appear on the normal list.
Private Const bAllowCopyFromReadOnlyProps As Boolean = True 'Default: True. In the Details Pane, keeps read-only property values enabled (but locked) so that the text can be copied.
Private Const bScrollToSelectedAfterSort As Boolean = True 'Default: True. Scrolls the selected item into view if it's out of view after a sort.
Private Const bDisableCopyPathMenuItem As Boolean = False 'Default: False. Hide the 'Copy path' item from the View menu.
Private Const bShowParentItemsInAllViews As Boolean = False 'Default: False. The ShowParentTreeInList can only show an indented tree in Details View, so by default only appears in that view.
                                                            '   If you set this to True, the parents will be added in the other views, but will not be visually distinguished from other items.
Private Const bAllowExpandChildrenInHPF As Boolean = True 'Default: True. Allow the option for adding children to the dropdown for the current selected folder in High Performance Mode. This
                                                          '   is done via a targeted SHCONTF_FOLDERS enum *after* the main loop, so won't slow things down unless you also expected tens of
                                                          '   thousands of folders.
Private Const bShowShellBackgroundContextMenu As Boolean = True 'Default: False. Experimental- Load the IContextMenu for the background of the folder if no items selected instead of View menu.
Private Const bShowLoadTimeAsStatus As Boolean = False 'Default: False. After loading a folder, the status becomes 'Ready'; you can use this option to set it to the load time instead.
Private Const bSoundNavigate As Boolean = True 'Provide more granular control for the PlaySounds option
Private Const bSoundDefBeep As Boolean = True
Private Const bSoundCritical As Boolean = True
Private Const nMaxFoldersInCustomSearchLabel As Long = 3& 'Default: 3. After a search, you can click to search again in Custom. It will display Search Results in Folder1, Folder2, nMaxFolders, ...
                                                          'Must be >0
Private Const bInsertNewFilterMatches As Boolean = True 'Default: True. If an item in the current folder is renamed, and now matches the filter where it didn't before, add it as a new item.
Private Const bRemoveNewFilteredItem As Boolean = True 'Default: True. If an item in the current folder is renamed and now no longer matches the filter, remove it from the list.
Private Const bEnableFixForGVSMICON As Boolean = True 'Default: True. Enable the fix for Group View with Small Icons: Manually adjusting label contents and width.
Private Const cxSmallIconColumnWidth As Single = 160 'Default: 160. Small icon view has a column width, and when group view is enabled, we need to set it and set item label widths to it

Private Const bPreserveDefColFirstInColSort As Boolean = True 'Default: True. In the Column Select popup, Advanced Mode enables column sorting. This option will keep defaults up top.

'NOTE :: You can set the folders for the 'Special Folders' submenu on the bookmark menu in the GetSpecialFolderMenuItem sub.
'******************************************************************************************************************
'*-
'**********************************DEBUGGING OPTIONS***********************************
Private Const dbg_PrintToImmediate As Boolean = False 'This control has very extensive debug information, you may not want
                                                      'to see that in your IDE.
Private Const dbg_IncludeDate As Boolean = True 'Prefix all Debug output with the date and time, [yyyy-mm-dd Hh:Mm:Ss]
Private Const dbg_IncludeName As Boolean = True 'Include Ambient.Name
Private Const dbg_dtFormat As String = "yyyy-mm-dd Hh:nn:Ss"
Private Const dbg_RaiseEvent As Boolean = False 'Raise DebugMessage event
Private Const dbg_PrintToFile As Boolean = False 'Now implemented as of 6.0
Private Const dbg_LogFileName = "ucsb-dbg" 'The exact startup time is appended to this, so the sames are uniqure.
Private Const dbg_LogFileExt = ".txt"
Private Const dbg_LogAppend As Boolean = False 'Append the existing log file, if it exists, rather than create a new one
Private Const dbg_LogOverwrite As Boolean = False 'If dbg_LogAppend is False, this sets whether to overwrite the existing file
                                                  'or create a new file.
Private Const dbg_LogExeOnly As Boolean = True 'Only turn on writing to external debug log for the compiled exe (if dbg_PrintToFile is enabled).
Private Const dbg_MinLevel As Long = 2000&   'Only log to immediate/file messages >= this level
'**************************************************************************************

'*********************PROCEDURE COUNT LIMIT FOR SELF-SUBCLASS CODE*********************
'NOTE: You only need to worry about this value if you add a large number of additional
'      methods to this .ctl file. Code in the rest of your project does not matter.
'Set this value a little above the number of methods in this module.
'You don't want it too high, but if the number of methods exceeds it, self-subclass
'and callbacks will break. Previously it was 1024, which was already increased over
'the original value of 512, and it was increased to 1500 when 1012 methods was hit.
'As of Version 10.0 R3, there were 1352 methods.
Private Const lProcLimit As Long = 1500&
'**************************************************************************************

'*************************************VB6 EXE NAME*************************************
'The IsIDE call this module uses the name of the EXE, which is normally VB6.EXE, for
'extra reliability. I had to rename it temporarily for a manifest issue, so decided to
'make a variable out of it and leave it in just in case anyone else needed to use a
'different name for their exe. (Which came in handy in this tB port :) )
Private Const gVBExeName As String = "twinbasic"
'**************************************************************************************
#End Region


#Region "Strings"
'*********************************************STRINGS FOR LOCALIZATION*********************************************
'
'The following section contains all strings that appear in the control, in order to have a single place to translate
'them to localize the control in other languages. No other modifications required (besides size if the replacement
'exceeds available width). Debug output is not included.
'Column/property names and values are loaded from Windows, so will always appear in whatever the system language is.
'

'Control captions
'Note that changing the caption in the Properties window has no effect at runtime, all captions are loaded from here.
Private Const scc_AboutBox = "About ucShellBrowse Control"
Private Const scc_Up = "Up"
Private Const scc_Back = " Back"
Private Const scc_Forward = "Fwd"
Private Const scc_View = "View"
Private Const scc_Ok = "OK"
Private Const scc_Cancel = "Cancel"
Private Const scc_Save = "Save"
Private Const scc_ChCols = "Choose columns"
Private Const scc_Prv = "Preview"
Private Const scc_Width = "Width"
Private Const scc_PropCol = "Property"
'6.3-6.4 Controls
Private Const scc_ShOpt = "Search Options"
Private Const scc_SearchBtn = "Search"
Private Const scc_sz = "Size"
Private Const scc_kb = "KB"
Private Const scc_ShIgNm = "Ignore name filter"
Private Const scc_ShTyp = "Kind:"
Private Const scc_FrDate = "Date:"
Private Const scc_ShIncFldr = "Include folders in results"
Private Const scc_clr = "Clear"
Private Const scc_cls = "X"
Private Const scc_bkm_alt As String = "B" 'There's only room for one letter. Only applies if comctl6 is not present.
'8.x Controls
Private Const scc_ColFil = "Show filterbar"
Private Const scc_AdvCol = "System name"
Private Const m_str_Matches = "Matches"
Private Const m_str_Cols = "Matching columns"
Private Const mn_ColAdv = "Advanced mode"
Private Const mn_Browse = "Browse"
Private Const mn_ColTop = "Send to top"
Private Const mn_CopyFN = "Copy file name"
Private Const mn_CopyFP = "Copy full path"
Private Const mn_CopyFNs = "Copy file names"
Private Const mn_CopyFPs = "Copy full paths"

'9.x Changes
Private Const mStrLessThan = "Less than"
Private Const mStrEqualTo = "Equal to"
Private Const mStrGreaterThan = "Greater than"

'Menu items
Private Const mn_sMore = "More..."           'There's no system resource to load localized translations like the other items
Private Const mn_sLock = "Keep same columns"  'on the column menu, so you may change it manually here if you wish
                                                       'Note: The lock item won't appear if columns are locked through the LockColumns property
Private Const mn_sLW = "Lock width"
Private Const mn_sLH = "Lock height"
Private Const mn_sSel = "Select"
Private Const mnv_sGrpHdr = "Group by"
Private Const mnv_sSortHdr = "Sort by"
Private Const mnv_sSortAsc = "Sort ascending"
Private Const mnv_sSortDsc = "Sort descending"
Private Const mnv_sXL = "Extra large icons"
Private Const mnv_sli = "Large icons"
Private Const mnv_sMD = "Medium icons"
Private Const mnv_sSM = "Small icons"
Private Const mnv_sLS = "List"
Private Const mnv_sDT = "Details"
Private Const mnv_sTV = "Tiles"
Private Const mnv_sCT = "Contents"
Private Const mnv_sJM = "Thumbnails"
Private Const mnv_sNN = "(none)"
Private Const mnv_sNF = "New folder"
Private Const mnv_sPR = "Properties"
Private Const mnv_sRF = "Refresh"
Private Const mnv_sSB = "Status bar"
Private Const mnv_sPV = "Preview pane"
Private Const mnv_sDB = "Details pane"
Private Const mnv_sSX = "Search box"
Private Const mnv_sSXA = "Search"
Private Const mnv_sSPP = "Advanced search..."
Private Const mnv_sPS = "Paste"
Private Const mnv_sBK = "Bookmarks"
Private Const mnv_sSA = "Select all"
Private Const mnv_sIS = "Invert selection"
Private Const m_sColCap = "Choose columns"
Private Const mn_sBkmAdd = "Bookmark current folder"
Private Const mn_sBkmRem = "Remove current folder bookmark"
Private Const mn_sBkmClr = "Clear all bookmarks"
Private Const mNavToStr = "Navigate to "
Private Const mNavToDsk = "the Desktop"
Private Const mn_sBkmSpc = "Special folders"


'Status bar messages
Private Const sSizeFmt_byte = "0 bytes"
Private Const sSizeFmt_kb = "#,##0 KB"
Private Const sSizeFmt_mb = "#,##0.00 MB"
Private Const sSizeFmt_gb = "#,##0.00 GB"
Private Const sSizeFmt_tb = "#,##0.00 TB"
Private Const sSizeFmt_pb = "#,##0.00 PB"
Private Const mFileStr = "file"
Private Const mFilesStr = "files"
Private Const mNoFilesSelStr = "No files selected."
Private Const mFileSelStr = "file selected."
Private Const mFilesSelStr = "files selected."
Private Const mFolderStr = "folder"
Private Const mFoldersStr = "folders"
Private Const mReadyStr = "Ready."
Private Const mNoItemsStr = "No items."
Private Const mSelFileStr = "Selects the current file."
Private Const mLoadPvStr = "Attempting to load preview handler..."
Private Const mPvhLoadFail = "Error: Could not load the preview handler associated with this file type."
Private Const mPvhNotFoundStr = "Could not find registered preview handler for file type."
Private Const mShowPvStr = "Showing preview for "
Private Const mProcExThumbStr = "Processing thumbnails. Video thumbnails enabled, this may be slow."
Private Const mProcThumbStr = "Generating thumbnails..."
Private Const mThumbExStatusStr = "Video thumbnails enabled, this may be slow. Processed "
Private Const mThumbStatusStr = "Generating thumbnails... Processed "
Private Const mOfStr = " of "
Private Const mThumbFinishStr = "Done. %1 thumbnails generated in %2 seconds."
Private Const mRenameFailStr = "Could not rename file."
Private Const mNoCheckStr = "No files checked."
Private Const mFileCheckStr = "1 file checked."
Private Const mFilesCheckStr = " files checked."
Private Const mEmptyFolderStr = "No items found."
Private Const mRatingTipStr = "Hold shift while clicking the rating to reset to 0."
'New in v6.0
Private Const mSearchBoxInvite = "Search %d"
Private Const mSrchResStr = "Search results"
Private Const mNoResStr = "No matches found."
Private Const mLoadFail = "Could not load requested location "
'New in 6.2
Private Const mSearchCD = "Searching "
Private Const mSearchDone = "Search complete."
Private Const mLVEMDrvRem = "This drive has been removed."
'New in 6.3-6.4
Private Const mSamS1 = "123 bytes"
Private Const mSamS2 = "Not My Type"
Private Const mSamS3 = "The day after the day after tomorrow."
Private Const mRenameChrLim = "The file name you have entered is too long. The total length of the path and file name cannot exceed %n characters."
Private Const mRenameIlgChr = "File names may not contain any of the following characters:" & vbCrLf & " / \ < > : ? * | """  ' & Chr$(34)
Private Const mInvPathZip = "Requested path is not a valid folder or archive."
Private Const mInvPath = "Requested path is not a valid folder."
Private Const RnErDsc1 = "The file name is fine. Something screwed up. "
Private Const RnErDsc2 = "File names may not contain any of the following characters:" & vbCrLf & " / \ < > : ? * | " & """"
Private Const RnErDsc3 = "The file name you have entered is too long. The path and filename combined cannot exceed 255 characters."
Private Const RnErDsc4 = "The file name you have entered is a reserved device name. Files may not be named CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, or LPT9."
Private Const RnErDsc5 = "File names may not consist of a single period or null character."
Private Const RnErDsc6 = "File names may not consist entirely of null characters."
Private Const RnErDsc7 = "File names may not consist of a single space or a single space plus extension."
Private Const RnErDsc8 = "The file name you have entered is not valid: unknown error (%1)"
Private Const mFldrSrch = "Search Results in "
Private Const mStrAny = "(any)"
Private Const mStrBfr = "Before"
Private Const mStrAft = "After"
Private Const mStrDsb = "(n/a)"
Private Const mSrchTip = "Double-click search box to bring up more options."
Private Const mSrchNoRes = "No matching items found."
Private Const mSrchAltCue = "Enter search text"
Private Const mStrUnspc = "Unspecified"
Private Const mnv_GrpCat = "Category"
'New in 6.5
Private Const mStrOpening = "Opening..."
Private Const mStrListing = "Listing items..."
Private Const mStrBlankNoOp = "Please load a folder before any action."
'New in 6.8
Private Const mStrForbidden = "Error: Path is not in root and root is locked."
Private Const mStrStartBlank = "Pick a folder to show files."
'New in 7.3
Private Const mSrchFldrInvalid = "The Search Results folder you selected could not be loaded."
'New in 8.0
Private Const mnv_sLO = "Layout"
Private Const mnv_sCtlBar = "Control bar"
Private Const mnv_sTree = "Navigation tree"
Private Const m_str_DroppingFiles = "Dropping files..."
Private Const m_str_FilesDropped = "Files dropped."
Private Const m_str_CantDrop = "Can't drop here."
Private Const m_str_CancelLoad = "ERROR: Loading has been canceled, some files not loaded."

'New in 8.4
Private Const mStrLoadColData = "Reading column data..."
Private Const mEnumSRes = "Gathering search results... "

'New in 8.5
Private Const mnv_CopyPath = "Copy path"
Private Const mBrowseFileStr = "Browse the selected location in this control."

'New in 9.x
Private Const m_str_SwVw = "Switching view..."
Private Const mItemStr = "item"
Private Const mItemsStr = "items"
Private Const mnv_sBack = "Back"
Private Const mnv_sFwd = "Forward"

Private Const m_str_DropError = "Failed to drop on the selected target."

Private Const mStrOpenWith = "Open with"
Private Const mStrCopyTo = "Copy to"
Private Const mStrCopyHere = "Copy here"
Private Const mStrMoveTo = "Move to"
Private Const mStrMoveHere = "Move here"
Private Const mStrNoDrop = "Can't drop here."
Private Const mStrNoADS = "Can't display menu for alt data streams."

'New in 9.6
Private Const mstrCpyNm = "Copy the selected item names to the clipboard."
Private Const mstrCpyPth = "Copy the selected item full paths to the clipboard."

'Search footer
Private Const sSearchFooter5 = "Custom..."
Private Const sSearchFtrHdr = "Search again in..."
Private Const sSearchPickCust = "Select folder(s) to search..."



'Group mode text
Private Const m_def_GroupSubsetLinkText = "Show more items..."
Private Const mLUPastHour = "Within the past hour"
Private Const mLULastDay = "In the last 24 hours"
Private Const mLULastWk = "In the last week"
Private Const mLULastMn = "In the last 30 days"
Private Const mLULast6Mn = "In the last 6 months"
Private Const mLULastYr = "In the last 12 months"
Private Const mLUGtYr = "Longer than 12 months"

'Menu item tips for the status bar (QueryMenuTip)
Private Const sQMT01 = "Change how files are displayed."
Private Const sQMT02 = "Disables group view."
Private Const sQMT03 = "Group files by their properties."
Private Const sQMT04 = "Group by the selected property."
Private Const sQMT05 = "Sort files by their properties."
Private Const sQMT06 = "Sort by the selected property."
Private Const sQMT07 = "Sort from lowest to highest."
Private Const sQMT08 = "Sort from highest to lowest."
Private Const sQMT09 = "Create a new folder in the current location."
Private Const sQMT10 = "Display information about this folder."
Private Const sQMT11 = "Refreshes the current folder."
Private Const sQMT12 = "Show or hide the status bar."
Private Const sQMT13 = "Toggles the display of the Preview Pane."
Private Const sQMT14 = "Toggles the display of the Details Pane."
Private Const sQMT15 = "Show or hide the selected column."
Private Const sQMT16 = "Choose from a list of all properties."
Private Const sQMT17 = "Retain the current column set when changing folders."
Private Const sQMT18 = "Disables the ability to resize the Details Pane."
Private Const sQMT19 = "Disables the ability to resize the Preview Pane."
Private Const sQMT20 = "Selects the current file."
Private Const sQMT21 = "Add a bookmark for the current directory."
Private Const sQMT22 = "Removes the current directory from bookmarks."
Private Const sQMT23 = "Remove all bookmarked directories from the list."
Private Const sQMT24 = "Navigate to the highlighted special folder."
Private Const sQMT25 = "Navigate to the highlighted special folder."
'New in v7.4
Private Const sQMT26 = "Select all items in the current folder."
Private Const sQMT27 = "Switch the selected state of each item."
'New in v7.5
Private Const sQMT28 = "Toggle the details, preview, statusbar, and search box."
Private Const sQMT29 = "Show or hide the directory dropdown and controls."
Private Const sQMT30 = "Toggles the display of the Search Box."
Private Const sQMT31 = "Toggles the display of the navigation tree."
'New in v8.4
Private Const sQMT32 = "Copy the full path of the current location to the clipboard."

'New in v9.x
Private Const sQMT33 = "Paste the files in the clipboard to the current folder."

'(End of strings for localization)
'******************************************************************************************************************
#End Region

#Region "LocalDeclarations"

Implements IDropTarget
Implements IListViewFooterCallback
Implements IObjectSafety
Implements IOleInPlaceActiveObjectVB

Public Event DebugMessage(sMsg As String, nLevel As Integer)

Public Event DirectoryChanged(ByVal sFullPath As String, siItem As IShellItem, pidlFQ As LongPtr)   'Fires after. Do not free pidlFQ, it is not a copy.
Public Event DragStart(sFiles() As String, siaDragged As IShellItemArray, pdoDragged As IDataObject, dwButton As Long)
Public Event DropFiles(sFiles() As String, siaFiles As IShellItemArray, doDropped As IDataObject, sDropParent As String, siDropParent As IShellItem, iEffect As DROPEFFECTS, dwKeyState As Long, ptX As Long, ptY As Long)
Public Event FileClick(ByVal sFile As String, siFile As IShellItem, ByVal lButton As Long)
Public Event FileExecute(ByVal sFile As String, siFile As IShellItem)
Public Event SelectionChanged(arFullPaths() As String, sFocusedItem As String, siFocused As IShellItem)
Public Event FileSearchStart(sPattern As String, pCondition As ICondition, sPath As String, pScope As IShellItemArray)
Public Event CustomColumnQueryData(ByVal lColID As Long, pItem As IShellItem, pidlFQ As LongPtr, sItemName As String, sPath As String, lPos As Long, out_ColText As String, out_nImage As Long)
              'For CustomColumnQueryData: pItem and pidlFQ are not copies and should not be freed. You set the value of the out_ vars to provide column data for the item described.
Public Event ControlTypeChange(ByVal nOldType As SB_CTL_TYPE, ByVal nNewType As SB_CTL_TYPE)
Public Event CustomColor(ByVal itemIndex As Long, ByVal ItemName As String, ByVal SubItemIndex As Long, ByVal SubItemProp As String, ByVal dwStateCD As Long, ByVal dwStateLV As Long, ByRef rgbFore As Long, ByRef rgbBack As Long)
Public Event FileCheck(ByVal Index As Long, ByVal sFile As String, ByVal fCheck As Long)
Public Event FileDetailsWrite(ByVal sFile As String, sPropSysName As String, sNewValue As String)
Public Event FileRenamed(ByVal sOldName As String, ByVal sNewName As String)
Public Event FilterBarOverride(ByVal sFilter As String, ByVal sColText As String, ByVal bCaseSensitive As Boolean, ByVal sFilePath As String, ByRef fShow As Long) 'Override the default filterbar matching
Public Event FilterFile(ByVal sName As String, ByVal sPath As String, ByRef fShow As Long) '0=hide file, >0 = show file. Overrides ItemFilter if used.
Public Event FilterFolder(ByVal sName As String, ByVal sPath As String, ByRef fShow As Long) '0=hide folder, >0 = show folder. Overrides ItemFilterFolder if used.
Public Event FilterDropdown(ByVal sName As String, ByVal sPath As String, siItem As IShellItem, ByRef fShow As Long) '0=hide folder, >0 = show folder.
Public Event FooterButtonClick(ByVal idx As Long, ByVal lParam As Long)
Public Event ItemAdded(ByVal sFile As String) 'File/folder added like above
Public Event ItemRemoved(ByVal sFile As String) 'File/folder removed from current folder (not raised when loading a new folder)
Public Event ItemLinkClick(ByVal sLink As String, fCancel As Long)
Public Event ListKeyDown(ByVal lKeyCode As Long, ByVal bShift As Boolean, ByVal bControl As Boolean, ByVal bAlt As Boolean, bCancel As Boolean) 'Set bCancel to True to disable built-in handling
Public Event ListKeyUp(ByVal lKeyCode As Long, ByVal bShift As Boolean, ByVal bControl As Boolean, ByVal bAlt As Boolean, ByVal lParam As LongPtr) 'See WM_KEYUP on MSDN for lParam contents
Public Event PreDirectoryChange(ByVal sFullPath As String, ByRef fCancel As Long) 'Fires before dirchange is executed. Set fCancel to nonzero to block.
Public Event SelectionCleared()
Public Event SortItems(ByVal lIndex As Long, ByVal SortDir As SORTDIRECTION, ByVal sPropSys As String, ByVal sPropCanonical As String)
Public Event StatusMessage(ByVal sMessage As String)
Public Event ValidateTextNavigate(ByRef sLoc As String) 'Modify text entered into the combobox before executing it (replace shorthand, etc)
Public Event ViewChanged(dwNewView As ShellBrowseView)
Public Event ShowShellTree(ByRef bShow As Boolean)
Public Event ComboEditChange(ByRef sText As String)
Public Event ComboDropdown()
Public Event ComboCloseUp()
Public Event DetailPaneHeightChanged()
Public Event PreviewPaneWidthChanged()
Public Event ToggleStatusBar(ByVal bShow As Boolean)
Public Event ToggleDetailsPane(ByVal bShow As Boolean)
Public Event TogglePreviewPane(ByVal bShow As Boolean)
Public Event FileSearchPopup(ByVal sCurPattern As String, fCancel As Long)
Public Event QueryCustomInfoTip(ByVal dwFlags As Long, ByVal sName As String, ByVal sFullPath As String, pidlFQItem As LongPtr, out_strTip As String)
Public Event QueryCustomIcon(ByVal sName As String, ByVal sPath As String, ByVal sFullPath As String, ByVal bIsFolder As Boolean, pidlFQItem As LongPtr, ByVal cxy As Long, out_HBMItem As LongPtr, out_HICOItem As LongPtr, out_Destroy As Boolean)
Public Event QueryCustomIconOverlay(ByVal nOverlayIndex As Long, ByVal cxy As Long, out_HBMOverlay As LongPtr, out_HICOOverlay As LongPtr, out_Destroy As Boolean)

'---------------
'Default UserControl events
Public Event EnterFocus()
Public Event ExitFocus()
Public Event Click()
Public Event DblClick()
Public Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
Public Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
Public Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
Public Event BackgroundKeyDown(ByVal lKeyCode As Long, ByVal bShift As Boolean, ByVal bControl As Boolean, ByVal bAlt As Boolean, ByVal lParam As LongPtr)
Public Event BackgroundKeyUp(ByVal lKeyCode As Long, ByVal bShift As Boolean, ByVal bControl As Boolean, ByVal bAlt As Boolean, ByVal lParam As LongPtr)


'Debug log
Private log_hFile As LongPtr
Private log_RetVal As Long
Private log_sBuf() As String
Private log_bBuf As Boolean
Private log_bActive As Boolean

Private mValidSession As Boolean 'Set if a full run rather than IDE load/unload.
Private mAppFolderName As String, mParentObjName As String, mRegDataName As String 'Try to make the registry key name as unique as possible; just "ucShellBrowse"
                                                                                   'would mean all projects with this control shared a key

'Control Shell Interfaces
Private pDTH As IDropTargetHelper
Private siFocus As IShellItem
Private siFocusNS As IShellItem
Private siaSelected As IShellItemArray
Private ICtxMenu2 As IContextMenu2
Private ICtxMenu3 As IContextMenu3
Private pcm As IContextMenu
Private psfCur As IShellFolder
Private siCurPath As IShellItem
Private mDataObj As IDataObject
Private pLVF As IListViewFooter
Private ipv As IPreviewHandler
Private pPvhVis As IPreviewHandlerVisuals
Private m_siDesktop As IShellItem
Private pAutoComp As IAutoComplete2
Private pACL As ACListISF
Private mCacheSearchCond As ICondition
Private pThumbFact As IThumbnailHandlerFactory
Private pThumbCache As LocalThumbnailCache
Private ImgPrvLTC As LocalThumbnailCache
Private pStoreCache As IPropertyStore
Private stcPst As IPropertyStore
Private imlSys16 As iImageList
Private imlSys32 As IImageList2
Private imlSysJM As iImageList
Private imlMisc As IImageList2
Private mIShIcon As IShellIcon

Private Type SearchStruct
    siSearch As IShellItem
    pidl As LongPtr
    sPath As String
    sDisp As String
    lParam As LongPtr
End Type
Private psiSearch() As SearchStruct

'**********************************************************************************
'~~~~~~~~~~~~~~~~~~Begin Control Properties~~~~~~~~~~~~~~~~~~
Private mLastSessionPath As String
Private mStartLast As Boolean
Private Const mDefStartLast As Boolean = False

Private mCustomRoot As String
Private Const m_defCustomRoot As String = ""
Private mCustomRootEnforce As Boolean
Private Const m_defCustomRootEnforce As Boolean = False

Private clrBack As stdole.OLE_COLOR
Private clrFore As stdole.OLE_COLOR
Private clrForeSubitem As stdole.OLE_COLOR
Private clrCtBack As stdole.OLE_COLOR
Private clrDtBack As stdole.OLE_COLOR
Private clrDtName As stdole.OLE_COLOR '&HC
Private clrDtFore As stdole.OLE_COLOR '&H0079675A&
Private clrSbFore As stdole.OLE_COLOR
Private clrSbBack As stdole.OLE_COLOR

Private clrColSel As stdole.OLE_COLOR

Public Enum ShellBrowseView
    SB_VIEW_ICON = &H0
    SB_VIEW_DETAILS = &H1
    SB_VIEW_SMALLICON = &H2
    SB_VIEW_LIST = &H3
    SB_VIEW_TILE = &H4
    SB_VIEW_CONTENTS = &H7
    SB_VIEW_THUMBNAIL = &H6
    SB_VIEW_XLICON = &H8
    SB_VIEW_MDICON = &H9
    SB_VIEW_CUSTOM = &H100
End Enum
Private m_ViewMode As ShellBrowseView
Private Const m_def_ViewMode = SB_VIEW_DETAILS

Private m_ViewModeEx As ShellBrowseView

Private m_StartEmpty As Boolean
Private Const m_def_StartEmpty As Boolean = False

Private mHighPerfMode As Boolean
Private Const mDefHighPerfMode As Boolean = True

Public Enum ShellBrowseGroupBy
    SBGB_None = &H0
    SBGB_Name = &H1
    SBGB_Size = &H2
    SBGB_Type = &H3
    SBGB_DateModified = &H4
    SBGB_DateCreated = &H5
    SBGB_DateAccessed = &H6
    SBGB_Extended = &H7
    SBGB_Categorizer = &H8
End Enum
Private m_GroupMode As ShellBrowseGroupBy
Private Const m_def_GroupMode As Long = SBGB_None

Private mLVOffX As Long
Private Const mDefLVOffX As Long = 2&

Private mDTOffsetX As Long
Private Const mDefDTOffsetX As Long = 1&

Private m_DisableOvr As Boolean
Private Const m_def_DisableOvr As Boolean = False

Private m_MultiSelect As Boolean
Private Const m_def_MultiSelect As Boolean = True

Private m_Filter As String
Private Const m_def_Filter As String = "*.*"

Private m_FolderFilter As String
Private Const m_def_FolderFilter As String = "*"

Private mMasterEnabled As Boolean
Private Const mMasterEnabled_def As Boolean = True

Private mExplorerStyle As Boolean
Private Const mExplorerStyle_def As Boolean = True

Private mExplSel As Boolean
Private Const mDefExplSel As Boolean = True

Private mFoldersOnly As Boolean
Private Const m_def_FoldersOnly As Boolean = False

Private mFilesOnly As Boolean
Private Const m_def_FilesOnly As Boolean = False

Private mDispParAndIndt As Boolean
Private Const mDefDispParAndIndt As Boolean = False

Private m_CompAsRoot As Boolean
Private Const m_def_CompAsRoot As Boolean = False

Private m_ControlBox As Boolean
Private Const m_def_ControlBox As Boolean = True

Private mAutoHideCtlBox As Boolean
Private Const mDefAutoHideCtlBox As Boolean = True

Private mShowDataStreams As Boolean
Private Const mDefShowDataStreams As Boolean = False

Private m_StatusBar As Boolean
Private Const m_def_StatusBar As Boolean = True

Private m_StatusSP As Boolean
Private Const m_def_StatusSP As Boolean = False

Private mDefStatusText As String
Private Const m_def_DefStatusText As String = ""

Private m_MaxComboCX As Long
Private Const m_def_MaxComboCX As Long = 400

Private m_DefCol As String
Private Const m_def_DefCol As String = "1,2,3"

Private m_HideIcons As Boolean
Private Const m_def_HideIcons As Boolean = False

Private mIncludeFldrLnkInFldrOnly As Boolean
Private Const mDefIncludeFldrLnkInFldrOnly As Boolean = True

Private mIncludeFldrLnkInFldrOnlyHPF As Boolean
Private Const mDefIncludeFldrLnkInFldrOnlyHPF As Boolean = False

Private mTileWidth As Long
Private Const mDefTileWidth As Long = 0&

Private mAutoComp As Boolean
Private Const m_def_AutoComp As Boolean = False

Private mBkFwInCtx As Boolean
Private Const mDefBkFwInCtx As Boolean = True

Private mCustomInMenu As Boolean
Private Const mDefCustomInMenu As Boolean = False

Private mCustomMenuCap As String
Private Const mDefCustomMenuCap As String = "Custom icons"

Private mcxyCustom As Long
Private Const mDefcxyCustom As Long = 48

Private m_HideComboIcons As Boolean
Private Const m_def_HideComboIcons As Boolean = False

Private mAlignTop As Boolean
Private Const mDefAlignTop As Boolean = True

Private mNoLblWrap As Boolean
Private Const mDefNoLblWrap As Boolean = False

Private mShowSelAlw As Boolean
Private Const mDefShowSelAlw As Boolean = True

Private mAutoArr As Boolean
Private Const mDefAutoArr As Boolean = True

Private mDispSecZn As Boolean
Private Const mDefDispSecZn As Boolean = True

Private m_UpButton As Boolean
Private Const m_def_UpButton As Boolean = True

Private m_OneClickAct As Boolean
Private Const m_def_OneClickAct As Boolean = False

Private m_TwoClickAct As Boolean
Private Const m_def_TwoClickAct As Boolean = False

Private m_ULHot As Boolean
Private Const m_def_ULHot As Boolean = False

Private m_ULCold As Boolean
Private Const m_def_ULCold As Boolean = False

Private m_CheckSel As Boolean
Private Const m_def_CheckSel As Boolean = False

Private m_ViewButton As Boolean
Private Const m_def_ViewButton As Boolean = True
Private mTrackVBtn As Long

Private m_BookmarkButton As Boolean
Private Const m_def_BookmarkButton As Boolean = False

Private mShowSearch As Boolean
Private Const mDefShowSearch As Boolean = False

Private mSearchAutoGroup As Boolean
Private Const mDefSearchAutoGroup As Boolean = True

Private mSearchPopupInMenu As Boolean
Private Const mDefSearchPopupInMenu As Boolean = False

Private mCXSearch As Long
Private Const m_def_CXSearch As Long = 140

Private mFtrPostSearch As Boolean
Private Const m_def_FtrPostSearch As Boolean = True

Private mPlaySnd As Boolean
Private Const mDefPlaySnd As Boolean = True

Private m_ThumbCXY As Long
Private Const m_def_ThumbCXY As Long = 96

Private m_ThumbScaleCXY As Boolean
Private Const m_def_ThumbScaleCXY As Boolean = True

Private m_ThumbExt As Boolean
Private Const m_def_ThumbExt As Boolean = True

Private m_ThumbPreload As Boolean
Private Const m_def_ThumbPreload As Boolean = False

Private m_IconPreload As Boolean
Private Const m_def_IconPreload As Boolean = False

Private m_PvPane As Boolean
Private Const m_def_PvPane As Boolean = False

Private mPvPaneNoRS As Boolean
Private Const mDefPvPaneNoRS As Boolean = False

Private m_NoWow64 As Boolean
Private Const m_def_NoWow64 As Boolean = False

Private m_DtPane As Boolean
Private Const m_def_DtPane As Boolean = True

Private mDtPaneNoRS As Boolean
Private Const mDefDtPaneNoRS As Boolean = False

Private m_FullRowSel As Boolean
Private Const m_def_FullRowSel As Boolean = False

Private m_Checkboxes As Boolean
Private Const m_def_Checkboxes As Boolean = False

Private m_AllowSorting As Boolean
Private Const m_def_AllowSorting As Boolean = True

Private m_AllowRename As Boolean
Private Const m_def_AllowRename As Boolean = True

Private m_NoHdrSize As Boolean
Private Const m_def_NoHdrSize As Boolean = False

Private m_HdrHotTrack As Boolean
Private Const m_def_HdrHotTrack As Boolean = False

Private mExtOverlay As Boolean
Private Const m_def_ExtOverlay As Boolean = False

Private m_HdrOverflow As Boolean
Private Const m_def_HdrOverflow As Boolean = False

Private m_HdrMinCX As Long
Private Const m_def_HdrMinCX As Long = 0&

Private m_AutoSzCol As Boolean
Private Const m_def_AutoSzCol As Boolean = False

Private m_BrowseZip As Boolean
Private Const m_def_BrowseZip As Boolean = True

Private m_LockNav As Boolean
Private Const m_def_LockNav As Boolean = False

Private m_HdrDD As Boolean
Private Const m_def_HdrDD As Boolean = True

Private mAutoSelCol As Boolean
Private Const mDefAutoSelCol As Boolean = False

Private mMaxHist As Long
Private Const m_def_MaxHist As Long = 32

Private m_TrackSel As Boolean
Private Const m_def_TrackSel As Boolean = False

Private m_InsColp As Boolean
Private Const m_def_InsColp As Boolean = False

Private m_Monitor As Boolean
Private Const m_def_Monitor As Boolean = True

Private m_FollowLinks As Boolean
Private Const m_def_FollowLinks As Boolean = True

Private m_NoDblClkNav As Boolean
Private Const m_def_NoDblClkNav As Boolean = False

Private mUserModeToggle As Boolean
Private Const m_def_UserModeToggle As Boolean = True

Private mAlwaysSortWithISF As Boolean
Private Const m_def_AlwaysSortWithISF As Boolean = False

Private m_DisableWhileLoading As Boolean
Private Const m_def_DisableWhileLoading As Boolean = False

Private m_FontScaleCXY As Boolean
Private Const m_def_FontScaleCXY As Boolean = True

Private mExtColPreload As Boolean
Private Const mDefExtColPreload As Boolean = False

Private m_ShellTree As Boolean
Private Const m_def_ShellTree As Boolean = False

Private mAlwaysShowExtVerbs As Boolean
Private Const mDefAlwaysShowExtVerbs As Boolean = False

Private mSFinBKM As Boolean
Private Const mDefSFinBKM As Boolean = True

Private mLMMaxCX As Long
Private Const mDefLMMaxCX As Long = 200&

Public Enum SB_EXT_PREF
    SBEP_UseExplorer = 0&
    SBEP_AlwaysShow = 1&
End Enum
Private m_ForceExt As SB_EXT_PREF
Private Const m_def_ForceExt As Long = 0&
Private mExSetExt As Boolean

Public Enum SB_HDN_PREF
    SBHP_UseExplorer = 0&
    SBHP_AlwaysShow = 1&
    SBHP_AlwaysHide = 2&
End Enum
Private m_HiddenPref As SB_HDN_PREF
Private Const m_def_HiddenPref As Long = 0&
Private mHPInExp As Boolean

Public Enum SB_SPRHDN_PREF
    SBSHP_UseExplorer = 0&
    SBSHP_AlwaysShow = 1&
    SBSHP_AlwaysHide = 2&
End Enum
Private m_SuperHiddenPref As SB_SPRHDN_PREF
Private Const m_def_SuperHiddenPref As Long = 0&
Private mSHPInExp As Boolean

Public Enum SB_NAV_BUTTONS
    SBNB_None = 0&
    SBNB_Normal = 1&
    SBNB_ThemeButton = 2& 'Appears to left of dir dropdown; not a member of the control box for ListControlBox purposes
    SBNB_ThemeBtnInBox = 3&
End Enum
Private m_NavBtnType As SB_NAV_BUTTONS
Private Const m_def_NavBtnType As Long = SBNB_ThemeButton

Public Enum SB_CTL_TYPE    'Main Control Type
    SBCTL_DirAndFiles = 0& 'Shows the Directory Dropdown combo and the File View
    SBCTL_DirOnly = 1&     'Shows only the Directory Dropdown
    SBCTL_FilesOnly = 2&   'Shows only the File View
    SBCTL_DrivesOnly = 3&  'Shows only the Directory Dropdown, further limiting that to only show root drives, and disabling the Control Box and NavButtons
    SBCTL_DirOnlyWithCtls = 4& 'Same as above only with the possibility of Control Box and Navigation Buttons. Carefully consider which of those you enable.
End Enum
Private m_Mode As SB_CTL_TYPE
Private Const m_def_Mode As Long = 0&

Public Enum SB_COMBO_TYPE
    SBCT_Dropdown = 1&
    SBCT_DropdownList = 2&
    SBCT_Simple = 3& 'Only available when mode=DirOnly or DrivesOnly
End Enum
Private m_CbType As SB_COMBO_TYPE
Private Const m_def_CbType As Long = SBCT_Dropdown

Public Enum SB_BORDERSTYLE 'ListView border
    SBBS_None = 0&
    SBBS_Standard = 1&
    SBBS_Thick = 2&
    SBBS_Thicker = 3&
End Enum
Private m_Border As SB_BORDERSTYLE
Private Const m_def_Border As Long = 1&

Public Enum SB_CTLBORDER 'Border around entire control
    SBCBS_None = 0&
    SBCBS_Single = 1&
    SBCBS_Thick = 2&
    SBCBS_Thicker = 3&
End Enum
Private m_CtlBorder As SB_CTLBORDER
Private Const m_def_CtlBorder As Long = 0&

Public Enum SB_INFOTIPMODE
    SBITM_Disable = 0&
    SBITM_LabelTipOnly = 1&
    SBITM_Extended = 2&
    SBITM_Custom = 3&
End Enum
Private mInfoTipMode As SB_INFOTIPMODE
Private Const mDefInfoTipMode As Long = 2&

Private mInfoTipLimitHPF As Boolean
Private Const mDefInfoTipLimitHPF As Boolean = True 'Formerly bLimitInfoTipsInHighPerfMode

Public Enum SB_EXPDDMODE
    SBEDM_DirModesOnly = 0&
    SBEDM_AllModes = 1&
    SBEDM_Disabled = 2&
End Enum
Private nExpandSelectedFolderInDropdown As SB_EXPDDMODE
Private Const nDefExpandSelectedFolderInDropdown As Integer = 0 'Default: 0. 0: When you select a folder, the children that are folders are only added if the mode is Directory Only or DO + Controls
                                                                '            1: The folder children of the selected folder are always added, regardless of mode.
                                                                '            2: The folder children of the selected folder are *never* added. This will make it impossible to navigate outside of the
                                                                '               initial list of folders unless you have a 2nd control that is listing the selected folder contents.

Private mSimpSel As Boolean
Private Const mDefSimpSel As Boolean = True

Private m_MinDropCX As Long
Private Const m_def_MinDropCX As Long = 150&

Private m_MinDropCY As Long
Private Const m_def_MinDropCY As Long = 300&

Private mFixedDropHeight As Long
Private Const mDefFixedDropHeight As Long = 0&

Private m_HideColumnHeader As Boolean
Private Const m_def_HideColumnHeader As Boolean = False

Private m_HideLabels As Boolean
Private Const m_def_HideLabels As Boolean = False

Private m_HeaderInAll As Boolean
Private Const m_def_HeaderInAll As Boolean = False

Private m_SnapToGrid As Boolean
Private Const m_def_SnapToGrid As Boolean = False

Private m_EnablePreview As Boolean
Private Const m_def_EnablePreview As Boolean = True

Private m_EnableDetails As Boolean
Private Const m_def_EnableDetails As Boolean = True

Private m_EnableSearchBox As Boolean
Private Const m_def_EnableSearchBox As Boolean = True

Private m_EnableStatusBar As Boolean
Private Const m_def_EnableStatusBar As Boolean = True

Private mEnableLayout As Boolean
Private Const mDefEnableLayout As Boolean = True

Private m_LockView As Boolean
Private Const m_def_LockView As Boolean = False

Private m_GridLines As Boolean
Private Const m_def_GridLines As Boolean = False

Private m_EnableViewMenu As Boolean
Private Const m_def_EnableViewMenu As Boolean = True

Private m_EnableShellMenu As Boolean
Private Const m_def_EnableShellMenu As Boolean = True

Private mEnableBookmark As Boolean
Private Const mDefEnableBookmark As Boolean = True

Private mEnableNewFolder As Boolean
Private Const mDefEnableNewFolder As Boolean = True

Private m_EditCB As Boolean
Private Const m_def_EditCB As Boolean = True

Private m_CBXNoIcons As Boolean
Private Const m_def_CBXNoIcons As Boolean = False

Private mEditMarq As Boolean
Private Const m_def_EditMarq As Boolean = True

Private m_FilterBar As Boolean
Private Const m_def_FilterBar As Boolean = False

Private m_FilterCase As Boolean
Private Const m_def_FilterCase As Boolean = False

Private m_GroupSubset As Long
Private Const m_def_GroupSubset As Long = 0&

Private m_GroupSubsetLinkText As String
'Default defined in compile options block below changelog

Private m_PreviewVidThumb As Boolean
Private Const m_def_PreviewVidThumb As Boolean = False

Public Enum SB_DDMODE
    SBDD_DragDrop = 0&
    SBDD_Disabled = 1&
    SBDD_DragOnly = 2&
    SBDD_DropOnly = 3&
End Enum
Private m_DDMode As SB_DDMODE
Private Const m_def_DDMode As Long = SBDD_DragDrop

Private m_ActiveDrop As Boolean
Private Const m_def_ActiveDrop As Boolean = True

Private mEnableGrp As Boolean
Private Const mDefEnableGrp As Boolean = True

Private mEnablePaste As Boolean
Private Const mDefEnablePaste As Boolean = True

Public Enum SB_COL_LOCK
    SBCL_None = 0& 'No forced control
    SBCL_LockNoAuto = 1& 'Only the columns specified in DefaultColumns are shown; Explorer defaults are not loaded
    SBCL_LockNoUser = 2& 'The above, plus the user cannot manually add/remove columns during runtime
End Enum
Private m_ColLock As SB_COL_LOCK
Private Const m_def_ColLock As Long = SBCL_None

Public Enum SB_ITEMSEL_MODE
    SBIM_FilesAndFolders = 0&
    SBIM_FilesOnly = 1&
    SBIM_FoldersOnly = 2&
End Enum

Public Enum SB_COLOR_PREF
    SBCP_UseExplorer = 0&
    SBCP_ForceOn = 1&
    SBCP_ForceOff = 2&
End Enum
Private m_NameColors As SB_COLOR_PREF
Private Const m_def_NameColors = SBCP_UseExplorer
Private m_NCExVal As SB_COLOR_PREF

Private mStrRVM As String
Private Const mDefStrRVM = "(none)"

'~~~~~~~~~~~~~~~~~~End Control Properties~~~~~~~~~~~~~~~~~~

'The pbIconData PictureBox array contains encoded images that replaced the old images in the res file.
'The index listed here gives the control index in pbIconData containing the specified image.
'Reminder: pbIconData is binary data encoded as an image, so the picture that shows up in the PictureBox
'          on the form in design mode just looks like garbage; the image data is run through the BMP2Array
'          function to decode the actual image file, then sent on functions to display it. See Post #2 in
'          the project thread for more info and the encoder tool if you want to add/modify images encoded
'          in this way.
Private Const pbidx_ICO_MNDETAILS = 0&
Private Const pbidx_ICO_BKM = 1&
Private Const pbidx_ICO_MNLGICON = 2&
Private Const pbidx_ICO_MNLIST = 3
Private Const pbidx_ICO_MNNEWF = 4
Private Const pbidx_ICO_MNPASTE = 5
Private Const pbidx_ICO_MNREFRESH = 6
Private Const pbidx_ICO_MNSMICON = 7
Private Const pbidx_ICO_MNSORTA = 8
Private Const pbidx_ICO_MNSORTD = 9
Private Const pbidx_ICO_MNTHUMB = 10
Private Const pbidx_ICO_MNTILE = 11
Private Const pbidx_ICO_MNCUST = 30
Private Const pbidx_ICO_GOBACK = 12
Private Const pbidx_ICO_LOBAR = 13
Private Const pbidx_ICO_LODTL = 14
Private Const pbidx_ICO_LOPRV = 15
Private Const pbidx_ICO_LOTOP = 16
Private Const pbidx_ICO_LOTRV = 17
Private Const pbidx_ICO_LOSTA = 26
Private Const pbidx_ICO_NEWBKM = 18
Private Const pbidx_ICO_SRCHBOX = 19
Private Const pbidx_ICO_SRCHDIS = 29
Private Const pbidx_ICO_SRMENU = 20
Private Const pbidx_ICO_MNBACK = 27
Private Const pbidx_ICO_MNFWD = 28
Private Const pbidx_ICO_UP = 21
Private Const pbidx_ICO_VIEW = 22
Private Const pbidx_PNG_RTHOT = 23
Private Const pbidx_PNG_RTNORM = 24
Private Const pbidx_PNG_RTOFF = 25


Private stcIdx As LongPtr
Private Const mPropCust = "Custom.Prop"
Private m_sDesktopPath As String
Private hColCX As LongPtr
Private hThemeProg As LongPtr
Private mTmrProc As LongPtr
Private mTmrProc2 As Long
Private mDtTmrProc As LongPtr
Private bFocusFlag As Boolean
Private bSILSet As Boolean
Private nsiSearch As Long
Private sThumbFactPath As String
Private propstoreFile As String
Private mCustomRootCompare As String
Private bBlankLoaded As Boolean
Private bBlockLoad As Boolean, nBlocks As Long
Private bColIsMapped As Boolean
Private nSFColComp As Long
Private mWinDrive As String, mWinDir As String
Private hFocused As LongPtr
Private hFocusFwd As LongPtr
Private bIPInit As Boolean
Private bFirstIPAOEvt As Boolean
Private IsWOW64 As boolean

'Med/L/XL Icons
Private himlLarge As LongPtr
Private cxyDispL As Long
Private nCthimlL As Long
Private bHoldDI As Boolean
Private Type SysImgCacheEntry
    sysimlid As Long
    limlidx As Long
End Type
Private SysImgCache() As SysImgCacheEntry
Private nSysImgCache As Long
Private bOvrAdded() As Boolean

'--

Private bForcedTypeCol As Boolean, bForcedPFCol As Boolean, bForcedDFSCol As Boolean
Private lDFSColIdx As Long
Private mStrVolOld As String

Private iidxBack As Long, iidxFwd As Long, iidxView As Long, iidxBkm As Long, iidxUp As Long
Private iidxMnBack As Long, iidxMnFwd As Long
Private iidxLgIcon As Long, iidxSmIcon As Long, iidxList As Long, iidxDetail As Long, iidxTile As Long, iidxThumb As Long, iidxCust As Long
Private iidxSortA As Long, iidxSortD As Long, iidxNewFldr As Long, iidxRefresh As Long, iidxPaste As Long
Private iidxLoTop As Long, iidxLoDtl As Long, iidxLoPrv As Long, iidxLoBar As Long, iidxLoTrv As Long, iidxLoSrch As Long, iidxLoSta As Long, iidxLoSPop As Long
Private cxyMenuImages As Long
Private m_hFwdBtn As LongPtr, m_hdcFwdBtn As LongPtr
Private m_hBackBtn As LongPtr, m_hdcBackBtn As LongPtr
Private cbSanityCheck1 As Long, cbSanityCheck2 As Long

Private m_ScaleX As Single, m_ScaleY As Single

Private cxLVIcon As Long, cyLVIcon As Long 'Large icon size for ListView; depends on ImageList

Private hUpButton As LongPtr
Private hViewButton As LongPtr
Private hBkmButton As LongPtr
Private hStdBackButton As LongPtr, hStdFwdButton As LongPtr
Private cxUpBtn As Long, cxViewBtn As Long, cxBkmBtn As Long, cxHistBtn As Long
Private bColSelWidthInit As Boolean

Private bUpEnable As Boolean

Private hIcoLnkOvr As LongPtr
Private hIcoLnkOvrSm As LongPtr
Private himlCxActual As Long, himlCyActual As Long

Private hSearchBox As LongPtr
Private hIcoSearchBox16 As LongPtr
Private hIcoSearchBox20 As LongPtr
Private hIcoSearchBox24 As LongPtr
Private hIcoSearchBoxDis16 As LongPtr
Private hIcoSearchBoxDis20 As LongPtr
Private hIcoSearchBoxDis24 As LongPtr
Private Const nSearchFooter1 As Long = 2147483640 'Libraries
Private Const nSearchFooter2 As Long = 2147483641 'Computer/This PC
Private Const nSearchFooter3 As Long = 2147483642 'Downloads
Private Const nSearchFooter4 As Long = 2147483643 'Recent
Private Const nSearchFooter5 As Long = 2147483644 'Custom
Private nSearchFtrIcon1 As Long
Private nSearchFtrIcon2 As Long
Private nSearchFtrIcon3 As Long
Private nSearchFtrIcon4 As Long
Private nSearchFtrIcon5 As Long

Private bIsWinVistaOrGreater As Boolean 'This control will not run on XP or lower
Private bIsWin7OrGreater As Boolean
Private bIsWin8OrGreater As Boolean
Private bIsWin10OrGreater As Boolean

Private bIsWow64 As Boolean
Private lWow64Data As Long

Private hLoadMarq As LongPtr
Private sMarqText As String

Private WithEvents PropFont As StdFont
Private mIFMain As IFont
Private CtlFont As StdFont
Private mIFCtl As IFont
Private TempFont As StdFont
Private Temp2Font As StdFont
Private mIFTmp As IFont
Private mIFTmp2 As IFont
Private hFontCtl As LongPtr
Private m_hFontMain As LongPtr
Private m_hFontDtHdr As LongPtr
Private m_hFontDtTxt As LongPtr
Private m_hFontMsg As LongPtr
Private m_cyFontDtTxt As Long
Private m_hFontDtAlt As LongPtr
Private m_hFontDtHdrAlt As LongPtr

Private cyDefSBox As Long
Private cyDefCbo As Long

Private m_hWnd As LongPtr

'ListView Rating Column - will require lvrHIML to be setup
Private lvrEnable As Boolean
Private lvrHIML As LongPtr
Private lvrCol As Long
Private lvrData() As Long

Private m_SubItemProgress As Long
Private m_SubItemFreeSpc As Long
Private m_SubItemType As Long
Private m_SubItemSize As Long

Private sUnsupportedHPF() As String
Private bFlagHPfErr As Boolean

Private hLinks() As LongPtr
Private nLinks As Long
Private mLinkCol As Long

Private himl_Thumb As LongPtr
Private bThumbsActive As Boolean

Private bRVM(8) As Boolean 'Restrict View Modes: 0=XLIcon,1=LgIcon,2=MedIcon,3=SmIcon,4=List,5=Detail,6=Tile,7=Content,8=Thumbnail

Private mCurCols As Long
Private sVax As String 'For LVN_GETDISPINFO text. Must be module level or memory gets corrupt and displays gibberish.

Private m_hSHNotify As Long
Private m_hSHSNC As Long

Private m_cbSort As LongPtr

Private nFooterBtn As Long

Private sCustomSet() As String
Private nCustomSet As Long
Private nCustomSetIcon As Long
Private lCustomSetIdx As Long
Private sTmpSearchSet() As String
Private kTmpSearchCt As Long
Private mSpec As String
Private bSbHasFocus As Boolean, bSbAltHasFocus As Boolean
Private nIcoForMq As Long
Private himlPtr16 As LongPtr
Private nAddIdx As Long
Private mColTmrProc As LongPtr
Private m_hCurBusy As LongPtr, m_hCurPrev As LongPtr
Private mExpIcoCB As Boolean
Private bAdjustOrder As Boolean, nAdjustOrder As Long
Private bSupDisp As Boolean
Private bFlag30 As Boolean
Private bFlagNoPL As Boolean
Private bUsedHPFforCD As Boolean
Private mDTSLeft As Long, mDTSRight As Long
Private mLastSelStr As String

Private bFolderHasCat As Boolean
Private Type siCategory
    lid As Long
    sName As String
End Type
Private sItemCats() As siCategory
Private bCatGrpActive As Boolean
Private mPrevGrpMode As ShellBrowseGroupBy
 
Private tcLastDirUpdate As LongLong

Private siDirect As IShellItem
Private pidlFQCur As LongPtr 'fully qualified pidl for current folder
Private lGrpCurCnt As Long
Private lGrp As Long
Private lGrpCol As Long
Private lGrpACnt(4) As Long
Private lGrpSCnt() As Long
Private lGrpTCnt() As Long
Private lGrpDCnt() As Long

Private hThemeNav As LongPtr
Private iNavStateCur As ucsb_NAV_BB_STATE
Private bBackEnable As Boolean
Private bBkBtnDown As Boolean
Private lOffBkBtn As Long
Private cxThemeButtonF As Long, cyThemeButtonF As Long
Private cxThemeButtonB As Long, cyThemeButtonB As Long

Private bHistoryOp As Boolean
Private bEnableFwd As Boolean
Private iFwdNavStateCur As ucsb_NAV_FB_STATE
Private bFwBtnDown As Boolean
Private lOffFwBtn As Long

Private tcHoldTime1 As Long, tcHoldTime2 As Long 'queue timers for select/deselect
Private bChangeQueued As Boolean
Private rzHoldTime1 As Long, rzHoldTime2 As Long 'queue timers for resize
Private bResizeQueued As Boolean
Private nmiclv As NMLISTVIEW

Private sManualFilter As String
Private ddRightButton As Boolean
Private bNoDrop As Boolean
Private mCurEf As DROPEFFECTS
Private lHover1 As Long, lHover2 As Long
Private xHover As Long, yHover As Long
Private lRaiseHover As Long
Private Const m_def_lRaiseHover As Long = 2500&
Private bHoverFired As Boolean
Private sFolder As String
Private bAbort As Boolean
Private bNoTarget As Boolean
Private lItemIndex As LongPtr
Private mDragOver As String
Private mDropTipMsg As String
Private mDropTipIns As String
Private mDropTipImg As DROPIMAGETYPE
Private mDefEffect As DROPEFFECTS
Private mIDOCalcdDef As DROPEFFECTS
Private mDropPathList() As String, bGotDropPathList As Boolean
Private dwAutoCompFlags As AUTOCOMPLETEOPTIONS
Private dwAutoCompListFlags As AUTOCOMPLETELISTOPTIONS
Private mPrevBarHeight As Long, mPrevBarTop As Long

Private sSelectedFile As String
Private tSelectedFile As UCSBFile
Private sSelectedFiles() As String
Private sSelectedFileNames() As String
Private sSelectedFileNamesF() As String
Private tSelectedFiles() As UCSBFile
Private sSelectedFilesOnly() As String
Private sSelectedFilesOnlyFull() As String
Private sSelectedFoldersOnly() As String
Private sSelectedFoldersOnlyFull() As String
Private SelectedFileIndex As Long

Private hLVS As LongPtr
Private hLVSHdr As LongPtr
Private hLVCHdr As LongPtr
Private hLEEdit As LongPtr
Private cxLV As Long
Private lvDragOverIdx As Long, lvDragOverLP As LongPtr
Private hLVC As LongPtr
Private m_ColSortCallback As LongPtr
Private hDtFocus As LongPtr
Private bUseDrvRemForEM As Boolean
Private mSelFirstIfNoPrev As Boolean, mSelFirstMustBeFile As Boolean
Private bLVCGroup As Boolean
Private mLVCFilt As String
Private bLVCAdv As Boolean
Private bLVCFlagLoad As Boolean
Private mLVCSort As Long
Private mLVCColSort As Long

Private bwpFlag As Boolean

Private bSearchExt As Boolean
Private sKindVals() As String, sKindTxt() As String
Private hDTSearch1 As LongPtr, hDTSearch2 As LongPtr
Private stShLast1 As SYSTEMTIME, stShLast2 As SYSTEMTIME
Private bDtSC As Boolean
Private bUseSearchMarkup As Boolean
Private hSearchBoxAlt As LongPtr
Private bSearchAltText As Boolean
Private bSearchAlt As Boolean
Private bSBSC1 As Boolean
Private bSrSetCancel As Boolean

Private bFlagNoIndent As Boolean 'Searches and custom folders won't have valid parents for indenting
Private lCurMaxInd As Long

Private nLastCbxSelChg As Long

Private bInGVSI As Boolean
Private hFontLVMain As LongPtr, hFontLVHdrMain As LongPtr
Private hFontDropdown As LongPtr
Private WithEvents PropFontLV As StdFont
Private mIFLV As IFont
Private WithEvents PropFontDt As StdFont

Private mUsingCustomIcons As Boolean

Private mUseAdvancedSort As Boolean
Private mAdvSortFlags As ucsb_COMPARE_FLAGS
Private mAdvSortLocale As String
Private mLastSortInfo As Long

Private lvcCurSel As Long
Private lvcCurDragLoc As Long
Private bLVCDragging As Boolean

Private hUpDown As LongPtr
Private bSetArrow As Boolean

Private mShellTreeVis As Boolean

Private bFlagRootReset As Boolean
Private sTrackPrevLoc As String

Private WinMediaDir As String

Private Const DESKTOPHORZRES As Long = 118
Private Const DESKTOPVERTRES As Long = 117

Private mActualZoom As Single 'Get actual DPI even if virtualized

Private hGlobalPV As LongPtr

Private bPvLockCX As Boolean
Private bDtLockCY As Boolean

Private bForceCtlOff As Boolean

Private bCustActive As Boolean

Private cyDtName As Long

Private Const WM_SHNOTIFY = &H477
Private Const WM_SHNOTIFYB = &H478

Private bInMenu As Boolean
Private mOvrMax As Long
Private mStatusText As String

Private mFontFolder As String
Private mDeskFolder As String

Private sColText() As String
Private lColSet() As Long
Private bKeepColumns As Boolean
Private lKeepColIdx As LongPtr
Private lKeepColSet() As Long
Private nCurrentCBItemIndex As LongPtr
Private bCbEditFocus As Boolean
Private bFilterActive As Boolean
Private bColSelActive As Boolean
Private bLVCFilterActive As Boolean
Private bFlagTabProc As Boolean
Private bComboOpen As Boolean
Private bFlagNewFldr As Boolean


Private m_sCurPathDisp As String
Private m_sCurPath As String
Private m_def_sCurPath As String
Private m_sAltDrop As String
Private m_CurSize As LongLong

Private m_Bookmarks As String

Private Const MIN_PANELWIDTH As Long = 100
Private Type PANEL_INFO
    lStyle     As Long
    lMinWidth  As Long
    lWidth     As Long
    eAutosize  As sbAutosizeStyleConstants
    sText      As String
    sTipText   As String
    lIconIndex As Long
End Type
 
Private Enum sbAutosizeStyleConstants
    sbNoAutosize = 0
    sbSpring = 1
    sbContents = 2
End Enum
 
Private m_hStatusBar   As LongPtr
Private m_hImageList   As LongPtr
Private m_uPanelInfo() As PANEL_INFO
Private m_lPanelCount  As Long
Private cyStatusBar As Long  'Status bar height

Private bRNf As Boolean
Private bHoldSS As Boolean
Private bTmrFlag As Boolean
Private bICFlag As Boolean
Private tct1 As Long
Private bDTHSC As Boolean
Private sPrevPath As String
Private sHistory() As String
Private nHistIdx As Long
Private bPropEditActive As Boolean
Private sOldLEText As String
Private pidlt As LongPtr
Private bStartup As Boolean
Private bSuppress As Boolean
Private hDetailName As LongPtr
Private bRegDD As Boolean
Private bFlagSwitch1 As Boolean

Private mDlgGuid As String
Private bInLVLFLoop As Boolean
Private bLVEscaped As Boolean
Private mLibRootDisp As String, mCompRtDisp As String, mDlDisp As String, mRplDisp As String
Private mSearchTextCache As String
Private bFooterDoReload As Boolean, bWillLoadSearchFt As Boolean
Private ftCache_LblText As String, ftCache_himl As LongPtr, ftCache_BtnCaps() As String, ftCache_BtnIcon As Variant, ftCache_BtnLp() As Long
Private mFlagActiveSearch As Boolean
Private mWPCFlag As Boolean, sWPCFlag As String
Private bFlagCustomFolderHasColSet As Boolean


Private hCombo As LongPtr
Private hCBEd As LongPtr
Private hCBBox As LongPtr
Private cyCombo As Long
Private nOldCbSel As Long

Private hIconBack As LongPtr, hIconFwd As LongPtr
Private hIconUp As LongPtr
Private hIconView As LongPtr
Private hIconBkm As LongPtr

Private himlFooter As LongPtr

Private Type HistPidl
    sPath As String
    pidlFQ As LongPtr
End Type
Private uPidlStore() As HistPidl 'Note: All pidls must be freed on terminate!

Private Type CBEntry
    sFullPath As String
    sDisp As String
    nIcon As Long
    iIndnt As Long
    lCacheIdx As Long
    lSearchIdx As Long
    lKey As Long
    bNoIdentMembers As Boolean
    bIsDefItem As Boolean
    bDeleted As Boolean
    bUseColset As Boolean 'user has changed the default columns, so use those instead of Explorer
    bHasProgress As Boolean 'Computer and any device with drive list
    lColSet() As LongPtr
    bUCDVisMap() As Boolean
End Type
Private cbItems() As CBEntry

Private Type DetailPaneProp
    hEdit As LongPtr
    hAlt As LongPtr 'datetime or dropdown
    nCol As Long
    sOrig As String
    vOrigForDT As Variant 'VT_FILETIME->vbDate Variant
    stNewForDT As SYSTEMTIME
    bUseNewST As Boolean
    sEdit As String
    sSysName As String
    sDispName As String
    sInvite As String 'The Edit Invitation, e.g. 'Add Author'
    dwDispType As PROPDESC_DISPLAYTYPE
    fReadOnly As Long 'S_OK = can edit
    bWrite As Boolean
    bHighlight As Boolean 'Border active on mouseover
    bUnformatNum As Boolean
    nVarTypeForNumber As VbVarType
    vNumberValue As Variant
    vEnumeratedValue As Variant 'current value for enumerated properties
    lEnumeratedInitialIndex As Long
    lEnumeratedNewIndex As Long
    bEnumeratedUseNewIndex As Boolean
    vEnumeratedEndRange As Variant
    vEnumeratedIsEmpty As Boolean
    vEnumeratedIsRanged As Boolean
    sEnumerated() As String 'Labels for enumerated properties
    vEnumerated() As Variant 'For ranged values
End Type
Private tDispProps() As DetailPaneProp 'The array of items in the current Details Pane
Private nDispProp As Long
Private Type DPColStruct
    tDP() As Long
End Type

Private Type ColumnData
    pKey As PROPERTYKEY
    szDisplayName As String
    szSystemName As String
    Visible As Boolean
    ColVis As Boolean
    IsDefProp As Boolean 'default columns; name,size,type,folder,modified,created,accessed
    DefPropOrder As Long
    pos As Long
    DefWidth As Long
    NoList As Boolean
    dwTypeFlags As PROPDESC_TYPE_FLAGS
    dwDispType As PROPDESC_DISPLAYTYPE
    dwViewFlags As PROPDESC_VIEW_FLAGS
    dwColState As SHCOLSTATEF
    dwCustColState As CM_STATE
    bFlagRecent As Boolean
    bFlagCustom As Boolean
    szCustomFor As String
    bFlagManual As Boolean
    lManualInsertAt As Long
    bFlagManHasImg As Boolean
    bFlagIsLink As Boolean
    nMapsTo As Long
    lParam As LongPtr
End Type
Private uColData() As ColumnData

Private bUCDhasCust As Boolean

Private lColKey() As Long
Private lRTColIdx As Long 'rating
Private lRTSColIdx As Long 'PreviewDetails for rating support check
Private lPFColIdx As Long '% full
Private bLockRating As Boolean
Private Const idFS_RatingLock = 2106
Private lrLastIndex       As Long
Private Const ID_Disable As Long = 2
Private Const ID_Hot As Long = 1
Private Const ID_Selected As Long = 0

Private idxSizePanel As Long, idxZonePanel As Long
Private Type ZoneData
    Zone As URLZONE
    szDisp As String
    szIcon As String
    hIcon As LongPtr
    hIconSm As LongPtr
End Type
Private arZones() As ZoneData

Private bFlagSearchDisable As Boolean
Private bFlagOWDropTrip As Boolean

Private bDTPaneSingleItemActive As Boolean
Private cxyDTPaneIcon As Long
Private cxyLgIcn As Long
Private m_cxMinLV As Long
Private himlHdrMV As LongPtr
Private bLoadDone As Boolean
Private Const widBkmAdd = 4000
Private Const widBkmRem = 4001
Private Const widBkmClr = 4002
Private Const wIDBkmVw As Long = 4005
Private Const widBaseSF = 700
Private Const widBkmLBase = 4011
Private Const widHisMnBase = 28000
Private Const widSL1 = 1598
Private Const widSL2 = 1599
Private Const widSL3 = 1597

Private Const widLockDT = 4003
Private Const widLockPV = 4004

Private Const widViewFirst = 5000
Private Const widViewLI = 5000
Private Const widViewSM = 5001
Private Const widViewLS = 5002
Private Const widViewDT = 5003
Private Const widViewTV = 5004
Private Const widViewCT = 5007
Private Const widViewJM = 5006
Private Const widViewXL = 5008
Private Const widViewMD = 5009
Private Const widViewCU = 5010
Private Const widViewLast = 5030 'Probably won't add more View Modes, but I was annoyed after widViewCU was added and didn't get a tip.
Private Const widGrpNone = 2999
Private Const widGrpCat = 2998
Private Const widBaseSort = 1500
Private Const widBaseGrp = 1501
Private Const widBaseG = 2000&
Private Const widBaseS = 3000&
Private Const widSortAsc = 1502
Private Const widSortDsc = 1503
Private Const widNewFldr = 1504
Private Const widProps = 1505
Private Const widRefresh = 1506
Private Const widShowSB = 1507
Private Const widShowPV = 1508
Private Const widShowDT = 1509
Private Const widBkPaste = 1510
Private Const widShowSX = 1511
Private Const widShowSXA = 1512
Private Const widSelAll = 1513
Private Const widSelInv = 1514
Private Const widLay = 1515
Private Const widCtlB = 1516
Private Const widNavTree = 1517
Private Const widCopyPath = 1518
Private Const widSearchPopup = 1519
Private Const widCtxBack = 1520
Private Const widCtxFwd = 1521

Private Const wIDSel As Long = &H7000
Private Const widBrowse = &H7001
Private Const widCpyNames = &H7002
Private Const widCpyPaths = &H7003
Private Const idColMnBase = 52000
Private Const idName As Long = 8000
Private Const idSize As Long = 8001
Private Const idType As Long = 8002
Private Const idMod As Long = 8004
Private Const idCrd As Long = 8005
Private Const idAcc As Long = 8006
Private Const idMore As Long = 8007
Private Const idLockCol As Long = 8008
Private Const widLVCCol As Long = 1551
Private Const widLVCTop As Long = 1552

Private mn_sName2 As String
Private mn_sSize2 As String
Private mn_sType2 As String
Private mn_sMod2 As String
Private mn_sCrd2 As String
Private mn_sAcc2 As String

Private bColStates(5) As Boolean
Private bDispCol() As Boolean
Private lDefColIdx(5) As Long
Private lDefColISF(5) As Long
Private lFBCol() As Long

Private Type UCSBF_ColLink
    hLink As LongPtr
    iCol As Long
    ucdIdx As Long
    sLink As String
End Type
Private Type ColumnCache 'Used to cache the column data of each item
    bSet As Boolean 'This value has been set (checking the value might be empty)
    cdid As Long 'ID of column: the index of it in uColData
    sDisp As String 'The text that's displayed in the ListView
    vRaw As Variant 'The raw data value from IPropertyStore.GetValue
End Type
Private Type UCSBFile
    sName As String
    sNameExt As String 'With extension
    sNameFull As String
    sNameParsing As String
    sNameReduced As String
    sFullPath As String
    sFullPKParse As String
    sFullDAPRaw As String
    sFullFSPRaw As String
    sParentFull As String
    sExt As String
    bFolder As Boolean
    bZip As Boolean 'Only set if bFolder is True
    bLink As Boolean
    bLinkToFolder As Boolean
    bLinkExe As Boolean
    bIsADS As Boolean
    dwAttrib As SFGAO_Flags
    nIcon As Long
    nFileIcon As Long
    idxThumb As Long
    nOverlay As Long
    nOverlayIdx As Long
    nFileOverlay As Long
    lIndent As Long
    lParam As LongPtr
    sDateC As String
    ftDateC As FILETIME
    sDateM As String
    ftDateM As FILETIME
    sDateA As String
    ftDateA As FILETIME
    cSize As LongLong
    sSize As String
    sType As String
    iGrp As Long
    lTypeID As Long
    lCatID As Long
    tThumbID As WTS_THUMBNAILID
    fChecked As Long
    lRating As Long 'only filled if rating column has been added
    bRatingSupport As Boolean 'if the file even supports a star rating; also only if col present
    lDropTarget As Long '0=not set, 1=not a drop target, 2=drop target
    lPercent As Long 'only filled if %full column displayed
    pidlRel As LongPtr
    bDeleted As Boolean
    bCut As Boolean
    sPropListInfoTip As String
    nLinkCols As Long
    dwID As Long 'ListView ID for LVM_MAPIDTOINDEX
    LinkCols() As UCSBF_ColLink
    ExtColData() As ColumnCache 'Cache the column data to improve performance
End Type
Private LVEntries() As UCSBFile


Private Type FolderCache
   sParsingPath As String
   bSet As Boolean
   bInvalidate As Boolean
   ColSet() As LongPtr
   FileData() As UCSBFile
End Type
Private MainCache() As FolderCache

Private nCurFolders As Long
Private nCurFiles As Long

Private Type EntryStream
  sStreamName As String
  cStreamSize As LongLong
End Type

Private Enum SortType
    eSortName = &H2
    eSortSize = &H4
    eSortType = &H8
    eSortDateM = &H10
    eSortDateC = &H20
    eSortDateA = &H40
    eSortText = &H80
    eSortExtDate = &H100
    eSortExtNum = &H200
End Enum
Private lSortD As Long
Private lSortK As Long
Private lSortProp As Long
Private ecdKey As Long

Private bGV As Boolean

Private Type LVGROUPIDS
    sEntry As String
    lGrpID As Long
    bInserted As Boolean
    dwRefData As Long 'extra data for various types; first use is typename default icon index
End Type
Private gidType() As LVGROUPIDS
Private gidText() As LVGROUPIDS
Private gidCat() As LVGROUPIDS
Private nGpCat As Long
Private nGpTxt As Long
Private lGrpIDs() As Long
Private nGrpIDs As Long
Private lvGroupsSize As String
Private arGroupsSize() As String
Private bSearchAutogrouped As Boolean
Private lPriorGroupCol As Long


Private arGroupsDates() As String
Private arGroupsDatesC() As String
Private arGroupsDatesA() As String

Private Const sComp = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}" 'Computer
Private Const sComp2 = "::{0AC0837C-BBF8-452A-850D-79D08E667CA7}" 'I'm not sure if that GUID differs on different OS's
                                                                  'Because why is it not FOLDERID_Computer to begin with???
                                                                  'So check this too
Private Const sLibRoot = "::{031E4825-7B94-4DC3-B131-E946B44C8DD5}\"
Private Const sLibRoot2 = "::{031E4825-7B94-4DC3-B131-E946B44C8DD5}"
Private Const sRecentPl = "::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"
Private Const lnLibRoot As Long = 41& 'length

Private Const COLOR_MENU = 4
Private Const COLOR_WINDOW = 5
Private Const COLOR_WINDOWTEXT = 8
Private Const COLOR_GRAYTEXT = 17
Private m_SysClrGray As Long
Private m_SysClrWindow As Long
Private m_SysClrText As Long
Private m_SysClrMenu As Long
Private cySysBorder As Long
Private bSMove As Boolean
Private bPMove As Boolean
Private nLastDtPaneOp As Long

Private szLVBKUrl As String
Private PropPicture As stdole.IPictureDisp
Private PropPictureWatermark As Boolean
Public Enum SBPictureAlignmentConstants
    SBPicAlignTopLeft = 0
    SBPicAlignTopRight = 1
    SBPicAlignBottomLeft = 2
    SBPicAlignBottomRight = 3
    SBPicAlignCenter = 4
    SBPicAlignTile = 5
End Enum
Private PropPictureAlignment As SBPictureAlignmentConstants

Private Const m_sVerbUndo As String = "undo" 'Possible glitch workaround for Ctrl+Z shortcut
Private Const m_sVerbRedo As String = "redo" 'For Ctrl+Y redo

'---------------------------------------------------------------------------------
'
'=================================================================================
'
'END CUSTOM DECLARES - All definitions below this point are for Windows API
'
'=================================================================================
'
'---------------------------------------------------------------------------------                ' close for each entry to ensure file buffers flushed
#End Region

#Region "APIDeclares"

Private Const TRANSPARENT = 1&
Private Const OPAQUE = 2&

Private Declare PtrSafe Function AssocGetPerceivedType Lib "shlwapi.dll" (ByVal pszExt As LongPtr, ptype As ucsb_PERCEIVED, pflag As ucsb_PERCEIVEDFLAG, ppszType As LongPtr) As Long
Private Declare PtrSafe Function AssocQueryString Lib "shlwapi.dll" Alias "AssocQueryStringA" (ByVal Flags As ASSOCF, ByVal str As ASSOCSTR, ByVal pszAssoc As String, ByVal pszExtra As String, ByVal pszOut As String, ByRef pcchOut As Long) As Long
Private Declare PtrSafe Function BitBlt Lib "gdi32" (ByVal hDestDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As LongPtr, ByVal XSrc As Long, ByVal YSrc As Long, ByVal dwRop As Long) As Long
Private Declare PtrSafe Function ClientToScreen Lib "user32" (ByVal hWnd As LongPtr, lpPoint As Any) As Long  ' lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function CloseThemeData Lib "uxtheme" (ByVal hTheme As LongPtr) As Long
Private Declare PtrSafe Function CLSIDFromString Lib "ole32" (ByVal lpszGuid As LongPtr, pGuid As Any) As Long
Private Declare PtrSafe Function CoCreateInstance Lib "ole32" (rclsid As Any, ByVal pUnkOuter As LongPtr, ByVal dwClsContext As Long, riid As UUID, pvarResult As Any) As Long
Private Declare PtrSafe Function CompareFileTime Lib "kernel32" (ByVal lpFileTime1 As LongPtr, ByVal lpFileTime2 As LongPtr) As Long
Private Declare PtrSafe Function CompareStringEx Lib "kernel32" (ByVal lpLocaleName As LongPtr, ByVal dwCmpFlags As ucsb_COMPARE_FLAGS, ByVal lpString1 As LongPtr, ByVal cchCount1 As Long, ByVal lpString2 As LongPtr, ByVal cchCount2 As Long, ByVal lpVersionInformation As LongPtr, ByVal lpReserved As LongPtr, ByVal lParam As LongPtr) As ucsb_CSTR_RETURNS
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
Private Declare PtrSafe Sub CoTaskMemFree Lib "ole32" (ByVal pv As LongPtr)
Private Declare PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hDC As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
Private Declare PtrSafe Function CreateDIBSection Lib "gdi32" (ByVal hDC As LongPtr, pBitmapInfo As BITMAPINFO, ByVal usage As Long, ByRef lplpVoid As Any, ByVal hSection As LongPtr, ByVal offset As Long) As LongPtr
Private Declare PtrSafe Function CreateDirectoryExW Lib "kernel32.dll" (ByVal lpTemplateDirectory As LongPtr, ByVal lpNewDirectory As LongPtr, lpSecurityAttributes As SECURITY_ATTRIBUTES) As Long
Private Declare PtrSafe Function CreateFileW Lib "kernel32" (ByVal lpFileName As LongPtr, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, lpSecurityAttributes As Any, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As LongPtr) As LongPtr
Private Declare PtrSafe Function CreateFontIndirect Lib "gdi32" Alias "CreateFontIndirectA" (ByRef lpLogFont As LOGFONT) As LongPtr
Private Declare PtrSafe Function CreateFontIndirectW Lib "gdi32" (ByRef lpLogFont As LOGFONTW) As LongPtr
Private Declare PtrSafe Function CreateIconFromResourceEx Lib "user32.dll" (ByRef presbits As Any, ByVal dwResSize As Long, ByVal fIcon As Long, ByVal dwVer As Long, ByVal cxDesired As Long, ByVal cyDesired As Long, ByVal Flags As Long) As LongPtr
Private Declare PtrSafe Function CreateMenu Lib "user32" () As LongPtr
Private Declare PtrSafe Function CreatePopupMenu Lib "user32" () As LongPtr
Private Declare PtrSafe Function CreateSolidBrush Lib "gdi32.dll" (ByVal crColor As Long) As LongPtr
Private Declare PtrSafe Function CreateStreamOnHGlobal Lib "ole32" (ByVal hGlobal As LongPtr, ByVal fDeleteOnRelease As Long, ppstm As IStream) As Long
Private Declare PtrSafe Function CreateWindowExW Lib "user32" (ByVal dwExStyle As Long, ByVal lpClassName As LongPtr, ByVal lpWindowName As LongPtr, ByVal dwStyle As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As LongPtr, ByVal hMenu As LongPtr, ByVal hInstance As LongPtr, lpParam As Any) As LongPtr
Private Declare PtrSafe Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function DestroyIcon Lib "user32.dll" (ByVal hIcon As LongPtr) As Long
Private Declare PtrSafe Function DestroyMenu Lib "user32" (ByVal hMenu As LongPtr) As Long
Private Declare PtrSafe Function DestroyWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function DispatchMessage Lib "user32" Alias "DispatchMessageW" (ByRef lpMsg As Any) As LongPtr
Private Declare PtrSafe Function DllGetVersion Lib "comctl32" (ByRef pdvi As DLLVERSIONINFO) As Long
Private Declare PtrSafe Function DragQueryFileW Lib "shell32.dll" (ByVal hDrop As LongPtr, ByVal iFile As Long, Optional ByVal lpszFile As LongPtr, Optional ByVal cch As Long) As Long
Private Declare PtrSafe Function DrawIconEx Lib "user32" (ByVal hDC As LongPtr, ByVal XLeft As Long, ByVal YTop As Long, ByVal hIcon As LongPtr, ByVal CXWidth As Long, ByVal CYWidth As Long, ByVal istepIfAniCur As Long, ByVal hbrFlickerFreeDraw As LongPtr, ByVal diFlags As Long) As Long
Private Declare PtrSafe Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As LongPtr, ByVal lpchText As LongPtr, ByVal nCount As Long, ByRef lpRect As RECT, ByVal uFormat As ucsb_DT_Flags) As Long
Private Declare PtrSafe Function DrawThemeBackground Lib "uxtheme" (ByVal hTheme As LongPtr, ByVal lhDC As LongPtr, ByVal iPartId As Long, ByVal iStateId As Long, pRect As RECT, pClipRect As Any) As Long
Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
Private Declare PtrSafe Function EnableWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal fEnable As Long) As Long
Private Declare PtrSafe Function ExpandEnvironmentStringsW Lib "kernel32" (ByVal lpSrc As LongPtr, ByVal lpDst As LongPtr, ByVal nSize As Long) As Long
Private Declare PtrSafe Function ExtractIconExW Lib "shell32.dll" (ByVal lpszFile As LongPtr, ByVal nIconIndex As Long, phiconLarge As LongPtr, phiconSmall As LongPtr, ByVal nIcons As Long) As Long
Private Declare PtrSafe Function FileTimeToLocalFileTime Lib "kernel32" (lpFileTime As FILETIME, lpLocalFileTime As FILETIME) As Long
Private Declare PtrSafe Function FileTimeToSystemTime Lib "kernel32" (lpFileTime As FILETIME, lpSystemTime As SYSTEMTIME) As Long
Private Declare PtrSafe Function FindResourceW Lib "kernel32" (ByVal hInstance As LongPtr, ByVal lpName As LongPtr, ByVal lpType As LongPtr) As LongPtr
Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hwndParent As LongPtr, ByVal hWndChildAfter As LongPtr, ByVal lpszClass As String, ByVal lpszWindow As String) As LongPtr
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
Private Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hWnd As LongPtr, ByVal gaFlags As GA_Flags) As LongPtr
Private Declare PtrSafe Function GetAsyncKeyState Lib "user32.dll" (ByVal VKey As Long) As Integer
Private Declare PtrSafe Function GetClientRect Lib "user32" (ByVal hWnd As LongPtr, lpRect As RECT) As Long
Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As LongPtr
Private Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As Any) As Long
Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetDIBits Lib "gdi32" (ByVal aHDC As LongPtr, ByVal hBitmap As LongPtr, ByVal nStartScan As Long, ByVal nNumScans As Long, ByRef lpBits As Any, ByRef lpBI As BITMAPINFO, ByVal wUsage As Long) As Long
Private Declare PtrSafe Function GetDriveType Lib "kernel32" Alias "GetDriveTypeW" (ByVal lpRootPathName As LongPtr) As ucsb_GDT_Types
Private Declare PtrSafe Function GetFileSize Lib "kernel32" (ByVal hFile As LongPtr, lpFileSizeHigh As Long) As Long
Private Declare PtrSafe Function GetFileVersionInfoSizeW Lib "version.dll" (ByVal lptstrFilename As LongPtr, lpdwHandle As Long) As Long
Private Declare PtrSafe Function GetFileVersionInfoW Lib "version.dll" (ByVal lptstrFilename As LongPtr, ByVal dwhandle As Long, ByVal dwLen As Long, lpData As Any) As Long
Private Declare PtrSafe Function GetIconInfo Lib "user32" (ByVal hIcon As LongPtr, pIconInfo As ICONINFO) As Long
Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Private Declare PtrSafe Function GetLastError Lib "kernel32" () As Long
Private Declare PtrSafe Sub GetLocalTime Lib "kernel32" (lpSystemTime As SYSTEMTIME)
Private Declare PtrSafe Function GetMenuItemCount Lib "user32" (ByVal hMenu As LongPtr) As Long
Private Declare PtrSafe Function GetMenuItemID Lib "user32" (ByVal hMenu As LongPtr, ByVal nPos As Long) As Long
Private Declare PtrSafe Function GetModuleFileName Lib "kernel32" Alias "GetModuleFileNameA" (ByVal hModule As LongPtr, ByVal lpFileName As String, ByVal nSize As Long) As Long
Private Declare PtrSafe Function GetObject Lib "gdi32" Alias "GetObjectA" (ByVal hObject As LongPtr, ByVal nCount As Long, lpObject As Any) As Long
Private Declare PtrSafe Function GetObjectW Lib "gdi32" (ByVal hObject As LongPtr, ByVal nCount As Long, lpObject As Any) As Long
Private Declare PtrSafe Function GetStockObject Lib "gdi32.dll" (ByVal nIndex As ucsb_StockObjects) As LongPtr
Private Declare PtrSafe Function GetStringTypeExW Lib "kernel32" (ByVal Locale As Long, ByVal dwInfoType As GST_Class, ByVal lpSrcStr As LongPtr, ByVal cchSrc As Long, lpCharType As Integer) As Long
Private Declare PtrSafe Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetSystemMetrics Lib "user32.dll" (ByVal nIndex As SystemMetrics) As Long
Private Declare PtrSafe Function GetTextExtentPoint32W Lib "gdi32" (ByVal hDC As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, lpSize As SIZE) As Long
Private Declare PtrSafe Function GetThemeMetric Lib "uxtheme" (ByVal hTheme As LongPtr, ByVal hDC As LongPtr, ByVal iPartId As Long, ByVal iStateId As Long, ByVal iPropId As Long, piVal As Long) As Long
Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
Private Declare PtrSafe Function GetTickCount64 Lib "kernel32" () As LongLong
Private Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, lpRect As RECT) As Long
Private Declare PtrSafe Function GetWindowsDirectoryW Lib "kernel32" (lpBuffer As Any, ByVal nSize As Long) As Long
Private Declare PtrSafe Function ILCreateFromPathW Lib "shell32" (ByVal pwszPath As LongPtr) As LongPtr
Private Declare PtrSafe Function ILFindLastID Lib "shell32" (ByVal pidl As LongPtr) As LongPtr
Private Declare PtrSafe Function InitPropVariantFromFileTime Lib "propsys" (ft As FILETIME, ppropvar As Variant) As Long
Private Declare PtrSafe Function InsertMenuItemW Lib "user32" (ByVal hMenu As LongPtr, ByVal uItem As Long, ByVal fByPosition As Boolean, lpmii As MENUITEMINFOW) As Boolean
Private Declare PtrSafe Function IsEqualIID Lib "ole32" Alias "IsEqualGUID" (iid1 As UUID, iid2 As UUID) As Long
Private Declare PtrSafe Function IsWow64Process Lib "kernel32.dll" (ByVal hProcess As LongPtr, ByRef Wow64Process As Long) As Long
Private Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal uIDEvent As LongPtr) As Long
Private Declare PtrSafe Function LoadCursor Lib "user32" Alias "LoadCursorW" (ByVal hInstance As LongPtr, ByVal lpCursorName As Any) As LongPtr
Private Declare PtrSafe Function LoadImageW Lib "user32" (ByVal hInst As LongPtr, ByVal lpsz As LongPtr, ByVal dwImageType As ucsb_ImageTypes, ByVal dwDesiredWidth As Long, ByVal dwDesiredHeight As Long, ByVal dwFlags As ucsb_LoadResourceFlags) As LongPtr
Private Declare PtrSafe Function LoadLibraryW Lib "kernel32" (ByVal lpLibFileName As LongPtr) As LongPtr
Private Declare PtrSafe Function LoadResource Lib "kernel32" (ByVal hInstance As LongPtr, ByVal hResInfo As LongPtr) As LongPtr
Private Declare PtrSafe Function LocalFileTimeToFileTime Lib "kernel32" (lpLocalFileTime As FILETIME, lpFileTime As FILETIME) As Long
Private Declare PtrSafe Function LockResource Lib "kernel32" (ByVal hResData As LongPtr) As LongPtr
Private Declare PtrSafe Function LockWindowUpdate Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function lstrcpyA Lib "kernel32" (lpString1 As Any, lpString2 As Any) As LongPtr
Private Declare PtrSafe Function lstrlenA Lib "kernel32" (lpString As Any) As Long
Private Declare PtrSafe Function lstrlenW Lib "kernel32" (lpString As Any) As Long
Private Declare PtrSafe Function MapWindowPoints Lib "user32" (ByVal hWndFrom As LongPtr, ByVal hWndTo As LongPtr, lpPoints As Any, ByVal cPoints As Long) As Long
Private Declare PtrSafe Function MessageBoxW Lib "user32.dll" (ByVal hWnd As LongPtr, ByVal lpText As LongPtr, ByVal lpCaption As LongPtr, ByVal wType As Long) As Long
Private Declare PtrSafe Function MoveWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare PtrSafe Function MulDiv Lib "kernel32" (ByVal nNumber As Long, ByVal nNumerator As Long, ByVal nDenominator As Long) As Long
Private Declare PtrSafe Function MultiByteToWideChar Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As MBWC_Flags, ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As Long, ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As Long) As Long
Private Declare PtrSafe Function NtClose Lib "ntdll" (ByVal ObjectHandle As LongPtr) As Long
Private Declare PtrSafe Function NtCreateFile Lib "ntdll" (FileHandle As LongPtr, ByVal DesiredAccess As Long, ObjectAttributes As OBJECT_ATTRIBUTES, IoStatusBlock As IO_STATUS_BLOCK, AllocationSize As Any, ByVal FileAttributes As Long, ByVal ShareAccess As Long, ByVal CreateDisposition As Long, ByVal CreateOptions As Long, EaBuffer As Any, ByVal EaLength As Long) As Long
Private Declare PtrSafe Function NtOpenFile Lib "ntdll" (FileHandle As LongPtr, ByVal DesiredAccess As Long, ObjectAttributes As OBJECT_ATTRIBUTES, IoStatusBlock As IO_STATUS_BLOCK, ByVal ShareAccess As Long, ByVal OpenOptions As Long) As Long
Private Declare PtrSafe Function NtQueryDirectoryFile Lib "ntdll" (ByVal FileHandle As LongPtr, ByVal hEvent As LongPtr, ByVal ApcRoutine As LongPtr, ByVal ApcContext As LongPtr, ByRef IoStatusBlock As Any, FileInformation As Any, ByVal Length As Long, ByVal FileInformationClass As FILE_INFORMATION_CLASS, ByVal ReturnSingleEntry As Long, FileName As Any, ByVal RestartScan As Long) As Long
Private Declare PtrSafe Function NtQueryInformationFile Lib "ntdll" (ByVal FileHandle As LongPtr, IoStatusBlock_Out As IO_STATUS_BLOCK, lpFileInformation_Out As LongPtr, ByVal Length As Long, ByVal FileInformationClass As Long) As Long
Private Declare PtrSafe Function OleGetClipboard Lib "ole32" (ppDataObj As IDataObject) As Long
Private Declare PtrSafe Function OleTranslateColor Lib "oleaut32" (ByVal Color As Long, ByVal hpal As LongPtr, ByRef RGBResult As Long) As Long
Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function OpenThemeData Lib "uxtheme" (ByVal hWnd As LongPtr, ByVal pszClassList As LongPtr) As LongPtr
Private Declare PtrSafe Function PathCompactPath Lib "shlwapi" Alias "PathCompactPathW" (ByVal hDC As LongPtr, ByVal pszPath As String, ByVal dx As Long) As Long
Private Declare PtrSafe Function PathFileExistsW Lib "shlwapi" (ByVal lpszPath As LongPtr) As Long
Private Declare PtrSafe Function PathIsDirectoryW Lib "shlwapi" (ByVal lpszPath As LongPtr) As Long
Private Declare PtrSafe Function PathFindFileNameW Lib "shlwapi" (ByVal pszPath As LongPtr) As LongPtr
Private Declare PtrSafe Function PathIsNetworkPath Lib "shlwapi" Alias "PathIsNetworkPathW" (ByVal pszPath As LongPtr) As Long
Private Declare PtrSafe Function PathMatchSpecW Lib "shlwapi" (ByVal pszFileParam As LongPtr, ByVal pszSpec As LongPtr) As Long
Private Declare PtrSafe Function PathMatchSpecExW Lib "shlwapi" (ByVal pszFile As LongPtr, ByVal pszSpec As LongPtr, ByVal dwFlags As ucsb_PMS_Flags) As Long
Private Declare PtrSafe Function PathYetAnotherMakeUniqueName Lib "shell32.dll" (ByVal pszUniqueName As LongPtr, ByVal pszPath As LongPtr, Optional ByVal pszShort As LongPtr, Optional ByVal pszFileSpec As LongPtr) As Long
Private Declare PtrSafe Function PeekMessage Lib "user32" Alias "PeekMessageW" (lpMsg As MSG, ByVal hWnd As LongPtr, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long, ByVal wRemoveMsg As Long) As Long
Private Declare PtrSafe Function PlaySound Lib "winmm.dll" Alias "PlaySoundW" (ByVal lpszName As LongPtr, ByVal hModule As LongPtr, ByVal dwFlags As ucsb_SND_FLAGS) As Long
Private Declare PtrSafe Function PropVariantChangeType Lib "propsys" (ByRef ppropvarDest As Any, ByRef propvarSrc As Any, ByVal Flags As Long, ByVal vt As VARENUM) As Long
Private Declare PtrSafe Function PropVariantClear Lib "ole32" (ByRef propvar As Any) As Long
Private Declare PtrSafe Function PropVariantToVariant Lib "propsys" (ByRef propvar As Any, ByRef var As Variant) As Long
Private Declare PtrSafe Function PSFormatPropertyValue Lib "propsys.dll" (ByVal pps As LongPtr, ByVal ppd As LongPtr, ByVal pdff As PROPDESC_FORMAT_FLAGS, ppszDisplay As LongPtr) As Long
Private Declare PtrSafe Function PSGetNameFromPropertyKey Lib "propsys.dll" (PropKey As PROPERTYKEY, ppszCanonicalName As LongPtr) As Long
Private Declare PtrSafe Function PSGetPropertyDescription Lib "propsys.dll" (PropKey As PROPERTYKEY, riid As UUID, ppv As Any) As Long
Private Declare PtrSafe Function PSGetPropertyKeyFromName Lib "propsys.dll" (ByVal pszName As LongPtr, ppropkey As PROPERTYKEY) As Long
Private Declare PtrSafe Function PSGetPropertySystem Lib "propsys.dll" (riid As UUID, ppv As Any) As Long
Private Declare PtrSafe Function PtInRect Lib "user32" (lpRect As RECT, ByVal Xy As LongLong) As Long
Private Declare PtrSafe Function ReadFile Lib "kernel32" (ByVal hFile As LongPtr, lpBuffer As Any, ByVal nNumberOfBytesToRead As Long, lpNumberOfBytesRead As Long, ByVal lpOverlapped As Any) As Long
Private Declare PtrSafe Function RedrawWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal lprcUpdate As LongPtr, ByVal hrgnUpdate As LongPtr, ByVal flags As RDW_Flags) As Long
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
Private Declare PtrSafe Function RegisterClipboardFormatW Lib "user32" (ByVal lpszFormat As LongPtr) As Long
Private Declare PtrSafe Function RegisterDragDrop Lib "ole32" (ByVal hWnd As LongPtr, ByVal DropTarget As IDropTarget) As Long
Private Declare PtrSafe Function RegOpenKeyExW Lib "advapi32" (ByVal hKey As LongPtr, ByVal lpSubKey As LongPtr, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
Private Declare PtrSafe Function RegQueryValueExW Lib "advapi32" (ByVal hKey As LongPtr, ByVal lpValueName As LongPtr, lpReserved As Long, ByRef lpType As Long, ByVal szData As LongPtr, ByRef lpcbData As Long) As Long
Private Declare PtrSafe Function ReleaseCapture Lib "user32" () As Long
Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function RevokeDragDrop Lib "ole32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function RtlDosPathNameToNtPathName_U Lib "ntdll" (ByVal DosFileName As LongPtr, NtFileName As UNICODE_STRING, FilePart As LongPtr, RelativeName As Any) As Boolean
Private Declare PtrSafe Sub RtlFreeUnicodeString Lib "ntdll" (UnicodeString As UNICODE_STRING)
Private Declare PtrSafe Sub RtlInitUnicodeString Lib "ntdll" (DestinationString As Any, ByVal SourceString As LongPtr)
Private Declare PtrSafe Function ScreenToClient Lib "user32" (ByVal hWnd As LongPtr, lpPoint As Any) As Long  ' lpPoint As POINT) As Long
Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr
Private Declare PtrSafe Function SendMessageW Lib "user32" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr
Private Declare PtrSafe Function SetBkColor Lib "gdi32" (ByVal hDC As LongPtr, ByVal crColor As Long) As Long
Private Declare PtrSafe Function SetBkMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nBkMode As Long) As Long
Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function SetCursor Lib "user32" (ByVal hCursor As LongPtr) As LongPtr
Private Declare PtrSafe Function SetFilePointer Lib "kernel32" (ByVal hFile As LongPtr, ByVal lDistanceToMove As Long, lpDistanceToMoveHigh As Long, ByVal dwMoveMethod As Long) As Long
Private Declare PtrSafe Function SetFocusAPI Lib "user32" Alias "SetFocus" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function SetParent Lib "user32" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
Private Declare PtrSafe Function SetRect Lib "user32" (ByRef lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare PtrSafe Function SetTextColor Lib "gdi32" (ByVal hDC As LongPtr, ByVal crColor As Long) As Long
Private Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr
Private Declare PtrSafe Function SetVolumeLabelW Lib "kernel32" (ByVal lpRootPathName As LongPtr, ByVal lpVolumeName As LongPtr) As Long
Private Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal CX As Long, ByVal cy As Long, ByVal wFlags As ucsb_SWP_Flags) As Long
Private Declare PtrSafe Function SetWindowTextW Lib "user32" (ByVal hWnd As LongPtr, ByVal lpString As LongPtr) As Long
Private Declare PtrSafe Function SetWindowTheme Lib "uxtheme" (ByVal hWnd As LongPtr, ByVal pszSubAppName As LongPtr, ByVal pszSubIdList As LongPtr) As Long
Private Declare PtrSafe Function SHCreateShellItem Lib "shell32" (ByVal pidlParent As LongPtr, ByVal psfParent As LongPtr, ByVal pidl As LongPtr, ppsi As IShellItem) As Long
Private Declare PtrSafe Function SHDefExtractIconW Lib "shell32" (ByVal pszIconFile As LongPtr, ByVal iIndex As Long, ByVal uFlags As Long, phiconLarge As LongPtr, phiconSmall As LongPtr, ByVal nIconSize As Long) As Long
Private Declare PtrSafe Function SHDoDragDrop Lib "Shell32" (ByVal hWnd As LongPtr, ByVal pdtobj As LongPtr, ByVal pdsrc As LongPtr, ByVal dwEffect As Long, pdwEffect As Long) As Long
Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteW" (ByVal hWnd As LongPtr, ByVal lpOperation As LongPtr, ByVal lpFile As LongPtr, ByVal lpParameters As LongPtr, ByVal lpDirectory As LongPtr, ByVal nShowCmd As SHOWWINDOW) As LongPtr
Private Declare PtrSafe Function SHFileOperationW Lib "shell32" (lpFileOp As SHFILEOPSTRUCT) As Long
Private Declare PtrSafe Function SHGetFileInfo Lib "shell32" Alias "SHGetFileInfoA" (ByVal pszPath As Any, ByVal dwFileAttributes As Long, psfi As SHFILEINFO, ByVal cbFileInfo As Long, ByVal uFlags As ucsb_SHGFI_flags) As LongPtr
Private Declare PtrSafe Function SHGetFileInfoW Lib "shell32" (ByVal pszPath As Any, ByVal dwFileAttributes As Long, psfi As SHFILEINFO, ByVal cbFileInfo As Long, ByVal uFlags As ucsb_SHGFI_flags) As LongPtr
Private Declare PtrSafe Function SHGetFolderLocation Lib "shell32.dll" (ByVal hWndOwner As LongPtr, ByVal nFolder As Long, ByVal hToken As LongPtr, ByVal dwReserved As Long, ppidl As LongPtr) As Long
Private Declare PtrSafe Function SHGetPathFromIDListW Lib "shell32.dll" (ByVal pidl As LongPtr, ByVal pszPath As LongPtr) As Long
Private Declare PtrSafe Function SHGetPropertyStoreFromParsingName Lib "shell32" (ByVal pszPath As LongPtr, pbc As Any, ByVal Flags As GETPROPERTYSTOREFLAGS, riid As UUID, ppv As Any) As Long
Private Declare PtrSafe Sub SHGetSetSettings Lib "shell32.dll" (ByRef lpss As SHELLSTATE, ByVal dwMask As SFS_MASK, Optional ByVal bSet As Long)
Private Declare PtrSafe Function SHGetSettings Lib "Shell32" (lpsfs As Integer, ByVal dwMask As SFS_MASK) As Long
Private Declare PtrSafe Function SHLoadNonloadedIconOverlayIdentifiers Lib "shell32" () As Long
Private Declare PtrSafe Function SHMultiFileProperties Lib "shell32" (ByVal pdtobj As LongPtr, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal nCmdShow As Long) As Long
Private Declare PtrSafe Function StrCmpLogicalW Lib "shlwapi" (ByVal lpStr1 As LongPtr, ByVal lpStr2 As LongPtr) As Long
Private Declare PtrSafe Function StrFormatByteSizeW Lib "shlwapi" (ByVal ull As LongLong, ByVal pszBuf As LongPtr, ByVal cchBuf As Long) As LongPtr
Private Declare PtrSafe Function StrRetToStrW Lib "shlwapi" (pStr As STRRET, ByVal pidl As LongPtr, ppsz As LongPtr) As Long
Private Declare PtrSafe Function SysReAllocString Lib "oleaut32.dll" (ByVal pBSTR As LongPtr, Optional ByVal pszStrPtr As LongPtr) As Long
Private Declare PtrSafe Function SysReAllocStringLen Lib "oleaut32.dll" (ByVal pBSTR As LongPtr, Optional ByVal pszStrPtr As LongPtr, Optional ByVal Length As Long) As Long
Private Declare PtrSafe Function SystemParametersInfo Lib "user32" Alias "SystemParametersInfoA" (ByVal uAction As Long, ByVal uParam As Long, lpvParam As Any, ByVal fuWinIni As Long) As Long
Private Declare PtrSafe Function SystemTimeToFileTime Lib "kernel32" (lpSystemTime As SYSTEMTIME, lpFileTime As FILETIME) As Long
Private Declare PtrSafe Function TaskDialog Lib "comctl32.dll" (ByVal hwndParent As LongPtr, ByVal hInstance As LongPtr, ByVal pszWindowTitle As LongPtr, ByVal pszMainInstruction As LongPtr, ByVal pszContent As LongPtr, ByVal dwCommonButtons As Long, ByVal pszIcon As LongPtr, pnButton As Long) As Long
Private Declare PtrSafe Function TrackMouseEvent Lib "user32" (lpEventTrack As TrackMouseEventStruct) As Boolean
Private Declare PtrSafe Function TrackPopupMenu Lib "user32" (ByVal hMenu As LongPtr, ByVal wFlags As ucsb_TPM_wFlags, ByVal x As Long, ByVal y As Long, ByVal nReserved As Long, ByVal hwnd As LongPtr, lpRC As Any) As Long
Private Declare PtrSafe Function TrackPopupMenuEx Lib "user32" (ByVal hMenu As LongPtr, ByVal wFlags As ucsb_TPM_wFlags, ByVal X As Long, ByVal Y As Long, ByVal hWnd As LongPtr, lptpm As Any) As Long
Private Declare PtrSafe Function TranslateMessage Lib "user32" (ByRef lpMsg As Any) As Long
Private Declare PtrSafe Function UpdateWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function VariantToFileTime Lib "propsys" (varIn As Variant, ByVal stfOut As Long, pftOut As FILETIME) As Long
Private Declare PtrSafe Function VariantToPropVariant Lib "propsys.dll" (ByRef pvar As Variant, ByRef ppropvar As Variant) As Long
Private Declare PtrSafe Function vbaObjSetAddRef Lib "msvbvm60.dll" Alias "__vbaObjSetAddref" (ByRef objDest As Object, ByVal pObject As LongPtr) As LongPtr 'THIS IS REDIRECTED TO A TWINBASIC INTERNAL IMPLEMENTATION
Private Declare PtrSafe Function VerQueryValue Lib "version.dll" Alias "VerQueryValueA" (pBlock As Any, lpSubBlock As Any, lplpBuffer As Any, puLen As Long) As Long
Private Declare PtrSafe Function VerQueryValueW Lib "version.dll" (ByRef pBlock As Any, ByVal lpSubBlock As LongPtr, ByRef lplpBuffer As LongPtr, ByRef puLen As Long) As Long
Private Declare PtrSafe Function VirtualQuery Lib "kernel32.dll" (ByVal addr As LongPtr, pMBI As Any, ByVal lenMBI As LongPtr) As LongPtr
Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, lpWideCharStr As Any, ByVal cchWideChar As Long, lpMultiByteStr As Any, ByVal cchMultiByte As Long, ByVal lpDefaultChar As String, ByVal lpUsedDefaultChar As Long) As Long
Private Declare PtrSafe Function Wow64DisableWow64FsRedirection Lib "kernel32" (pOldVal As Long) As Long
Private Declare PtrSafe Function Wow64RevertWow64FsRedirection Lib "kernel32" (pOldVal As Long) As Long
Private Declare PtrSafe Function WriteFile Lib "kernel32.dll" (ByVal hFile As LongPtr, lpBuffer As Any, ByVal nNumberOfBytesToWrite As Long, lpNumberOfBytesWritten As Long, lpOverlapped As LongPtr) As Long
Private Declare PtrSafe Sub ZeroMemory Lib "ntdll" Alias "RtlZeroMemory" (dest As Any, ByVal numBytes As LongPtr)
#If Win64 Then
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongPtrW" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As LongPtr
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongPtrW" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
#Else
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongW" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongW" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If

'API :: ImageList
Private Declare PtrSafe Function ImageList_Add Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal hbmImage As LongPtr, ByVal hBMMask As LongPtr) As Long
Private Declare PtrSafe Function ImageList_AddMasked Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal hbmImage As LongPtr, ByVal crMask As Long) As Long
Private Declare PtrSafe Function ImageList_BeginDrag Lib "comctl32.dll" (ByVal himlTrack As LongPtr, ByVal iTrack As Long, ByVal dxHotspot As Long, ByVal dyHotspot As Long) As Boolean
Private Declare PtrSafe Function ImageList_Copy Lib "comctl32.dll" (ByVal himlDst As LongPtr, ByVal iDst As Long, ByVal himlSrc As LongPtr, ByVal iSrc As Long, ByVal uFlags As Long) As Boolean
Private Declare PtrSafe Function ImageList_Create Lib "comctl32.dll" (ByVal cx As Long, ByVal cy As Long, ByVal Flags As ucsb_IL_CreateFlags, ByVal cInitial As Long, ByVal cGrow As Long) As LongPtr
Private Declare PtrSafe Function ImageList_Destroy Lib "comctl32.dll" (ByVal himl As LongPtr) As Boolean
Private Declare PtrSafe Function ImageList_DragEnter Lib "comctl32.dll" (ByVal hWndLock As LongPtr, ByVal X As Long, ByVal Y As Long) As Boolean
Private Declare PtrSafe Function ImageList_DragMove Lib "comctl32.dll" (ByVal X As Long, ByVal Y As Long) As Boolean
Private Declare PtrSafe Function ImageList_Draw Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal i As Long, ByVal hdcDst As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal fStyle As IMAGELISTDRAWFLAGS) As Boolean
Private Declare PtrSafe Sub ImageList_EndDrag Lib "comctl32.dll" ()
Private Declare PtrSafe Function ImageList_GetIcon Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal i As Long, ByVal Flags As IMAGELISTDRAWFLAGS) As LongPtr
Private Declare PtrSafe Function ImageList_GetIconSize Lib "comctl32.dll" (ByVal himl As LongPtr, lpcx As Long, lpcy As Long) As Boolean
Private Declare PtrSafe Function ImageList_Remove Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal i As Long) As Boolean
Private Declare PtrSafe Function ImageList_ReplaceIcon Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal i As Long, ByVal hIcon As LongPtr) As Long
Private Declare PtrSafe Function ImageList_SetBkColor Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal clrBk As Long) As Long
Private Declare PtrSafe Function ImageList_SetOverlayImage Lib "comctl32.dll" (ByVal himl As LongPtr, ByVal iImage As Long, ByVal iOverlay As Long) As Boolean
Private Declare PtrSafe Function ImageList_CoCreateInstance Lib "comctl32.dll " (refclsid As UUID, ByVal pUnkOuter As Long, riid As UUID, ppv As Any) As Long
Private Declare PtrSafe Function HIMAGELIST_QueryInterface Lib "comctl32.dll" (ByVal himl As LongPtr, riid As UUID, ppv As Any) As Long

'API :: GDI+
Private Declare PtrSafe Function GdiplusStartup Lib "gdiplus" (ByRef token As LongPtr, ByRef lpInput As GdiplusStartupInput, ByRef lpOutput As Long) As Long
Private Declare PtrSafe Function GdiplusShutdown Lib "gdiplus" (ByVal token As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateBitmapFromHBITMAP Lib "GDIPlus" (ByVal hbm As LongPtr, ByVal hPal As LongPtr, ByRef BITMAP As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateBitmapFromHICON Lib "GDIPlus" (ByVal hicon As LongPtr, ByRef BITMAP As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateBitmapFromStream Lib "GDIplus" (ByVal Stream As IStream, ByRef BITMAP As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateFromHDC Lib "gdiplus" (ByVal hdc As LongPtr, ByRef graphics As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal BITMAP As LongPtr, hbmReturn As LongPtr, ByVal background As LongPtr) As Long
Private Declare PtrSafe Function GdipCreatePen1 Lib "gdiplus.dll" (ByVal mColor As Long, ByVal mWidth As Single, ByRef mUnit As Long, ByRef mPen As LongPtr) As Long
Private Declare PtrSafe Function GdipDeleteGraphics Lib "gdiplus" (ByVal graphics As LongPtr) As Long
Private Declare PtrSafe Function GdipDeletePen Lib "GdiPlus.dll" (ByVal mPen As LongPtr) As Long
Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
Private Declare PtrSafe Function GdipDrawImageRectI Lib "gdiplus.dll" (ByVal graphics As LongPtr, ByVal Img As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal Width As Long, ByVal Height As Long) As Long
Private Declare PtrSafe Function GdipDrawImageRectRectI Lib "GDIPlus" (ByVal graphics As LongPtr, ByVal Image As LongPtr, ByVal dstx As Long, ByVal dsty As Long, ByVal dstwidth As Long, ByVal dstheight As Long, ByVal srcx As Long, ByVal srcy As Long, ByVal srcwidth As Long, ByVal srcheight As Long, ByVal srcUnit As Long, ByVal imageAttributes As Long, ByVal callback As Long, ByVal callbackData As LongPtr) As Long
Private Declare PtrSafe Function GdipDrawRectangleI Lib "GdiPlus.dll" (ByVal mGraphics As LongPtr, ByVal mPen As LongPtr, ByVal mX As Long, ByVal mY As Long, ByVal mWidth As Long, ByVal mHeight As Long) As Long
Private Declare PtrSafe Function GdipGetImageHeight Lib "gdiplus.dll" (ByVal Image As LongPtr, Height As Long) As Long
Private Declare PtrSafe Function GdipGetImageWidth Lib "gdiplus.dll" (ByVal Image As LongPtr, Width As Long) As Long
Private Declare PtrSafe Function GdipLoadImageFromFile Lib "gdiplus.dll" (ByVal FileName As LongPtr, GpImage As LongPtr) As Long
Private Declare PtrSafe Function GdipLoadImageFromStream Lib "GDIplus" (ByVal Stream As IUnknown, Image As LongPtr) As Long
Private Declare PtrSafe Function GdipSetInterpolationMode Lib "gdiplus.dll" (ByVal graphics As LongPtr, ByVal InterMode As Long) As Long

'API :: Subclassing
Private Declare PtrSafe Function DefSubclassProc Lib "comctl32.dll" Alias "#413" (ByVal hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Private Declare PtrSafe Function SetWindowSubclass Lib "comctl32.dll" Alias "#410" (ByVal hWnd As LongPtr, ByVal pfnSubclass As LongPtr, ByVal uIdSubclass As LongPtr, Optional ByVal dwRefData As LongPtr) As Long
Private Declare PtrSafe Function RemoveWindowSubclass Lib "comctl32.dll" Alias "#412" (ByVal hWnd As LongPtr, ByVal pfnSubclass As LongPtr, ByVal uIdSubclass As LongPtr) As Long




'Future work
Private Const bForceHidden As Boolean = False
' Private Declare Function CreateBindCtx Lib "ole32" (ByVal Reserved As Long, ppbc As IBindCtx) As Long
' Private Declare Function PSCreateMemoryPropertyStore Lib "propsys" (riid As UUID, ppv As Any) As Long
'Private Declare Function PSPropertyBag_WriteDWORD Lib "propsys" (propBag As IPropertyBag, ByVal propName As Long, ByVal value As Long) As Long

Private Const WM_USER = &H400

Private Type MSG
    hWnd        As LongPtr
    message     As Long
    wParam      As LongPtr
    lParam      As LongPtr
    Time        As Long
    PT          As POINT
End Type

Private Type VS_FIXEDFILEINFO
   dwSignature As Long
   dwStrucVersionl As Integer   ' e.g. = &h0000 = 0
   dwStrucVersionh As Integer   ' e.g. = &h0042 = .42
   dwFileVersionMSl As Integer   ' e.g. = &h0003 = 3
   dwFileVersionMSh As Integer   ' e.g. = &h0075 = .75
   dwFileVersionLSl As Integer   ' e.g. = &h0000 = 0
   dwFileVersionLSh As Integer   ' e.g. = &h0031 = .31
   dwProductVersionMSl As Integer   ' e.g. = &h0003 = 3
   dwProductVersionMSh As Integer   ' e.g. = &h0010 = .1
   dwProductVersionLSl As Integer   ' e.g. = &h0000 = 0
   dwProductVersionLSh As Integer   ' e.g. = &h0031 = .31
   dwFileFlagsMask As Long   ' = &h3F for version "0.42"
   dwFileFlags As Long   ' e.g. VFF_DEBUG Or VFF_PRERELEASE
   dwFileOS As Long   ' e.g. VOS_DOS_WINDOWS16
   dwFileType As Long   ' e.g. VFT_DRIVER
   dwFileSubtype As Long   ' e.g. VFT2_DRV_KEYBOARD
   dwFileDateMS As Long   ' e.g. 0
   dwFileDateLS As Long   ' e.g. 0
End Type
Private Type VS_VERSIONINFO_FIXED_PORTION
    wLength As Integer
    wValueLength As Integer
    wType As Integer
    szKey(1 To 16) As Integer   'Unicode "VS_VERSION_INFO" & vbNullChar.
    Padding1(1 To 1) As Integer 'Pad next field to DWORD boundary.
    Value As VS_FIXEDFILEINFO
End Type
Private Const RT_VERSION = 16


Private Const SM_CYFRAME         As Long = 33
Private Const SM_CYCAPTION = 4

Private Const IDC_ARROW = 32512&
Private Const IDC_WAIT = 32514&

Private Const LOGPIXELSX = 88
Private Const LOGPIXELSY = 90


Private CF_SHELLIDLIST As Long
Private CF_DROPDESCRIPTION As Long
Private CF_PREFERREDDROPEFFECT As Long
Private CF_COMPUTEDDRAGIMAGE As Long
Private CF_INDRAGLOOP As Long

Private Enum ucsb_SHGFI_flags
  SHGFI_LARGEICON = &H0            ' sfi.hIcon is large icon
  SHGFI_SMALLICON = &H1            ' sfi.hIcon is small icon
  SHGFI_OPENICON = &H2              ' sfi.hIcon is open icon
  SHGFI_SHELLICONSIZE = &H4      ' sfi.hIcon is shell size (not system size), rtns BOOL
  SHGFI_PIDL = &H8                        ' pszPath is pidl, rtns BOOL
  ' Indicates that the function should not attempt to access the file specified by pszPath.
  ' Rather, it should act as if the file specified by pszPath exists with the file attributes
  ' passed in dwFileAttributes. This flag cannot be combined with the SHGFI_ATTRIBUTES,
  ' SHGFI_EXETYPE, or SHGFI_PIDL flags <---- !!!
  SHGFI_USEFILEATTRIBUTES = &H10   ' pretend pszPath exists, rtns BOOL
  SHGFI_ICON = &H100                    ' fills sfi.hIcon, rtns BOOL, use DestroyIcon
  SHGFI_DISPLAYNAME = &H200    ' isf.szDisplayName is filled (SHGDN_NORMAL), rtns BOOL
  SHGFI_TYPENAME = &H400          ' isf.szTypeName is filled, rtns BOOL
  SHGFI_ATTRIBUTES = &H800         ' rtns IShellFolder::GetAttributesOf  SFGAO_* flags
  SHGFI_ICONLOCATION = &H1000   ' fills sfi.szDisplayName with filename
                                                        ' containing the icon, rtns BOOL
  SHGFI_EXETYPE = &H2000            ' rtns two ASCII chars of exe type
  SHGFI_SYSICONINDEX = &H4000   ' sfi.iIcon is sys il icon index, rtns hImagelist
  SHGFI_LINKOVERLAY = &H8000&    ' add shortcut overlay to sfi.hIcon
  SHGFI_SELECTED = &H10000        ' sfi.hIcon is selected icon
  SHGFI_ATTR_SPECIFIED = &H20000    ' get only attributes specified in sfi.dwAttributes
End Enum
Private Type SHFILEINFO   ' shfi
  hIcon As LongPtr
  iIcon As Long
  dwAttributes As Long
  szDisplayName As String * MAX_PATH
  szTypeName As String * 80
End Type

Private Type EDITBALLOONTIP
    cbStruct As Long
    pszTitle As LongPtr
    pszText As LongPtr
    ttiIcon As ucsb_BalloonTipIconConstants ' ; // From TTI_*
End Type

Private Enum ucsb_BalloonTipIconConstants
   TTI_NONE = 0
   TTI_INFO = 1
   TTI_WARNING = 2
   TTI_ERROR = 3
End Enum

Private Enum ucsb_TPM_wFlags
  TPM_LEFTBUTTON = &H0
  TPM_RIGHTBUTTON = &H2
  TPM_LEFTALIGN = &H0
  TPM_CENTERALIGN = &H4
  TPM_RIGHTALIGN = &H8
  TPM_TOPALIGN = &H0
  TPM_VCENTERALIGN = &H10
  TPM_BOTTOMALIGN = &H20

  TPM_HORIZONTAL = &H0         ' Horz alignment matters more
  TPM_VERTICAL = &H40            ' Vert alignment matters more
  TPM_NONOTIFY = &H80           ' Don't send any notification msgs
  TPM_RETURNCMD = &H100
  
  TPM_HORPOSANIMATION = &H400
  TPM_HORNEGANIMATION = &H800
  TPM_VERPOSANIMATION = &H1000
  TPM_VERNEGANIMATION = &H2000
  TPM_NOANIMATION = &H4000
End Enum
Private Enum ucsb_SND_FLAGS
    SND_ALIAS = &H10000 ' name is a WIN.INI [sounds] entry
    SND_ALIAS_ID = &H110000 ' name is a WIN.INI [sounds]Entry identifier
    SND_ALIAS_START = 0 ' must be > 4096 to keep strings insame section of resource file
    SND_APPLICATION = &H80 ' look for applicationspecific association
    SND_ASYNC = &H1 ' play asynchronously
    SND_FILENAME = &H20000 ' name is a file name
    SND_LOOP = &H8 ' loop the sound until nextsndPlaySound
    SND_MEMORY = &H4 ' lpszSoundName points to a memoryFile
    SND_NODEFAULT = &H2 ' silence not default, if soundnot found
    SND_NOSTOP = &H10 ' don't stop any currently playingsound
    SND_NOWAIT = &H2000 ' don't wait if the driver is busy
    SND_PURGE = &H40 ' purge non-static events forTask
    SND_RESERVED = &HFF000000 ' In particular these flags areReserved
    SND_RESOURCE = &H40004 ' name is a resource name or atom
    SND_SYNC = &H0 ' play synchronously (default)
    SND_TYPE_MASK = &H170007
    SND_VALID = &H1F ' valid flags / ;Internal /
    SND_VALIDFLAGS = &H17201F ' Set of valid flag bits.
End Enum

Private Enum ucsb_ShellImageListFlags
    SHIL_LARGE = &H0
    SHIL_SMALL = &H1
    SHIL_EXTRALARGE = &H2
    SHIL_SYSSMALL = &H3
    '6.0
    SHIL_JUMBO = &H4
    SHIL_LAST = &H5 'NOT AN IMAGEL
End Enum



'API Window Classes for CreateWindowEx
Private Const WC_LISTVIEW = "SysListView32"
Private Const WC_COMBOBOXEX = "ComboBoxEx32"
Private Const WC_EDIT = "EDIT"
Private Const DATETIMEPICK_CLASS = "SysDateTimePick32"
Private Const WC_COMBOBOX = "ComboBox"
Private Const WC_LINK = "SysLink"
Private Const WC_STATIC = "STATIC"
Private Const WC_BUTTON = "Button"
Private Const STATUSCLASSNAME = "msctls_statusbar32"
Private Const PROGRESS_CLASS = "msctls_progress32"
Private Const UPDOWN_CLASS = "msctls_updown32"
'--

Private Const INPLACE_S_TRUNCATED = &H401A0

Private Const HTCAPTION = 2

Private Const REG_SZ = 1&

Private Const LOCALE_USER_DEFAULT = &H400

Private Const HKEY_CURRENT_USER = &H80000001
Private Const HKEY_LOCAL_MACHINE = &H80000002
Private Const STANDARD_RIGHTS_READ = &H20000
Private Const KEY_QUERY_VALUE = &H1&
Private Const KEY_ENUMERATE_SUB_KEYS = &H8&
Private Const KEY_NOTIFY = &H10&
Private Const KEY_WOW64_64KEY = &H100
Private Const KEY_WOW64_32KEY = &H200
Private Const SYNCHRONIZE = &H100000

Private Const KEY_READ = ((STANDARD_RIGHTS_READ Or _
                        KEY_QUERY_VALUE Or _
                        KEY_ENUMERATE_SUB_KEYS Or _
                        KEY_NOTIFY) And _
                        (Not SYNCHRONIZE))
Private Enum ucsb_Shell_Flags_1
    fShowAllObjects = &H1
    fShowExtensions = &H2
    fNoConfirmRecycle = &H4
    fShowSysFiles = &H8
    fShowCompColor = &H10
    fDoubleClickInWebView = &H20
    fDesktopHTML = &H40
    fWin95Classic = &H80
    fDontPrettyPath = &H100
    fShowAttribCol = &H200
    fMapNetDrvBtn = &H400
    fShowInfoTip = &H800
    fHideIcons = &H1000
    fWebView = &H2000
    fFilter = &H4000
    fShowSuperHidden = &H8000&
    fNoNetCrawling = &H10000
End Enum

Private Enum ucsb_Shell_Flags_2
    fSepProcess = &H1
    fStartPanelOn = &H2
    fShowStartPage = &H4
    fAutoCheckSelect = &H8
    fIconsOnly = &H10
    fShowTypeOverlay = &H20
    fShowStatusBar = &H40
End Enum

Private Enum GA_Flags
    GA_PARENT = 1
    GA_ROOT = 2
    GA_ROOTOWNER = 3
End Enum


' Private Type MsgType
'     hWnd        As Long
'     message     As Long
'     wParam      As Long
'     lParam      As Long
'     Time        As Long
'     PT          As Point
' End Type
Private Const PM_NOREMOVE           As Long = 0&
Private Const PM_REMOVE             As Long = 1&

Private Const SECURITY_IMPERSONATION = &H20000

Private Enum ucsb_GDT_Types
    DRIVE_UNKNOWN = 0
    DRIVE_NO_ROOT_DIR = 1
    DRIVE_REMOVABLE = 2
    DRIVE_FIXED = 3
    DRIVE_REMOTE = 4
    DRIVE_CDROM = 5 'Any optical drive
    DRIVE_RAMDISK = 6
End Enum

Public Enum ucsb_COMPARE_FLAGS
    SORT_STRINGSORT = &H1000&
    SORT_DIGITSASNUMBERS = &H8          'Sort 1 2 10 instead of 1 10 2
    LINGUISTIC_IGNORECASE = &H10&
    LINGUISTIC_IGNOREDIACRITIC = &H20&
    NORM_IGNORECASE = &H1&
    NORM_IGNORENONSPACE = &H2&
    NORM_IGNORESYMBOLS = &H4&
    NORM_IGNOREKANATYPE = &H10000
    NORM_IGNOREWIDTH = &H20000
    NORM_LINGUISTIC_CASING = &H8000000
End Enum
Private Enum ucsb_CSTR_RETURNS
    CSTR_FAIL = 0&
    CSTR_LESS_THAN = 1&
    CSTR_EQUAL = 2&
    CSTR_GREATER_THAN = 3&
End Enum
Private Const LOCALE_NAME_INVARIANT As String = ""
Private Const LOCALE_NAME_USER_DEFAULT As String = vbNullString
Private Const LOCALE_NAME_SYSTEM_DEFAULT As String = "!x-sys-default-locale"

Public Enum GST_Class
    CT_CTYPE1 = &H1          ' ctype 1 information
    CT_CTYPE2 = &H2          ' ctype 2 information
    CT_CTYPE3 = &H4          ' ctype 3 information
End Enum
Private Const C1_UPPER As Integer = &H1      ' upper case
Private Const C1_LOWER As Integer = &H2      ' lower case
Private Const C1_DIGIT As Integer = &H4      ' decimal digits
Private Const C1_SPACE As Integer = &H8      ' spacing characters
Private Const C1_PUNCT As Integer = &H10     ' punctuation characters
Private Const C1_CNTRL As Integer = &H20     ' control characters
Private Const C1_BLANK As Integer = &H40     ' blank characters
Private Const C1_XDIGIT As Integer = &H80     ' other digits
Private Const C1_ALPHA As Integer = &H100    ' any linguistic character
Private Const C1_DEFINED As Integer = &H200    ' defined character

Private Type UNICODE_STRING
    uLength As Integer
    uMaximumLength As Integer
    pBuffer As LongPtr
End Type

Private Type OBJECT_ATTRIBUTES
	Length As Long
    RootDirectory As LongPtr
    ObjectName As LongPtr
    Attributes As Long
    SecurityDescriptor As LongPtr
    SecurityQualityOfService As LongPtr
End Type

Private Type FILE_DIRECTORY_INFORMATION
  NextEntryOffset As Long
  FileIndex As Long
  CreationTime As FILETIME
  LastAccessTime As FILETIME
  LastWriteTime As FILETIME
  ChangeTime As FILETIME
  EndOfFile As LARGE_INTEGER
  AllocationSize As LARGE_INTEGER
  FileAttributes As Long
  FileNameLength As Long
  FileName1 As Integer 'OFFSET=&H40 (64)
End Type

Private Type FILE_STREAM_INFORMATION
    NextEntryOffset As Long
    StreamNameLength As Long
    StreamSize As LARGE_INTEGER
    StreamAllocationSize As LARGE_INTEGER
    StreamName(259) As Byte
End Type

Private Type IO_STATUS_BLOCK
    StatusPointer As LongPtr
    Information As LongPtr
End Type

'Only the uncommented values can be used with NtQueryDirectoryFile
Private Enum FILE_INFORMATION_CLASS
        FileDirectoryInformation = 1
        FileFullDirectoryInformation = 2
        FileBothDirectoryInformation = 3
'        FileBasicInformation = 4
'        FileStandardInformation = 5
'        FileInternalInformation = 6
'        FileEaInformation = 7
'        FileAccessInformation = 8
'        FileNameInformation = 9
'        FileRenameInformation = 10
'        FileLinkInformation = 11
        FileNamesInformation = 12
'        FileDispositionInformation = 13
'        FilePositionInformation = 14
'        FileFullEaInformation = 15
'        FileModeInformation = 16
'        FileAlignmentInformation = 17
'        FileAllInformation = 18
'        FileAllocationInformation = 19
'        FileEndOfFileInformation = 20
'        FileAlternateNameInformation = 21
        FileStreamInformation = 22
'        FilePipeInformation = 23
'        FilePipeLocalInformation = 24
'        FilePipeRemoteInformation = 25
'        FileMailslotQueryInformation = 26
'        FileMailslotSetInformation = 27
'        FileCompressionInformation = 28
        FileObjectIdInformation = 29
'        FileCompletionInformation = 30
'        FileMoveClusterInformation = 31
'        FileQuotaInformation = 32
        FileReparsePointInformation = 33
'        FileNetworkOpenInformation = 34
'        FileAttributeTagInformation = 35
'        FileTrackingInformation = 36
        FileIdBothDirectoryInformation = 37
        FileIdFullDirectoryInformation = 38
'        FileValidDataLengthInformation = 39
'        FileShortNameInformation = 40
'        FileHardLinkInformation = 46
            
End Enum
Private Const OBJ_CASE_INSENSITIVE = &H40

Private Const CP_ACP = 0        ' ANSI code page
Private Const CP_OEMCP = 1   ' OEM code page
Private Enum MBWC_Flags
    MB_PRECOMPOSED = &H1
    MB_COMPOSITE = &H2
    MB_USEGLYPHCHARS = &H4
    MB_ERR_INVALID_CHARS = &H8
End Enum

Private Type CSFV
    cbSize As Long
    pshf As IShellFolder
    psvOuter As IShellView
    pidl As LongPtr
    lEvents As Long
    pfnCallback As LongPtr
    fvm As FOLDERVIEWMODE
End Type
Private Type SFV_CREATE
    cbSize As Long
    pshf As IShellFolder
    psvOuter As IShellView
    psfvcb As IShellFolderViewCB
End Type

Private Enum ucsb_DRAWICON_FLAGS
    DI_MASK = &H1
    DI_IMAGE = &H2
    DI_NORMAL = &H3
    DI_COMPAT = &H4
    DI_DEFAULTSIZE = &H8
    DI_NOMIRROR = &H10
End Enum

Private Type TPMPARAMS
    cbSize As Long
    rcExclude As RECT
End Type

Private Const GBF_DIRECT = &H1
Private Const GBF_COPY = &H2
Private Const GBF_VALIDBITS = GBF_DIRECT Or GBF_COPY
Private Const TMT_DIBDATA = 2
Private Const TMT_GLYPHDIBDATA = 8

Private Enum ucsb_PBSTYLE
    PBS_SMOOTH = &H1&
    PBS_VERTICAL = &H4&
    PBS_MARQUEE = &H8&             ' control must be themed & v6 of common controls installed
    PBS_SMOOTHREVERSE = &H10&       ' vista+ only
End Enum
Private Const PBM_SETMARQUEE = WM_USER + 10

'---
'TaskDialog Declares
Private Enum ucsb_TDICONS
    TD_WARNING_ICON = -1 'exclamation point in a yellow 'yield' triangle (same image as IDI_EXCLAMATION)
    TD_ERROR_ICON = -2 'round red circle containg 'X' (same as IDI_HAND)
    TD_INFORMATION_ICON = -3 'round blue circle containing 'i' (same image as IDI_ASTERISK)
    TD_SHIELD_ICON = -4 'Vista's security shield
    IDI_APPLICATION = 32512& 'miniature picture of an application window
    IDI_QUESTION = 32514& 'round blue circle containing '?'

    TD_SHIELD_GRADIENT_ICON = -5 'same image as TD_SHIELD_ICON; main message text on gradient blue background
    TD_SHIELD_WARNING_ICON = -6 'exclamation point in yellow Shield shape; main message text on gradient orange background
    TD_SHIELD_ERROR_ICON = -7 'X contained within Shield shape; main message text on gradient red background
    TD_SHIELD_OK_ICON = -8 'Shield shape containing green checkmark; main message text on gradient green background
    TD_SHIELD_GRAY_ICON = -9 'same image as TD_SHIELD_ICON; main message text on medium gray background
    TD_NO_ICON = 0 'no icon; text on white background
End Enum

'taskdialog common button flags
Private Enum ucsb_TDBUTTONS
    TDCBF_OK_BUTTON = &H1&      'return value 1 (IDOK)
    TDCBF_YES_BUTTON = &H2&     'return value 6 (IDYES)
    TDCBF_NO_BUTTON = &H4&      'return value 7 (IDNO)
    TDCBF_CANCEL_BUTTON = &H8&  'return value 2 (IDCANCEL)
    TDCBF_RETRY_BUTTON = &H10&   'return value 4 (IDRETRY)
    TDCBF_CLOSE_BUTTON = &H20&   'return value 8 (IDCLOSE)
End Enum
Private Enum ucsb_TDRESULT
    TD_OK = 1
    TD_YES = 6
    TD_NO = 7
    TD_CANCEL = 2
    TD_RETRY = 4
    TD_CLOSE = 8
End Enum
'---

'-----------------
'Begin Theme API Consts
'
'ProgressBar Parts
Private Const PP_BAR = 1
Private Const PP_BARVERT = 2
Private Const PP_CHUNK = 3
Private Const PP_CHUNKVERT = 4
Private Const PP_FILL = 5
Private Const PP_FILLVERT = 6
Private Const PP_PULSEOVERLAY = 7
Private Const PP_MOVEOVERLAY = 8
Private Const PP_PULSEOVERLAYVERT = 9
Private Const PP_MOVEOVERLAYVERT = 10
Private Const PP_TRANSPARENTBAR = 11
Private Const PP_TRANSPARENTBARVERT = 12

'TransparentBarStates
Private Const PBBS_NORMAL = 1
Private Const PBBS_PARTIAL = 2
'TransparentBarVertStates
Private Const PBBVS_NORMAL = 1
Private Const PBBVS_PARTIAL = 2
'FillStates
Private Const PBFS_NORMAL = 1
Private Const PBFS_ERROR = 2
Private Const PBFS_PAUSED = 3
Private Const PBFS_PARTIAL = 4
'FillVertStates
Private Const PBFVS_NORMAL = 1
Private Const PBFVS_ERROR = 2
Private Const PBFVS_PAUSED = 3
Private Const PBFVS_PARTIAL = 4

'Navigation Buttons
Private Const NAV_BACKBUTTON = 1
Private Const NAV_FORWARDBUTTON = 2
Private Const NAV_MENUBUTTON = 3
Private Enum ucsb_NAV_BB_STATE
    NAV_BB_NORMAL = 1
    NAV_BB_HOT = 2
    NAV_BB_PRESSED = 3
    NAV_BB_DISABLED = 4
End Enum
Private Enum ucsb_NAV_FB_STATE
    NAV_FB_NORMAL = 1
    NAV_FB_HOT = 2
    NAV_FB_PRESSED = 3
    NAV_FB_DISABLED = 4
End Enum
Private Const TMT_WIDTH = 2416
Private Const TMT_HEIGHT = 2417
'
'End Theme API Consts
'---------------------

Private Const BCM_FIRST = &H1600
Private Const BCM_SETIMAGELIST = (BCM_FIRST + &H2)
Private Const BM_SETIMAGE = &HF7
Private Const BM_SETSTATE = &HF3
Private Const BM_SETSTYLE = &HF4

Private Const BST_UNCHECKED = &H0&
Private Const BST_CHECKED = &H1&
Private Const BST_INDETERMINATE = &H2&
Private Const BST_PUSHED As Long = &H4
Private Const BST_HOT As Long = &H200
Private Const BST_DROPDOWNPUSHED As Long = &H400
Private Const BST_FOCUS = &H8&
Private Const BST_DONTCLICK = &H80
Private Const BS_3STATE = &H5&
Private Const BS_TEXT As Long = &H0

Private Const BS_DEFPUSHBUTTON = &H1&
Private Const BS_LEFTTEXT = &H20&
Private Const BS_OWNERDRAW = &HB&
Private Const BS_PUSHBUTTON = &H0&
Private Const BS_ICON = &H40&
Private Const BS_BITMAP = &H80&
Private Const BS_LEFT = &H100&
Private Const BS_RIGHT = &H200&
Private Const BS_CENTER = &H300&
Private Const BS_TOP = &H400&
Private Const BS_BOTTOM = &H800&
Private Const BS_VCENTER = &HC00&
Private Const BS_NOTIFY = &H4000&

' Button notifications:
Private Const BN_CLICKED = 0&
Private Const BN_SETFOCUS = 6&
Private Const BN_KILLFOCUS = 7&

Private Enum ButtonSplitMask
    BCSIF_GLYPH = 1
    BCSIF_IMAGE = 2
    BCSIF_STYLE = 4
    BCSIF_SIZE = 8
End Enum
Private Enum ButtonSplitStyle
    BCSS_NOSPLIT = 1
    BCSS_STRETCH = 2
    BCSS_ALIGNLEFT = 4
    BCSS_IMAGE = 8
End Enum

Private Type BUTTON_SPLITINFO
    Mask As ButtonSplitMask
    himlGlyph As LongPtr
    uSplitStyle As ButtonSplitStyle
    SIZE As SIZE
End Type

Private Enum ButtonImageListAlign
    BUTTON_IMAGELIST_ALIGN_LEFT = 0
    BUTTON_IMAGELIST_ALIGN_RIGHT = 1
    BUTTON_IMAGELIST_ALIGN_TOP = 2
    BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
    BUTTON_IMAGELIST_ALIGN_CENTER = 4
End Enum

Private Type BUTTON_IMAGELIST
    himl As LongPtr
    margin As RECT
    uAlign As ButtonImageListAlign
End Type





Private Const IDC_APPSTARTING = 32650

Private Type TrackMouseEventStruct
    cbSize As Long
    dwFlags As ucsb_TME_Flags
    hWndTrack As LongPtr
    dwHoverTime As Long
End Type
Private Enum ucsb_TME_Flags
    TME_HOVER = &H1
    TME_LEAVE = &H2
    TME_NONCLIENT = &H10
    TME_QUERY = &H40000000
    TME_CANCEL = &H80000000
End Enum
Private Const HOVER_DEFAULT As Long = &HFFFFFFFF


'GDI+
Private gdipInitToken As LongPtr
Private Type GdiplusStartupInput
    GdiplusVersion           As Long
    DebugEventCallback       As LongPtr
    SuppressBackgroundThread As Long
    SuppressExternalCodecs   As Long
End Type

Private Const DIB_RGB_COLORS        As Long = 0&
Private Type COLORMATRIX
    m(0 To 4, 0 To 4)   As Single
End Type
Private Type ARGB
    Blue            As Byte
    Green           As Byte
    Red             As Byte
    Alpha           As Byte
End Type
Private Const PixelFormat32bppARGB  As Long = &H26200A
Private Const PixelFormat32bppRGB   As Long = &H22009

Private Type ICONINFO
    fIcon As Long
    XHotspot As Long
    YHotspot As Long
    hBMMask As LongPtr
    hBMColor As LongPtr
End Type
Private Type BITMAPFILEHEADER
    bfType As Integer
    bfSize As Long
    bfReserved1 As Integer
    bfReserved2 As Integer
    bfOffBits As Long
End Type
Private Type BITMAPINFOHEADER
   biSize                   As Long
   biWidth                  As Long
   biHeight                 As Long
   biPlanes                 As Integer
   biBitCount               As Integer
   biCompression            As Long
   biSizeImage              As Long
   biXPelsPerMeter          As Long
   biYPelsPerMeter          As Long
   biClrUsed                As Long
   biClrImportant           As Long
End Type
Private Type BITMAPINFO
   bmiHeader                As BITMAPINFOHEADER
   bmiColors(3)             As Long
End Type
Private Type BITMAPV5HEADER
    bV5Size As Long
    bV5Width As Long
    bV5Height As Long
    bV5Planes As Integer
    bV5BitCount As Integer
    bV5Compression As Long
    bV5SizeImage As Long
    bV5XPelsPerMeter As Long
    bV5YPelsPerMeter As Long
    bV5ClrUsed As Long
    bV5ClrImportant As Long
    bV5RedMask As Long
    bV5GreenMask As Long
    bV5BlueMask As Long
    bV5AlphaMask As Long
    bV5CSType As Long
    bV5EndpointsRedX As Long
    bV5EndpointsRedY As Long
    bV5EndpointsRedZ As Long
    bV5EndpointsGreenX As Long
    bV5EndpointsGreenY As Long
    bV5EndpointsGreenZ As Long
    bV5EndpointsBlueX As Long
    bV5EndpointsBlueY As Long
    bV5EndpointsBlueZ As Long
    bV5GammaRed As Long
    bV5GammaGreen As Long
    bV5GammaBlue As Long
    bV5Intent As Long
    bV5ProfileData As Long
    bV5ProfileSize As Long
    bV5Reserved As Long
End Type
Private Type BITMAP
    BMType As Long
    BMWidth As Long
    BMHeight As Long
    BMWidthBytes As Long
    BMPlanes As Integer
    BMBitsPixel As Integer
    BMBits As LongPtr
End Type
Private Type BitmapData
    Width           As Long
    Height          As Long
    Stride          As Long
    PixelFormat     As Long
    Scan0           As LongPtr
    Reserved        As LongPtr
End Type

Private Enum ucsb_ImageTypes
  IMAGE_BITMAP = 0
  IMAGE_ICON = 1
  IMAGE_CURSOR = 2
  IMAGE_ENHMETAFILE = 3
End Enum
Private Enum ucsb_LoadResourceFlags
  LR_DEFAULTCOLOR = &H0
  LR_MONOCHROME = &H1
  LR_COLOR = &H2
  LR_COPYRETURNORG = &H4
  LR_COPYDELETEORG = &H8
  LR_LOADFROMFILE = &H10
  LR_LOADTRANSPARENT = &H20
  LR_DEFAULTSIZE = &H40
  LR_VGACOLOR = &H80
  LR_LOADMAP3DCOLORS = &H1000
  LR_CREATEDIBSECTION = &H2000
  LR_COPYFROMRESOURCE = &H4000
  LR_SHARED = &H8000&
End Enum

Private Type IconHeader
    ihReserved      As Integer
    ihType          As Integer
    ihCount         As Integer
End Type

Private Type IconEntry
    ieWidth         As Byte
    ieHeight        As Byte
    ieColorCount    As Byte
    ieReserved      As Byte
    iePlanes        As Integer
    ieBitCount      As Integer
    ieBytesInRes    As Long
    ieImageOffset   As Long
End Type

Private Enum ucsb_IL_DrawStyle
  ILD_NORMAL = &H0
  ILD_TRANSPARENT = &H1
  ILD_MASK = &H10
  ILD_IMAGE = &H20
'#If (WIN32_IE >= &H300) Then
  ILD_ROP = &H40
'#End If
  ILD_BLEND25 = &H2
  ILD_BLEND50 = &H4
  ILD_OVERLAYMASK = &HF00
 
  ILD_SELECTED = ILD_BLEND50
  ILD_FOCUS = ILD_BLEND25
  ILD_BLEND = ILD_BLEND50
  ILD_PRESERVEALPHA = &H1000
  ILD_SCALE = &H2000
  ILD_DPISCALE = &H4000
  ILD_ASYNC = &H8000&
End Enum

Private Const ILCF_MOVE = &H0

Private Enum ucsb_IL_CreateFlags
  ILC_MASK = &H1
  ILC_COLOR = &H0
  ILC_COLORDDB = &HFE
  ILC_COLOR4 = &H4
  ILC_COLOR8 = &H8
  ILC_COLOR16 = &H10
  ILC_COLOR24 = &H18
  ILC_COLOR32 = &H20
  ILC_PALETTE = &H800                  ' (no longer supported...never worked anyway)
  '5.0
  ILC_MIRROR = &H2000
  ILC_PERITEMMIRROR = &H8000&
  '6.0
  ILC_ORIGINALSIZE = &H10000
  ILC_HIGHQUALITYSCALE = &H20000
End Enum
Private Const CLR_NONE = &HFFFFFFFF

Private Enum ucsb_PERCEIVED
  PERCEIVED_TYPE_CUSTOM = -3
  PERCEIVED_TYPE_UNSPECIFIED = -2
  PERCEIVED_TYPE_FOLDER = -1
  PERCEIVED_TYPE_UNKNOWN = 0
  PERCEIVED_TYPE_TEXT = 1
  PERCEIVED_TYPE_IMAGE = 2
  PERCEIVED_TYPE_AUDIO = 3
  PERCEIVED_TYPE_VIDEO = 4
  PERCEIVED_TYPE_COMPRESSED = 5
  PERCEIVED_TYPE_DOCUMENT = 6
  PERCEIVED_TYPE_SYSTEM = 7
  PERCEIVED_TYPE_APPLICATION = 8
  PERCEIVED_TYPE_GAMEMEDIA = 9
  PERCEIVED_TYPE_CONTACTS = 10
End Enum
Private Enum ucsb_PERCEIVEDFLAG
    PERCEIVEDFLAG_UNDEFINED = &H0 'No perceived type was found (PERCEIVED_TYPE_UNSPECIFIED.
    PERCEIVEDFLAG_SOFTCODED = &H1 'The perceived type was determined through an association in the registry.
    PERCEIVEDFLAG_HARDCODED = &H2 'The perceived type is inherently known to Windows.
    PERCEIVEDFLAG_NATIVESUPPORT = &H4 'The perceived type was determined through a codec provided with Windows.
    PERCEIVEDFLAG_GDIPLUS = &H10 'The perceived type is supported by the GDI+ library.
    PERCEIVEDFLAG_WMSDK = &H20 'The perceived type is supported by the Windows Media SDK.
    PERCEIVEDFLAG_ZIPFOLDER = &H40 'The perceived type is supported by Windows compressed folders.
End Enum

Private Enum ucsb_PMS_Flags
    PMSF_NORMAL = &H0
    PMSF_MULTIPLE = &H1
    PMSF_DONT_STRIP_SPACES = &H10000
End Enum

Private Type SHFILEOPSTRUCT
   hWnd        As LongPtr
   wFunc       As FILEOP
   pFrom       As LongPtr
   pTo         As LongPtr
   fFlags      As FILEOP_FLAGS
   fAborted    As Boolean
   hNameMaps   As LongPtr
   sProgress   As LongPtr
 End Type
 
Private Const InterpolationModeHighQualityBicubic = 7
Private Const UnitPixel = 2

Private Enum ucsb_DT_Flags
    DT_BOTTOM = &H8&
    DT_CENTER = &H1&
    DT_LEFT = &H0&
    DT_CALCRECT = &H400&
    DT_WORDBREAK = &H10&
    DT_VCENTER = &H4&
    DT_TOP = &H0&
    DT_TABSTOP = &H80&
    DT_SINGLELINE = &H20&
    DT_RIGHT = &H2&
    DT_NOCLIP = &H100&
    DT_INTERNAL = &H1000&
    DT_EXTERNALLEADING = &H200&
    DT_EXPANDTABS = &H40&
    DT_CHARSTREAM = 4&
    DT_NOPREFIX = &H800&
    DT_EDITCONTROL = &H2000&
    DT_PATH_ELLIPSIS = &H4000&
    DT_END_ELLIPSIS = &H8000&
    DT_MODIFYSTRING = &H10000
    DT_RTLREADING = &H20000
    DT_WORD_ELLIPSIS = &H40000
End Enum

Public Enum ucsb_StaticControlStyles
    SS_LEFT = &H0
    SS_CENTER = &H1
    SS_RIGHT = &H2
    SS_ICON = &H3
    SS_BLACKRECT = &H4
    SS_GRAYRECT = &H5
    SS_WHITERECT = &H6
    SS_BLACKFRAME = &H7
    SS_GRAYFRAME = &H8
    SS_WHITEFRAME = &H9
    SS_USERITEM = &HA
    SS_SIMPLE = &HB
    SS_LEFTNOWORDWRAP = &HC
    SS_OWNERDRAW = &HD
    SS_BITMAP = &HE
    SS_ENHMETAFILE = &HF
    SS_ETCHEDHORZ = &H10
    SS_ETCHEDVERT = &H11
    SS_ETCHEDFRAME = &H12
    SS_TYPEMASK = &H1F
    SS_REALSIZECONTROL = &H40
    SS_NOPREFIX = &H80
    SS_NOTIFY = &H100
    SS_CENTERIMAGE = &H200
    SS_RIGHTJUST = &H400
    SS_REALSIZEIMAGE = &H800
    SS_SUNKEN = &H1000
    SS_EDITCONTROL = &H2000
    SS_ENDELLIPSIS = &H4000
    SS_PATHELLIPSIS = &H8000&
    SS_WORDELLIPSIS = &HC000
    SS_ELLIPSISMASK = &HC000
End Enum

Private Const ANSI_CHARSET As Byte = &H0
Private Const DEFAULT_CHARSET As Byte = &H1

Private Const DEFAULT_PITCH = 0
Private Const FIXED_PITCH = 1
Private Const VARIABLE_PITCH As Integer = 2

Private Const FF_DONTCARE = 0
Private Const FF_ROMAN = 16
Private Const FF_SWISS = 32
Private Const FF_MODERN = 48
Private Const FF_SCRIPT = 64
Private Const FF_DECORATIVE = 80


Private Const DEFAULT_QUALITY As Byte = (0)
Private Const DRAFT_QUALITY As Byte = (1)
Private Const PROOF_QUALITY As Byte = (2)
Private Const NONANTIALIASED_QUALITY As Byte = (3)
Private Const ANTIALIASED_QUALITY As Byte = (4)
Private Const CLEARTYPE_QUALITY As Byte = (5)
Private Const CLEARTYPE_NATURAL_QUALITY As Byte = (6)

Private Enum ucsb_FontWeight
        FW_DONTCARE = 0
        FW_THIN = 100
        FW_EXTRALIGHT = 200
        FW_LIGHT = 300
        FW_NORMAL = 400
        FW_MEDIUM = 500
        FW_SEMIBOLD = 600
        FW_BOLD = 700
        FW_EXTRABOLD = 800
        FW_HEAVY = 900
        FW_ULTRALIGHT = FW_EXTRALIGHT
        FW_REGULAR = FW_NORMAL
        FW_DEMIBOLD = FW_SEMIBOLD
        FW_ULTRABOLD = FW_EXTRABOLD
        FW_BLACK = FW_HEAVY
End Enum
Private Const LF_FACESIZE = 32
Private Type LOGFONT 'LOGFONTA, use with CreateFontIndirectA
        LFHeight As Long
        LFWidth As Long
        LFEscapement As Long
        LFOrientation As Long
        LFWeight As ucsb_FontWeight
        LFItalic As Byte
        LFUnderline As Byte
        LFStrikeOut As Byte
        LFCharset As Byte
        LFOutPrecision As Byte
        LFClipPrecision As Byte
        LFQuality As Byte
        LFPitchAndFamily As Byte
        LFFaceName(31) As Byte
End Type
Private Type LOGFONTW
    LFHeight As Long
    LFWidth As Long
    LFEscapement As Long
    LFOrientation As Long
    LFWeight As ucsb_FontWeight
    LFItalic As Byte
    LFUnderline As Byte
    LFStrikeOut As Byte
    LFCharset As Byte
    LFOutPrecision As Byte
    LFClipPrecision As Byte
    LFQuality As Byte
    LFPitchAndFamily As Byte
    LFFaceName(0 To ((LF_FACESIZE * 2) - 1)) As Byte
End Type

Private Type DLLVERSIONINFO
    cbSize As Long
    dwMajor As Long
    dwMinor As Long
    dwBuildNumber As Long
    dwPlatformID As Long
End Type

Private Const SB_LINELEFT = 0
Private Const SB_LINEDOWN = 1
Private Const SB_LEFT = 6
Private Const SB_BOTTOM = 7
Private Const SB_ENDSCROLL = 8
Private Const SB_LINEUP = 0
Private Const SB_LINERIGHT = 1
Private Const SB_PAGEDOWN = 3
Private Const SB_PAGELEFT = 2
Private Const SB_PAGERIGHT = 3
Private Const SB_PAGEUP = 2
Private Const SB_THUMBPOSITION = 4
Private Const SB_THUMBTRACK = 5
Private Const SB_TOP = 6
Private Const SB_RIGHT = 7


Private Const H_MAX As Long = (&HFFFF + 1)


Private Const UDN_FIRST As Long = (H_MAX - 721)
Private Const UDN_DELTAPOS As Long = (UDN_FIRST - 1)
Private Const UDS_WRAP As Long = &H1
Private Const UDS_SETBUDDYINT As Long = &H2
Private Const UDS_ALIGNRIGHT As Long = &H4
Private Const UDS_ALIGNLEFT As Long = &H8
Private Const UDS_AUTOBUDDY As Long = &H10
Private Const UDS_ARROWKEYS As Long = &H20
Private Const UDS_HORZ As Long = &H40
Private Const UDS_NOTHOUSANDS As Long = &H80
Private Const UDS_HOTTRACK As Long = &H100
Private Const UDM_SETRANGE As Long = (WM_USER + 101)
Private Const UDM_GETRANGE As Long = (WM_USER + 102)
Private Const UDM_SETRANGE32 As Long = (WM_USER + 111)
Private Const UDM_GETRANGE32 As Long = (WM_USER + 112)
Private Const UDM_SETPOS As Long = (WM_USER + 103)
Private Const UDM_GETPOS As Long = (WM_USER + 104)
Private Const UDM_GETPOS32 As Long = (WM_USER + 114)
Private Const UDM_SETPOS32 As Long = (WM_USER + 113)
Private Const UDM_SETBUDDY As Long = (WM_USER + 105)
Private Const UDM_GETBUDDY As Long = (WM_USER + 106)
Private Const UDM_SETACCEL As Long = (WM_USER + 107)
Private Const UDM_GETACCEL As Long = (WM_USER + 108)
Private Const UDM_SETBASE As Long = (WM_USER + 109)
Private Const UDM_GETBASE As Long = (WM_USER + 110)


Private Const FILE_READ_DATA = &H1
Private Const FILE_SHARE_READ = &H1&
Private Const FILE_ANY_ACCESS = 0
Private Const FILE_READ_ACCESS = 1
Private Const FILE_LIST_DIRECTORY = 1
Private Const FILE_DIRECTORY_FILE = 1
Private Const FILE_OPEN = 1
Private Const FILE_SYNCHRONOUS_IO_NONALERT = &H20
Private Const FILE_OPEN_FOR_BACKUP_INTENT = &H4000
Private Const FILE_FLAG_BACKUP_SEMANTICS As Long = &H2000000
Private Const CREATE_ALWAYS As Long = 2&
Private Const OPEN_EXISTING = 3&
Private Const OPEN_ALWAYS As Long = 4&
Private Const GENERIC_READ As Long = &H80000000
Private Const GENERIC_WRITE As Long = &H40000000
Private Const FILE_END As Long = 2&
Private Const INVALID_HANDLE_VALUE = -1&
Private Enum RDW_Flags
    RDW_INVALIDATE = &H1
    RDW_INTERNALPAINT = &H2
    RDW_ERASE = &H4
    RDW_VALIDATE = &H8
    RDW_NOINTERNALPAINT = &H10
    RDW_NOERASE = &H20
    RDW_NOCHILDREN = &H40
    RDW_ALLCHILDREN = &H80
    RDW_UPDATENOW = &H100
    RDW_ERASENOW = &H200
    RDW_FRAME = &H400
    RDW_NOFRAME = &H800
End Enum

Private Const MK_CONTROL = 8
Private Const MK_LBUTTON = 1
Private Const MK_MBUTTON = &H10
Private Const MK_RBUTTON = 2
Private Const MK_SHIFT = 4
Private Const MK_XBUTTON1 = &H20
Private Const MK_XBUTTON2 = &H40
Private Enum ucsb_SWP_Flags
    SWP_NOSIZE = &H1
    SWP_NOMOVE = &H2
    SWP_NOZORDER = &H4
    SWP_NOREDRAW = &H8
    SWP_NOACTIVATE = &H10
    SWP_FRAMECHANGED = &H20
    SWP_DRAWFRAME = &H20
    SWP_SHOWWINDOW = &H40
    SWP_HIDEWINDOW = &H80
    SWP_NOCOPYBITS = &H100
    SWP_NOREPOSITION = &H200
    SWP_NOSENDCHANGING = &H400
    
    SWP_DEFERERASE = &H2000
    SWP_ASYNCWINDOWPOS = &H4000
End Enum
Private Const HWND_DESKTOP = 0&
Private Const HWND_TOP = 0&
Private Const HWND_BOTTOM = 1&

Private Type MINMAXINFO
   ptReserved As Point
   ptMaxSize As Point
   ptMaxPosition As Point
   ptMinTrackSize As Point
   ptMaxTrackSize As Point
End Type

Private Const SPI_GETNONCLIENTMETRICS = &H29

Private SND_NAVIGATESTART As String
Private SND_DEFAULTBEEP As String
Private SND_CRITICAL As String

Private Enum ucsb_StockObjects
    WHITE_BRUSH = 0
    LTGRAY_BRUSH = 1
    GRAY_BRUSH = 2
    DKGRAY_BRUSH = 3
    BLACK_BRUSH = 4
    NULL_BRUSH = 5
    HOLLOW_BRUSH = NULL_BRUSH
    WHITE_PEN = 6
    BLACK_PEN = 7
    NULL_PEN = 8
    OEM_FIXED_FONT = 10
    ANSI_FIXED_FONT = 11
    ANSI_VAR_FONT = 12
    SYSTEM_FONT = 13
    DEVICE_DEFAULT_FONT = 14
    DEFAULT_PALETTE = 15
    SYSTEM_FIXED_FONT = 16
    DEFAULT_GUI_FONT = 17
    DC_BRUSH = 18
    DC_PEN = 19
End Enum

Private Type NONCLIENTMETRICS
    cbSize As Long
    iBorderWidth As Long
    iScrollWidth As Long
    iScrollHeight As Long
    iCaptionWidth As Long
    iCaptionHeight As Long
    lfCaptionFont As LOGFONT
    iSMCaptionWidth As Long
    iSMCaptionHeight As Long
    lfSMCaptionFont As LOGFONT
    iMenuWidth As Long
    iMenuHeight As Long
    lfMenuFont As LOGFONT
    lfStatusFont As LOGFONT
    lfMessageFont As LOGFONT
End Type

Private Const CCS_BOTTOM As Long = &H3
Private Const SBARS_SIZEGRIP As Long = &H100
Private Const SBARS_TOOLTIPS As Long = &H800
 
Private Const SBT_NOBORDERS  As Long = &H100
Private Const SBT_POPOUT     As Long = &H200
 
Private Const SB_SETTEXT      As Long = (WM_USER + 1)
Private Const SB_SETTEXTW     As Long = (WM_USER + 11)
Private Const SB_SETPARTS     As Long = (WM_USER + 4)
Private Const SB_SETMINHEIGHT As Long = (WM_USER + 8)
Private Const SB_GETRECT      As Long = (WM_USER + 10)
Private Const SB_SETICON      As Long = (WM_USER + 15)
Private Const SB_SETTIPTEXT   As Long = (WM_USER + 16)
Private Const SB_SETTIPTEXTW  As Long = (WM_USER + 17)
Private Const SB_GETICON      As Long = (WM_USER + 20)
Private Const SB_SETBKCOLOR   As Long = (&H2000 + 1) 'CCM_SETBKCOLOR

Private Enum ucsb_sbPanelStyleConstants
    sbNormal = 0
    sbNoBorders = SBT_NOBORDERS
    sbPopOut = SBT_POPOUT
End Enum

Private Type MENUITEMINFOW
    cbSize As Long
    fMask As ucsb_MII_Mask
    fType As ucsb_MF_Type
    fState As ucsb_MF_State
    wID As Long                       ' MIIM_ID
    hSubMenu As LongPtr            ' MIIM_SUBMENU
    hbmpChecked As LongPtr      ' MIIM_CHECKMARKS
    hbmpUnchecked As LongPtr  ' MIIM_CHECKMARKS
    dwItemData As LongPtr          ' MIIM_DATA
    dwTypeData As LongPtr        ' MIIM_TYPE
    cch As Long                       ' MIIM_TYPE
    hbmpItem As LongPtr
End Type
Private Enum ucsb_MII_Mask
  MIIM_STATE = &H1
  MIIM_ID = &H2
  MIIM_SUBMENU = &H4
  MIIM_CHECKMARKS = &H8
  MIIM_TYPE = &H10
  MIIM_DATA = &H20
  MIIM_BITMAP = &H80
  MIIM_STRING = &H40
End Enum
Private Enum ucsb_MenuFlags
  MF_INSERT = &H0
  MF_ENABLED = &H0
  MF_UNCHECKED = &H0
  MF_BYCOMMAND = &H0
  MF_STRING = &H0
  MF_UNHILITE = &H0
  MF_GRAYED = &H1
  MF_DISABLED = &H2
  MF_BITMAP = &H4
  MF_CHECKED = &H8
  MF_POPUP = &H10
  MF_MENUBARBREAK = &H20
  MF_MENUBREAK = &H40
  MF_HILITE = &H80
  MF_CHANGE = &H80
  MF_END = &H80                    ' Obsolete -- only used by old RES files
  MF_APPEND = &H100
  MF_OWNERDRAW = &H100
  MF_DELETE = &H200
  MF_USECHECKBITMAPS = &H200
  MF_BYPOSITION = &H400
  MF_SEPARATOR = &H800
  MF_REMOVE = &H1000
  MF_DEFAULT = &H1000
  MF_SYSMENU = &H2000
  MF_HELP = &H4000
  MF_RIGHTJUSTIFY = &H4000
  MF_MOUSESELECT = &H8000&
End Enum
Private Enum ucsb_MF_Type
  MFT_STRING = MF_STRING
  MFT_BITMAP = MF_BITMAP
  MFT_MENUBARBREAK = MF_MENUBARBREAK
  MFT_MENUBREAK = MF_MENUBREAK
  MFT_OWNERDRAW = MF_OWNERDRAW
  MFT_RADIOCHECK = &H200
  MFT_SEPARATOR = MF_SEPARATOR
  MFT_RIGHTORDER = &H2000
  MFT_RIGHTJUSTIFY = MF_RIGHTJUSTIFY
End Enum
Private Enum ucsb_MF_State
  MFS_GRAYED = &H3
  MFS_DISABLED = MFS_GRAYED
  MFS_CHECKED = MF_CHECKED
  MFS_HILITE = MF_HILITE
  MFS_ENABLED = MF_ENABLED
  MFS_UNCHECKED = MF_UNCHECKED
  MFS_UNHILITE = MF_UNHILITE
  MFS_DEFAULT = MF_DEFAULT
End Enum

Private Const NFR_UNICODE = 2
Private Const MSGFLT_ADD        As Long = 1&


Private Type NMMOUSE
     hdr As NMHDR
     dwItemSpec As LongPtr
     dwItemData As LongPtr
     PT As Point
     dwHitInfo As LongPtr
End Type

Private Const DTM_FIRST                     As Long = &H1000
Private Const DTM_GETSYSTEMTIME             As Long = (DTM_FIRST + 1)
Private Const DTM_SETSYSTEMTIME             As Long = (DTM_FIRST + 2)
Private Const DTM_SETRANGE                  As Long = (DTM_FIRST + 4)
Private Const DTM_SETFORMATA                As Long = (DTM_FIRST + 5)
Private Const DTM_SETMCCOLOR                As Long = (DTM_FIRST + 6)
Private Const DTM_GETMCCOLOR                As Long = (DTM_FIRST + 7)
Private Const DTM_GETMONTHCAL               As Long = (DTM_FIRST + 8)
Private Const DTM_SETMCFONT                 As Long = (DTM_FIRST + 9)
Private Const DTM_GETMCFONT                 As Long = (DTM_FIRST + 10)
Private Const DTM_SETMCSTYLE                As Long = (DTM_FIRST + 11) ' ; >= Vista
Private Const DTM_GETMCSTYLE                As Long = (DTM_FIRST + 12) ' ; >= Vista
Private Const DTM_CLOSEMONTHCAL             As Long = (DTM_FIRST + 13) '; >= Vista
Private Const DTM_GETDATETIMEPICKERINFO     As Long = (DTM_FIRST + 14) '; >= Vista
Private Const DTM_GETIDEALSIZE              As Long = (DTM_FIRST + 15)
Private Const DTM_SETFORMATW                As Long = (DTM_FIRST + 50)

Private Const DTN_FIRST                     As Long = (-760)
Private Const DTN_LAST                      As Long = (-799)
Private Const DTN_DATETIMECHANGE            As Long = (DTN_FIRST + 1)
Private Const DTN_USERSTRINGA               As Long = (DTN_FIRST + 2)
Private Const DTN_WMKEYDOWNA                As Long = (DTN_FIRST + 3)
Private Const DTN_FORMATA                   As Long = (DTN_FIRST + 4)
Private Const DTN_FORMATQUERYA              As Long = (DTN_FIRST + 5)
Private Const DTN_DROPDOWN                  As Long = (DTN_FIRST + 6)
Private Const DTN_CLOSEUP                   As Long = (DTN_FIRST + 7)
Private Const DTN_USERSTRINGW               As Long = (DTN_FIRST + 15)
Private Const DTN_WMKEYDOWNW                As Long = (DTN_FIRST + 16)
Private Const DTN_FORMATW                   As Long = (DTN_FIRST + 17)
Private Const DTN_FORMATQUERYW              As Long = (DTN_FIRST + 18)

Private Const GDT_ERROR                     As Long = -1
Private Const GDT_VALID                     As Long = 0
Private Const GDT_NONE                      As Long = 1
Private Const GDTR_MAX                      As Long = &H2
Private Const GDTR_MIN                      As Long = &H1

Private Enum ucsb_DTSTYLES
    DTS_SHORTDATEFORMAT = &H0
    DTS_UPDOWN = &H1
    DTS_SHOWNONE = &H2
    DTS_LONGDATEFORMAT = &H4
    DTS_TIMEFORMAT = &H9
    DTS_APPCANPARSE = &H10
    DTS_RIGHTALIGN = &H20
    DTS_SHORTDATECENTURYFORMAT = &HC
End Enum

Private Type NMDATETIMECHANGE
    NMHDR                       As NMHDR
    Flags                       As Long
    ST                          As SYSTEMTIME
End Type

Private Type NMUPDOWN
    hdr As NMHDR
    iPos As Long
    iDelta As Long
End Type


Private Const ECM_FIRST As Long = &H1500
Private Const EM_SETCUEBANNER As Long = (ECM_FIRST + 1)
Private Const EM_SHOWBALLOONTIP As Long = (ECM_FIRST + 3)
Private Const EM_SETREADONLY As Long = &HCF
Private Const EM_GETSEL = &HB0
Private Const EM_SETSEL = &HB1
Private Const EM_LIMITTEXT = &HC5
Private Const EM_SETMARGINS = &HD3
Private Const EM_GETMARGINS = &HD4
Private Const EC_LEFTMARGIN = &H1
Private Const EC_RIGHTMARGIN = &H2

Private Const EN_CHANGE = &H300

Private Const ES_NUMBER = &H2000
Private Const ES_AUTOHSCROLL As Long = &H80
Private Const ES_READONLY As Long = &H800

Private Type SHFILEINFOW   ' shfi
  hIcon As LongPtr
  iIcon As Long
  dwAttributes As Long
  szDisplayName(519) As Byte
  szTypeName(160) As Byte
End Type

'************************************************************************************
'GENERIC CONTROL DEFS
'These are required for LV structures, but are also used elsewhere.
Private Const CCM_FIRST = &H2000
Private Const CCM_SETBKCOLOR = (CCM_FIRST + 1)   ' lParam is bkColor
Private Const CCM_SETCOLORSCHEME = (CCM_FIRST + 2)     ' lParam is color scheme
Private Const CCM_GETCOLORSCHEME = (CCM_FIRST + 3)     ' fills in COLORSCHEME pointed to by lParam
Private Const CCM_GETDROPTARGET = (CCM_FIRST + 4)
Private Const CCM_SETUNICODEFORMAT = (CCM_FIRST + 5)
Private Const CCM_GETUNICODEFORMAT = (CCM_FIRST + 6)
Private Const CCM_SETVERSION = (CCM_FIRST + 7)
Private Const CCM_GETVERSION = (CCM_FIRST + 8)
Private Const CCM_SETNOTIFYWINDOW = (CCM_FIRST + 9) '// wParam == hwndParent.
Private Const CCM_SETWINDOWTHEME = (CCM_FIRST + 11)
Private Const CCM_DPISCALE = (CCM_FIRST + 12)
Private Const CCM_TRANSLATEACCELERATOR = &H461 '(WM_USER + 97)

'These might be missing from the current oleexp WM_ enum
Private Const WM_IME_CHAR = &H286
Private Const WM_UNICHAR = &H109

Private Const UNICODE_NOCHAR = &HFFFF

Private Type WINDOWPOS
    hWnd As LongPtr
    hWndInsertAfter As LongPtr
    X As Long
    Y As Long
    cx As Long
    cy As Long
    dwFlags As Long 'SWP_*
End Type
'END GENERIC CONTROL DEFS
'***********************************

'*****************************************************
'ComboBoxEx Defs
Private Const CB_ADDSTRING = &H143
Private Const CB_DELETESTRING = &H144
Private Const CB_DIR = &H145
Private Const CB_FINDSTRING = &H14C
Private Const CB_FINDSTRINGEXACT = &H158
Private Const CB_GETCOMBOBOXINFO = &H164
Private Const CB_GETCOUNT = &H146
Private Const CB_GETCURSEL = &H147
Private Const CB_GETDROPPEDCONTROLRECT = &H152
Private Const CB_GETDROPPEDSTATE = &H157
Private Const CB_GETDROPPEDWIDTH = &H15F
Private Const CB_GETEDITSEL = &H140
Private Const CB_GETEXTENDEDUI = &H156
Private Const CB_GETHORIZONTALEXTENT = &H15D
Private Const CB_GETITEMDATA = &H150
Private Const CB_GETITEMHEIGHT = &H154
Private Const CB_GETLBTEXT = &H148
Private Const CB_GETLBTEXTLEN = &H149
Private Const CB_GETLOCALE = &H15A
Private Const CB_GETTOPINDEX = &H15B
Private Const CB_INITSTORAGE = &H161
Private Const CB_INSERTSTRING = &H14A
Private Const CB_LIMITTEXT = &H141
Private Const CB_MSGMAX = &H15B
Private Const CB_MULTIPLEADDSTRING = &H163
Private Const CB_RESETCONTENT = &H14B
Private Const CB_SELECTSTRING = &H14D
Private Const CB_SETCURSEL = &H14E
Private Const CB_SETDROPPEDWIDTH = &H160
Private Const CB_SETEDITSEL = &H142
Private Const CB_SETEXTENDEDUI = &H155
Private Const CB_SETHORIZONTALEXTENT = &H15E
Private Const CB_SETITEMDATA = &H151
Private Const CB_SETITEMHEIGHT = &H153
Private Const CB_SETLOCALE = &H159
Private Const CB_SETTOPINDEX = &H15C
Private Const CB_SHOWDROPDOWN = &H14F
Private Const CBM_FIRST As Long = &H1700&
Private Const CB_SETMINVISIBLE = (CBM_FIRST + 1)
Private Const CB_GETMINVISIBLE = (CBM_FIRST + 2)
Private Const CB_SETCUEBANNER As Long = CBM_FIRST + 3
Private Const CB_GETCUEBANNER = (CBM_FIRST + 4)
Private Const CBEM_INSERTITEMA = (WM_USER + 1)
Private Const CBEM_SETIMAGELIST = (WM_USER + 2)
Private Const CBEM_GETIMAGELIST = (WM_USER + 3)
Private Const CBEM_GETITEMA = (WM_USER + 4)
Private Const CBEM_SETITEMA = (WM_USER + 5)
Private Const CBEM_DELETEITEM = CB_DELETESTRING
Private Const CBEM_GETCOMBOCONTROL = (WM_USER + 6)
Private Const CBEM_GETEDITCONTROL = (WM_USER + 7)
Private Const CBEM_SETEXTENDEDSTYLE = (WM_USER + 8)
Private Const CBEM_GETEXTENDEDSTYLE = (WM_USER + 9)
Private Const CBEM_HASEDITCHANGED = (WM_USER + 10)
Private Const CBEM_INSERTITEMW = (WM_USER + 11)
Private Const CBEM_SETITEMW = (WM_USER + 12)
Private Const CBEM_GETITEMW = (WM_USER + 13)
Private Const CBEM_INSERTITEM = CBEM_INSERTITEMA
Private Const CBEM_SETITEM = CBEM_SETITEMA
Private Const CBEM_GETITEM = CBEM_GETITEMA
Private Const CBEM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT '8192 + 5
Private Const CBEM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT '8192 + 6
Private Const CBEM_SETWINDOWTHEME = CCM_SETWINDOWTHEME '8192 + 11
Private Enum ucsb_ComboBox_Styles
    CBS_SIMPLE = &H1&
    CBS_DROPDOWN = &H2&
    CBS_DROPDOWNLIST = &H3&
    CBS_OWNERDRAWFIXED = &H10&
    CBS_OWNERDRAWVARIABLE = &H20&
    CBS_AUTOHSCROLL = &H40
    CBS_OEMCONVERT = &H80
    CBS_SORT = &H100&
    CBS_HASSTRINGS = &H200&
    CBS_NOINTEGRALHEIGHT = &H400&
    CBS_DISABLENOSCROLL = &H800&
    CBS_UPPERCASE = &H2000
    CBS_LOWERCASE = &H4000
End Enum
Private Const CBN_ERRSPACE = (-1)
Private Const CBN_SELCHANGE = 1
Private Const CBN_DBLCLK = 2
Private Const CBN_SETFOCUS = 3
Private Const CBN_KILLFOCUS = 4
Private Const CBN_EDITCHANGE = 5
Private Const CBN_EDITUPDATE = 6
Private Const CBN_DROPDOWN = 7
Private Const CBN_CLOSEUP = 8
Private Const CBN_SELENDOK = 9
Private Const CBN_SELENDCANCEL = 10
Private Const CBEN_FIRST = (H_MAX - 800&)
Private Const CBEN_LAST = (H_MAX - 830&)
'// Notification messages
Private Const CBEN_GETDISPINFO = (CBEN_FIRST - 0)
Private Const CBEN_INSERTITEM = (CBEN_FIRST - 1)
Private Const CBEN_DELETEITEM = (CBEN_FIRST - 2)
Private Const CBEN_BEGINEDIT = (CBEN_FIRST - 4)
Private Const CBEN_ENDEDIT = (CBEN_FIRST - 5)
Private Const CBEN_ENDEDITW = (CBEN_FIRST - 6)
Private Const CBEN_GETDISPINFOW = (CBEN_FIRST - 7)
Private Const CBEN_DRAGBEGIN = (CBEN_FIRST - 8)
Private Const CBEN_DRAGBEGINW = (CBEN_FIRST - 9)

'// lParam specifies why the endedit is happening
Private Const CBENF_KILLFOCUS = 1
Private Const CBENF_RETURN = 2
Private Const CBENF_ESCAPE = 3
Private Const CBENF_DROPDOWN = 4

Private Enum ucsb_CBEX_ExStyles
    CBES_EX_NOEDITIMAGE = &H1
    CBES_EX_NOEDITIMAGEINDENT = &H2
    CBES_EX_PATHWORDBREAKPROC = &H4
    CBES_EX_NOSIZELIMIT = &H8
    CBES_EX_CASESENSITIVE = &H10
    '6.0
    CBES_EX_TEXTENDELLIPSIS = &H20
End Enum
Private Type COMBOBOXEXITEM
    Mask As ucsb_COMBOBOXEXITEM_Mask
    iItem As LongPtr
    pszText As String
    cchTextMax As Long
    iImage As Long
    iSelectedImage As Long
    iOverlay As Long
    iIndent As Long
    lParam As LongPtr
End Type
Private Type COMBOBOXEXITEMW
    Mask As ucsb_COMBOBOXEXITEM_Mask
    iItem As LongPtr
    pszText As LongPtr      '// LPCSTR
    cchTextMax As Long
    iImage As Long
    iSelectedImage As Long
    iOverlay As Long
    iIndent As Long
    lParam As LongPtr
End Type
Private Enum ucsb_COMBOBOXEXITEM_Mask
    CBEIF_TEXT = &H1
    CBEIF_IMAGE = &H2
    CBEIF_SELECTEDIMAGE = &H4
    CBEIF_OVERLAY = &H8
    CBEIF_INDENT = &H10
    CBEIF_LPARAM = &H20
    CBEIF_DI_SETITEM = &H10000000
End Enum
Private Type NMCOMBOBOXEX
    hdr As NMHDR
    ceItem As COMBOBOXEXITEM
End Type
Private Type NMCOMBOBOXEXW
    hdr As NMHDR
    ceItem As COMBOBOXEXITEMW
End Type

Private Const CBEMAXSTRLEN = 260

'// Drag notification struct
Private Type NMCBEDRAGBEGIN
    hdr As NMHDR
    iItemid As Long
    szText(0 To CBEMAXSTRLEN - 1) As Byte   '// As String * CBEMAXSTRLEN
End Type
Private Type NMCBEDRAGBEGINW
    hdr As NMHDR
    iItemid As Long
    szText(0 To CBEMAXSTRLEN - 1) As Integer   '// As String * CBEMAXSTRLEN
End Type

'// CBEN_ENDEDIT sends this information...
'// fChanged if the user actually did anything
'// iNewSelection gives what would be the new selection unless the notify is failed
'// iNewSelection may be CB_ERR if there's no match
Private Type NMCBEENDEDIT
    hdr As NMHDR
    fChanged As Long
    iNewSelection As Long
    szText(0 To CBEMAXSTRLEN - 1) As Byte   '// As String * CBEMAXSTRLEN
    iWhy As Long
End Type
Private Type NMCBEENDEDITW
    hdr As NMHDR
    fChanged As Long
    iNewSelection As Long
    szText(0 To CBEMAXSTRLEN - 1) As Integer   '// As String * CBEMAXSTRLEN
    iWhy As Long
End Type


'******************************************************
'END COMBOBOX DECL


Private Const NM_FIRST As Long = 0&
Private Const NM_OUTOFMEMORY = NM_FIRST - 1&
Private Const NM_CLICK As Long = NM_FIRST - 2& 'uses NMCLICK struct
Private Const NM_DBLCLK As Long = NM_FIRST - 3&
Private Const NM_RETURN As Long = NM_FIRST - 4&
Private Const NM_RCLICK As Long = NM_FIRST - 5& 'uses NMCLICK struct
Private Const NM_RDBLCLK As Long = NM_FIRST - 6&
Private Const NM_SETFOCUS As Long = NM_FIRST - 7&
Private Const NM_KILLFOCUS As Long = NM_FIRST - 8&
Private Const NM_CUSTOMDRAW As Long = NM_FIRST - 12&
Private Const NM_HOVER = (NM_FIRST - 13)
Private Const NM_NCHITTEST = (NM_FIRST - 14)
Private Const NM_KEYDOWN = (NM_FIRST - 15)
Private Const NM_RELEASEDCAPTURE = (NM_FIRST - 16)
Private Const NM_SETCURSOR = (NM_FIRST - 17)
Private Const NM_CHAR = (NM_FIRST - 18)
Private Const NM_TOOLTIPSCREATED = (NM_FIRST - 19)

Private Type NMHDR
  hWndFrom As LongPtr   ' Window handle of control sending message
  idFrom As LongPtr      ' Identifier of control sending message
  code  As Long          ' Specifies the notification code
End Type
Private Type NMCUSTOMDRAW
    hdr As NMHDR
    dwDrawStage As Long
    hDC As LongPtr
    rc As RECT
    dwItemSpec As LongPtr
    uItemState As Long
    lItemlParam As LongPtr
End Type

Private Const CDRF_NOTIFYITEMDRAW As Long = &H20&
Private Const CDRF_NOTIFYPOSTPAINT As Long = &H10
Private Const CDRF_NOTIFYSUBITEMDRAW As Long = &H20&
Private Const CDRF_SKIPDEFAULT       As Long = &H4
Private Const CDRF_NEWFONT As Long = &H2&
Private Const CDRF_DODEFAULT As Long = &H0&
Private Const CDDS_PREPAINT As Long = &H1&
Private Const CDDS_ITEM As Long = &H10000
Private Const CDDS_ITEMPREPAINT As Long = CDDS_ITEM Or CDDS_PREPAINT
Private Const CDDS_ITEMPOSTPAINT = (&H10000 Or &H2)
Private Const CDDS_SUBITEM = &H20000

Private Const CDIS_SELECTED = &H1
Private Const CDIS_GRAYED = &H2
Private Const CDIS_DISABLED = &H4
Private Const CDIS_CHECKED = &H8
Private Const CDIS_FOCUS = &H10
Private Const CDIS_DEFAULT = &H20
Private Const CDIS_HOT = &H40
Private Const CDIS_MARKED = &H80
Private Const CDIS_INDETERMINATE = &H100
Private Const CDIS_SHOWKEYBOARDCUES = &H200
Private Const CDIS_NEARHOT = &H400
Private Const CDIS_OTHERSIDEHOT = &H800
Private Const CDIS_DROPHILITED = &H1000

' ================================================================
' BEGIN GENERIC LISTVIEW DEFINITIONS
'  This section contains all ListView defs and is comprehensive
'  as of at least Win7. All known undocumented messages included.
'  This section is intended to be the basis of a ListView module,
'  to be copy pasted in, then custom content added.

Private Const IDD_LISTVIEW = 101

Private Enum ucsb_LVStyles
  LVS_ICON = &H0
  LVS_REPORT = &H1
  LVS_SMALLICON = &H2
  LVS_LIST = &H3
  LVS_TYPEMASK = &H3
  LVS_SINGLESEL = &H4
  LVS_SHOWSELALWAYS = &H8
  LVS_SORTASCENDING = &H10
  LVS_SORTDESCENDING = &H20
  LVS_SHAREIMAGELISTS = &H40
  LVS_NOLABELWRAP = &H80
  LVS_AUTOARRANGE = &H100
  LVS_EDITLABELS = &H200
  LVS_OWNERDRAWFIXED = &H400
  LVS_ALIGNLEFT = &H800
  LVS_OWNERDATA = &H1000
  LVS_NOSCROLL = &H2000
  LVS_NOCOLUMNHEADER = &H4000
  LVS_NOSORTHEADER = &H8000&
  LVS_TYPESTYLEMASK = &HFC00
  LVS_ALIGNTOP = &H0
  LVS_ALIGNMASK = &HC00
End Enum   ' LVStyles

Private Enum ucsb_LVStylesEx
  LVS_EX_GRIDLINES = &H1
  LVS_EX_SUBITEMIMAGES = &H2
  LVS_EX_CHECKBOXES = &H4
  LVS_EX_TRACKSELECT = &H8
  LVS_EX_HEADERDRAGDROP = &H10
  LVS_EX_FULLROWSELECT = &H20         ' // applies to report mode only
  LVS_EX_ONECLICKACTIVATE = &H40
  LVS_EX_TWOCLICKACTIVATE = &H80
  LVS_EX_FLATSB = &H100
  LVS_EX_REGIONAL = &H200             'Not supported on 6.0+ (Vista+)
  LVS_EX_INFOTIP = &H400              ' listview does InfoTips for you
  LVS_EX_UNDERLINEHOT = &H800
  LVS_EX_UNDERLINECOLD = &H1000
  LVS_EX_MULTIWORKAREAS = &H2000
  LVS_EX_LABELTIP = &H4000
  LVS_EX_BORDERSELECT = &H8000&
  LVS_EX_DOUBLEBUFFER = &H10000
  LVS_EX_HIDELABELS = &H20000
  LVS_EX_SINGLEROW = &H40000
  LVS_EX_SNAPTOGRID = &H80000 '// Icons automatically snap to grid.
  LVS_EX_SIMPLESELECT = &H100000        '// Also changes overlay rendering to top right for icon mode.
  LVS_EX_JUSTIFYCOLUMNS = &H200000      '// Icons are lined up in columns that use up the whole view area.
  LVS_EX_TRANSPARENTBKGND = &H400000    '// Background is painted by the parent via WM_PRINTCLIENT
  LVS_EX_TRANSPARENTSHADOWTEXT = &H800000    '// Enable shadow text on transparent backgrounds only (useful with bitmaps)
  LVS_EX_AUTOAUTOARRANGE = &H1000000    '// Icons automatically arrange if no icon positions have been set
  LVS_EX_HEADERINALLVIEWS = &H2000000   '// Display column header in all view modes
  LVS_EX_DRAWIMAGEASYNC = &H4000000     'UNDOCUMENTED. LVN_ASYNCDRAW, NMLVASYNCDRAW
  LVS_EX_AUTOCHECKSELECT = &H8000000
  LVS_EX_AUTOSIZECOLUMNS = &H10000000
  LVS_EX_COLUMNSNAPPOINTS = &H40000000
  LVS_EX_COLUMNOVERFLOW = &H80000000
End Enum

' value returned by many listview messages indicating
' the index of no listview item (user defined)
Private Const LVI_NOITEM = &HFFFFFFFF

' messages
Private Const LVM_FIRST = &H1000
Private Const LVM_GETBKCOLOR = (LVM_FIRST + 0)
Private Const LVM_SETBKCOLOR = (LVM_FIRST + 1)
Private Const LVM_GETIMAGELIST = (LVM_FIRST + 2)
Private Const LVM_SETIMAGELIST = (LVM_FIRST + 3)
Private Const LVM_GETITEMCOUNT = (LVM_FIRST + 4)
Private Const LVM_GETITEM = (LVM_FIRST + 5)
Private Const LVM_SETITEM = (LVM_FIRST + 6)
Private Const LVM_INSERTITEM = (LVM_FIRST + 7)
Private Const LVM_DELETEITEM = (LVM_FIRST + 8)
Private Const LVM_DELETEALLITEMS = (LVM_FIRST + 9)
Private Const LVM_GETCALLBACKMASK = (LVM_FIRST + 10)
Private Const LVM_SETCALLBACKMASK = (LVM_FIRST + 11)
Private Const LVM_GETNEXTITEM = (LVM_FIRST + 12)
Private Const LVM_FINDITEM = (LVM_FIRST + 13)
Private Const LVM_GETITEMRECT = (LVM_FIRST + 14)
Private Const LVM_SETITEMPOSITION = (LVM_FIRST + 15)
Private Const LVM_GETITEMPOSITION = (LVM_FIRST + 16)
Private Const LVM_GETSTRINGWIDTH = (LVM_FIRST + 17)
Private Const LVM_HITTEST = (LVM_FIRST + 18)
Private Const LVM_ENSUREVISIBLE = (LVM_FIRST + 19)
Private Const LVM_SCROLL = (LVM_FIRST + 20)
Private Const LVM_REDRAWITEMS = (LVM_FIRST + 21)
Private Const LVM_ARRANGE = (LVM_FIRST + 22)
Private Const LVM_EDITLABEL = (LVM_FIRST + 23)
Private Const LVM_GETEDITCONTROL = (LVM_FIRST + 24)
Private Const LVM_GETCOLUMN = (LVM_FIRST + 25)
Private Const LVM_SETCOLUMN = (LVM_FIRST + 26)
Private Const LVM_INSERTCOLUMN = (LVM_FIRST + 27)
Private Const LVM_DELETECOLUMN = (LVM_FIRST + 28)
Private Const LVM_GETCOLUMNWIDTH = (LVM_FIRST + 29)
Private Const LVM_SETCOLUMNWIDTH = (LVM_FIRST + 30)
Private Const LVM_GETHEADER = (LVM_FIRST + 31)
Private Const LVM_CREATEDRAGIMAGE = (LVM_FIRST + 33)
Private Const LVM_GETVIEWRECT = (LVM_FIRST + 34)
Private Const LVM_GETTEXTCOLOR = (LVM_FIRST + 35)
Private Const LVM_SETTEXTCOLOR = (LVM_FIRST + 36)
Private Const LVM_GETTEXTBKCOLOR = (LVM_FIRST + 37)
Private Const LVM_SETTEXTBKCOLOR = (LVM_FIRST + 38)
Private Const LVM_GETTOPINDEX = (LVM_FIRST + 39)
Private Const LVM_GETCOUNTPERPAGE = (LVM_FIRST + 40)
Private Const LVM_GETORIGIN = (LVM_FIRST + 41)
Private Const LVM_UPDATE = (LVM_FIRST + 42)
Private Const LVM_SETITEMSTATE = (LVM_FIRST + 43)
Private Const LVM_GETITEMSTATE = (LVM_FIRST + 44)
Private Const LVM_GETITEMTEXT = (LVM_FIRST + 45)
Private Const LVM_SETITEMTEXT = (LVM_FIRST + 46)
Private Const LVM_SETITEMCOUNT = (LVM_FIRST + 47)
Private Const LVM_SORTITEMS = (LVM_FIRST + 48)
Private Const LVM_SETITEMPOSITION32 = (LVM_FIRST + 49)
Private Const LVM_GETSELECTEDCOUNT = (LVM_FIRST + 50)
Private Const LVM_GETITEMSPACING = (LVM_FIRST + 51)
Private Const LVM_GETISEARCHSTRING = (LVM_FIRST + 52)
Private Const LVM_SETICONSPACING = (LVM_FIRST + 53)
Private Const LVM_SETEXTENDEDLISTVIEWSTYLE = (LVM_FIRST + 54)
Private Const LVM_GETEXTENDEDLISTVIEWSTYLE = (LVM_FIRST + 55)
Private Const LVM_GETSUBITEMRECT = (LVM_FIRST + 56)
Private Const LVM_SUBITEMHITTEST = (LVM_FIRST + 57)
Private Const LVM_SETCOLUMNORDERARRAY = (LVM_FIRST + 58)
Private Const LVM_GETCOLUMNORDERARRAY = (LVM_FIRST + 59)
Private Const LVM_SETHOTITEM = (LVM_FIRST + 60)
Private Const LVM_GETHOTITEM = (LVM_FIRST + 61)
Private Const LVM_SETHOTCURSOR = (LVM_FIRST + 62)
Private Const LVM_GETHOTCURSOR = (LVM_FIRST + 63)
Private Const LVM_APPROXIMATEVIEWRECT = (LVM_FIRST + 64)
Private Const LVM_SETWORKAREAS = (LVM_FIRST + 65)
Private Const LVM_GETSELECTIONMARK = (LVM_FIRST + 66)
Private Const LVM_SETSELECTIONMARK = (LVM_FIRST + 67)
Private Const LVM_SETBKIMAGE = (LVM_FIRST + 68)
Private Const LVM_GETBKIMAGE = (LVM_FIRST + 69)
Private Const LVM_GETWORKAREAS = (LVM_FIRST + 70)
Private Const LVM_SETHOVERTIME = (LVM_FIRST + 71)
Private Const LVM_GETHOVERTIME = (LVM_FIRST + 72)
Private Const LVM_GETNUMBEROFWORKAREAS = (LVM_FIRST + 73)
Private Const LVM_SETTOOLTIPS = (LVM_FIRST + 74)
Private Const LVM_GETITEMW = (LVM_FIRST + 75)
Private Const LVM_SETITEMW = (LVM_FIRST + 76)
Private Const LVM_INSERTITEMW = (LVM_FIRST + 77)
Private Const LVM_GETTOOLTIPS = (LVM_FIRST + 78)
Private Const LVM_GETHOTLIGHTCOLOR = (LVM_FIRST + 79) 'UNDOCUMENTED
Private Const LVM_SETHOTLIGHTCOLOR = (LVM_FIRST + 80) 'UNDOCUMENTED
Private Const LVM_SORTITEMSEX = (LVM_FIRST + 81)
Private Const LVM_SETRANGEOBJECT = (LVM_FIRST + 82) 'UNDOCUMENTED
Private Const LVM_FINDITEMW = (LVM_FIRST + 83)
Private Const LVM_RESETEMPTYTEXT = (LVM_FIRST + 84) 'UNDOCUMENTED
Private Const LVM_SETFROZENITEM = (LVM_FIRST + 85) 'UNDOCUMENTED
Private Const LVM_GETFROZENITEM = (LVM_FIRST + 86) 'UNDOCUMENTED
Private Const LVM_GETSTRINGWIDTHW = (LVM_FIRST + 87)
Private Const LVM_SETFROZENSLOT = (LVM_FIRST + 88) 'UNDOCUMENTED
Private Const LVM_GETFROZENSLOT = (LVM_FIRST + 89) 'UNDOCUMENTED
Private Const LVM_SETVIEWMARGIN = (LVM_FIRST + 90) 'UNDOCUMENTED
Private Const LVM_GETVIEWMARGIN = (LVM_FIRST + 91) 'UNDOCUMENTED
Private Const LVM_GETGROUPSTATE = (LVM_FIRST + 92)
Private Const LVM_GETFOCUSEDGROUP = (LVM_FIRST + 93)
Private Const LVM_EDITGROUPLABEL = (LVM_FIRST + 94) 'UNDOCUMENTED
Private Const LVM_GETCOLUMNW = (LVM_FIRST + 95)
Private Const LVM_SETCOLUMNW = (LVM_FIRST + 96)
Private Const LVM_INSERTCOLUMNW = (LVM_FIRST + 97)  '
Private Const LVM_GETGROUPRECT = (LVM_FIRST + 98)

Private Const LVM_GETITEMTEXTW = (LVM_FIRST + 115)
Private Const LVM_SETITEMTEXTW = (LVM_FIRST + 116)
Private Const LVM_GETISEARCHSTRINGW = (LVM_FIRST + 117)
Private Const LVM_EDITLABELW = (LVM_FIRST + 118)

Private Const LVM_SETBKIMAGEW = (LVM_FIRST + 138)
Private Const LVM_GETBKIMAGEW = (LVM_FIRST + 139)
Private Const LVM_SETSELECTEDCOLUMN = (LVM_FIRST + 140)
Private Const LVM_SETTILEWIDTH = (LVM_FIRST + 141)
Private Const LVM_SETVIEW = (LVM_FIRST + 142)
Private Const LVM_GETVIEW = (LVM_FIRST + 143)

Private Const LVM_INSERTGROUP = (LVM_FIRST + 145)

Private Const LVM_SETGROUPINFO = (LVM_FIRST + 147)

Private Const LVM_GETGROUPINFO = (LVM_FIRST + 149)
Private Const LVM_REMOVEGROUP = (LVM_FIRST + 150)
Private Const LVM_MOVEGROUP = (LVM_FIRST + 151)
Private Const LVM_GETGROUPCOUNT = (LVM_FIRST + 152)
Private Const LVM_GETGROUPINFOBYINDEX = (LVM_FIRST + 153)
Private Const LVM_MOVEITEMTOGROUP = (LVM_FIRST + 154)
Private Const LVM_SETGROUPMETRICS = (LVM_FIRST + 155)
Private Const LVM_GETGROUPMETRICS = (LVM_FIRST + 156)
Private Const LVM_ENABLEGROUPVIEW = (LVM_FIRST + 157)
Private Const LVM_SORTGROUPS = (LVM_FIRST + 158)
Private Const LVM_INSERTGROUPSORTED = (LVM_FIRST + 159)
Private Const LVM_REMOVEALLGROUPS = (LVM_FIRST + 160)
Private Const LVM_HASGROUP = (LVM_FIRST + 161)
Private Const LVM_SETTILEVIEWINFO = (LVM_FIRST + 162)
Private Const LVM_GETTILEVIEWINFO = (LVM_FIRST + 163)
Private Const LVM_SETTILEINFO = (LVM_FIRST + 164)
Private Const LVM_GETTILEINFO = (LVM_FIRST + 165)
Private Const LVM_SETINSERTMARK = (LVM_FIRST + 166)
Private Const LVM_GETINSERTMARK = (LVM_FIRST + 167)
Private Const LVM_INSERTMARKHITTEST = (LVM_FIRST + 168)
Private Const LVM_GETINSERTMARKRECT = (LVM_FIRST + 169)
Private Const LVM_SETINSERTMARKCOLOR = (LVM_FIRST + 170)
Private Const LVM_GETINSERTMARKCOLOR = (LVM_FIRST + 171)

Private Const LVM_SETINFOTIP = (LVM_FIRST + 173)
Private Const LVM_GETSELECTEDCOLUMN = (LVM_FIRST + 174)
Private Const LVM_ISGROUPVIEWENABLED = (LVM_FIRST + 175)
Private Const LVM_GETOUTLINECOLOR = (LVM_FIRST + 176)
Private Const LVM_SETOUTLINECOLOR = (LVM_FIRST + 177)
Private Const LVM_SETKEYBOARDSELECTED = (LVM_FIRST + 178)  'UNDOCUMENTED
Private Const LVM_CANCELEDITLABEL = (LVM_FIRST + 179)
Private Const LVM_MAPINDEXTOID = (LVM_FIRST + 180)
Private Const LVM_MAPIDTOINDEX = (LVM_FIRST + 181)
Private Const LVM_ISITEMVISIBLE = (LVM_FIRST + 182)
Private Const LVM_EDITSUBITEM = (LVM_FIRST + 183)          'UNDOCUMENTED
Private Const LVM_ENSURESUBITEMVISIBLE = (LVM_FIRST + 184) 'UNDOCUMENTED
Private Const LVM_GETCLIENTRECT = (LVM_FIRST + 185)        'UNDOCUMENTED
Private Const LVM_GETFOCUSEDCOLUMN = (LVM_FIRST + 186)     'UNDOCUMENTED
Private Const LVM_SETOWNERDATACALLBACK = (LVM_FIRST + 187) 'UNDOCUMENTED
Private Const LVM_RECOMPUTEITEMS = (LVM_FIRST + 188)      'UNDOCUMENTED
Private Const LVM_QUERYINTERFACE = (LVM_FIRST + 189)      'UNDOCUMENTED: NOT OFFICIAL NAME
Private Const LVM_SETGROUPSUBSETCOUNT = (LVM_FIRST + 190) 'UNDOCUMENTED
Private Const LVM_GETGROUPSUBSETCOUNT = (LVM_FIRST + 191) 'UNDOCUMENTED
Private Const LVM_ORDERTOINDEX = (LVM_FIRST + 192)        'UNDOCUMENTED
Private Const LVM_GETACCVERSION = (LVM_FIRST + 193)       'UNDOCUMENTED
Private Const LVM_MAPACCIDTOACCINDEX = (LVM_FIRST + 194)  'UNDOCUMENTED
Private Const LVM_MAPACCINDEXTOACCID = (LVM_FIRST + 195)  'UNDOCUMENTED
Private Const LVM_GETOBJECTCOUNT = (LVM_FIRST + 196)      'UNDOCUMENTED
Private Const LVM_GETOBJECTRECT = (LVM_FIRST + 197)       'UNDOCUMENTED
Private Const LVM_ACCHITTEST = (LVM_FIRST + 198)          'UNDOCUMENTED
Private Const LVM_GETFOCUSEDOBJECT = (LVM_FIRST + 199)    'UNDOCUMENTED
Private Const LVM_GETOBJECTROLE = (LVM_FIRST + 200)       'UNDOCUMENTED
Private Const LVM_GETOBJECTSTATE = (LVM_FIRST + 201)      'UNDOCUMENTED
Private Const LVM_ACCNAVIGATE = (LVM_FIRST + 202)         'UNDOCUMENTED
Private Const LVM_INVOKEDEFAULTACTION = (LVM_FIRST + 203) 'UNDOCUMENTED
Private Const LVM_GETEMPTYTEXT = (LVM_FIRST + 204)
Private Const LVM_GETFOOTERRECT = (LVM_FIRST + 205)
Private Const LVM_GETFOOTERINFO = (LVM_FIRST + 206)
Private Const LVM_GETFOOTERITEMRECT = (LVM_FIRST + 207)
Private Const LVM_GETFOOTERITEM = (LVM_FIRST + 208)
Private Const LVM_GETITEMINDEXRECT = (LVM_FIRST + 209)
Private Const LVM_SETITEMINDEXSTATE = (LVM_FIRST + 210)
Private Const LVM_GETNEXTITEMINDEX = (LVM_FIRST + 211)
Private Const LVM_SETPRESERVEALPHA = (LVM_FIRST + 212)    'UNDOCUMENTED

Private Const LVM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT
Private Const LVM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT

Private Const I_IMAGECALLBACK As Long = (-1)
Private Const I_IMAGENONE = (-2)
Private Const I_COLUMNSCALLBACK As Long = (-1)
Private Const I_GROUPIDCALLBACK As Long = (-1)
Private Const I_GROUPIDNONE As Long = (-2)
Private Const LPSTR_TEXTCALLBACKA = (-1)
Private Const LPSTR_TEXTCALLBACKW = (-1)

Private Enum ucsb_LV_VIEW
    LV_VIEW_ICON = &H0
    LV_VIEW_DETAILS = &H1
    LV_VIEW_SMALLICON = &H2
    LV_VIEW_LIST = &H3
    LV_VIEW_TILE = &H4&
    LV_VIEW_CONTENTS = &H7
'Below are not part of API, but are implemented by this project.
    LV_VIEW_THUMBNAIL = &H6&
    LV_VIEW_XLICON = &H8
    LV_VIEW_MDICON = &H9
    LV_VIEW_CUSTOM = &H100
End Enum

Private Enum ucsb_LVTVI_Flags
    LVTVIF_AUTOSIZE = &H0
    LVTVIF_FIXEDWIDTH = &H1
    LVTVIF_FIXEDHEIGHT = &H2
    LVTVIF_FIXEDSIZE = &H3
    '6.0
    LVTVIF_EXTENDED = &H4
End Enum
Private Enum ucsb_LVTVI_Mask
    LVTVIM_TILESIZE = &H1
    LVTVIM_COLUMNS = &H2
    LVTVIM_LABELMARGIN = &H4
End Enum

Private Type SIZELVT
    CX As Long
    CY As Long
End Type
Private Type LVTILEVIEWINFO
    cbSize As Long
    dwMask As LVTVI_Mask ';     //LVTVIM_*
    dwFlags As LVTVI_Flags ';    //LVTVIF_*
    SizeTile As SIZE ' ;
    cLines As Long
    RCLabelMargin As RECT
End Type

Private Type LVTILEINFO
    cbSize As Long
    iItem As Long
    cColumns As Long
    puColumns As LongPtr
'#if (_WIN32_WINNT >= 0x0600)
    piColFmt As LongPtr
'#End If
End Type


' ============================================
' Notifications

Private Enum LVNotifications
  LVN_FIRST = -100&   ' &HFFFFFF9C   ' (0U-100U)
  LVN_LAST = -199&   ' &HFFFFFF39   ' (0U-199U)
                                                                          ' lParam points to:
  LVN_ITEMCHANGING = (LVN_FIRST - 0)            ' NMLISTVIEW, ?, rtn T/F
  LVN_ITEMCHANGED = (LVN_FIRST - 1)             ' NMLISTVIEW, ?
  LVN_INSERTITEM = (LVN_FIRST - 2)                  ' NMLISTVIEW, iItem
  LVN_DELETEITEM = (LVN_FIRST - 3)                 ' NMLISTVIEW, iItem
  LVN_DELETEALLITEMS = (LVN_FIRST - 4)         ' NMLISTVIEW, iItem = -1, rtn T/F

  LVN_COLUMNCLICK = (LVN_FIRST - 8)              ' NMLISTVIEW, iItem = -1, iSubItem = column
  LVN_BEGINDRAG = (LVN_FIRST - 9)                  ' NMLISTVIEW, iItem
  LVN_BEGINRDRAG = (LVN_FIRST - 11)              ' NMLISTVIEW, iItem

  LVN_ODCACHEHINT = (LVN_FIRST - 13)           ' NMLVCACHEHINT
  LVN_ITEMACTIVATE = (LVN_FIRST - 14)           ' v4.70 = NMHDR, v4.71 = NMITEMACTIVATE
  LVN_ODSTATECHANGED = (LVN_FIRST - 15)  ' NMLVODSTATECHANGE, rtn T/F
  LVN_HOTTRACK = (LVN_FIRST - 21)                 ' NMLISTVIEW, see docs, rtn T/F
  LVN_BEGINLABELEDITA = (LVN_FIRST - 5)        ' NMLVDISPINFO, iItem, rtn T/F
  LVN_ENDLABELEDITA = (LVN_FIRST - 6)           ' NMLVDISPINFO, see docs
 
  LVN_GETDISPINFOA = (LVN_FIRST - 50)            ' NMLVDISPINFO, see docs
  LVN_SETDISPINFOA = (LVN_FIRST - 51)            ' NMLVDISPINFO, see docs
  LVN_ODFINDITEMA = (LVN_FIRST - 52)             ' NMLVFINDITEM
 
  LVN_KEYDOWN = (LVN_FIRST - 55)                 ' NMLVKEYDOWN
  LVN_MARQUEEBEGIN = (LVN_FIRST - 56)       ' NMLISTVIEW, rtn T/F
  LVN_GETINFOTIPA = (LVN_FIRST - 57)             ' NMLVGETINFOTIP
  LVN_GETINFOTIPW = (LVN_FIRST - 58)              ' NMLVGETINFOTIP
  LVN_INCREMENTALSEARCHA = (LVN_FIRST - 62)
  LVN_INCREMENTALSEARCHW = (LVN_FIRST - 63)
'#If (WIN32_IE >= &H600) Then
  LVN_COLUMNDROPDOWN = (LVN_FIRST - 64)
  LVN_COLUMNOVERFLOWCLICK = (LVN_FIRST - 66)
'#End If
  LVN_BEGINLABELEDITW = (LVN_FIRST - 75)
  LVN_ENDLABELEDITW = (LVN_FIRST - 76)
  LVN_GETDISPINFOW = (LVN_FIRST - 77)
  LVN_SETDISPINFOW = (LVN_FIRST - 78)
  LVN_ODFINDITEMW = (LVN_FIRST - 79)             ' NMLVFINDITEM
  LVN_BEGINSCROLL = (LVN_FIRST - 80)
  LVN_ENDSCROLL = (LVN_FIRST - 81)
  LVN_LINKCLICK = (LVN_FIRST - 84)
  LVN_ASYNCDRAW = (LVN_FIRST - 86) 'Undocumented; NMLVASYNCDRAW
  LVN_GETEMPTYMARKUP = (LVN_FIRST - 87)
  LVN_GROUPCHANGED = (LVN_FIRST - 88)   ' Undocumented; NMLVGROUP
'We're going to default to Unicode, but allow targeting ANSI
#If ANSI = 1 Then
  LVN_BEGINLABELEDIT = LVN_BEGINLABELEDITA
  LVN_ENDLABELEDIT = LVN_ENDLABELEDITA
  LVN_GETDISPINFO = LVN_GETDISPINFOA
  LVN_SETDISPINFO = LVN_SETDISPINFOA
  LVN_ODFINDITEM = LVN_ODFINDITEMA         ' NMLVFINDITEM
  LVN_GETINFOTIP = LVN_GETINFOTIPA              ' NMLVGETINFOTIP
  LVN_INCREMENTALSEARCH = LVN_INCREMENTALSEARCHA
#Else
  LVN_BEGINLABELEDIT = LVN_BEGINLABELEDITW
  LVN_ENDLABELEDIT = LVN_ENDLABELEDITW
  LVN_GETDISPINFO = LVN_GETDISPINFOW
  LVN_SETDISPINFO = LVN_SETDISPINFOW
  LVN_ODFINDITEM = LVN_ODFINDITEMW         ' NMLVFINDITEM
  LVN_GETINFOTIP = LVN_GETINFOTIPW              ' NMLVGETINFOTIP
  LVN_INCREMENTALSEARCH = LVN_INCREMENTALSEARCHW
#End If
End Enum   ' LVNotifications


' LVM_GET/SETIMAGELIST wParam

Private Enum LV_ImageList
    LVSIL_NORMAL = 0
    LVSIL_SMALL = 1
    LVSIL_STATE = 2
    LVSIL_GROUPHEADER = 3
    LVSIL_FOOTER = 4 'UNDOCUMENTED: For footer items... see IListViewFooter
End Enum

' LVM_GET/SETITEM lParam
Private Type LVITEM 'LVITEMW
  Mask As LVITEM_mask
  iItem As Long
  iSubItem As Long
  State As LVITEM_state
  StateMask As LVITEM_state
  pszText As LongPtr
  cchTextMax As Long
  iImage As Long
  lParam As LongPtr
'#If (WIN32_IE >= &H300) Then
  iIndent As Long
'#End If
'#If (WIN32_IE >= &H501) Then
  iGroupId As Long
  cColumns As Long
  puColumns As LongPtr
'#End If
'#If (WIN32_IE >= &H600) Then
  piColFmt As LongPtr 'array of certain LVCFMT_ for each subitem
  iGroup As Long 'for single item in multiple groups in virtual listview
'#End If
End Type
Private Type LVITEMA   ' LVITEM with pszText as string
  Mask As LVITEM_mask
  iItem As Long
  iSubItem As Long
  State As LVITEM_state
  StateMask As Long
  pszText As String  ' if String, must be pre-allocated
  cchTextMax As Long
  iImage As Long
  lParam As LongPtr
'#If (WIN32_IE >= &H300) Then
  iIndent As Long
'#End If
'#If (WIN32_IE >= &H501) Then
  iGroupId As Long
  cColumns As Long
  puColumns As LongPtr
'#End If
'#If (WIN32_IE >= &H600) Then
  piColFmt As LongPtr 'array of certain LVCFMT_ for each subitem
  iGroup As Long 'for single item in multiple groups in virtual listview
'#End If
End Type
' LVITEM mask
Private Enum LVITEM_mask
  LVIF_TEXT = &H1
  LVIF_IMAGE = &H2
  LVIF_PARAM = &H4
  LVIF_STATE = &H8
  LVIF_INDENT = &H10
  LVIF_GROUPID = &H100
  LVIF_COLUMNS = &H200
  LVIF_NORECOMPUTE = &H800
  LVIF_DI_SETITEM = &H1000   ' NMLVDISPINFO notification
  '6.0
  LVIF_COLFMT = &H10000
End Enum

' LVITEM state, stateMask, LVM_SETCALLBACKMASK wParam
Private Enum LVITEM_state
  LVIS_FOCUSED = &H1
  LVIS_SELECTED = &H2
  LVIS_CUT = &H4
  LVIS_DROPHILITED = &H8
  LVIS_GLOW = &H10
  LVIS_ACTIVATING = &H20
 
  LVIS_OVERLAYMASK = &HF00
  LVIS_STATEIMAGEMASK = &HF000
End Enum
Private Type LVBKIMAGE
  ulFlags As LVBKIMAGE_Flags
  hBm As LongPtr
  pszImage As LongPtr  ' if String, must be pre-allocated
  cchImageMax As Long
  XOffsetPercent As Long
  YOffsetPercent As Long
End Type
Private Enum LVBKIMAGE_Flags
    LVBKIF_SOURCE_NONE = &H0
    LVBKIF_SOURCE_HBITMAP = &H1
    LVBKIF_SOURCE_URL = &H2
    LVBKIF_SOURCE_MASK = &H3
    LVBKIF_STYLE_NORMAL = &H0
    LVBKIF_STYLE_TILE = &H10
    LVBKIF_STYLE_MASK = &H10
  '5.0
    LVBKIF_FLAG_TILEOFFSET = &H100
    LVBKIF_TYPE_WATERMARK = &H10000000
    LVBKIF_FLAG_ALPHABLEND = &H20000000
End Enum

' LVM_GETNEXTITEM LOWORD(lParam)
Private Enum LVNI_Flags
    LVNI_ALL = &H0
    LVNI_FOCUSED = &H1
    LVNI_SELECTED = &H2
    LVNI_CUT = &H4
    LVNI_DROPHILITED = &H8
    
    LVNI_ABOVE = &H100
    LVNI_BELOW = &H200
    LVNI_TOLEFT = &H400
    LVNI_TORIGHT = &H800
'#If (WIN32_IE >= &H600) Then
    LVNI_STATEMASK = (LVNI_FOCUSED Or LVNI_SELECTED Or LVNI_CUT Or LVNI_DROPHILITED)
    LVNI_DIRECTIONMASK = (LVNI_ABOVE Or LVNI_BELOW Or LVNI_TOLEFT Or LVNI_TORIGHT)

    LVNI_PREVIOUS = &H20
    LVNI_VISIBLEORDER = &H10
    LVNI_VISIBLEONLY = &H40
    LVNI_SAMEGROUPONLY = &H80
'#End If
End Enum
' LVM_GETITEMRECT rc.Left (lParam)
Private Enum LVIR_Flags
    LVIR_BOUNDS = 0
    LVIR_ICON = 1
    LVIR_LABEL = 2
    LVIR_SELECTBOUNDS = 3
End Enum
Private Enum LVSIC_Flags
    LVSICF_NOINVALIDATEALL = &H1
    LVSICF_NOSCROLL = &H2
End Enum

' LVM_HITTEST lParam
Private Type LVHITTESTINFO   ' was LV_HITTESTINFO
  PT As POINT
  Flags As LVHT_Flags
  iItem As Long
'#If (WIN32_IE >= &H300) Then
  iSubItem As Long    ' this is was NOT in win95.  valid only for LVM_SUBITEMHITTEST
'#End If
'#If (WIN32_IE >= &H600) then
  iGroup As Long
'#End If
End Type
Private Enum LVA_Flags
  LVA_DEFAULT = &H0
  LVA_ALIGNLEFT = &H1
  LVA_ALIGNTOP = &H2
  LVA_SNAPTOGRID = &H5
End Enum
Private Enum LVHT_Flags
     LVHT_NOWHERE = &H1   ' in LV client area, but not over item
     LVHT_ONITEMICON = &H2
     LVHT_ONITEMLABEL = &H4
     LVHT_ONITEMSTATEICON = &H8
     LVHT_ONITEM = (LVHT_ONITEMICON Or LVHT_ONITEMLABEL Or LVHT_ONITEMSTATEICON)
    
    '  ' outside the LV's client area
     LVHT_ABOVE = &H8
     LVHT_BELOW = &H10
     LVHT_TORIGHT = &H20
     LVHT_TOLEFT = &H40
'#If (WIN32_IE >= &H600) Then
    LVHT_EX_GROUP_HEADER = &H10000000
    LVHT_EX_GROUP_FOOTER = &H20000000
    LVHT_EX_GROUP_COLLAPSE = &H40000000
    LVHT_EX_GROUP_BACKGROUND = &H80000000
    LVHT_EX_GROUP_STATEICON = &H1000000
    LVHT_EX_GROUP_SUBSETLINK = &H2000000
    LVHT_EX_GROUP = (LVHT_EX_GROUP_BACKGROUND Or LVHT_EX_GROUP_COLLAPSE Or LVHT_EX_GROUP_FOOTER Or LVHT_EX_GROUP_HEADER Or LVHT_EX_GROUP_STATEICON Or LVHT_EX_GROUP_SUBSETLINK)
    LVHT_EX_ONCONTENTS = &H4000000          'On item AND not on the background
    LVHT_EX_FOOTER = &H8000000
'#End If
End Enum
Private Type LVFINDINFOA   ' was LV_FINDINFO
  Flags As LVFINDINFO_flags
  psz As String  ' if String, must be pre-allocated
  lParam As LongPtr
  PT As POINT
  VKDirection As Long
End Type
 Private Type LVFINDINFOW   ' was LV_FINDINFO
  Flags As LVFINDINFO_flags
  psz As LongPtr  ' if String, must be pre-allocated
  lParam As LongPtr
  PT As POINT
  VKDirection As Long
End Type
Private Enum LVFINDINFO_flags
  LVFI_PARAM = &H1
  LVFI_STRING = &H2
  LVFI_SUBSTRING = &H4 'same as LVFI_PARTIAL
  LVFI_PARTIAL = &H8
  LVFI_WRAP = &H20
  LVFI_NEARESTXY = &H40
End Enum
Private Const LVFF_ITEMCOUNT = &H1
Private Type LVFOOTERINFO
     Mask As Long 'must be LVFF_ITEMCOUNT
     pszText As LongPtr 'not supported, must be 0
     cchText As Long 'not supported, must be 0
     cItems As Long
End Type
Private Enum LVFOOTERITEM_Flags
    LVFIF_TEXT = &H1
    LVFIF_STATE = &H2
End Enum
' footer item state
Private Const LVFIS_FOCUSED = &H1

Private Type LVFOOTERITEM
    Mask As LVFOOTERITEM_Flags
    iItem As Long
    pszText As LongPtr
    cchTextMax As Long
    State As Long
    StateMask As Long
End Type

Private Const LVIM_AFTER = &H1
Private Type LVINSERTMARK
    cbSize As Long
    dwFlags As Long 'must be LVIM_AFTER
    iItem As Long
    dwReserved As Long 'must be 0
End Type

Private Type LVITEMINDEX
    iItem As Long '          // listview item index
    iGroup As Long
End Type
Private Type LVSETINFOTIP
    cbSize As Long
    dwFlags As Long
    pszText As LongPtr ' LPWSTR
    iItem As Long
    iSubItem As Long
End Type


' key flags stored in uKeyFlags
Private Const LVKF_ALT = &H1
Private Const LVKF_CONTROL = &H2
Private Const LVKF_SHIFT = &H4
' #end If '(_WIN32_IE >= =&H0400)

Private Type LVCOLUMN   ' was LV_COLUMN
  Mask As LVCOLUMN_mask
  fmt As LVCOLUMN_fmt
  CX As Long
  pszText As String  ' if String, must be pre-allocated
  cchTextMax As Long
  iSubItem As Long
'#If (WIN32_IE >= &H300) Then
  iImage As Long
  iOrder As Long
'#End If
'#if (WIN32_IE >= &H600)
  cxMin As Long
  cxDefault As Long
  cxIdeal As Long
'#End If
End Type
Private Enum LVCOLUMN_mask
  LVCF_FMT = &H1
  LVCF_WIDTH = &H2
  LVCF_TEXT = &H4
  LVCF_SUBITEM = &H8
'#If (WIN32_IE >= &H300) Then
  LVCF_IMAGE = &H10
  LVCF_ORDER = &H20
'#End If
'#If (WIN32_IE >= &H600) Then
  LVCF_MINWIDTH = &H40
  LVCF_DEFAULTWIDTH = &H80
  LVCF_IDEALWIDTH = &H100
'#End If
End Enum
Private Type LVCOLUMNW   ' was LV_COLUMN
  Mask As LVCOLUMN_mask
  fmt As LVCOLUMN_fmt
  CX As Long
  pszText As LongPtr  ' if String, must be pre-allocated
  cchTextMax As Long
  iSubItem As Long
'#If (WIN32_IE >= &H300) Then
  iImage As Long
  iOrder As Long
'#End If
'#if (WIN32_IE >= &H600)
  cxMin As Long
  cxDefault As Long
  cxIdeal As Long
'#End If
End Type

 
Private Enum LVCOLUMN_fmt
  LVCFMT_LEFT = &H0
  LVCFMT_RIGHT = &H1
  LVCFMT_CENTER = &H2
  LVCFMT_JUSTIFYMASK = &H3
'#If (WIN32_IE >= &H300) Then
  LVCFMT_IMAGE = &H800
  LVCFMT_BITMAP_ON_RIGHT = &H1000
  LVCFMT_COL_HAS_IMAGES = &H8000&
'#End If
'#If (WIN32_IE >= &H600) Then
  LVCFMT_FIXED_WIDTH = &H100
  LVCFMT_NO_DPI_SCALE = &H40000
  LVCFMT_FIXED_RATIO = &H80000
  LVCFMT_LINE_BREAK = &H100000
  LVCFMT_FILL = &H200000
  LVCFMT_WRAP = &H400000
  LVCFMT_NO_TITLE = &H800000
  LVCFMT_TILE_PLACEMENTMASK = (LVCFMT_LINE_BREAK Or LVCFMT_FILL)
  LVCFMT_SPLITBUTTON = &H1000000
'#End If
End Enum



Private Enum LVGROUPRECT
    LVGGR_GROUP = 0                      'Entire expanded group
    LVGGR_HEADER = 1                     'Header only (collapsed group)
    LVGGR_LABEL = 2                      'Label only
    LVGGR_SUBSETLINK = 3                 'subset link only
End Enum
Private Enum LVGROUPMETRICFLAGS
    LVGMF_NONE = 0
    LVGMF_BORDERSIZE = 1
    LVGMF_BORDERCOLOR = 2
    LVGMF_TEXTCOLOR = 4
End Enum
Private Enum LVGROUPMASK
     LVGF_NONE = 0
     LVGF_HEADER = &H1
     LVGF_FOOTER = &H2
     LVGF_STATE = &H4
     LVGF_ALIGN = &H8
     LVGF_GROUPID = &H10
    ' If SO >= WinVista Then
     LVGF_SUBTITLE = &H100
     LVGF_TASK = &H200
     LVGF_DESCRIPTIONTOP = &H400
     LVGF_DESCRIPTIONBOTTOM = &H800
     LVGF_TITLEIMAGE = &H1000
     LVGF_EXTENDEDIMAGE = &H2000
     LVGF_ITEMS = &H4000
     LVGF_SUBSET = &H8000&
     LVGF_SUBSETITEMS = &H10000               'readonly, cItems holds count of items in visible subset, iFirstItem is valid
End Enum

Private Enum LVGROUPSTATE
     LVGS_NORMAL = &H0
     LVGS_COLLAPSED = &H1
     LVGS_HIDDEN = &H2
    
    ' SO >= WinVista
     LVGS_NOHEADER = &H4
     LVGS_COLLAPSIBLE = &H8
     LVGS_FOCUSED = &H10
     LVGS_SELECTED = &H20
     LVGS_SUBSETED = &H40
     LVGS_SUBSETLINKFOCUSED = &H80
End Enum
Private Enum LVGROUPALIGN
     LVGA_HEADER_LEFT = &H1
     LVGA_HEADER_CENTER = &H2
     LVGA_HEADER_RIGHT = &H4             ' Don't forget to validate exclusivity
    ' SO >= WinVista
     LVGA_FOOTER_LEFT = &H8
     LVGA_FOOTER_CENTER = &H10
     LVGA_FOOTER_RIGHT = &H20             ' Don't forget to validate exclusivity
End Enum

Private Type LVGROUP
    cbSize                  As Long
    Mask                    As LVGROUPMASK
    pszHeader               As LongPtr
    cchHeader               As Long
    
    pszFooter               As LongPtr
    cchFooter               As Long
    
    iGroupId                As Long
    
    StateMask               As LVGROUPSTATE
    State                   As LVGROUPSTATE
    uAlign                  As LVGROUPALIGN
' SO >= WinVista
    pszSubtitle            As LongPtr
    cchSubtitle            As Long
    pszTask                As LongPtr
    cchTask                As Long
    pszDescriptionTop      As LongPtr
    cchDescriptionTop      As Long
    pszDescriptionBottom   As LongPtr
    cchDescriptionBottom   As Long
    iTitleImage            As Long
    iExtendedImage         As Long
    iFirstItem             As Long     ' Read only
    cItems                 As Long     ' Read only
    pszSubsetTitle         As LongPtr   ' NULL if group is not subset
    cchSubsetTitle         As Long
End Type
Private Type LVINSERTGROUPSORTED
    pfnGroupCompare As LongPtr
    pvData As LongPtr
    LVG As LVGROUP
End Type

Private Type LVGROUPMETRICS
    cbSize      As Long
    Mask        As LVGROUPMETRICFLAGS
    Left        As Long
    Top         As Long
    Right       As Long
    Bottom      As Long
    crLeft      As Long
    crTop       As Long
    crRigth     As Long
    crBottom    As Long
    crHeader    As Long
    crFooter    As Long
End Type
' Notify Message Header for Listview
Private Type NMHEADER
     hdr As NMHDR
     iItem As Long
     iButton As Long
     lPtrHDItem As LongPtr ' HDITEM FAR* pItem
End Type
Private Type NMLISTVIEW   ' was NM_LISTVIEW
  hdr As NMHDR
  iItem As Long
  iSubItem As Long
  uNewState As LVITEM_state
  uOldState As LVITEM_state
  uChanged As LVITEM_mask
  PTAction As POINT
  lParam As LongPtr
End Type
Private Enum LVCD_ItemType
    LVCDI_ITEM = &H0
    LVCDI_GROUP = &H1
    LVCDI_ITEMSLIST = &H2
End Enum
Private Const LVCDRF_NOSELECT = &H10000
Private Const LVCDRF_NOGROUPFRAME = &H20000

Private Type NMLVCUSTOMDRAW
  NMCD As NMCUSTOMDRAW
  ClrText As Long
  ClrTextBk As Long
  ' if IE >= 4.0 this member of the struct can be used
  iSubItem As Integer
  '>=5.01
  dwItemType As LVCD_ItemType
  clrFace As Long
  iIconEffect As Integer
  iIconPhase As Integer
  iPartId As Integer
  iStateId As Integer
  rcText As RECT
  uAlign As Long
End Type
Private Type NMLVKEYDOWN   ' was LV_KEYDOWN
   hdr As NMHDR
   wVKey As Integer   ' can't be KeyCodeConstants, enums are Longs!
   Flags As Long   ' Always zero.
End Type
Private Type NMLVDISPINFO   ' was LV_DISPINFO
  hdr As NMHDR
  Item As LVITEM
End Type
Private Type NMLVDISPINFOA   ' was LV_DISPINFO
  hdr As NMHDR
  Item As LVITEMA
End Type

Private Const L_MAX_URL_LENGTH = 2084
Private Const MAX_LINKID_TEXT = 48
Private Enum LITEM_Mask
    LIF_ITEMINDEX = &H1
    LIF_STATE = &H2
    LIF_URL = &H8
    LIF_ITEMID = &H4
End Enum
Private Enum LITEM_State
    LIS_FOCUSED = &H1
    LIS_ENABLED = &H2
    LIS_VISITED = &H4
    LIS_HOTTRACK = &H8
    LIS_DEFAULTCOLORS = &H10
End Enum
Private Type LITEM
    Mask As LITEM_Mask
    iLink As Long
    State As LITEM_State
    StateMask As LITEM_State
    szID(0 To ((MAX_LINKID_TEXT * 2) - 1)) As Byte
    szURL(0 To ((L_MAX_URL_LENGTH * 2) - 1)) As Byte
End Type
Private Type NMLVLINK
    hdr As NMHDR
    Item As LITEM
    iItem As Long
    iGroupId As Long
End Type
Private Const LWS_USEVISUALSTYLE As Long = &H8 ' Unusable
Private Const LWS_TRANSPARENT As Long = &H1 ' Unusable
Private Type LHITTESTINFO
    PT As POINT
    Item As lItem
End Type
Private Type NMLINK
    hdr As NMHDR
    Item As lItem
End Type

Private Const EMF_CENTERED = &H1
Private Type NMLVEMPTYMARKUP
    hdr As NMHDR
    dwFlags As Long
    szMarkup(0 To ((L_MAX_URL_LENGTH * 2) - 1)) As Byte
End Type
Private Type NMLVEMPTYMARKUPW
    hdr As NMHDR
    dwFlags As Long
    szMarkup(0 To (L_MAX_URL_LENGTH - 1)) As Integer
End Type
Private Type NMLVSCROLL
    hdr As NMHDR
    DX As Long
    DY As Long
End Type

Private Type NMLVGROUP
    hdr As NMHDR
    iGroupId As Long
    uNewState As Long
    uOldState As Long
End Type

Private Type NMLVODSTATECHANGE
    hdr As NMHDR
    iFrom As Long
    iTo As Long
    uNewState As Long
    uOldState As Long
End Type
Private Const LVGIT_UNFOLDED = &H1
Private Type NMLVGETINFOTIP
    hdr As NMHDR
    dwFlags As Long
    pszText As LongPtr
    cchTextMax As Long
    iItem As Long
    iSubItem As Long
    lParam As LongPtr
End Type

Private Type NMLVFINDITEMA
    hdr As NMHDR
    iStart As Long
    LVFI As LVFINDINFOA
End Type
Private Type NMLVFINDITEMW
    hdr As NMHDR
    iStart As Long
    LVFI As LVFINDINFOW
End Type

Private Type NMLVCACHEHINT
    hdr As NMHDR
    iFrom As Long
    iTo As Long
End Type

Private Type NMITEMACTIVATE
    hdr As NMHDR
    iItem As Long
    iSubItem As Long
    uNewState As Long
    uOldState As Long
    uChanged As Long
    PTAction As POINT
    lParam As LongPtr
    uKeyFlags As Long
End Type

Private Type NMLVASYNCDRAW 'Undocumented; for LVN_ASYNCDRAW
    hdr As NMHDR
    pimldp As LongPtr 'IMAGELISTDRAWPARAMS
    hr As Long
    iPart As LVAD_Parts
    iItem As Long
    iSubItem As Long
    dwRetFlags As Long
    iRetImageIndex As Long
End Type
Private Enum LVAD_Parts
    LVADPART_ITEM = &H0&
    LVADPART_GROUP = &H1& 'iItem = group id, others unused
    LVADPART_IMAGETITLE = &H2& 'value unconfirmed and purpose unknown
End Enum

Private Const LVSR_SELECTION = &H0
Private Const LVSR_CUT = &H1

Private Const HEADER32_CLASS   As String = "SysHeader32"
Private Const HEADER_CLASS     As String = "SysHeader"

'header info

Private Enum ucsb_HeaderStyles
    HDS_HORZ = &H0
    HDS_BUTTONS = &H2
    HDS_HIDDEN = &H8
    HDS_HOTTRACK = &H4 ' v 4.70
    HDS_DRAGDROP = &H40 ' v 4.70
    HDS_FULLDRAG = &H80
    HDS_FILTERBAR = &H100 ' v 5.0
    HDS_FLAT = &H200 ' v 5.1
    HDS_CHECKBOXES = &H400 '6.0
    HDS_NOSIZING = &H800
    HDS_OVERFLOW = &H1000
End Enum
Private Enum ucsb_HDMASK
    HDI_WIDTH = &H1
    HDI_HEIGHT = HDI_WIDTH
    HDI_TEXT = &H2
    HDI_FORMAT = &H4
    HDI_LPARAM = &H8
    HDI_BITMAP = &H10
    HDI_IMAGE = &H20
    HDI_DI_SETITEM = &H40
    HDI_ORDER = &H80
    '5.0
    HDI_FILTER = &H100
    '6.0
    HDI_STATE = &H200
End Enum

Private Enum ucsb_HeaderHitTestFlags
    HHT_NOWHERE = &H1
    HHT_ONHEADER = &H2
    HHT_ONDIVIDER = &H4
    HHT_ONDIVOPEN = &H8
'#if (_WIN32_IE >= =&h0500)
    HHT_ONFILTER = &H10
    HHT_ONFILTERBUTTON = &H20
'#End If
    HHT_ABOVE = &H100
    HHT_BELOW = &H200
    HHT_TORIGHT = &H400
    HHT_TOLEFT = &H800
'#if _WIN32_WINNT >= =&h0600
    HHT_ONITEMSTATEICON = &H1000
    HHT_ONDROPDOWN = &H2000
    HHT_ONOVERFLOW = &H4000
End Enum
Private Enum ucsb_HeaderImageListFlags
    HDSIL_NORMAL = 0
    HDSIL_STATE = 1
End Enum
Private Type HDHITTESTINFO
    PT As POINT
    Flags As ucsb_HeaderHitTestFlags
    iItem As Long
End Type

Private Const HDN_FIRST As Long = -300&
Private Const HDN_ITEMCLICK = (HDN_FIRST - 2)
Private Const HDN_DIVIDERDBLCLICK = (HDN_FIRST - 5)
Private Const HDN_BEGINTRACK = (HDN_FIRST - 6)
Private Const HDN_ENDTRACK = (HDN_FIRST - 7)
Private Const HDN_TRACK = (HDN_FIRST - 8)
Private Const HDN_GETDISPINFO = (HDN_FIRST - 9)
Private Const HDN_ITEMCHANGING As Long = (HDN_FIRST - 0)
Private Const HDN_ITEMDBLCLICK As Long = (HDN_FIRST - 3)
Private Const HDN_ITEMCHANGINGA = (HDN_FIRST - 0)
Private Const HDN_ITEMCHANGINGW = (HDN_FIRST - 20)
Private Const HDN_ITEMCHANGEDA = (HDN_FIRST - 1)
Private Const HDN_ITEMCHANGEDW = (HDN_FIRST - 21)
Private Const HDN_ITEMCLICKA = (HDN_FIRST - 2)
Private Const HDN_ITEMCLICKW = (HDN_FIRST - 22)
Private Const HDN_ITEMDBLCLICKA = (HDN_FIRST - 3)
Private Const HDN_ITEMDBLCLICKW = (HDN_FIRST - 23)
Private Const HDN_DIVIDERDBLCLICKA = (HDN_FIRST - 5)
Private Const HDN_DIVIDERDBLCLICKW = (HDN_FIRST - 25)
Private Const HDN_BEGINTRACKA = (HDN_FIRST - 6)
Private Const HDN_BEGINTRACKW = (HDN_FIRST - 26)
Private Const HDN_ENDTRACKA = (HDN_FIRST - 7)
Private Const HDN_ENDTRACKW = (HDN_FIRST - 27)
Private Const HDN_TRACKA = (HDN_FIRST - 8)
Private Const HDN_TRACKW = (HDN_FIRST - 28)
Private Const HDN_GETDISPINFOA = (HDN_FIRST - 9)
Private Const HDN_GETDISPINFOW = (HDN_FIRST - 29)
Private Const HDN_BEGINDRAG = (HDN_FIRST - 10)
Private Const HDN_ENDDRAG = (HDN_FIRST - 11)
Private Const HDN_FILTERCHANGE = (HDN_FIRST - 12)
Private Const HDN_FILTERBTNCLICK = (HDN_FIRST - 13)
'#If (WIN32_IE > 600) Then
Private Const HDN_BEGINFILTEREDIT = (HDN_FIRST - 14)
Private Const HDN_ENDFILTEREDIT = (HDN_FIRST - 15)
Private Const HDN_ITEMSTATEICONCLICK = (HDN_FIRST - 16)
Private Const HDN_ITEMKEYDOWN = (HDN_FIRST - 17)
Private Const HDN_DROPDOWN = (HDN_FIRST - 18)
Private Const HDN_OVERFLOWCLICK = (HDN_FIRST - 19)
'#End If

Private Const HDM_FIRST As Long = &H1200
Private Const HDM_GETITEMCOUNT = (HDM_FIRST + 0)
Private Const HDM_INSERTITEMA = (HDM_FIRST + 1)
Private Const HDM_DELETEITEM = (HDM_FIRST + 2)
Private Const HDM_GETITEMA = (HDM_FIRST + 3)
Private Const HDM_SETITEMA = (HDM_FIRST + 4)
Private Const HDM_LAYOUT = (HDM_FIRST + 5)
Private Const HDM_HITTEST = (HDM_FIRST + 6)
Private Const HDM_GETITEMRECT = (HDM_FIRST + 7)
Private Const HDM_SETIMAGELIST = (HDM_FIRST + 8)
Private Const HDM_GETIMAGELIST = (HDM_FIRST + 9)
Private Const HDM_INSERTITEMW = (HDM_FIRST + 10)
Private Const HDM_GETITEMW = (HDM_FIRST + 11)
Private Const HDM_SETITEMW = (HDM_FIRST + 12)

Private Const HDM_ORDERTOINDEX = (HDM_FIRST + 15)
Private Const HDM_CREATEDRAGIMAGE = (HDM_FIRST + 16)      '// wparam = which item (by index)
Private Const HDM_GETORDERARRAY = (HDM_FIRST + 17)
Private Const HDM_SETORDERARRAY = (HDM_FIRST + 18)
Private Const HDM_SETHOTDIVIDER = (HDM_FIRST + 19)
Private Const HDM_SETBITMAPMARGIN = (HDM_FIRST + 20)
Private Const HDM_GETBITMAPMARGIN = (HDM_FIRST + 21)
Private Const HDM_SETFILTERCHANGETIMEOUT = (HDM_FIRST + 22)
Private Const HDM_EDITFILTER = (HDM_FIRST + 23)
Private Const HDM_CLEARFILTER = (HDM_FIRST + 24)
Private Const HDM_GETITEMDROPDOWNRECT = (HDM_FIRST + 25) ' // rect of item's drop down button
Private Const HDM_GETOVERFLOWRECT = (HDM_FIRST + 26) '// rect of overflow button
Private Const HDM_GETFOCUSEDITEM = (HDM_FIRST + 27)
Private Const HDM_SETFOCUSEDITEM = (HDM_FIRST + 28)
Private Const HDM_TRANSLATEACCELERATOR = &H461  ' CCM_TRANSLATEACCELERATOR

Private Const HDM_GETITEM = HDM_GETITEMA
Private Const HDM_SETITEM = HDM_SETITEMA
Private Const HDM_INSERTITEM = HDM_INSERTITEMA
Private Const HDM_SETUNICODEFORMAT = CCM_SETUNICODEFORMAT
Private Const HDM_GETUNICODEFORMAT = CCM_GETUNICODEFORMAT
'#define Header_GetItemDropDownRect(hwnd, iItem, lprc) \
'        (BOOL)SNDMSG((hwnd), HDM_GETITEMDROPDOWNRECT, (WPARAM)(iItem), (LPARAM)(lprc))

'#define Header_GetOverflowRect(hwnd, lprc) \
'        (BOOL)SNDMSG((hwnd), HDM_GETOVERFLOWRECT, 0, (LPARAM)(lprc))
'
'#define Header_GetFocusedItem(hwnd) \
'        (int)SNDMSG((hwnd), HDM_GETFOCUSEDITEM, (WPARAM)(0), (LPARAM)(0))


'#End if
' HDITEM fmt
Private Enum HDITEM_FMT
    HDF_LEFT = 0
    HDF_RIGHT = 1
    HDF_CENTER = 2
    HDF_JUSTIFYMASK = &H3
    HDF_RTLREADING = 4
    HDF_BITMAP = &H2000
    HDF_STRING = &H4000
    HDF_OWNERDRAW = &H8000&
    '3.0
    HDF_IMAGE = &H800
    HDF_BITMAP_ON_RIGHT = &H1000
    '5.0
    HDF_SORTUP = &H400
    HDF_SORTDOWN = &H200
    '6.0
    HDF_CHECKBOX = &H40
    HDF_CHECKED = &H80
    HDF_FIXEDWIDTH = &H100
    HDF_SPLITBUTTON = &H1000000
End Enum
Private Enum HDF_TYPE
    HDFT_ISSTRING = &H0           '// HD_ITEM.pvFilter points to a HD_TEXTFILTER
    HDFT_ISNUMBER = &H1           '// HD_ITEM.pvFilter points to a INT
    HDFT_ISDATE = &H2
    HDFT_HASNOVALUE = &H8000&      '// clear the filter, by setting this bit
End Enum
Private Const HDIS_FOCUSED = &H1

' Header Item Type

Private Type HDITEM
    Mask As ucsb_HDMASK
    CXY As Long
    pszText As String
    hBm As LongPtr
    cchTextMax As Long
    fmt As HDITEM_FMT
    lParam As LongPtr
    iImage As Long
    iOrder As Long
'#If (WIN32_IE >= &H500) then
    type As HDF_TYPE
    pvFilter As LongPtr
'#If (WIN32_IE >= &H600) then
    State As Long
End Type
Private Type HDITEMW
    Mask As ucsb_HDMASK
    CXY As Long
    pszText As LongPtr
    hBm As LongPtr
    cchTextMax As Long
    fmt As HDITEM_FMT
    lParam As LongPtr
'#If (WIN32_IE >= &H300) then
    iImage As Long
    iOrder As Long
'#If (WIN32_IE >= &H500) then
    type As HDF_TYPE
    pvFilter As LongPtr
'#If (WIN32_IE >= &H600) then
    State As Long
End Type
Private Type HD_TEXTFILTERA
    pszText As String
    cchTextMax As Long
End Type
Private Type HD_TEXTFILTERW
    pszText  As LongPtr
    cchTextMax As Long
End Type
Private Type HDLAYOUT
    prc As RECT
    pwpos As WINDOWPOS
End Type

Private Type NMHEADERX
     hdr As NMHDR
     iItem As Long
     iButton As Long
     pItem As HDITEMW ' HDITEM FAR* pItem
End Type
Private Type HD_NOTIFY
    hdr As NMHDR
    iItem As Long
    iButton As Long
    pItem As HDITEM
End Type
Private Type NMHDDISPINFOW
    hdr As NMHDR
    iItem As Long
    Mask As Long
    pszText As LongPtr
    cchTextMax As Long
    iImage As Long
    lParam As LongPtr
End Type
Private Type NMHDDISPINFOA
    hdr As NMHDR
    iItem As Long
    Mask As Long
    pszText As String
    cchTextMax As Long
    iImage As Long
    lParam As LongPtr
End Type
Private Type NMHDFILTERBTNCLICK
    hdr As NMHDR
    iItem As Long
    rc As RECT
End Type

#End Region

#Region "ControlCode"

Private Sub ShowAboutDialog()
    Dim sAbout As String
    #If Win64 Then
        sAbout = mVersionStr & " twinBASIC 64bit build" & vbCrLf & "Detected OS: "
    #Else
        sAbout = mVersionStr & " twinBASIC 32bit build" & vbCrLf & "Detected OS: "
    #End If
    If bIsWin10OrGreater Then
        sAbout = sAbout & "Windows 10 or greater"
    ElseIf bIsWin8OrGreater Then
        sAbout = sAbout & "Windows 8"
    ElseIf bIsWin7OrGreater Then
        sAbout = sAbout & "Windows 7"
    ElseIf bIsWinVistaOrGreater Then
        sAbout = sAbout & "Windows Vista"
    Else
        sAbout = sAbout & "Unsupported: XP or earlier, or unknown."
    End If
    sAbout = sAbout & vbCrLf & "Common Controls 6.0 Support: " & CStr(IsComCtl6)
    #If Win64 Then
        sAbout = sAbout & vbCrLf & "WOW64 Redirection Disabled: n/a"
    #Else
    sAbout = sAbout & vbCrLf & "WOW64 Redirection Disabled: " & CStr(m_NoWow64)
    #End If
    sAbout = sAbout & vbCrLf & "Scaling factor: x=" & CStr(m_ScaleX) & ",y=" & m_ScaleY
    sAbout = sAbout & vbCrLf & "High performance mode: " & CStr(mHighPerfMode)
    sAbout = sAbout & vbCrLf & "Host app version: " & App.Major & "." & App.Minor & "." & App.Revision
    sAbout = sAbout & vbCrLf & "Registry data key: " & mRegDataName
    
    MessageBoxW hLVS, StrPtr(sAbout), StrPtr(scc_AboutBox), 0&
End Sub

'--------------------
'Debug Logger
Private Sub DebugAppend(ByVal sMsg As String, Optional ilvl As Long = 0)
If ilvl < dbg_MinLevel Then Exit Sub
Dim sOut As String
If dbg_IncludeDate Then sOut = "[" & Format$(Now, dbg_dtFormat) & "] "
If dbg_IncludeName Then sOut = sOut & Ambient.DisplayName & ": "
sOut = sOut & sMsg
If dbg_PrintToImmediate Then Debug.Print sOut
If dbg_RaiseEvent = True Then RaiseEvent DebugMessage(sOut, CInt(ilvl))
If dbg_PrintToFile Then
    If log_hFile Then
        WriteLog sOut
    End If
End If
End Sub

Public Property Get LogActive() As Boolean: LogActive = log_bActive: End Property
[ Hidden ]
Public Property Let LogActive(bVal As Boolean)
If bVal <> log_bActive Then
    log_bActive = bVal
    If log_bActive Then
        If ((dbg_LogExeOnly = True) And (IsIDE = False)) Or (dbg_LogExeOnly = False) Then
            If (dbg_LogAppend = True) Or (dbg_LogOverwrite = True) Then
                StartLog AddBackslash(App.Path) & dbg_LogFileName & dbg_LogFileExt, dbg_LogAppend
            Else
                StartLog AddBackslash(App.Path) & dbg_LogFileName & Format$(Now, "yyyymmddHhNnSs") & dbg_LogFileExt, False
            End If
        End If
    Else
        StopLog
    End If
End If
End Property

Private Sub StartLog(szFile As String, Append As Boolean)
Debug.Print "StartLog.szFile=" & szFile
If Append = True Then
    If PathFileExistsW(StrPtr(szFile)) = 0 Then Append = False
End If
If Not Append Then
    'open the file for writing, clearing the contents of any existing file
    log_hFile = CreateFileW(StrPtr(szFile), GENERIC_WRITE, FILE_SHARE_READ, ByVal 0&, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, 0&)

    'if error
    If log_hFile = -1 Then Debug.Print "ERROR: Logfile could not be opened for writing."
Else
'open the file for appending
    log_hFile = CreateFileW(StrPtr(szFile), GENERIC_WRITE, FILE_SHARE_READ, ByVal 0&, OPEN_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, 0&)
    'if error
    If log_hFile = -1 Then
        Debug.Print "ERROR: Logfile could not be opened for writing."
    Else
        'we need to move to EOF
        log_RetVal = SetFilePointer(log_hFile, 0&, 0&, FILE_END)
    End If
End If
log_bActive = True
End Sub

Private Function WriteLog(ByVal data As String) As Long
Dim lngBytesWritten As Long 'output number of bytes actually written to the file

If log_bActive = False Then Exit Function

Dim sWrite As String
sWrite = data & vbCrLf
If log_bBuf = True Then
    Call BufferEntry(sWrite)
    WriteLog = -555
Else
    WriteLog = WriteFile(log_hFile, ByVal StrPtr(sWrite), LenB(sWrite), lngBytesWritten, ByVal 0&)
End If
End Function

Private Function WriteBuffer() As Long
If (UBound(log_sBuf) = 0) And (log_sBuf(0) = "") Then Exit Function

Dim i As Long
Dim lngBytesWritten As Long 'output number of bytes actually written to the file
Dim sItem As String

For i = 0 To UBound(log_sBuf)
    sItem = log_sBuf(i) ' & vbCrLf
    WriteBuffer = WriteFile(log_hFile, ByVal StrPtr(sItem), LenB(sItem), lngBytesWritten, ByVal 0&)
Next i

ReDim log_sBuf(0)

End Function

Private Sub StopLog()
If log_hFile Then log_RetVal = CloseHandle(log_hFile)
log_hFile = 0& 'just in case
log_bActive = False
End Sub

Private Sub BufferEntry(ByVal data As String)
'exposing this as a public is purely optional
If log_sBuf(0) = "" Then
    log_sBuf(0) = data
Else
    ReDim Preserve log_sBuf(UBound(log_sBuf) + 1)
    log_sBuf(UBound(log_sBuf)) = data
End If

End Sub

Private Sub StartBuffer()
'all calls to WriteLog are stored in a buffer rather than written to disk
'this is designed for when a massive number of writes are expected in a short time,
'therefore writing to disk would be a massive reduction in performance
On Error Resume Next
'If dbg_no_buffer Then Exit Sub

log_bBuf = True

End Sub

Private Sub StopBuffer()
'writes the existing buffer to disk and returns WriteLog to immediate disk writes
log_bBuf = False
WriteBuffer

End Sub

Public Sub DebugLogInsertMessage(sMsg As String)
'If internal logging is active, you can manually append a message
DebugAppend sMsg
End Sub
'End Debug Logger

Private Function Subclass2(hWnd As LongPtr, lpFN As LongPtr, Optional uId As LongPtr = 0&, Optional dwRefData As LongPtr = 0&) As Boolean
If uId = 0 Then uId = hWnd
    Subclass2 = SetWindowSubclass(hWnd, lpFN, uId, dwRefData):      Debug.Assert Subclass2
End Function

Private Function UnSubclass2(hWnd As LongPtr, ByVal lpFN As LongPtr, pid As LongPtr) As Boolean
    UnSubclass2 = RemoveWindowSubclass(hWnd, lpFN, pid)
End Function
    
Private Sub IObjectSafety_GetInterfaceSafetyOptions(riid As UUID, pdwSupportedOptions As Long, pdwEnabledOptions As Long) Implements IObjectSafety.GetInterfaceSafetyOptions
Const INTERFACESAFE_FOR_UNTRUSTED_CALLER As Long = &H1, INTERFACESAFE_FOR_UNTRUSTED_DATA As Long = &H2
pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER Or INTERFACESAFE_FOR_UNTRUSTED_DATA
pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER Or INTERFACESAFE_FOR_UNTRUSTED_DATA
End Sub

Private Sub IObjectSafety_SetInterfaceSafetyOptions(riid As UUID, ByVal dwOptionSetMask As Long, ByVal dwEnabledOptions As Long) Implements IObjectSafety.SetInterfaceSafetyOptions
    
End Sub

Private Sub UserControl_Initialize() Handles UserControl.Initialize
    DebugAppend "UserControl_Initialize"
    On Error GoTo e0
    mExpIcoCB = True
    If dbg_PrintToFile Then
        If ((dbg_LogExeOnly = True) And (IsIDE = False)) Or (dbg_LogExeOnly = False) Then
            ReDim log_sBuf(0)
            If (dbg_LogAppend = True) Or (dbg_LogOverwrite = True) Then
                StartLog AddBackslash(App.Path) & dbg_LogFileName & dbg_LogFileExt, dbg_LogAppend
            Else
                StartLog AddBackslash(App.Path) & dbg_LogFileName & Format$(Now, "yyyymmddHhNnSs") & dbg_LogFileExt, False
            End If
        End If
    End If
    Dim lWOW64 As Long
    IsWow64Process GetCurrentProcess(), lWOW64
    If lWOW64 Then IsWOW64 = True
    DebugAppend "UCSB Initialize Entry at " & Now
    bStartup = True
    'm_def_sCurPath = App.Path
    ReadWindowsVersion
    
    mFontFolder = SpecialFolderPath(FOLDERID_Fonts)
    mDeskFolder = SpecialFolderPath(FOLDERID_Desktop)
    
    Dim sBuff As String
    sBuff = String$(MAX_PATH, 0)
    GetWindowsDirectoryW ByVal StrPtr(sBuff), MAX_PATH
    If InStr(sBuff, vbNullChar) > 1 Then
        mWinDir = Left$(sBuff, InStr(sBuff, vbNullChar) - 1)
        mWinDrive = Left$(mWinDir, 3)
    End If
    If mWinDrive = "" Then
        mWinDrive = Left$(mFontFolder, 3)
    End If
    SetUnsupportedHPfLocs
    
    SND_NAVIGATESTART = GetRegistryValueW(HKEY_CURRENT_USER, "AppEvents\Schemes\Apps\Explorer\Navigating\.Current", "")
    SND_DEFAULTBEEP = GetRegistryValueW(HKEY_CURRENT_USER, "AppEvents\Schemes\Apps\.Default\.Default\.Current", "")
    SND_CRITICAL = GetRegistryValueW(HKEY_CURRENT_USER, "AppEvents\Schemes\Apps\.Default\SystemHand\.Current", "")
    
    dwAutoCompFlags = ACO_AUTOAPPEND Or ACO_AUTOSUGGEST
    dwAutoCompListFlags = ACLO_FILESYSDIRS
    
    lGrpCol = -1
    ReDim tDispProps(0)
    ReDim lColSet(0)
    ReDim sItemCats(0)
    ReDim gidCat(0)
    ReDim MainCache(0)
    ReDim sSelectedFiles(0)
    ReDim sSelectedFileNames(0)
    ReDim sSelectedFilesOnly(0)
    ReDim sSelectedFilesOnlyFull(0)
    ReDim sSelectedFoldersOnly(0)
    ReDim sSelectedFoldersOnlyFull(0)
    SelectedFileIndex = -1
    
    lDefColISF(0) = -1
    lDefColISF(1) = -1
    lDefColISF(2) = -1
    lDefColISF(3) = -1
    lDefColISF(4) = -1
    lDefColISF(5) = -1
    lColSet(0) = -1
    lKeepColIdx = -1
    nCustomSet = -1
    Dim hDC As LongPtr
    hDC = GetDC(0&)
    m_ScaleX = GetDeviceCaps(hDC, LOGPIXELSX) / 96
    DebugAppend "dpix=" & GetDeviceCaps(hDC, LOGPIXELSX) / 96
    m_ScaleY = GetDeviceCaps(hDC, LOGPIXELSY) / 96
    ReleaseDC 0&, hDC
    
    mDlgGuid = "{A9B5D3BC-1CD6-4ea8-9C5F-314CD0655C94}"
    'Get the actual scale factor even if virtualized.
    'Thanks LaVolpe
    Dim tDC As LongPtr, lRez As Long, lDPI As Long
    tDC = GetDC(0)
    lRez = GetDeviceCaps(tDC, DESKTOPHORZRES)
    ReleaseDC 0, tDC
    lDPI = 96! * lRez / (Screen.Width / Screen.TwipsPerPixelX)
    mActualZoom = CSng(lDPI) / 96!
    '
    'If IsIDE = False Then
    '    mActualZoom = m_ScaleX
    'End If
    'If IsIDE Then
        mActualZoom = m_ScaleX
    'End If
    cxyDispL = cxyLargeIcons * mActualZoom
    cyDtName = 19&
    
    cyMaxDetailPane = 265& * m_ScaleY '256 + 9 border fits max unscaled icons
    
    bDtLockCY = False
    
    m_SysClrWindow = GetSysColor(COLOR_WINDOW)
    m_SysClrText = GetSysColor(COLOR_WINDOWTEXT)
    m_SysClrGray = GetSysColor(COLOR_GRAYTEXT)
    m_SysClrMenu = GetSysColor(COLOR_MENU)
    
    If ExplorerSettingEnabled(SSF_SHOWCOMPCOLOR) Then
        m_NCExVal = SBCP_ForceOn
    Else
        m_NCExVal = SBCP_ForceOff
    End If
    If ExplorerSettingEnabled(SSF_SHOWALLOBJECTS) Then
        mHPInExp = True
    Else
        mHPInExp = False
    End If
    If ExplorerSettingEnabled(SSF_SHOWSUPERHIDDEN) Then
        mSHPInExp = True
    Else
        mSHPInExp = False
    End If
    If ExplorerSettingEnabled(SSF_SHOWEXTENSIONS) Then
        mExSetExt = True
    Else
        mExSetExt = False
    End If
    
    cySysBorder = GetSystemMetrics(SM_CYBORDER)
    cxyLgIcn = GetSystemMetrics(SM_CXICON)
    
    gdipInitToken = InitGDIPlus()
    hThemeProg = OpenThemeData(hWnd, StrPtr("Progress"))
    hThemeNav = OpenThemeData(hWnd, StrPtr("NAVIGATION"))
    
    Dim lVal As Long
    GetThemeMetric hThemeNav, 0&, NAV_BACKBUTTON, NAV_BB_NORMAL, TMT_WIDTH, lVal
    If lVal Then
        cxThemeButtonB = lVal
    Else
        cxThemeButtonB = 30
    End If
    lVal = 0&
    GetThemeMetric hThemeNav, 0&, NAV_BACKBUTTON, NAV_BB_NORMAL, TMT_HEIGHT, lVal
    If lVal Then
        cyThemeButtonB = lVal
    Else
        cyThemeButtonB = 30
    End If
    lVal = 0&
    GetThemeMetric hThemeNav, 0&, NAV_FORWARDBUTTON, NAV_FB_NORMAL, TMT_WIDTH, lVal
    If lVal Then
        cxThemeButtonF = lVal
    Else
        cxThemeButtonF = 30
    End If
    lVal = 0&
    GetThemeMetric hThemeNav, 0&, NAV_FORWARDBUTTON, NAV_FB_NORMAL, TMT_HEIGHT, lVal
    If lVal Then
        cyThemeButtonF = lVal
    Else
        cyThemeButtonF = 30
    End If
    
    
    InitFonts
    InitImageLists
    cyMinDetailPane = cyLVIcon + (cySysBorder * 2)
    
    InitZoneStr
    
    'hIcoSearchBox16 = ResIconTohIcon("ICO_SRCHBOX", 16, 16)
    'hIcoSearchBox20 = ResIconTohIcon("ICO_SRCHBOX", 20, 20)
    'hIcoSearchBox24 = ResIconTohIcon("ICO_SRCHBOX", 24, 24)
    hIcoSearchBox16 = PBEncodedIconTohIcon(pbidx_ICO_SRCHBOX, 16, 16)
    hIcoSearchBox20 = PBEncodedIconTohIcon(pbidx_ICO_SRCHBOX, 20, 20)
    hIcoSearchBox24 = PBEncodedIconTohIcon(pbidx_ICO_SRCHBOX, 24, 24)
    hIcoSearchBoxDis16 = PBEncodedIconTohIcon(pbidx_ICO_SRCHDIS, 16, 16)
    hIcoSearchBoxDis20 = PBEncodedIconTohIcon(pbidx_ICO_SRCHDIS, 20, 20)
    hIcoSearchBoxDis24 = PBEncodedIconTohIcon(pbidx_ICO_SRCHDIS, 24, 24)
    
    'If m_sCurPath = "" Then m_sCurPath = App.Path
    ReDim sHistory(0)
    sHistory(0) = m_sCurPath
    ReDim uPidlStore(0)
    ReDim gidType(0)
    lvGroupsSize = "0;1048575;1048576;52428799;52428800;262143999;262144000;1073741823;1073741824;-1"
    '<1MB, 1MB-50MB, 50MB-250MB, 250MB-1GB, 1GB++
    arGroupsSize = Split(lvGroupsSize, ";")
    
    ReDim arGroupsDates(6)
    ReDim arGroupsDatesC(6)
    ReDim arGroupsDatesA(6)
    arGroupsDates(0) = "1;" & mLUPastHour
    arGroupsDates(1) = "24;" & mLULastDay
    arGroupsDates(2) = "168;" & mLULastWk '1week
    arGroupsDates(3) = "720;" & mLULastMn 'past 30 days
    arGroupsDates(4) = "4320;" & mLULast6Mn 'past 180 days
    arGroupsDates(5) = "8766;" & mLULastYr 'past year
    arGroupsDates(6) = "0;" & mLUGtYr
    arGroupsDatesC(0) = "1;" & mLUPastHour
    arGroupsDatesC(1) = "24;" & mLULastDay
    arGroupsDatesC(2) = "168;" & mLULastWk '1week
    arGroupsDatesC(3) = "720;" & mLULastMn 'past 30 days
    arGroupsDatesC(4) = "4320;" & mLULast6Mn 'past 180 days
    arGroupsDatesC(5) = "8766;" & mLULastYr 'past year
    arGroupsDatesC(6) = "0;" & mLUGtYr
    arGroupsDatesA(0) = "1;" & mLUPastHour
    arGroupsDatesA(1) = "24;" & mLULastDay
    arGroupsDatesA(2) = "168;" & mLULastWk '1week
    arGroupsDatesA(3) = "720;" & mLULastMn 'past 30 days
    arGroupsDatesA(4) = "4320;" & mLULast6Mn 'past 180 days
    arGroupsDatesA(5) = "8766;" & mLULastYr 'past year
    arGroupsDatesA(6) = "0;" & mLUGtYr
    ReDim lGrpIDs(0)
    ReDim bDispCol(1023)
    ReDim lColKey(1023)
    CF_DROPDESCRIPTION = RegisterClipboardFormatW(StrPtr(CFSTR_DROPDESCRIPTION))
    CF_PREFERREDDROPEFFECT = RegisterClipboardFormatW(StrPtr(CFSTR_PREFERREDDROPEFFECT))
    
    Set pDTH = New DragDropHelper
    DebugAppend "-->UC_INIT_OUT"
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.Show->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
        Resume Next
End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag) Handles UserControl.ReadProperties
DebugAppend "UserControl_ReadProperties", 2000
mStartLast = PropBag.ReadProperty("BrowserStartLastPath", mDefStartLast)
m_StartEmpty = PropBag.ReadProperty("BrowserStartBlank", m_def_StartEmpty)
mCustomRoot = PropBag.ReadProperty("CustomRoot", m_defCustomRoot)
mCustomRootEnforce = PropBag.ReadProperty("CustomRootLocked", m_defCustomRootEnforce)
mHighPerfMode = PropBag.ReadProperty("HighPerformanceMode", mDefHighPerfMode)
m_CtlBorder = PropBag.ReadProperty("BorderStyleControl", m_def_CtlBorder)
m_Border = PropBag.ReadProperty("BorderStyle", m_def_Border)
m_FontScaleCXY = PropBag.ReadProperty("FontScaleForDPI", m_def_FontScaleCXY)
Set PropFont = PropBag.ReadProperty("Font", Ambient.Font)
' If PropFont Is Nothing Then
'     DebugAppend "UC_ReadProperties::PropFont is nothing"
'     Set PropFont = Ambient.Font
'     If PropFont Is Nothing Then
'         DebugAppend "UC_ReadProperties::PropFont is STILL nothing"
'     End If
' End If
Set PropFontDt = PropBag.ReadProperty("FontDetails", PropFont)
' If PropFontDt Is Nothing Then
'     DebugAppend "UC_ReadProperties::PropFontDt is nothing"
'     Set PropFontDt = Ambient.Font
'     If PropFontDt Is Nothing Then
'         DebugAppend "UC_ReadProperties::PropFontDt is STILL nothing"
'     End If
' End If
Set FontDetails = PropFontDt
Set PropFontLV = PropBag.ReadProperty("FontFileControls", PropFont)
' If PropFontLV Is Nothing Then
'     Set PropFontLV = PropFont
' End If
' DebugAppend "ReadLVFont " & PropFontLV.Name, 444
Set FontFileControls = PropFontLV
Set PropPicture = PropBag.ReadProperty("Picture", Nothing)
mUserModeToggle = PropBag.ReadProperty("EnableUserModeSwitch", m_def_UserModeToggle)
mLVOffX = PropBag.ReadProperty("ListViewOffsetX", mDefLVOffX)
mDTOffsetX = PropBag.ReadProperty("DetailsPaneOffsetX", mDefDTOffsetX)
PropPictureAlignment = PropBag.ReadProperty("PictureAlignment", SBPicAlignTopLeft)
PropPictureWatermark = PropBag.ReadProperty("PictureWatermark", False)
clrBack = PropBag.ReadProperty("BackColor", vbWindowBackground)
clrFore = PropBag.ReadProperty("ForeColor", vbWindowText)
clrForeSubitem = PropBag.ReadProperty("ForeColorSubitem", vbWindowText)
clrCtBack = PropBag.ReadProperty("ControlBackColor", vbButtonFace)
clrDtBack = PropBag.ReadProperty("DetailsPaneBackColor", &HFBF5F1)
clrDtName = PropBag.ReadProperty("DetailsPaneFileNameColor", &HC)
clrDtFore = PropBag.ReadProperty("DetailsPaneForeColor", &H79675A)
clrColSel = PropBag.ReadProperty("ColumnSelectColor", &HF7F7F7)
clrSbBack = PropBag.ReadProperty("SearchBoxBackColor", vbWindowBackground)
clrSbFore = PropBag.ReadProperty("SearchBoxForeColor", vbWindowText)
mMasterEnabled = PropBag.ReadProperty("Enabled", mMasterEnabled_def)
mExplorerStyle = PropBag.ReadProperty("ExplorerStyle", mExplorerStyle_def)
mExplSel = PropBag.ReadProperty("ExplorerStyleSelection", mDefExplSel)
mFoldersOnly = PropBag.ReadProperty("FoldersOnly", m_def_FoldersOnly)
mFilesOnly = PropBag.ReadProperty("FilesOnly", m_def_FilesOnly)
mDispParAndIndt = PropBag.ReadProperty("ShowParentTreeInList", mDefDispParAndIndt)
m_HiddenPref = PropBag.ReadProperty("ShowHiddenItems", m_def_HiddenPref)
m_SuperHiddenPref = PropBag.ReadProperty("ShowSuperHidden", m_def_SuperHiddenPref)
m_NoWow64 = PropBag.ReadProperty("DisableWow64Redirect", m_def_NoWow64)
m_Mode = PropBag.ReadProperty("ControlType", m_def_Mode)
m_CbType = PropBag.ReadProperty("ComboType", m_def_CbType)
m_CBXNoIcons = PropBag.ReadProperty("ComboHideIcons", m_def_CBXNoIcons)
m_CompAsRoot = PropBag.ReadProperty("ComputerAsRoot", m_def_CompAsRoot)
m_sCurPath = PropBag.ReadProperty("BrowserPath", m_def_sCurPath)
m_MultiSelect = PropBag.ReadProperty("MultiSelect", m_def_MultiSelect)
m_ViewMode = PropBag.ReadProperty("ViewMode", m_def_ViewMode)
m_GroupMode = PropBag.ReadProperty("GroupMode", m_def_GroupMode)
m_GroupSubset = PropBag.ReadProperty("GroupSubsetCount", m_def_GroupSubset)
m_GroupSubsetLinkText = PropBag.ReadProperty("GroupSubsetLinkText", m_def_GroupSubsetLinkText)
m_InsColp = PropBag.ReadProperty("GroupStartCollapsed", m_def_InsColp)
m_Filter = PropBag.ReadProperty("ItemFilter", m_def_Filter)
m_FolderFilter = PropBag.ReadProperty("ItemFilterFolder", m_def_FolderFilter)
m_ControlBox = PropBag.ReadProperty("ListControlBox", m_def_ControlBox)
mAutoHideCtlBox = PropBag.ReadProperty("AutoHideControlBox", mDefAutoHideCtlBox)
m_MaxComboCX = PropBag.ReadProperty("MaxComboWidth", m_def_MaxComboCX)
m_DefCol = PropBag.ReadProperty("DefaultColumns", m_def_DefCol)
m_HideIcons = PropBag.ReadProperty("HideIcons", m_def_HideIcons)
m_HideComboIcons = PropBag.ReadProperty("HideDropdownIcons", m_def_HideComboIcons)
m_ForceExt = PropBag.ReadProperty("FileExtensions", m_def_ForceExt)
m_FullRowSel = PropBag.ReadProperty("FullRowSelect", m_def_FullRowSel)
m_SnapToGrid = PropBag.ReadProperty("SnapToGrid", m_def_SnapToGrid)
m_NameColors = PropBag.ReadProperty("FileNameColors", m_def_NameColors)
m_StatusBar = PropBag.ReadProperty("ShowStatusBar", m_def_StatusBar)
m_StatusSP = PropBag.ReadProperty("StatusSinglePanel", m_def_StatusSP)
mDefStatusText = PropBag.ReadProperty("StatusTextStart", m_def_DefStatusText)
m_ThumbCXY = PropBag.ReadProperty("ThumbnailSize", m_def_ThumbCXY)
m_ThumbScaleCXY = PropBag.ReadProperty("ThumbnailScaleForDPI", m_def_ThumbScaleCXY)
m_ThumbExt = PropBag.ReadProperty("ExtendedThumbnails", m_def_ThumbExt)
m_ThumbPreload = PropBag.ReadProperty("ThumbnailPreload", m_def_ThumbPreload)
mExtColPreload = PropBag.ReadProperty("ColumnPreload", mDefExtColPreload)
m_ViewButton = PropBag.ReadProperty("ViewButton", m_def_ViewButton)
m_UpButton = PropBag.ReadProperty("UpButton", m_def_UpButton)
m_NavBtnType = PropBag.ReadProperty("NavigationButtons", m_def_NavBtnType)
m_BookmarkButton = PropBag.ReadProperty("BookmarkButton", m_def_BookmarkButton)
m_PvPane = PropBag.ReadProperty("PreviewPane", m_def_PvPane)
m_DtPane = PropBag.ReadProperty("DetailsPane", m_def_DtPane)
mDtPaneNoRS = PropBag.ReadProperty("DetailsPaneNoResizing", mDefDtPaneNoRS)
mPvPaneNoRS = PropBag.ReadProperty("PreviewPaneNoResizing", mDefPvPaneNoRS)
m_AutoSzCol = PropBag.ReadProperty("AutosizeColumns", m_def_AutoSzCol)
m_ColLock = PropBag.ReadProperty("LockColumns", m_def_ColLock)
m_BrowseZip = PropBag.ReadProperty("BrowseZip", m_def_BrowseZip)
m_LockNav = PropBag.ReadProperty("LockNavigation", m_def_LockNav)
m_Monitor = PropBag.ReadProperty("MonitorDirChanges", m_def_Monitor)
m_DDMode = PropBag.ReadProperty("FileDragDropMode", m_def_DDMode)
m_ActiveDrop = PropBag.ReadProperty("ActiveDrop", m_def_ActiveDrop)
m_Checkboxes = PropBag.ReadProperty("Checkboxes", m_def_Checkboxes)
m_EnableDetails = PropBag.ReadProperty("EnableDetails", m_def_EnableDetails)
m_EnableSearchBox = PropBag.ReadProperty("EnableSearch", m_def_EnableSearchBox)
m_EnableStatusBar = PropBag.ReadProperty("EnableStatusBar", m_def_EnableStatusBar)
mEnableBookmark = PropBag.ReadProperty("EnableBookmarks", mDefEnableBookmark)
mEnableNewFolder = PropBag.ReadProperty("EnableNewFolder", mDefEnableNewFolder)
m_LockView = PropBag.ReadProperty("LockView", m_def_LockView)
m_EnableViewMenu = PropBag.ReadProperty("EnableViewMenu", m_def_EnableViewMenu)
m_EnableShellMenu = PropBag.ReadProperty("EnableShellMenu", m_def_EnableShellMenu)
m_EnablePreview = PropBag.ReadProperty("EnablePreview", m_def_EnablePreview)
mEnableLayout = PropBag.ReadProperty("EnableLayout", mDefEnableLayout)
m_MinDropCX = PropBag.ReadProperty("MinWidthDropdown", m_def_MinDropCX)
m_MinDropCY = PropBag.ReadProperty("MinHeightDropdown", m_def_MinDropCY)
mFixedDropHeight = PropBag.ReadProperty("DropdownFixedHeight", mDefFixedDropHeight)
m_HideColumnHeader = PropBag.ReadProperty("HideColumnHeader", m_def_HideColumnHeader)
m_HideLabels = PropBag.ReadProperty("HideLabels", m_def_HideLabels)
m_GridLines = PropBag.ReadProperty("GridLines", m_def_GridLines)
m_AllowSorting = PropBag.ReadProperty("AllowSorting", m_def_AllowSorting)
m_AllowRename = PropBag.ReadProperty("AllowRename", m_def_AllowRename)
m_NoHdrSize = PropBag.ReadProperty("HeaderNoSizing", m_def_NoHdrSize)
m_HdrDD = PropBag.ReadProperty("HeaderDragDrop", m_def_HdrDD)
m_HdrOverflow = PropBag.ReadProperty("HeaderOverflowButton", m_def_HdrOverflow)
m_HdrHotTrack = PropBag.ReadProperty("HeaderHotTracking", m_def_HdrHotTrack)
m_HdrMinCX = PropBag.ReadProperty("HeaderMinWidth", m_def_HdrMinCX)
m_TrackSel = PropBag.ReadProperty("TrackSelect", m_def_TrackSel)
m_OneClickAct = PropBag.ReadProperty("OneClickActivate", m_def_OneClickAct)
m_TwoClickAct = PropBag.ReadProperty("TwoClickActivate", m_def_TwoClickAct)
m_ULHot = PropBag.ReadProperty("UnderlineHot", m_def_ULHot)
m_ULCold = PropBag.ReadProperty("UnderlineCold", m_def_ULCold)
m_CheckSel = PropBag.ReadProperty("AutoCheckSelect", m_def_CheckSel)
m_FollowLinks = PropBag.ReadProperty("FollowLinks", m_def_FollowLinks)
m_EditCB = PropBag.ReadProperty("ComboCanEdit", m_def_EditCB)
m_FilterBar = PropBag.ReadProperty("FilterBar", m_def_FilterBar)
m_FilterCase = PropBag.ReadProperty("FilterCaseSensitive", m_def_FilterCase)
m_HeaderInAll = PropBag.ReadProperty("HeaderInAllViews", m_def_HeaderInAll)
m_PreviewVidThumb = PropBag.ReadProperty("PreviewVideoAsThumb", m_def_PreviewVidThumb)
mShowSearch = PropBag.ReadProperty("SearchBox", mDefShowSearch)
mSearchPopupInMenu = PropBag.ReadProperty("SearchPopupInMenu", mDefSearchPopupInMenu)
mSearchAutoGroup = PropBag.ReadProperty("SearchAutoGroup", mDefSearchAutoGroup)
mCXSearch = PropBag.ReadProperty("SearchBoxWidth", m_def_CXSearch)
m_NoDblClkNav = PropBag.ReadProperty("NoNavigateOnSelect", m_def_NoDblClkNav)
m_DisableWhileLoading = PropBag.ReadProperty("DisableWhileLoading", m_def_DisableWhileLoading)
mEditMarq = PropBag.ReadProperty("LoadingMarquee", m_def_EditMarq)
mMaxHist = PropBag.ReadProperty("MaxHistoryDisplayed", m_def_MaxHist)
mExtOverlay = PropBag.ReadProperty("ExtendedOverlays", m_def_ExtOverlay)
m_DisableOvr = PropBag.ReadProperty("DisableOverlays", m_def_DisableOvr)
mAlwaysSortWithISF = PropBag.ReadProperty("AlwaysSortWithISF", m_def_AlwaysSortWithISF)
m_IconPreload = PropBag.ReadProperty("IconPreload", m_def_IconPreload)
m_ShellTree = PropBag.ReadProperty("ShellTreeInLayout", m_def_ShellTree)
mAutoComp = PropBag.ReadProperty("Autocomplete", m_def_AutoComp)
mInfoTipMode = PropBag.ReadProperty("InfoTipMode", mDefInfoTipMode)
mInfoTipLimitHPF = PropBag.ReadProperty("InfoTipsLimitForHPF", mDefInfoTipLimitHPF)
mSimpSel = PropBag.ReadProperty("SimpleSelect", mDefSimpSel)
mAlignTop = PropBag.ReadProperty("AlignTop", mDefAlignTop)
mNoLblWrap = PropBag.ReadProperty("NoLabelWrap", mDefNoLblWrap)
mShowSelAlw = PropBag.ReadProperty("ShowSelAlways", mDefShowSelAlw)
mAutoArr = PropBag.ReadProperty("AutoArrange", mDefAutoArr)
mFtrPostSearch = PropBag.ReadProperty("ShowFooterAfterSearch", m_def_FtrPostSearch)
lRaiseHover = PropBag.ReadProperty("ActiveDropHoverTime", m_def_lRaiseHover)
mStrRVM = PropBag.ReadProperty("RestrictViewModes", mDefStrRVM)
mAlwaysShowExtVerbs = PropBag.ReadProperty("AlwaysShowExtendedVerbs", mDefAlwaysShowExtVerbs)
mSFinBKM = PropBag.ReadProperty("SpecialFoldersInBookmarks", mDefSFinBKM)
mAutoSelCol = PropBag.ReadProperty("SelectColumnOnSort", mDefAutoSelCol)
mPlaySnd = PropBag.ReadProperty("PlaySounds", mDefPlaySnd)
mIncludeFldrLnkInFldrOnly = PropBag.ReadProperty("FoldersOnlyIncludeLinks", mDefIncludeFldrLnkInFldrOnly)
mIncludeFldrLnkInFldrOnlyHPF = PropBag.ReadProperty("FoldersOnlyIncludeLinksHPF", mDefIncludeFldrLnkInFldrOnlyHPF)
nExpandSelectedFolderInDropdown = PropBag.ReadProperty("DropdownExpandChildren", nDefExpandSelectedFolderInDropdown)
mBkFwInCtx = PropBag.ReadProperty("NavShowOnFilesOnlyCtxMenu", mDefBkFwInCtx)
mTileWidth = PropBag.ReadProperty("TileWidth", mDefTileWidth)
mLMMaxCX = PropBag.ReadProperty("ListModeMaxWidth", mDefLMMaxCX)
mShowDataStreams = PropBag.ReadProperty("ShowAltDataStreams", mDefShowDataStreams)
mCustomInMenu = PropBag.ReadProperty("CustomIconsEnabled", mDefCustomInMenu)
mCustomMenuCap = PropBag.ReadProperty("CustomIconsCaption", mDefCustomMenuCap)
mcxyCustom = PropBag.ReadProperty("CustomIconsSize", mDefcxyCustom)
mEnableGrp = PropBag.ReadProperty("AllowGroups", mDefEnableGrp)
mEnablePaste = PropBag.ReadProperty("AllowPasting", mDefEnablePaste)
mDispSecZn = PropBag.ReadProperty("ShowSecurityZone", mDefDispSecZn)
DebugAppend "ReadProp ViewMode=" & m_ViewMode
pvCreate
    
End Sub

Private Sub UserControl_WriteProperties(PropBag As PropertyBag) Handles UserControl.WriteProperties
PropBag.WriteProperty "BrowserStartLastPath", mStartLast, mDefStartLast
PropBag.WriteProperty "BrowserStartBlank", m_StartEmpty, m_def_StartEmpty
PropBag.WriteProperty "CustomRoot", mCustomRoot, m_defCustomRoot
PropBag.WriteProperty "CustomRootLocked", mCustomRootEnforce, m_defCustomRootEnforce
PropBag.WriteProperty "HighPerformanceMode", mHighPerfMode, mDefHighPerfMode
PropBag.WriteProperty "BorderStyleControl", m_CtlBorder, m_def_CtlBorder
PropBag.WriteProperty "BorderStyle", m_Border, m_def_Border
PropBag.WriteProperty "Font", PropFont, Ambient.Font
PropBag.WriteProperty "FontDetails", IIf(OLEFontIsEqual(PropFontDt, PropFont) = False, PropFontDt, Nothing)
DebugAppend "WriteLVFont " & PropFontLV.Name, 444
PropBag.WriteProperty "FontFileControls", IIf(OLEFontIsEqual(PropFontLV, PropFont) = False, PropFontLV, Nothing)
PropBag.WriteProperty "FontScaleForDPI", m_FontScaleCXY, m_def_FontScaleCXY
PropBag.WriteProperty "EnableUserModeSwitch", mUserModeToggle, m_def_UserModeToggle
PropBag.WriteProperty "ListViewOffsetX", mLVOffX, mDefLVOffX
PropBag.WriteProperty "DetailsPaneOffsetX", mDTOffsetX, mDefDTOffsetX
PropBag.WriteProperty "Picture", PropPicture, Nothing
PropBag.WriteProperty "PictureAlignment", PropPictureAlignment, SBPicAlignTopLeft
PropBag.WriteProperty "PictureWatermark", PropPictureWatermark, False
PropBag.WriteProperty "BackColor", clrBack, vbWindowBackground
PropBag.WriteProperty "ForeColor", clrFore, vbWindowText
PropBag.WriteProperty "ControlBackColor", clrCtBack, vbButtonFace
PropBag.WriteProperty "DetailsPaneBackColor", clrDtBack, &HFBF5F1
PropBag.WriteProperty "DetailsPaneFileNameColor", clrDtName, &HC
PropBag.WriteProperty "DetailsPaneForeColor", clrDtFore, &H79675A
PropBag.WriteProperty "ColumnSelectColor", clrColSel, &HF7F7F7
PropBag.WriteProperty "ForeColorSubitem", clrForeSubitem, vbWindowText
PropBag.WriteProperty "SearchBoxBackColor", clrSbBack, vbWindowBackground
PropBag.WriteProperty "SearchBoxForeColor", clrSbFore, vbWindowText
PropBag.WriteProperty "DisableWow64Redirect", m_NoWow64, m_def_NoWow64
PropBag.WriteProperty "ControlType", m_Mode, m_def_Mode
PropBag.WriteProperty "ComboType", m_CbType, m_def_CbType
PropBag.WriteProperty "ComboHideIcons", m_CBXNoIcons, m_def_CBXNoIcons
PropBag.WriteProperty "Enabled", mMasterEnabled, mMasterEnabled_def
PropBag.WriteProperty "ExplorerStyle", mExplorerStyle, mExplorerStyle_def
PropBag.WriteProperty "ExplorerStyleSelection", mExplSel, mDefExplSel
PropBag.WriteProperty "FoldersOnly", mFoldersOnly, m_def_FoldersOnly
PropBag.WriteProperty "FilesOnly", mFilesOnly, m_def_FilesOnly
PropBag.WriteProperty "ShowParentTreeInList", mDispParAndIndt, mDefDispParAndIndt
PropBag.WriteProperty "ShowHiddenItems", m_HiddenPref, m_def_HiddenPref
PropBag.WriteProperty "ShowSuperHidden", m_SuperHiddenPref, m_def_SuperHiddenPref
PropBag.WriteProperty "ComputerAsRoot", m_CompAsRoot, m_def_CompAsRoot
PropBag.WriteProperty "BrowserPath", m_sCurPath, m_def_sCurPath
PropBag.WriteProperty "MultiSelect", m_MultiSelect, m_def_MultiSelect
PropBag.WriteProperty "ViewMode", m_ViewMode, m_def_ViewMode
PropBag.WriteProperty "GroupMode", m_GroupMode, m_def_GroupMode
PropBag.WriteProperty "GroupSubsetCount", m_GroupSubset, m_def_GroupSubset
PropBag.WriteProperty "GroupSubsetLinkText", m_GroupSubsetLinkText, m_def_GroupSubsetLinkText
PropBag.WriteProperty "GroupStartCollapsed", m_InsColp, m_def_InsColp
PropBag.WriteProperty "ItemFilter", m_Filter, m_def_Filter
PropBag.WriteProperty "ItemFilterFolder", m_FolderFilter, m_def_FolderFilter
PropBag.WriteProperty "ListControlBox", m_ControlBox, m_def_ControlBox
PropBag.WriteProperty "AutoHideControlBox", mAutoHideCtlBox, mDefAutoHideCtlBox
PropBag.WriteProperty "MaxComboWidth", m_MaxComboCX, m_def_MaxComboCX
PropBag.WriteProperty "DefaultColumns", m_DefCol, m_def_DefCol
PropBag.WriteProperty "HideIcons", m_HideIcons, m_def_HideIcons
PropBag.WriteProperty "HideDropdownIcons", m_HideComboIcons, m_def_HideComboIcons
PropBag.WriteProperty "FileExtensions", m_ForceExt, m_def_ForceExt
PropBag.WriteProperty "FullRowSelect", m_FullRowSel, m_def_FullRowSel
PropBag.WriteProperty "SnapToGrid", m_SnapToGrid, m_def_SnapToGrid
PropBag.WriteProperty "FileNameColors", m_NameColors, m_def_NameColors
PropBag.WriteProperty "ShowStatusBar", m_StatusBar, m_def_StatusBar
PropBag.WriteProperty "StatusSinglePanel", m_StatusSP, m_def_StatusSP
PropBag.WriteProperty "StatusTextStart", mDefStatusText, m_def_DefStatusText
PropBag.WriteProperty "ThumbnailSize", m_ThumbCXY, m_def_ThumbCXY
PropBag.WriteProperty "ThumbnailScaleForDPI", m_ThumbScaleCXY, m_def_ThumbScaleCXY
PropBag.WriteProperty "ExtendedThumbnails", m_ThumbExt, m_def_ThumbExt
PropBag.WriteProperty "ThumbnailPreload", m_ThumbPreload, m_def_ThumbPreload
PropBag.WriteProperty "ColumnPreload", mExtColPreload, mDefExtColPreload
PropBag.WriteProperty "ViewButton", m_ViewButton, m_def_ViewButton
PropBag.WriteProperty "UpButton", m_UpButton, m_def_UpButton
PropBag.WriteProperty "NavigationButtons", m_NavBtnType, m_def_NavBtnType
PropBag.WriteProperty "BookmarkButton", m_BookmarkButton, m_def_BookmarkButton
PropBag.WriteProperty "PreviewPane", m_PvPane, m_def_PvPane
PropBag.WriteProperty "DetailsPane", m_DtPane, m_def_DtPane
PropBag.WriteProperty "DetailsPaneNoResizing", mDtPaneNoRS, mDefDtPaneNoRS
PropBag.WriteProperty "PreviewPaneNoResizing", mPvPaneNoRS, mDefPvPaneNoRS
PropBag.WriteProperty "BrowseZip", m_BrowseZip, m_def_BrowseZip
PropBag.WriteProperty "LockNavigation", m_LockNav, m_def_LockNav
PropBag.WriteProperty "MonitorDirChanges", m_Monitor, m_def_Monitor
PropBag.WriteProperty "AutosizeColumns", m_AutoSzCol, m_def_AutoSzCol
PropBag.WriteProperty "LockColumns", m_ColLock, m_def_ColLock
PropBag.WriteProperty "FileDragDropMode", m_DDMode, m_def_DDMode
PropBag.WriteProperty "ActiveDrop", m_ActiveDrop, m_def_ActiveDrop
PropBag.WriteProperty "Checkboxes", m_Checkboxes, m_def_Checkboxes
PropBag.WriteProperty "EnablePreview", m_EnablePreview, m_def_EnablePreview
PropBag.WriteProperty "EnableDetails", m_EnableDetails, m_def_EnableDetails
PropBag.WriteProperty "EnableViewMenu", m_EnableViewMenu, m_def_EnableViewMenu
PropBag.WriteProperty "EnableShellMenu", m_EnableShellMenu, m_def_EnableShellMenu
PropBag.WriteProperty "EnableSearch", m_EnableSearchBox, m_def_EnableSearchBox
PropBag.WriteProperty "EnableStatusBar", m_EnableStatusBar, m_def_EnableStatusBar
PropBag.WriteProperty "EnableLayout", mEnableLayout, mDefEnableLayout
PropBag.WriteProperty "EnableBookmarks", mEnableBookmark, mDefEnableBookmark
PropBag.WriteProperty "EnableNewFolder", mEnableNewFolder, mDefEnableNewFolder
PropBag.WriteProperty "LockView", m_LockView, m_def_LockView
PropBag.WriteProperty "MinWidthDropdown", m_MinDropCX, m_def_MinDropCX
PropBag.WriteProperty "MinHeightDropdown", m_MinDropCY, m_def_MinDropCY
PropBag.WriteProperty "DropdownFixedHeight", mFixedDropHeight, mDefFixedDropHeight
PropBag.WriteProperty "HideColumnHeader", m_HideColumnHeader, m_def_HideColumnHeader
PropBag.WriteProperty "HideLabels", m_HideLabels, m_def_HideLabels
PropBag.WriteProperty "GridLines", m_GridLines, m_def_GridLines
PropBag.WriteProperty "AllowSorting", m_AllowSorting, m_def_AllowSorting
PropBag.WriteProperty "AllowRename", m_AllowRename, m_def_AllowRename
PropBag.WriteProperty "HeaderNoSizing", m_NoHdrSize, m_def_NoHdrSize
PropBag.WriteProperty "HeaderDragDrop", m_HdrDD, m_def_HdrDD
PropBag.WriteProperty "HeaderOverflowButton", m_HdrOverflow, m_def_HdrOverflow
PropBag.WriteProperty "HeaderHotTracking", m_HdrHotTrack, m_def_HdrHotTrack
PropBag.WriteProperty "HeaderMinWidth", m_HdrMinCX, m_def_HdrMinCX
PropBag.WriteProperty "TrackSelect", m_TrackSel, m_def_TrackSel
PropBag.WriteProperty "OneClickActivate", m_OneClickAct, m_def_OneClickAct
PropBag.WriteProperty "TwoClickActivate", m_TwoClickAct, m_def_TwoClickAct
PropBag.WriteProperty "UnderlineHot", m_ULHot, m_def_ULHot
PropBag.WriteProperty "UnderlineCold", m_ULCold, m_def_ULCold
PropBag.WriteProperty "AutoCheckSelect", m_CheckSel, m_def_CheckSel
PropBag.WriteProperty "FollowLinks", m_FollowLinks, m_def_FollowLinks
PropBag.WriteProperty "ComboCanEdit", m_EditCB, m_def_EditCB
PropBag.WriteProperty "FilterBar", m_FilterBar, m_def_FilterBar
PropBag.WriteProperty "FilterCaseSensitive", m_FilterCase, m_def_FilterCase
PropBag.WriteProperty "HeaderInAllViews", m_HeaderInAll, m_def_HeaderInAll
PropBag.WriteProperty "PreviewVideoAsThumb", m_PreviewVidThumb, m_def_PreviewVidThumb
PropBag.WriteProperty "SearchBox", mShowSearch, mDefShowSearch
PropBag.WriteProperty "SearchPopupInMenu", mSearchPopupInMenu, mDefSearchPopupInMenu
PropBag.WriteProperty "SearchAutoGroup", mSearchAutoGroup, mDefSearchAutoGroup
PropBag.WriteProperty "SearchBoxWidth", mCXSearch, m_def_CXSearch
PropBag.WriteProperty "NoNavigateOnSelect", m_NoDblClkNav, m_def_NoDblClkNav
PropBag.WriteProperty "ActiveDropHoverTime", lRaiseHover, m_def_lRaiseHover
PropBag.WriteProperty "DisableWhileLoading", m_DisableWhileLoading, m_def_DisableWhileLoading
PropBag.WriteProperty "LoadingMarquee", mEditMarq, m_def_EditMarq
PropBag.WriteProperty "MaxHistoryDisplayed", mMaxHist, m_def_MaxHist
PropBag.WriteProperty "ExtendedOverlays", mExtOverlay, m_def_ExtOverlay
PropBag.WriteProperty "DisableOverlays", m_DisableOvr, m_def_DisableOvr
PropBag.WriteProperty "AlwaysSortWithISF", mAlwaysSortWithISF, m_def_AlwaysSortWithISF
PropBag.WriteProperty "IconPreload", m_IconPreload, m_def_IconPreload
PropBag.WriteProperty "ShellTreeInLayout", m_ShellTree, m_def_ShellTree
PropBag.WriteProperty "Autocomplete", mAutoComp, m_def_AutoComp
PropBag.WriteProperty "InfoTipMode", mInfoTipMode, mDefInfoTipMode
PropBag.WriteProperty "InfoTipsLimitForHPF", mInfoTipLimitHPF, mDefInfoTipLimitHPF
PropBag.WriteProperty "SimpleSelect", mSimpSel, mDefSimpSel
PropBag.WriteProperty "AlignTop", mAlignTop, mDefAlignTop
PropBag.WriteProperty "NoLabelWrap", mNoLblWrap, mDefNoLblWrap
PropBag.WriteProperty "ShowSelAlways", mShowSelAlw, mDefShowSelAlw
PropBag.WriteProperty "AutoArrange", mAutoArr, mDefAutoArr
PropBag.WriteProperty "ShowFooterAfterSearch", mFtrPostSearch, m_def_FtrPostSearch
PropBag.WriteProperty "RestrictViewModes", mStrRVM, mDefStrRVM
PropBag.WriteProperty "AlwaysShowExtendedVerbs", mAlwaysShowExtVerbs, mDefAlwaysShowExtVerbs
PropBag.WriteProperty "SpecialFoldersInBookmarks", mSFinBKM, mDefSFinBKM
PropBag.WriteProperty "SelectColumnOnSort", mAutoSelCol, mDefAutoSelCol
PropBag.WriteProperty "PlaySounds", mPlaySnd, mDefPlaySnd
PropBag.WriteProperty "FoldersOnlyIncludeLinks", mIncludeFldrLnkInFldrOnly, mDefIncludeFldrLnkInFldrOnly
PropBag.WriteProperty "FoldersOnlyIncludeLinksHPF", mIncludeFldrLnkInFldrOnlyHPF, mDefIncludeFldrLnkInFldrOnlyHPF
PropBag.WriteProperty "DropdownExpandChildren", nExpandSelectedFolderInDropdown, nDefExpandSelectedFolderInDropdown
PropBag.WriteProperty "NavShowOnFilesOnlyCtxMenu", mBkFwInCtx, mDefBkFwInCtx
PropBag.WriteProperty "TileWidth", mTileWidth, mDefTileWidth
PropBag.WriteProperty "ListModeMaxWidth", mLMMaxCX, mDefLMMaxCX
PropBag.WriteProperty "ShowAltDataStreams", mShowDataStreams, mDefShowDataStreams
PropBag.WriteProperty "CustomIconsEnabled", mCustomInMenu, mDefCustomInMenu
PropBag.WriteProperty "CustomIconsCaption", mCustomMenuCap, mDefCustomMenuCap
PropBag.WriteProperty "CustomIconsSize", mcxyCustom, mDefcxyCustom
PropBag.WriteProperty "AllowGroups", mEnableGrp, mDefEnableGrp
PropBag.WriteProperty "AllowPasting", mEnablePaste, mDefEnablePaste
PropBag.WriteProperty "ShowSecurityZone", mDispSecZn, mDefDispSecZn
DebugAppend "UserControl_WriteProperties()", 1
    
End Sub

Private Sub UserControl_Click() Handles UserControl.Click
    RaiseEvent Click
End Sub

Private Sub UserControl_EnterFocus() Handles UserControl.EnterFocus
RaiseEvent EnterFocus
End Sub

Private Sub UserControl_ExitFocus() Handles UserControl.ExitFocus
RaiseEvent ExitFocus
End Sub
Private Sub UserControl_DblClick() Handles UserControl.DblClick
RaiseEvent DblClick
End Sub

Private Sub UserControl_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles UserControl.MouseDown
RaiseEvent MouseDown(Button, Shift, X, Y)
End Sub

Private Sub UserControl_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles UserControl.MouseMove
RaiseEvent MouseMove(Button, Shift, X, Y)
End Sub

Private Sub UserControl_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles UserControl.MouseUp
RaiseEvent MouseUp(Button, Shift, X, Y)
End Sub

Private Sub UserControl_Resize() Handles UserControl.Resize
    'Dim rcUCf As RECT, bRz As Boolean
    'Call GetClientRect(UserControl.hWnd, rcUCf)
    'If rcUCf.Right <= (cxMinUC * m_ScaleX) Then
    '    rcUCf.Right = (cxMinUC * m_ScaleX): bRz = True
    'End If
    'If rcUCf.Bottom <= (cyMinUC * m_ScaleY) Then
    '    rcUCf.Bottom = (cyMinUC * m_ScaleY): bRz = True
    'End If
    'If bRz Then SetWindowPos UserControl.hWnd, 0&, 0&, 0&, rcUCf.Right, rcUCf.Bottom, SWP_NOREPOSITION Or SWP_NOZORDER
    'If bStartup Then Exit Sub
    On Error Resume Next
    Dim rc As RECT
    Dim rclvw As RECT, rcsb As RECT
    Dim lw As Long
    Dim lOffX As Long
    Dim lOffY As Long, lOffY2 As Long
    Dim cyLV As Long, cypv As Long
    Dim ptydt As Long
    Call GetClientRect(UserControl.hWnd, rc)
    DebugAppend Ambient.DisplayName & ".UserControl_Resize::UC->rc.Right=" & rc.Right & ",ScaleWidth=" & UserControl.ScaleWidth, 1111
    If rc.Right = 0 Then Exit Sub 'temp workaround for tB bug
    Call GetWindowRect(hLVS, rclvw)
    If (m_StatusBar = True) And ((m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly)) Then
        Call GetClientRect(m_hStatusBar, rcsb)
        lOffY = cyCombo + rcsb.Bottom + (6 * m_ScaleY)
        lOffY2 = rcsb.Bottom
        If Ambient.UserMode = False Then
            SetWindowPos m_hStatusBar, HWND_BOTTOM, 0, UserControl.ScaleHeight - lOffY2, UserControl.ScaleWidth, lOffY2, SWP_DRAWFRAME
        Else
            SetWindowPos m_hStatusBar, HWND_BOTTOM, 0, UserControl.ScaleHeight - lOffY2, UserControl.ScaleWidth, lOffY2, SWP_DRAWFRAME
        End If
        SetWindowPos m_hStatusBar, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_FRAMECHANGED
    Else
        lOffY = cyCombo + (6 * m_ScaleY)
    End If
    Dim gMinY As Long
    gMinY = lOffY
    If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Then
        gMinY = gMinY + cyMinListView
    End If
    If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then
        gMinY = cyCombo + (6 * m_ScaleY)
        UserControl.Height = gMinY * Screen.TwipsPerPixelY
        UserControl.Width = rc.Right * Screen.TwipsPerPixelX
    End If
    If m_DtPane Then
        If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Then
            gMinY = gMinY + (cyMinDetailPane + (10 * m_ScaleY))
        End If
    End If
    'DebugAppend "UCY=" & rc.Bottom & ",gMinY=" & gMinY & ",UCX=" & rc.Right, 1
    'If rc.Bottom < gMinY Then
    ''    SetWindowPos UserControl.hWnd, 0&, 0&, 0&, gMinY, rc.Right, SWP_NOMOVE Or SWP_NOZORDER
    ''    UserControl.Refresh
    '    UserControl.Height = gMinY * Screen.TwipsPerPixelY
    '    UserControl.Width = rc.Right * Screen.TwipsPerPixelX
    '    Call GetClientRect(UserControl.hWnd, rc)
    'End If
    
    If m_DtPane Then
        If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Then
            ptydt = UserControl.ScaleHeight - pbDetailPane.Height - lOffY2
            pbDetailPane.Left = mDTOffsetX
            pbDetailPane.Width = rc.Right - 2 - mDTOffsetX
            DebugAppend "Resize::pbDetailPane->rc.Right=" & rc.Right & ",mDTOffsetX=" & mDTOffsetX & ",Setcx=" & pbDetailPane.Width & ", StartDtPaneTop/Height=" & pbDetailPane.Top & "/" & pbDetailPane.ScaleHeight, 22
            pbDetailSizer.Width = pbDetailPane.Width - 10
            If bSMove Then
                pbDetailPane.Top = pbDetailSizer.Top
                pbDetailPane.Height = (UserControl.ScaleHeight - lOffY2) - pbDetailSizer.Top
                pbDetailSizer.Left = pbDetailPane.Left + 5
                DebugAppend "DetailSizerTop(Move=True)=" & pbDetailSizer.Top & ",rc.Bottom=" & rc.Bottom & ",Min=" & (cyMinDetailPane) & "+SBOff=" & (rcsb.Bottom) & ",Dif=" & (pbDetailSizer.Top - rc.Bottom)
                If (rc.Bottom - pbDetailSizer.Top) < (cyMinDetailPane + rcsb.Bottom) Then
                    pbDetailSizer.Top = rc.Bottom - (cyMinDetailPane + rcsb.Bottom)
                    pbDetailPane.Height = (UserControl.ScaleHeight - lOffY2) - pbDetailSizer.Top
                    pbDetailPane.Top = pbDetailSizer.Top
                End If
                If (pbDetailSizer.Top) < ((lOffY + cyMinListView) - lOffY2) Then
                    pbDetailSizer.Top = ((lOffY + cyMinListView) - lOffY2)
                    pbDetailPane.Height = (UserControl.ScaleHeight - lOffY2) - pbDetailSizer.Top
                    pbDetailPane.Top = pbDetailSizer.Top
                End If
                DebugAppend "FinalDtPaneTop/Height=" & pbDetailPane.Top & "/" & pbDetailPane.ScaleHeight
                RaiseEvent DetailPaneHeightChanged
            Else
                If ptydt < ((lOffY + cyMinListView) - lOffY2) Then
                    pbDetailPane.Top = (lOffY + cyMinListView) - lOffY2
                Else
                    pbDetailPane.Top = ptydt
                End If
                pbDetailSizer.Top = pbDetailPane.Top
                pbDetailPane.Height = (UserControl.ScaleHeight - lOffY2) - pbDetailPane.Top
                DebugAppend "DetailSizerTop(Move=False)=" & pbDetailSizer.Top & ",rc.Bottom=" & rc.Bottom & ",PaneTop=" & pbDetailPane.Top
        '        If (rc.Bottom - pbDetailSizer.Top) < (cyMinDetailPane + rcsb.Bottom) Then
        '            pbDetailSizer.Top = rc.Bottom - (cyMinDetailPane + rcsb.Bottom)
        '            pbDetailPane.Height = (UserControl.ScaleHeight - lOffY2) - pbDetailSizer.Top
        '            pbDetailPane.Top = pbDetailSizer.Top
        '        End If
            End If
            lOffY = lOffY + pbDetailPane.ScaleHeight + pbDetailSizer.Height
        End If
    End If
    If m_PvPane Then
        If bPMove Then
            fraPreview.Left = pbPreviewSizer.Left + 2
            fraPreview.Width = UserControl.ScaleWidth - (fraPreview.Left) - 6
            
            If fraPreview.Left < 10 Then fraPreview.Left = 10
            If fraPreview.Width < 30 Then
                fraPreview.Width = 30
            End If
            RaiseEvent PreviewPaneWidthChanged
        Else
            If fraPreview.Width < 30 Then
                fraPreview.Width = 30
            End If
            fraPreview.Left = UserControl.ScaleWidth - fraPreview.Width - (6 * m_ScaleX)
            pbPreviewSizer.Left = fraPreview.Left - 2
        End If
        cypv = UserControl.ScaleHeight - lOffY
        If cypv < (cyMinListView) Then
            cypv = cyMinListView 'lOffY +
        End If
        fraPreview.Height = cypv - 2 '
        pbPreviewSizer.Height = fraPreview.Height - 10
        pbPreviewSizer.Top = fraPreview.Top + 5
        pbPreviewPane.Height = (fraPreview.Height * Screen.TwipsPerPixelY) - (270)
        pbPreviewPane.Width = (fraPreview.Width * Screen.TwipsPerPixelX) - (150)
        lOffX = fraPreview.Width + pbPreviewSizer.Width + 12
        cyLV = rc.Bottom - lOffY
        If cyLV < cyMinListView Then
            cyLV = cyMinListView
        End If
        SetWindowPos hLVS, 0, mLVOffX, cyCombo + (5 * m_ScaleY), rc.Right - lOffX - mLVOffX, cyLV, 0
    Else
        lOffX = 4
        cyLV = rc.Bottom - lOffY
        DebugAppend Ambient.DisplayName & ".Resize::LV->rc.Right=" & rc.Right & ",rc.Bottom=" & rc.Bottom & ",ScaleWidth=" & UserControl.ScaleWidth, 1111
        If cyLV < cyMinListView Then
            cyLV = cyMinListView
        End If
        SetWindowPos hLVS, 0, mLVOffX, cyCombo + (5 * m_ScaleY), rc.Right - lOffX - mLVOffX, cyLV, 0
    End If
    cxLV = rc.Right - lOffX
    If bForceCtlOff Then
        If UserControl.ScaleWidth > (cxMinForCtlBoxHide * m_ScaleX) Then
            bForceCtlOff = False
            If m_Mode <> SBCTL_FilesOnly Then
                Me.ListControlBox = True
            End If
        End If
    End If
    Dim cbcy As Long
    If m_ControlBox Then
        If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Then
            'The m_ControlBox flag isn't set to false in these modes, but the control box
            'and/or navbuttons aren't visible nonetheless
            lw = rc.Right - ((2 * m_ScaleX))
        Else
            lw = rc.Right - pbControlBox.ScaleWidth - ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
        End If
        If (mAutoHideCtlBox = True) And (lw < (cxMinForCtlBoxHide * m_ScaleX)) Then
            If (m_Mode <> SBCTL_FilesOnly) And (m_Mode <> SBCTL_DirOnly) And (m_Mode <> SBCTL_DrivesOnly) Then
                Me.ListControlBox = False
            End If
            bForceCtlOff = True
            GoTo nocbox
        End If
        If (m_MaxComboCX > 0) And (lw > (m_MaxComboCX * m_ScaleX)) Then lw = (m_MaxComboCX * m_ScaleX)
        If m_CbType = SBCT_Simple Then
            cbcy = rc.Bottom - 4
        Else
            cbcy = m_MinDropCY * m_ScaleY
            If (mFixedDropHeight > 0&) Then
                If mFixedDropHeight > m_MinDropCY Then
                    cbcy = mFixedDropHeight * m_ScaleY
                End If
            Else
                If (rc.Bottom - 12) > cbcy Then cbcy = (rc.Bottom - 12)
            End If
        End If
        If lw > (cyMinCombo * m_ScaleX) Then
            SetWindowPos hCombo, 0, 0, 0, lw - (1 + (1 * m_ScaleX)), cbcy, SWP_NOMOVE
            pbControlBox.Left = lw + ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
            DebugAppend "Resize::pbControlBox.Left=" & pbControlBox.Left & ", lw=" & lw & ",lOffBkBtn=" & lOffBkBtn & "," & ",lOffFwBtn=" & lOffFwBtn & ",m_ScaleX=" & m_ScaleX
        End If
    Else
    nocbox:
        If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Then
            lw = rc.Right - ((2 * m_ScaleX))
        Else
            lw = rc.Right - ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
        End If
        If (m_MaxComboCX > 0) And (lw > (m_MaxComboCX * m_ScaleX)) Then lw = (m_MaxComboCX * m_ScaleX)
        If m_CbType = SBCT_Simple Then
            cbcy = rc.Bottom - 4
        Else
            cbcy = m_MinDropCY * m_ScaleY
            If (mFixedDropHeight > 0&) Then
                If mFixedDropHeight > m_MinDropCY Then
                    cbcy = mFixedDropHeight * m_ScaleY
                End If
            Else
                If (rc.Bottom - 12) > cbcy Then cbcy = (rc.Bottom - 12)
            End If
        End If
        SetWindowPos hCombo, 0, 0, 0, lw - (1 + (1 * m_ScaleX)), cbcy, SWP_NOMOVE
    End If
    
    If pbColumns.Visible = True Then
        SetWindowPos pbColumns.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    End If
    
    'Enqueue a refresh of panes
    If Ambient.UserMode Then
    If (bSMove = False) And (bPMove = False) Then
        If (m_DtPane = True) Or (m_PvPane = True) Then
            If bStartup = False Then
                If bResizeQueued = False Then
                    bResizeQueued = True
                    rzHoldTime1 = GetTickCount()
                    tmrResize.Enabled = True 'Timer will trigger pane refresh after 500ms
                Else
                    rzHoldTime1 = GetTickCount() 'Another resize call resets the hold time
                End If
            End If
        End If
    End If
    End If
End Sub

Private Sub UserControl_Terminate() Handles UserControl.Terminate
    
    On Error Resume Next
    DebugAppend "terminate event"
    
    If mValidSession And mStartLast Then
        SaveSetting mRegDataName, "UserData", "LastPath", m_sCurPath
    End If
    
    StopNotify
    StopNotifyOnComp
    
    RemoveVTableHandling Me, VTableInterfaceInPlaceActiveObject
    
    Dim i As Long
    If nLinks > 0 Then
        For i = 0 To UBound(hLinks)
            DestroyWindow hLinks(i)
        Next i
    End If
        
    Set m_siDesktop = Nothing
    Set psfCur = Nothing
    Set siCurPath = Nothing
    Set mDataObj = Nothing
    Set siFocus = Nothing
    Set siFocusNS = Nothing
    Set siaSelected = Nothing
    Set siDirect = Nothing
    Set ICtxMenu2 = Nothing
    Set ICtxMenu3 = Nothing
    Set pcm = Nothing
    If (pLVF Is Nothing) = False Then
        pLVF.RemoveAllButtons
        Set pLVF = Nothing
    End If
    
    If pidlFQCur Then CoTaskMemFree pidlFQCur
    If pidlt Then CoTaskMemFree pidlt
    
    For i = 0 To UBound(uPidlStore)
        If uPidlStore(i).pidlFQ Then
            CoTaskMemFree uPidlStore(i).pidlFQ
        End If
    Next i
    
    If gdipInitToken Then FreeGDIPlus gdipInitToken
    
    Call Detach
    Set pDTH = Nothing
    
    If hGlobalPV Then GlobalFree hGlobalPV
    
    If (stcPst Is Nothing) = False Then
        Set stcPst = Nothing
    End If
    
    If hUpButton Then DestroyWindow hUpButton
    If hViewButton Then DestroyWindow hViewButton
    If hBkmButton Then DestroyWindow hBkmButton
    
    DestroyIcon hIconView
    DestroyIcon hIconUp
    DestroyIcon hIconBack
    DestroyIcon hIconFwd
    DestroyIcon hIconBkm
    DestroyIcon hIcoSearchBox16
    DestroyIcon hIcoSearchBox20
    DestroyIcon hIcoSearchBox24
    If hIcoLnkOvr Then DestroyIcon hIcoLnkOvr
    If hIcoLnkOvrSm Then DestroyIcon hIcoLnkOvrSm
    For i = 0 To UBound(arZones)
        DestroyIcon arZones(i).hIcon
        DestroyIcon arZones(i).hIconSm
    Next i
    
    DestroyWindow hSearchBox
    If hDTSearch1 Then DestroyWindow hDTSearch1
    If hDTSearch2 Then DestroyWindow hDTSearch2
    If hSearchBoxAlt Then DestroyWindow hSearchBoxAlt
    
    ResetDetailPane 'destroy/unthunk any hEdits
    If hDetailName Then
        DestroyWindow hDetailName
    End If
        
    Set ipv = Nothing
    
    ' Call ssc_Terminate
    ' Call scb_TerminateCallbacks
    
    DeleteObject m_hFontDtHdr
    DeleteObject m_hFontDtHdrAlt
    DeleteObject m_hFontDtTxt
    DeleteObject m_hFontDtAlt
    DeleteObject m_hFontMsg
    If m_hFontMain <> 0& Then
        DeleteObject m_hFontMain
        m_hFontMain = 0&
    End If
    If hFontLVMain Then
        DeleteObject hFontLVMain
        hFontLVMain = 0&
    End If
    If hFontLVHdrMain Then
        DeleteObject hFontLVHdrMain
        hFontLVHdrMain = 0&
    End If
    
    If m_NoWow64 Then
        DebugAppend "Revert WOW64 Redirects"
        RevertWow64Redir
    End If
    
    If hThemeProg Then CloseThemeData hThemeProg
    If hThemeNav Then CloseThemeData hThemeNav
    
    DestroyImageLists
    
    If hLVC Then DestroyWindow hLVC
    If hUpDown Then DestroyWindow hUpDown
    If hColCX Then DestroyWindow hColCX
    If hCombo Then DestroyWindow hCombo
    If hLVS Then DestroyWindow hLVS
    If m_hStatusBar Then DestroyWindow m_hStatusBar
    If hDetailName Then DestroyWindow hDetailName
    
    Set mIFMain = Nothing
    Set PropFont = Nothing
    Set CtlFont = Nothing
    Set mIFCtl = Nothing
    Set mIFTmp2 = Nothing
    Set mIFTmp = Nothing
    Set TempFont = Nothing
    Set Temp2Font = Nothing
    Set mIFLV = Nothing
    Set PropFontLV = Nothing
    Set PropFontDt = Nothing
    
    If hFontLVHdrMain Then DeleteObject hFontLVHdrMain
    
    If dbg_PrintToFile Then
        If ((dbg_LogExeOnly = True) And (IsIDE = False)) Or (dbg_LogExeOnly = False) Then
            DebugAppend "ControlTerminate::Shutting down log"
        End If
        StopLog
    End If
End Sub


Private Sub UserControl_InitProperties() Handles UserControl.InitProperties
mStartLast = mDefStartLast
m_StartEmpty = m_def_StartEmpty
mCustomRoot = m_defCustomRoot
mCustomRootEnforce = m_defCustomRootEnforce
mHighPerfMode = mDefHighPerfMode
m_CtlBorder = m_def_CtlBorder
m_Border = m_def_Border
m_sCurPath = m_def_sCurPath
Set PropFont = Ambient.Font
Set PropFontDt = Ambient.Font
Set PropFontLV = Ambient.Font
m_FontScaleCXY = m_def_FontScaleCXY
mUserModeToggle = m_def_UserModeToggle
mLVOffX = mDefLVOffX
mDTOffsetX = mDefDTOffsetX
Set PropPicture = Nothing
PropPictureAlignment = SBPicAlignTopLeft
PropPictureWatermark = False
clrBack = vbWindowBackground
clrFore = vbWindowText
clrForeSubitem = vbWindowText
clrCtBack = vbButtonFace
clrDtBack = &HFBF5F1
clrDtFore = &H79675A
clrDtName = &HC
clrColSel = &HF7F7F7
clrSbFore = vbWindowText
clrSbBack = vbWindowBackground
mMasterEnabled = mMasterEnabled_def
mExplorerStyle = mExplorerStyle_def
mExplSel = mDefExplSel
mFoldersOnly = m_def_FoldersOnly
mFilesOnly = m_def_FilesOnly
mDispParAndIndt = mDefDispParAndIndt
m_HiddenPref = m_def_HiddenPref
m_SuperHiddenPref = m_def_SuperHiddenPref
m_NoWow64 = m_def_NoWow64
m_Mode = m_def_Mode
m_CbType = m_def_CbType
m_CBXNoIcons = m_def_CBXNoIcons
m_CompAsRoot = m_def_CompAsRoot
m_MultiSelect = m_def_MultiSelect
m_ViewMode = m_def_ViewMode
m_GroupMode = m_def_GroupMode
m_InsColp = m_def_InsColp
m_Filter = m_def_Filter
m_FolderFilter = m_def_FolderFilter
m_ControlBox = m_def_ControlBox
mAutoHideCtlBox = mDefAutoHideCtlBox
m_MaxComboCX = m_def_MaxComboCX
m_DefCol = m_def_DefCol
m_HideIcons = m_def_HideIcons
m_HideComboIcons = m_def_HideComboIcons
m_ForceExt = m_def_ForceExt
m_FullRowSel = m_def_FullRowSel
m_SnapToGrid = m_def_SnapToGrid
m_NameColors = m_def_NameColors
m_StatusBar = m_def_StatusBar
m_StatusSP = m_def_StatusSP
mDefStatusText = m_def_DefStatusText
m_ThumbCXY = m_def_ThumbCXY
m_ThumbScaleCXY = m_def_ThumbScaleCXY
m_ThumbExt = m_def_ThumbExt
m_ThumbPreload = m_def_ThumbPreload
mExtColPreload = mDefExtColPreload
m_ViewButton = m_def_ViewButton
m_UpButton = m_def_UpButton
m_NavBtnType = m_def_NavBtnType
m_BookmarkButton = m_def_BookmarkButton
m_PvPane = m_def_PvPane
m_DtPane = m_def_DtPane
mDtPaneNoRS = mDefDtPaneNoRS
mPvPaneNoRS = mDefPvPaneNoRS
m_AutoSzCol = m_def_AutoSzCol
m_ColLock = m_def_ColLock
m_BrowseZip = m_def_BrowseZip
m_LockNav = m_def_LockNav
m_Monitor = m_def_Monitor
m_DDMode = m_def_DDMode
m_ActiveDrop = m_def_ActiveDrop
m_Checkboxes = m_def_Checkboxes
m_EnablePreview = m_def_EnablePreview
m_EnableDetails = m_def_EnableDetails
m_EnableViewMenu = m_def_EnableViewMenu
m_EnableShellMenu = m_def_EnableShellMenu
m_EnableSearchBox = m_def_EnableSearchBox
m_EnableStatusBar = m_def_EnableStatusBar
mEnableBookmark = mDefEnableBookmark
mEnableNewFolder = mDefEnableNewFolder
mEnableLayout = mDefEnableLayout
m_LockView = m_def_LockView
m_MinDropCX = m_def_MinDropCX
m_MinDropCY = m_def_MinDropCY
mFixedDropHeight = mDefFixedDropHeight
m_HideColumnHeader = m_def_HideColumnHeader
m_HideLabels = m_def_HideLabels
m_GridLines = m_def_GridLines
m_AllowSorting = m_def_AllowSorting
m_AllowRename = m_def_AllowRename
m_NoHdrSize = m_def_NoHdrSize
m_HdrDD = m_def_HdrDD
m_HdrOverflow = m_def_HdrOverflow
m_HdrMinCX = m_def_HdrMinCX
m_TrackSel = m_def_TrackSel
m_OneClickAct = m_def_OneClickAct
m_TwoClickAct = m_def_TwoClickAct
m_ULHot = m_def_ULHot
m_ULCold = m_def_ULCold
m_CheckSel = m_def_CheckSel
m_FollowLinks = m_def_FollowLinks
m_EditCB = m_def_EditCB
m_FilterBar = m_def_FilterBar
m_FilterCase = m_def_FilterCase
m_HeaderInAll = m_def_HeaderInAll
m_PreviewVidThumb = m_def_PreviewVidThumb
mShowSearch = mDefShowSearch
mSearchPopupInMenu = mDefSearchPopupInMenu
mSearchAutoGroup = mDefSearchAutoGroup
mCXSearch = m_def_CXSearch
m_NoDblClkNav = m_def_NoDblClkNav
m_DisableWhileLoading = m_def_DisableWhileLoading
mEditMarq = m_def_EditMarq
mMaxHist = m_def_MaxHist
mExtOverlay = m_def_ExtOverlay
m_DisableOvr = m_def_DisableOvr
mAlwaysSortWithISF = m_def_AlwaysSortWithISF
m_IconPreload = m_def_IconPreload
m_ShellTree = m_def_ShellTree
mAutoComp = m_def_AutoComp
mInfoTipMode = mDefInfoTipMode
mInfoTipLimitHPF = mDefInfoTipLimitHPF
mAlignTop = mDefAlignTop
mNoLblWrap = mDefNoLblWrap
mShowSelAlw = mDefShowSelAlw
mAutoArr = mDefAutoArr
mFtrPostSearch = m_def_FtrPostSearch
lRaiseHover = m_def_lRaiseHover
mStrRVM = mDefStrRVM
mAlwaysShowExtVerbs = mDefAlwaysShowExtVerbs
mSFinBKM = mDefSFinBKM
mAutoSelCol = mDefAutoSelCol
mPlaySnd = mDefPlaySnd
mIncludeFldrLnkInFldrOnly = mDefIncludeFldrLnkInFldrOnly
mIncludeFldrLnkInFldrOnlyHPF = mDefIncludeFldrLnkInFldrOnlyHPF
nExpandSelectedFolderInDropdown = nDefExpandSelectedFolderInDropdown
mBkFwInCtx = mDefBkFwInCtx
mTileWidth = mDefTileWidth
mLMMaxCX = mDefLMMaxCX
mShowDataStreams = mDefShowDataStreams
mCustomInMenu = mDefCustomInMenu
mCustomMenuCap = mDefCustomMenuCap
mcxyCustom = mDefcxyCustom
mEnableGrp = mDefEnableGrp
mEnablePaste = mDefEnablePaste
mDispSecZn = mDefDispSecZn
pvCreate
End Sub

Private Function ExplorerSettingEnabled(lSetting As SFS_MASK) As Boolean
Dim lintg As Integer
Call SHGetSettings(lintg, lSetting)
Select Case lSetting
    Case SSF_SHOWALLOBJECTS
        ExplorerSettingEnabled = lintg And 2 ^ 0 'fShowAllObjects
    Case SSF_SHOWEXTENSIONS
        ExplorerSettingEnabled = lintg And 2 ^ 1 'fShowExtensions
    Case SSF_NOCONFIRMRECYCLE
        ExplorerSettingEnabled = lintg And 2 ^ 2 'fNoConfirmRecycly
    Case SSF_SHOWSYSFILES
        ExplorerSettingEnabled = lintg And 2 ^ 3 'fShowSysFiles
    Case SSF_SHOWCOMPCOLOR
        ExplorerSettingEnabled = lintg And 2 ^ 4 'fShowCompColor
    Case SSF_DOUBLECLICKINWEBVIEW
        ExplorerSettingEnabled = lintg And 2 ^ 5 'fDoubleClickInWebView
    Case SSF_DESKTOPHTML
        ExplorerSettingEnabled = lintg And 2 ^ 6 'fDesktopHTML
    Case SSF_WIN95CLASSIC
        ExplorerSettingEnabled = lintg And 2 ^ 7 'fWin95Classic
    Case SSF_DONTPRETTYPATH
        ExplorerSettingEnabled = lintg And 2 ^ 8 'fDontPrettyPath
    Case SSF_SHOWATTRIBCOL
        ExplorerSettingEnabled = lintg And 2 ^ 9 'fShowAttribCol
    Case SSF_MAPNETDRVBUTTON
        ExplorerSettingEnabled = lintg And 2 ^ 10 'fMapNetDrvButton
    Case SSF_SHOWINFOTIP
        ExplorerSettingEnabled = lintg And 2 ^ 11 'fShowInfoTip
    Case SSF_HIDEICONS
        ExplorerSettingEnabled = lintg And 2 ^ 12 'fHideIcons
    Case SSF_SHOWSUPERHIDDEN
        Dim SS As SHELLSTATE
        SHGetSetSettings SS, SSF_SHOWSUPERHIDDEN
        ExplorerSettingEnabled = ((SS.fFlags1 And fShowSuperHidden) = fShowSuperHidden)
        
End Select
End Function

    Private Sub pvCreate() 'Formerly in UserControl_Show()
    DebugAppend "-->PvCreate", 2000
    If hLVS Then Exit Sub
    SetRegKeyName
    On Error GoTo e0
    m_Bookmarks = GetSetting(mRegDataName, "UserData", "Bookmarks", "")
    mLastSessionPath = GetSetting(mRegDataName, "UserData", "LastPath", "")
    IsComCtl6
    
    If Ambient.UserMode Then
        Call SetVTableHandling(Me, VTableInterfaceInPlaceActiveObject)
        If m_ThumbScaleCXY Then m_ThumbCXY = m_ThumbCXY * m_ScaleX
        If IsWOW64 Then
            If m_NoWow64 Then
                DebugAppend "Disabling WOW64 Redirects"
                DisableWow64Redir
            End If
        End If
    End If
    
    If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then
        m_DtPane = False
        m_PvPane = False
    End If
    pbDetailPane.Visible = m_DtPane
    pbDetailSizer.Visible = m_DtPane
    If m_DtPane Then
        pbDetailSizer.Top = pbDetailPane.Top
    End If
    
    lSortD = 1
    stcIdx = -1
    
    InitPKeys
    EnumPropKind
    
        pbSearchContainer.Width = mCXSearch * m_ScaleX
    
    If Ambient.UserMode Then
    ' If ssc_Subclass(UserControl.hWnd, , , , , True) Then
    '  Call ssc_AddMsg(UserControl.hWnd, MSG_BEFORE, ALL_MESSAGES)
     
    ' End If
        Subclass2 UserControl.hWnd, AddressOf ucWndProc, UserControl.hWnd
    End If
    cmdColOK.Caption = scc_Ok
    cmdColCancel.Caption = scc_Cancel
    cmdPropCancel.Caption = scc_Cancel
    cmdPropSave.Caption = scc_Save
    fraPreview.Caption = scc_Prv
    lblColCap.Caption = scc_ChCols
    lblColCX.Caption = scc_Width
    chkColFilter.Caption = scc_ColFil
    cmdStartSearch.Caption = scc_SearchBtn
    cmdSrCn.Caption = scc_Cancel
    cmdSrClr.Caption = scc_clr
    cmdSrCl.Caption = scc_cls
    cmdSrCl.Width = 23
    cmdSrCl.Left = pbSearch.Width - 30
    fraSrDate.Caption = scc_FrDate
    chkShFldr.Caption = scc_ShIncFldr
    lblKB1.Caption = scc_kb
    lblSrch.Caption = scc_ShOpt
    lblShType.Caption = scc_ShTyp
    lblShSz.Caption = scc_sz
    cbSrSize1.AddItem mStrLessThan
    cbSrSize1.AddItem mStrEqualTo
    cbSrSize1.AddItem mStrGreaterThan
    cbDateType.AddItem uColData(LookupColFromPK2(PKEY_DateModified)).szDisplayName
    cbDateType.AddItem uColData(LookupColFromPK2(PKEY_DateCreated)).szDisplayName
    cbDateType.AddItem uColData(LookupColFromPK2(PKEY_DateAccessed)).szDisplayName
    cbDateCmp1.AddItem mStrBfr
    cbDateCmp1.AddItem mStrAft
    cbDateType.ListIndex = 0
    cbDateCmp1.ListIndex = 0
    cbSrSize1.ListIndex = 0
    
    Dim k As Long
    cbShType.AddItem mStrAny
    For k = 0 To UBound(sKindTxt)
        cbShType.AddItem sKindTxt(k)
    Next k
    cbShType.ListIndex = 0
    
    SetNumbersOnly txtSrSize1.hWnd
    
    bSuppress = True
    UserControl.BackColor = clrCtBack
    pbControlBox.BackColor = clrCtBack
    pbControlBox.Refresh
    cmdPropSave.BackColor = clrDtBack
    cmdPropCancel.BackColor = clrDtBack
    pbBackBtn.BackColor = clrCtBack
    pbBackBtn.Refresh
    pbFwdBtn.BackColor = clrCtBack
    pbFwdBtn.Refresh
    pbBackBtnAlt.Top = 0
    pbBackBtnAlt.BackColor = clrCtBack
    pbBackBtnAlt.Refresh
    pbFwdBtnAlt.Top = 0
    pbFwdBtnAlt.BackColor = clrCtBack
    pbFwdBtnAlt.Refresh
    pbSearchContainer.BackColor = clrCtBack
    pbSearchContainer.Refresh
    pbDetailPane.BackColor = clrDtBack
    pbDetailPane.ForeColor = clrDtFore
    pbDetailPane.Refresh
    fraPreview.BackColor = clrCtBack
    pbPreviewPane.BackColor = clrCtBack
    fraPreview.Refresh
    pbPreviewPane.Refresh
    lblColCap.Caption = m_sColCap
    If m_NavBtnType = SBNB_ThemeBtnInBox Then
        pbBackBtnAlt.Width = cxThemeButtonB
        pbBackBtnAlt.Height = cyThemeButtonB
        pbFwdBtnAlt.Width = cxThemeButtonF
        pbFwdBtnAlt.Height = cyThemeButtonF
    End If
    If m_NavBtnType = SBNB_ThemeButton Then
        pbBackBtn.Width = cxThemeButtonB
        pbBackBtn.Height = cyThemeButtonB
        pbFwdBtn.Width = cxThemeButtonF
        pbFwdBtn.Height = cyThemeButtonF
        pbBackBtn.Left = 0
        pbBackBtn.Top = 0
        pbFwdBtn.Left = (cxThemeButtonF) + 1 ' * m_ScaleX
        pbFwdBtn.Top = 0
        lOffBkBtn = cxThemeButtonB
        m_hFwdBtn = pbFwdBtn.hWnd
        m_hdcFwdBtn = pbFwdBtn.hDC
        m_hBackBtn = pbBackBtn.hWnd
        m_hdcBackBtn = pbBackBtn.hDC
        pvDrawBack NAV_BB_DISABLED
        lOffFwBtn = cxThemeButtonF
        pvDrawFwd NAV_FB_DISABLED
            If ((m_Mode <> SBCTL_DirAndFiles) And (m_Mode <> SBCTL_DirOnlyWithCtls)) Then lOffBkBtn = 0&: lOffFwBtn = 0&
    
        If Ambient.UserMode Then
            ' If ssc_Subclass(pbBackBtn.hWnd, , 9, , , True) Then
            '  Call ssc_AddMsg(pbBackBtn.hWnd, MSG_BEFORE, ALL_MESSAGES)
            ' End If
            Subclass2 pbBackBtn.hWnd, AddressOf BKWndProc, pbBackBtn.hWnd
        End If
        If Ambient.UserMode Then
            ' If ssc_Subclass(pbFwdBtn.hWnd, , 10, , , True) Then
            '  Call ssc_AddMsg(pbFwdBtn.hWnd, MSG_BEFORE, ALL_MESSAGES)
            ' End If
            Subclass2 pbFwdBtn.hWnd, AddressOf FWWndProc, pbFwdBtn.hWnd
        End If
    Else
        lOffBkBtn = 0&
        lOffFwBtn = 0&
        pbBackBtn.Visible = False
        pbFwdBtn.Visible = False
    End If
    
    pvCreateCombo
    pvCreateStatusBar
    
    pvCreateControlButtons
    InitControlBox
    SetButtonIcons
    
    If Ambient.UserMode Then
        ' If ssc_Subclass(pbControlBox.hWnd, , 24) Then
        '  Call ssc_AddMsg(pbControlBox.hWnd, MSG_BEFORE, ALL_MESSAGES)
        ' End If
        Subclass2 pbControlBox.hWnd, AddressOf CtlBoxWndProc, pbControlBox.hWnd
    End If
    
    
    If (m_ControlBox = True) And ((m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_DirOnlyWithCtls)) Then
        fraPreview.Top = cyCombo + (5 * m_ScaleY)
        pbControlBox.Visible = True
    Else
        pbControlBox.Visible = False
        fraPreview.Top = 4 * m_ScaleY
    End If
     
    If m_NavBtnType = SBNB_ThemeBtnInBox Then
        m_hFwdBtn = pbFwdBtnAlt.hWnd
        m_hdcFwdBtn = pbFwdBtnAlt.hDC
        m_hBackBtn = pbBackBtnAlt.hWnd
        m_hdcBackBtn = pbBackBtnAlt.hDC
        pvDrawBack NAV_BB_DISABLED
        pvDrawFwd NAV_FB_DISABLED
        If Ambient.UserMode Then
            ' If ssc_Subclass(pbBackBtnAlt.hWnd, , 9, , , True) Then
            '  Call ssc_AddMsg(pbBackBtnAlt.hWnd, MSG_BEFORE, ALL_MESSAGES)
            ' End If
            Subclass2 pbBackBtnAlt.hWnd, AddressOf BKWndProc, pbBackBtnAlt.hWnd
        End If
        If Ambient.UserMode Then
            ' If ssc_Subclass(pbFwdBtnAlt.hWnd, , 10, , , True) Then
            '  Call ssc_AddMsg(pbFwdBtnAlt.hWnd, MSG_BEFORE, ALL_MESSAGES)
            ' End If
            Subclass2 pbFwdBtnAlt.hWnd, AddressOf FWWndProc, pbFwdBtnAlt.hWnd
        End If
    End If
    
    If mShowSearch Then pvCreateSearchBox
    
    Dim lpr As LongPtr
    Dim siLL As IShellItem
    SHGetKnownFolderItem FOLDERID_Libraries, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siLL
    If (siLL Is Nothing) = False Then
        siLL.GetDisplayName SIGDN_NORMALDISPLAY, lpr
        mLibRootDisp = LPWSTRtoStr(lpr)
    End If
    Set siLL = Nothing: lpr = 0&
    SHGetKnownFolderItem FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siLL
    If (siLL Is Nothing) = False Then
        siLL.GetDisplayName SIGDN_NORMALDISPLAY, lpr
        mCompRtDisp = LPWSTRtoStr(lpr)
    End If
    Set siLL = Nothing: lpr = 0&
    SHGetKnownFolderItem FOLDERID_Downloads, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siLL
    If (siLL Is Nothing) = False Then
        siLL.GetDisplayName SIGDN_NORMALDISPLAY, lpr
        mDlDisp = LPWSTRtoStr(lpr)
    End If
    Set siLL = Nothing: lpr = 0&
    SHCreateItemFromParsingName StrPtr("shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"), Nothing, IID_IShellItem, siLL
    If (siLL Is Nothing) = False Then
        siLL.GetDisplayName SIGDN_NORMALDISPLAY, lpr
        mRplDisp = LPWSTRtoStr(lpr)
    End If
    Set siLL = Nothing
    
    
    
     bSuppress = False
     If Ambient.UserMode Then
    If m_sCurPath = "" Then
        If mCustomRoot <> "" Then
            m_sCurPath = mCustomRoot
        Else
            m_sCurPath = App.Path
        End If
    Else
        If InStr(m_sCurPath, "%") Then
            m_sCurPath = ExpandEnvVars(m_sCurPath)
            DebugAppend "Expanded Environ shortcuts->" & m_sCurPath
        End If
    End If
    End If
    
    If m_PvPane Then
        pbPreviewSizer.Visible = True
        SetPVInitPos
    Else
        pbPreviewSizer.Visible = False
    End If
    
    SetNavInitPos
    
    InitRVM
    
    m_cxMinLV = cxMinListView * m_ScaleX
    If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Then
        InitLV
    End If
    
    If Ambient.UserMode Then
    'DebugAppend "Exec runtime-only"
        mValidSession = True
        Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, m_siDesktop)
        Dim lpdsk As LongPtr
        m_siDesktop.GetDisplayName SIGDN_FILESYSPATH, lpdsk
        m_sDesktopPath = LPWSTRtoStr(lpdsk)
        SHLoadNonloadedIconOverlayIdentifiers
        bSuppress = True
    '    If m_ViewMode > 4 Then
    '        SwitchView m_ViewMode
    '    End If
        m_ViewModeEx = -1
        SwitchView m_ViewMode, True
    
        If m_StartEmpty = False Then
    
            Dim li As Long
            Dim idx As Long
            Dim siItem As IShellItem
                
            Dim sLoad As String
            
            If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
                sLoad = m_sCurPath 'mCustomRoot
                sHistory(0) = sLoad
            Else
                If (mStartLast = True) And (mLastSessionPath <> "") And PathFileExistsW(StrPtr(mLastSessionPath)) Then
                    sLoad = mLastSessionPath
                    sHistory(0) = sLoad
                Else
                    sLoad = m_sCurPath
                    sHistory(0) = sLoad
                End If
            End If
            
            Call SHCreateItemFromParsingName(StrPtr(sLoad), Nothing, IID_IShellItem, siItem)
            If (siItem Is Nothing) And (Left$(sLoad, 3) = "::{") Then
                'virtual item fallback
                Dim sh As String
                sh = "shell:" & sLoad
                Call SHCreateItemFromParsingName(StrPtr(sh), Nothing, IID_IShellItem, siItem)
            End If
            
            
            If siItem Is Nothing Then
                sLoad = App.Path
                Call SHCreateItemFromParsingName(StrPtr(sLoad), Nothing, IID_IShellItem, siItem)
            End If
            
            Dim bFlag1 As Boolean
            If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
                If IsRootChild(, siItem) = False Then
                    Set siItem = Nothing
                    sLoad = mCustomRoot
                    bFlag1 = True
                    Call SHCreateItemFromParsingName(StrPtr(sLoad), Nothing, IID_IShellItem, siItem)
                End If
            End If
            
            If m_Mode <> SBCTL_DrivesOnly Then
                If bFlag1 = False Then
                    idx = AddStandardFSItem(siItem, li, True)
                End If
                Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
                DebugAppend "UserControl_Show::LVLoadFolder"
                LVLoadFolder sLoad
                If m_GroupMode <> SBGB_None Then
                    Dim lGM As Long
                    lGM = m_GroupMode
                    m_GroupMode = SBGB_None
                    If lGM <= SBGB_DateModified Then
                        'The other modes are columns that would need to be added first (the supported
                        'ones might, but usually don't) or are special situations the are handled
                        'in other ways.
                        If lGM = SBGB_Name Then lGrpCol = lDefColIdx(0)
                        If lGM = SBGB_Size Then lGrpCol = lDefColIdx(1)
                        If lGM = SBGB_Type Then lGrpCol = lDefColIdx(2)
                        If lGM = SBGB_DateModified Then lGrpCol = lDefColIdx(3)
                        SetGroupMode lGM
                    End If
                End If
            Else
                Call SendMessage(hCombo, CB_SETCURSEL, 1&, ByVal 0&)
                DirSelForDrivesOnly 1&
            End If
        Else
            sHistory(0) = ""
            nHistIdx = -1
            ReDim LVEntries(0)
            LVEntries(0).bDeleted = True
            m_sCurPath = ""
            bBlankLoaded = True
        End If
        bSuppress = False
        SetFocusAPI hLVS
        bStartup = False
        If m_DtPane Then
            pbDetailSizer.Visible = True
            pbDetailSizer.Top = pbDetailPane.Top
            pbDetailSizer.Width = pbDetailPane.Width - 10
            pbDetailSizer.Left = pbDetailPane.Left + 5
    '        UserControl_Resize
        Else
            pbDetailSizer.Visible = False
        End If
        
    
    End If
    
    ApplyCtlBorder
    
    
    Dim lpw As Long
    lpw = PackWords(1, 0)
    If m_ControlBox = False Then
        pbControlBox.Visible = False
    End If
    
    Set Me.Font = PropFont
    
    
    'SendMessageW pbDetailPane.hWnd, WM_SETFONT, m_hFontDtAlt, ByVal 1&
    
    
    If mMasterEnabled = False Then
        EnableWindow hLVS, IIf(mMasterEnabled = True, 1, 0)
        EnableWindow hCombo, IIf(mMasterEnabled = True, 1, 0)
        UserControl.Enabled = False
    End If
    
    StartNotifyOnComp
    
    If (m_ViewMode = SB_VIEW_THUMBNAIL) Then
        SwitchView LV_VIEW_THUMBNAIL, True
    End If
    If (m_ViewMode = SB_VIEW_CUSTOM) Then
        SwitchView LV_VIEW_CUSTOM, True
    End If
    
    If mDefStatusText <> "" Then UpdateStatus mDefStatusText
    
    'If hLVS Then SetWindowPos hLVS, 0, mLVOffX, cyCombo + (5 * m_ScaleY), 0, 0, SWP_NOSIZE Or SWP_NOZORDER
    UserControl_Resize
    
    
    bStartup = False
    DebugAppend "dpix=" & m_ScaleX 'GetDeviceCaps(hDC, LOGPIXELSX) / 96
    DebugAppend "color=&H" & Hex$(m_SysClrText)
    DebugAppend "lvrEnable=" & lvrEnable
    DebugAppend "Ambient.UserMode=" & Ambient.UserMode
    DebugAppend "Exit UC_SHow, LastSessionPath=" & mLastSessionPath
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.pvCreate->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
        Resume Next
    End Sub
    
    Private Sub SetPVInitPos()
    Dim rc As RECT
    Call GetClientRect(UserControl.hWnd, rc)
    fraPreview.Visible = True
    pbPreviewSizer.Visible = True
    fraPreview.Left = UserControl.ScaleWidth - fraPreview.Width - 2
    Dim lOffY As Long, lOffY2 As Long
    If m_StatusBar Then
        lOffY = cyCombo + cyStatusBar + 6 '48
        lOffY2 = cyStatusBar
    Else
        lOffY = cyCombo + 6 '35
    End If
    If m_DtPane Then
        pbDetailPane.Top = UserControl.ScaleHeight - pbDetailPane.Height - lOffY2
        pbDetailPane.Left = mDTOffsetX
        pbDetailPane.Width = rc.Right - 2 - mDTOffsetX
        DebugAppend "SetPVInitPos::pbDetailPane->rc.Right=" & rc.Right & ",mDTOffsetX=" & mDTOffsetX & ",Setcx=" & pbDetailPane.Width, 22
        lOffY = lOffY + pbDetailPane.Height
    End If
        fraPreview.Height = UserControl.ScaleHeight - lOffY - 4
        fraPreview.Refresh
        pbPreviewPane.Height = (fraPreview.Height * Screen.TwipsPerPixelY) - (250) ' * m_ScaleY)
        pbPreviewPane.Width = (fraPreview.Width * Screen.TwipsPerPixelX) - (150) ' * m_ScaleX)
    
    pbPreviewSizer.Left = fraPreview.Left
    pbPreviewSizer.Top = fraPreview.Top + 5
    pbPreviewSizer.Height = fraPreview.Height - 5
    SetWindowPos pbPreviewSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    
    End Sub
    
    Private Sub SetLVInitPos()
    Dim rc As RECT
    Call GetClientRect(UserControl.hWnd, rc)
    DebugAppend Ambient.DisplayName & ".SetLVInitPos::LV ->rc.Right = " & rc.Right & " , ScaleWidth = " & UserControl.ScaleWidth, 1111
    Dim lOffX As Long, lOffY As Long, lOffY2 As Long
    If m_StatusBar Then
        lOffY = cyCombo + cyStatusBar + 6 '48
        lOffY2 = cyStatusBar
    Else
        lOffY = cyCombo + 5 '35
    End If
    If m_DtPane Then
        pbDetailPane.Top = UserControl.ScaleHeight - pbDetailPane.Height - lOffY2
        pbDetailPane.Left = mDTOffsetX
        pbDetailPane.Width = rc.Right - 2 - mDTOffsetX
        DebugAppend "SetLVInitPos::pbDetailPane->rc.Right=" & rc.Right & ",mDTOffsetX=" & mDTOffsetX & ",Setcx=" & pbDetailPane.Width, 22
        lOffY = lOffY + pbDetailPane.Height
    End If
    
    If m_PvPane Then
        lOffX = 6 + (fraPreview.Width)
    Else
    '    lOffX = 18
    End If
    SetWindowPos hLVS, 0, mLVOffX, cyCombo + 6, rc.Right - lOffX - mLVOffX, rc.Bottom - lOffY, 0
    DebugAppend Ambient.DisplayName & ".SetLVInitPos::LV->rc.Right=" & rc.Right & "rc.Bottom=" & rc.Bottom & ",ScaleWidth=" & UserControl.ScaleWidth, 1111
    cxLV = rc.Right - lOffX
    End Sub
    
    Private Sub SetNavInitPos()
    Dim rc As RECT
    Call GetClientRect(UserControl.hWnd, rc)
    Dim lw As Long
    
    If m_ControlBox Then
        pbControlBox.Top = 0
        If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Then
            lw = rc.Right - ((2 * m_ScaleX))
        Else
            lw = rc.Right - pbControlBox.ScaleWidth - ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
        End If
        If (mAutoHideCtlBox = True) And (lw < (cxMinForCtlBoxHide * m_ScaleX)) Then '8 Then
            Me.ListControlBox = False
            bForceCtlOff = True
            GoTo nocbox
        End If
        If (m_MaxComboCX > 0) And (lw > (m_MaxComboCX * m_ScaleX)) Then lw = (m_MaxComboCX * m_ScaleX)
        SetWindowPos hCombo, 0, 0, 0, lw - (1 + (1 * m_ScaleX)), 300, SWP_NOMOVE
        pbControlBox.Left = lw + ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
        DebugAppend "SetNavInitPos::pbControlBox.Left=" & pbControlBox.Left & ", lw=" & lw & ",lOffBkBtn=" & lOffBkBtn & "," & ",lOffFwBtn=" & lOffFwBtn & ",m_ScaleX=" & m_ScaleX
    Else
    nocbox:
        lw = rc.Right - ((lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX))
        If (m_MaxComboCX > 0) And (lw > (m_MaxComboCX * m_ScaleX)) Then lw = (m_MaxComboCX * m_ScaleX)
        SetWindowPos hCombo, 0, 0, 0, lw, 300, SWP_NOMOVE
    End If
    End Sub
    
    Private Sub RepositionControlBox()
    Dim cyUCTxt As Long
    cyUCTxt = UserControl.TextHeight("|T1")
    Dim rc As RECT
    Call GetClientRect(hCombo, rc)
    cyCombo = rc.Bottom + (4 * m_ScaleY)
    DebugAppend "RepositionControlBox cyCombo=" & cyCombo
    'A larger font could change the height of the combobox
    Dim lDif As Long
    lDif = cyCombo - cyDefCbo
    SetWindowPos hUpButton, 0&, 0&, 0&, cxUpBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hViewButton, 0&, 0&, 0&, cxViewBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hBkmButton, 0&, 0&, 0&, cxBkmBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hStdBackButton, 0&, 0&, 0&, cxHistBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hStdFwdButton, 0&, 0&, 0&, cxHistBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    
    If m_Mode = SBCTL_FilesOnly Then cyCombo = 0&
    
        Dim rcsb As RECT, rccb As RECT
        Dim cytt As Single
        Call GetClientRect(hSearchBox, rcsb)
        rcsb.Bottom = cyDefSBox + lDif
        Call GetClientRect(pbControlBox.hWnd, rccb)
        rccb.Bottom = rccb.Bottom + lDif
        
    If hSearchBox And ((cyUCTxt + (6 * m_ScaleY)) > cyCombo) Then
        SetWindowPos pbControlBox.hWnd, 0&, 0&, 0&, rccb.Right + 2, rccb.Bottom + 2, SWP_NOMOVE Or SWP_NOZORDER
        SetWindowPos pbSearchContainer.hWnd, 0&, 0&, 0&, rcsb.Right + 2, cyUCTxt + (6 * m_ScaleY), SWP_NOMOVE Or SWP_NOZORDER
        SetWindowPos hSearchBox, 0&, 0&, 0&, rcsb.Right, cyUCTxt + (4 * m_ScaleY), SWP_NOMOVE Or SWP_NOZORDER
    Else
        Call GetClientRect(pbControlBox.hWnd, rccb)
        rccb.Bottom = cyCombo + (6 * m_ScaleY)
        SetWindowPos pbControlBox.hWnd, 0&, 0&, 0&, rccb.Right, rccb.Bottom, SWP_NOMOVE Or SWP_NOZORDER
    
    End If
    End Sub
    
    Private Sub InitControlBox()
    Dim ccx As Long
    pbControlBox.Visible = True
    If m_NavBtnType = SBNB_ThemeBtnInBox Then
        pbBackBtnAlt.Visible = True
        pbBackBtnAlt.Left = 0
        ccx = pbBackBtnAlt.Width + 1
        pbFwdBtnAlt.Visible = True
        pbFwdBtnAlt.Left = ccx
        ccx = ccx + pbBackBtnAlt.Width + 1
    Else
        pbBackBtnAlt.Visible = False
        pbFwdBtnAlt.Visible = False
    End If
    If m_UpButton Then
        SetWindowPos hUpButton, 0&, ccx, 1&, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
        ShowWindow hUpButton, SW_SHOW
        ccx = ccx + (47& * m_ScaleX) + 1&
    Else
        ShowWindow hUpButton, SW_HIDE
    End If
    If m_NavBtnType = SBNB_Normal Then
        SetWindowPos hStdBackButton, 0&, ccx, 1&, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
        ShowWindow hStdBackButton, SW_SHOW
        ccx = ccx + (53& * m_ScaleX) + 1&
        SetWindowPos hStdFwdButton, 0&, ccx, 1&, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
        ShowWindow hStdFwdButton, SW_SHOW
        ccx = ccx + (53& * m_ScaleX) + 1&
    
    Else
        ShowWindow hStdFwdButton, SW_HIDE
        ShowWindow hStdBackButton, SW_HIDE
    End If
    If m_ViewButton Then
        SetWindowPos hViewButton, 0&, ccx, 1&, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
        ShowWindow hViewButton, SW_SHOW
        ccx = ccx + (62& * m_ScaleX) + 1&
    Else
        ShowWindow hViewButton, SW_HIDE
    End If
    If m_BookmarkButton Then
        SetWindowPos hBkmButton, 0&, ccx, 1&, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
        ShowWindow hBkmButton, SW_SHOW
        ccx = ccx + (26& * m_ScaleX) + 1&
    Else
        ShowWindow hBkmButton, SW_HIDE
    End If
    If mShowSearch Then
        pbSearchContainer.Visible = True
        pbSearchContainer.Left = ccx
        Dim rc As RECT
        Call GetClientRect(hCombo, rc)
        cyCombo = rc.Bottom + (4 * m_ScaleY)
        pbSearchContainer.Height = cyCombo
        Dim rcsb As RECT
        Call GetClientRect(pbSearchContainer.hWnd, rcsb)
        SetWindowPos hSearchBox, 0&, 0&, 0&, rcsb.Right - 2&, (cyCombo - (6 * m_ScaleY)), SWP_NOMOVE Or SWP_NOZORDER
        ccx = ccx + pbSearchContainer.Width + 1
    Else
        pbSearchContainer.Visible = False
    End If
    If ccx = 0 Then
        pbControlBox.Width = 1
        pbControlBox.Visible = False
    Else
        pbControlBox.Width = ccx
    End If
    End Sub
    
    Private Sub pvCreateControlButtons()
    Dim dwStyle As Long
    Dim ccx As Long
    If hUpButton = 0& Then
        cxUpBtn = 47& * m_ScaleX
        dwStyle = WS_CHILD Or WS_VISIBLE Or BS_PUSHBUTTON Or BS_TEXT Or BS_NOTIFY Or BS_LEFT
        hUpButton = CreateWindowExW(0&, StrPtr(WC_BUTTON), 0&, dwStyle, ccx, 1&, cxUpBtn, 28& * m_ScaleY, pbControlBox.hWnd, 0&, App.hInstance, ByVal 0&)
        SetWindowTextW hUpButton, StrPtr(scc_Up)
        SendMessage hUpButton, WM_SETFONT, hFontCtl, ByVal 1&
    End If
    cxHistBtn = 53& * m_ScaleX
    If hStdBackButton = 0& Then
        dwStyle = WS_CHILD Or WS_VISIBLE Or BS_PUSHBUTTON Or BS_TEXT Or BS_NOTIFY Or BS_LEFT
        hStdBackButton = CreateWindowExW(0&, StrPtr(WC_BUTTON), 0&, dwStyle, ccx, 1&, cxHistBtn, 28& * m_ScaleY, pbControlBox.hWnd, 0&, App.hInstance, ByVal 0&)
        SetWindowTextW hStdBackButton, StrPtr(scc_Back)
        SendMessage hStdBackButton, WM_SETFONT, hFontCtl, ByVal 1&
        EnableWindow hStdBackButton, 0&
    End If
    If hStdFwdButton = 0& Then
        dwStyle = WS_CHILD Or WS_VISIBLE Or BS_PUSHBUTTON Or BS_TEXT Or BS_NOTIFY Or BS_LEFT
        hStdFwdButton = CreateWindowExW(0&, StrPtr(WC_BUTTON), 0&, dwStyle, ccx, 1&, cxHistBtn, 28& * m_ScaleY, pbControlBox.hWnd, 0&, App.hInstance, ByVal 0&)
        SetWindowTextW hStdFwdButton, StrPtr(scc_Forward)
        SendMessage hStdFwdButton, WM_SETFONT, hFontCtl, ByVal 1&
        EnableWindow hStdFwdButton, 0&
    End If
    If hViewButton = 0& Then
        cxViewBtn = 62& * m_ScaleX
        dwStyle = WS_CHILD Or WS_VISIBLE Or BS_PUSHBUTTON Or BS_TEXT Or BS_NOTIFY Or BS_LEFT
        hViewButton = CreateWindowExW(0&, StrPtr(WC_BUTTON), 0&, dwStyle, ccx, 1&, cxViewBtn, 28& * m_ScaleY, pbControlBox.hWnd, 0&, App.hInstance, ByVal 0&)
        SetWindowTextW hViewButton, StrPtr(scc_View)
        SendMessage hViewButton, WM_SETFONT, hFontCtl, ByVal 1&
    End If
    If hBkmButton = 0& Then
        cxBkmBtn = 26& * m_ScaleX
        dwStyle = WS_CHILD Or WS_VISIBLE Or BS_PUSHBUTTON Or BS_TEXT Or BS_NOTIFY Or BS_LEFT
        hBkmButton = CreateWindowExW(0&, StrPtr(WC_BUTTON), 0&, dwStyle, ccx, 1&, cxBkmBtn, 28& * m_ScaleY, pbControlBox.hWnd, 0&, App.hInstance, ByVal 0&)
        If IsComCtl6() = False Then SetWindowTextW hBkmButton, StrPtr(scc_bkm_alt)
        SendMessage hBkmButton, WM_SETFONT, hFontCtl, ByVal 1&
    End If
    
    End Sub
    
Private Sub IDropTarget_DragEnter(ByVal pDataObject As IDataObject, ByVal grfKeyState As Long, ByVal pt As LongLong, pdwEffect As DROPEFFECTS) Implements IDropTarget.DragEnter
       DebugAppend "DragEnter"
       sFolder = ""
        ReDim mDropPathList(0)
        bGotDropPathList = False
       mDragOver = m_sCurPathDisp
        Dim PTT As POINT
        ' pt.x = ptX
        ' pt.y = ptY
        CopyMemory PTT, pt, 8
       bNoDrop = False
       m_sAltDrop = ""
       If grfKeyState And MK_RBUTTON Then
        ddRightButton = True
    Else
        ddRightButton = False
    End If
    If (DataObjSupportsFormat(pDataObject, CF_HDROP) = False) Or (Left$(m_sCurPath, 3) = "::{") Then
        If InStr(m_sCurPath, "\\\?\usb#") < 1 Then
            DebugAppend "DragEnter::No HDROP or ::{ path,path=" & m_sCurPath
            DebugAppend "lnlibr=" & lnLibRoot & ",slr=" & sLibRoot
            If (Len(m_sCurPath) > lnLibRoot) Then
                If Left$(LCase$(m_sCurPath), Len(sLibRoot)) = LCase$(sLibRoot) Then
                    'we're in a library
                    m_sAltDrop = LibGetDefLoc()
                    DebugAppend "SetLibDropLoc=" & m_sAltDrop
                    If m_sAltDrop <> "" Then GoTo skp
                End If
            End If
            bNoDrop = True
            pdwEffect = DROPEFFECT_NONE
        '    SetPreferredEffect pDataObj, DROPEFFECT_NONE
            AddDropDescription pDataObject, DROPIMAGE_NONE, mStrNoDrop, ""
        Else
            pdwEffect = DROPEFFECT_COPY 'Default to copy on a USB device
        End If
    Else
    '  pdwEffect = DROPEFFECT_MOVE
    'pdwEffect = GetPreferredEffect(pDataObj)
       DebugAppend "DragEnter::PreferredEffect=" & pdwEffect
    End If
    skp:
       pDTH.DragEnter m_hWnd, pDataObject, PTT, pdwEffect
    If (grfKeyState And MK_LBUTTON) = MK_LBUTTON Then
    
        mIDOCalcdDef = GetDefaultDropEffect(pDataObject)
    Else
        mIDOCalcdDef = pdwEffect
    End If
       DebugAppend "DragEnter::Effect=" & pdwEffect & ",calculated=" & mIDOCalcdDef
      Set mDataObj = pDataObject
                      Select Case mIDOCalcdDef
                        Case DROPEFFECT_NONE
                            AddDropDescription mDataObj, DROPIMAGE_NONE, mStrNoDrop, ""
                            bNoDrop = True
                        Case DROPEFFECT_COPY
                            AddDropDescription mDataObj, DROPIMAGE_COPY, IIf(mDragOver = "", mStrCopyHere, mStrCopyTo & " %1"), mDragOver
                        Case DROPEFFECT_MOVE
                            AddDropDescription mDataObj, DROPIMAGE_MOVE, IIf(mDragOver = "", mStrMoveHere, mStrMoveTo & " %1"), mDragOver
                    End Select
    
    '    RaiseEvent DragEnter(pDataObj, grfKeyState, ptx, pty, pdwEffect)
        
        
    End Sub
    
    Private Function GetPreferredEffect(pDataObj As IDataObject) As DROPEFFECTS
    Dim tSTG As STGMEDIUM
    Dim tFMT As FORMATETC
    Dim lpGlobal As LongPtr
    Dim lEf As Long
    
        tFMT.cfFormat = CF_PREFERREDDROPEFFECT
        tFMT.dwAspect = DVASPECT_CONTENT
        tFMT.lIndex = -1
        tFMT.TYMED = TYMED_HGLOBAL
    
        pDataObj.GetData tFMT, tSTG
        lpGlobal = GlobalLock(tSTG.data)
        CopyMemory lEf, ByVal lpGlobal, 4&
        Call GlobalUnlock(tSTG.data)
        ReleaseStgMedium tSTG
        
        GetPreferredEffect = lEf
    End Function
    
    Private Function LibGetDefLoc() As String
    'if current path is a library, get its default save location to drop there
    Dim siLib As IShellItem
    Dim siItem As IShellItem
    Dim lpPath As LongPtr
    Dim pSL As ShellLibrary
    Set pSL = New ShellLibrary
    Set siLib = siCurPath
    If (siLib Is Nothing) = False Then
        pSL.LoadLibraryFromItem siLib, STGM_READ
        pSL.GetDefaultSaveFolder DSFT_DETECT, IID_IShellItem, siItem
        If (siItem Is Nothing) = False Then
            siItem.GetDisplayName SIGDN_FILESYSPATH, lpPath
            LibGetDefLoc = LPWSTRtoStr(lpPath)
            Set siItem = Nothing
        End If
        
        Set pSL = Nothing
        Set siLib = Nothing
    End If
    
    End Function
    
    Private Function LibGetDefLoc2(szPath As String) As String
    'if current path is a library, get its default save location to drop there
    Dim siLib As IShellItem
    Dim siItem As IShellItem
    Dim lpPath As LongPtr
    Dim pSL As ShellLibrary
    Set pSL = New ShellLibrary
    
    SHCreateItemFromParsingName StrPtr(szPath), Nothing, IID_IShellItem, siLib
    
    If (siLib Is Nothing) = False Then
        pSL.LoadLibraryFromItem siLib, STGM_READ
        pSL.GetDefaultSaveFolder DSFT_DETECT, IID_IShellItem, siItem
        If (siItem Is Nothing) = False Then
            siItem.GetDisplayName SIGDN_FILESYSPATH, lpPath
            LibGetDefLoc2 = LPWSTRtoStr(lpPath)
            Set siItem = Nothing
        End If
        
        Set pSL = Nothing
        Set siLib = Nothing
    End If
    
    End Function

Private Sub IDropTarget_DragOver(ByVal grfKeyState As Long, ByVal pt As LongLong, pdwEffect As DROPEFFECTS) Implements IDropTarget.DragOver
    '    DebugAppend "DragOver.Enter::Effect=" & pdwEffect
    On Error GoTo e0
    If pdwEffect = DROPEFFECT_MOVE Then
        AddDropDescription mDataObj, DROPIMAGE_MOVE, mStrMoveTo & " %1", m_sCurPathDisp
    End If
    Dim PTT As POINT
    ' pt.x = ptX
    ' pt.y = ptY
    CopyMemory PTT, pt, 8
    
    pDTH.DragOver PTT, pdwEffect
    
    If (xHover <> PTT.x) Or (yHover <> PTT.y) Then
        lHover1 = GetTickCount()
        xHover = PTT.x
        yHover = PTT.y
        bHoverFired = False
    Else
        If lHover1 = 0 Then 'initial run
            lHover1 = GetTickCount()
            xHover = PTT.x
            yHover = PTT.y
        Else
            If bHoverFired = False Then
                lHover2 = GetTickCount()
                If (lHover2 - lHover1) > lRaiseHover Then
                    DebugAppend "DragHover " & PTT.x & "," & PTT.y & ",t1=" & lHover1 & ",t2=" & lHover2
    '                RaiseEvent DragHover(ptx, pty, grfKeyState)
                    bHoverFired = True 'set flag to not raise again until pt changes
    '                lHover1 = 0
                End If
            End If
        End If
    End If
    Dim lPrevItemIndex As LongPtr
    'pdwEffect = mDefEffect
    pdwEffect = DROPEFFECT_MOVE
    If bAbort Then Exit Sub
    If m_ActiveDrop Then
        lPrevItemIndex = lItemIndex
        Dim fGrp As Boolean
        Dim bNo As Boolean
        Dim sOld As String
        Dim nPrev As LongPtr
        nPrev = lItemIndex
        LVDT_QueryDragOverItem PTT.x, PTT.y, nPrev, lItemIndex, fGrp
        If lItemIndex <> nPrev Then
        If (lItemIndex >= 0) Then
            If fGrp Then
                sOld = sFolder
                LVDT_QueryDragOverData lItemIndex, True, sFolder, bNo
                If sOld <> sFolder Then
                    mDragOver = PathGetDisp(sFolder)
                End If
            Else
                sOld = sFolder
                LVDT_QueryDragOverData lItemIndex, False, sFolder, bNo
                If sOld <> sFolder Then
                    If m_sCurPath = sLibRoot2 Then
                        mDragOver = Right$(sFolder, Len(sFolder) - InStrRev(sFolder, "\"))
                    Else
                        mDragOver = PathGetDisp(sFolder)
                    End If
                End If
    
            End If
            If (Left$(sFolder, 3) = "::{") Then
    
                If (Len(sFolder) > lnLibRoot) Then
                    If Left$(LCase$(sFolder), Len(sLibRoot)) = LCase$(sLibRoot) Then
                        sFolder = LibGetDefLoc2(sFolder)
                    End If
                Else
                    bNo = True
                End If
            End If
            DebugAppend "dragover set dir=" & sFolder ', 9
        Else
            If m_sCurPath <> "" Then
                sFolder = m_sCurPath
                mDragOver = m_sCurPathDisp
            Else
                DebugAppend "QueryDragOverItem index=" & lItemIndex
                mDragOver = ""
                sFolder = ""
            End If
        End If
        End If
        If bNo Then
            pdwEffect = DROPEFFECT_NONE
            DebugAppend "DragOver::bNo=True,set->none"
        End If
        If (lItemIndex <> lPrevItemIndex) Then
            DebugAppend "cDropTarget.DragOver::New dragover item; resetting DropDesc", 3
            mIDOCalcdDef = GetDefaultDropEffect(mDataObj)
            If False Then 'If bQueryTip Then
    '            Dim sp1 As String, sp2 As String, nImg As DROPIMAGETYPE, bDDF As Boolean
    '            LVDT_QueryDragOverTip lItemIndex, fGrp, sFolder, pdwEffect, bDDF, sp1, sp2, nImg
    '            If bDDF = False Then
    '                If (sp2 = "$CD") Then sp2 = Replace$(sp2, "$CD", iif(sFolder = "", m_sCurPath, sFolder))
    '                AddDropDescription mDataObj, nImg, sp1, sp2
    '            Else
    '                GoTo DefaultTipSet
    '            End If
            Else
    DefaultTipSet:
                If mDropTipMsg <> "" Then
                    DebugAppend "mDropTipIns=" & mDropTipIns & ",m_sCurPath=" & m_sCurPath & ",sFolder=" & sFolder ', 9
                    If (mDropTipIns = "$CD") Then
                        mDropTipIns = Replace$(mDropTipIns, "$CD", IIf(sFolder = "", m_sCurPath, sFolder))
                        AddDropDescription mDataObj, IIf(bNo, DROPIMAGE_NONE, mDropTipImg), mDropTipMsg, mDropTipIns
                        mDropTipIns = "$CD"
                    Else
                        AddDropDescription mDataObj, IIf(bNo, DROPIMAGE_NONE, mDropTipImg), mDropTipMsg, mDropTipIns
                    End If
    '                bNoDrop = False
                Else
                    bNoTarget = False
                    If lItemIndex = -1 Then
    '                    DebugAppend "DragOver::lItemIndex=-1,set effect (NOCHANGE),cur=" & pdwEffect
                        sFolder = m_sCurPath
                        mDragOver = m_sCurPathDisp
                        If bNoDrop Then
                            pdwEffect = DROPEFFECT_NONE
                        End If
                    End If
                    
                        If (lvDragOverIdx > -1&) And (FileIsExecutable(lvDragOverLP) = True) Then
                            AddDropDescription mDataObj, DROPIMAGE_LABEL, IIf(mDragOver = "", mStrOpenWith, mStrOpenWith & " %1"), mDragOver
                            mCurEf = DROPEFFECT_COPY
                        Else
                            Select Case mIDOCalcdDef
                                Case DROPEFFECT_NONE
                                    AddDropDescription mDataObj, DROPIMAGE_NONE, "Can't drop here.", ""
                                    mCurEf = DROPEFFECT_NONE
                                Case DROPEFFECT_COPY
                                    AddDropDescription mDataObj, DROPIMAGE_COPY, IIf(mDragOver = "", mStrCopyHere, mStrCopyTo & " %1"), mDragOver
                                    mCurEf = DROPEFFECT_COPY
                                Case DROPEFFECT_MOVE
                                    AddDropDescription mDataObj, DROPIMAGE_MOVE, IIf(mDragOver = "", mStrMoveHere, mStrMoveTo & " %1"), mDragOver
                                    mCurEf = DROPEFFECT_MOVE
                            End Select
                        End If
                End If
            End If
        End If
    End If
    
    'DebugAppend "IDropTarget_DragOver lvDragOverIdx=" & lvDragOverIdx & ",sFolder=" & sFolder
    qts:
       
    '    RaiseEvent DragOver(grfKeyState, ptx, pty, pdwEffect)
        'Notice that the text shows 'Move' in the caption; you can change pdwEffect to something else
        'pdwEffect = DROPEFFECT_COPY
        'pdwEffect = DROPEFFECT_NONE 'this shows that a drop is not allowed, and the drop event won't fire
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.IDropTarget_DragOver->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
End Sub

Private Sub IDropTarget_DragLeave() Implements IDropTarget.DragLeave
    'DebugAppend "DragLeave"
    
    pDTH.DragLeave
    If bAbort Then Exit Sub
    AddDropDescription mDataObj, DROPIMAGE_INVALID, "", ""
    Set mDataObj = Nothing
End Sub

Private Sub IDropTarget_Drop(ByVal pDataObj As IDataObject, ByVal grfKeyState As Long, ByVal pt As LongLong, pdwEffect As DROPEFFECTS) Implements IDropTarget.Drop
    DebugAppend "IDropTarget_Drop, Effect=" & mCurEf
    Dim PTT As POINT
    ' PT.x = ptX
    ' PT.y = ptY
    CopyMemory PTT, pt, 8
    pDTH.Drop pDataObj, PTT, pdwEffect
    If mCurEf = DROPEFFECT_NONE Then
        UpdateStatus m_str_CantDrop
    Else
        UpdateStatus m_str_DroppingFiles
        SetWaitCursor
        If LVHandleDropEx(pDataObj, PTT, pdwEffect, grfKeyState) = -1& Then
            UpdateStatus m_str_DropError
        End If
        ClearWaitCursor
    End If
End Sub

Private Sub IListViewFooterCallback_OnButtonClicked(ByVal itemIndex As Long, ByVal lParam As Long, pRemoveFooter As Long) Implements IListViewFooterCallback.OnButtonClicked
    DebugAppend "Get footer button click, index=" & itemIndex & ",lparam=" & lParam
    pLVF.SetFooterFocus itemIndex
    If (lParam >= nSearchFooter1) Then
        'Internal search footer; don't raise event
        Dim sia As IShellItemArray
        If lParam = nSearchFooter1 Then
            'Repeat search in Library Root
            If EnumLibraryPaths(sia) = S_OK Then
                pLVF.RemoveAllButtons
                Set pLVF = Nothing 'otherwise results get drawn right on top of it while loading
                ExecSearchInNewLoc sia, sLibRoot2, mLibRootDisp
            End If
        End If
        
        If lParam = nSearchFooter2 Then
            If EnumComputerPaths(sia) = S_OK Then
                pLVF.RemoveAllButtons
                Set pLVF = Nothing
                ExecSearchInNewLoc sia, sComp, mCompRtDisp
            End If
        End If
        
        If lParam = nSearchFooter3 Then
            Dim siDL As IShellItem
            Dim sPathDL As String, lpPath As LongPtr
            SHGetKnownFolderItem FOLDERID_Downloads, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siDL
            If (siDL Is Nothing) = False Then
                siDL.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
                sPathDL = LPWSTRtoStr(lpPath)
                SHCreateShellItemArrayFromShellItem siDL, IID_IShellItemArray, sia
                If (sia Is Nothing) = False Then
                    pLVF.RemoveAllButtons
                    Set pLVF = Nothing
                    ExecSearchInNewLoc sia, sPathDL, mDlDisp
                End If
            End If
        End If
            
        If lParam = nSearchFooter4 Then
            If EnumRecentPlacesPaths(sia) = S_OK Then
                pLVF.RemoveAllButtons
                Set pLVF = Nothing
                ExecSearchInNewLoc sia, "shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}", mRplDisp
            End If
        End If
            
        If lParam = nSearchFooter5 Then
            'Custom...
            Dim fod As FileOpenDialog
            Set fod = New FileOpenDialog
            With fod
                .SetTitle sSearchPickCust
                .SetOptions FOS_PICKFOLDERS Or FOS_ALLOWMULTISELECT
                Dim tGuid As UUID
                CLSIDFromString StrPtr(mDlgGuid), tGuid
                .SetClientGuid tGuid
                .SetOkButtonLabel scc_SearchBtn
                
                On Error Resume Next
                .Show hLVS
                On Error GoTo hErr
                .GetResults sia
            End With
            
            If (sia Is Nothing) = False Then
                Dim sLbl As String
                sLbl = GetSearchLabelForArray(sia, nMaxFoldersInCustomSearchLabel)
                If (sLbl = "") Or (sLbl = vbNullChar) Or (sLbl = ", ") Or (sLbl = ", ...") Or (sLbl = "...") Then
                    sLbl = sSearchFooter5
                End If
                pLVF.RemoveAllButtons
                Set pLVF = Nothing
                ExecSearchInNewLoc sia, sComp, sLbl
            End If
            
        End If
    Else
        RaiseEvent FooterButtonClick(itemIndex, lParam)
    End If
    
    Exit Sub
    hErr:
        DebugAppend "IListviewFooterCallback_OnButtonClick Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
End Sub

Private Sub IListViewFooterCallback_OnDestroyButton(ByVal itemIndex As Long, ByVal lParam As Long) Implements IListViewFooterCallback.OnDestroyButton
    
End Sub

'--------------------------------------------
'IIDs and PROPERTYKEYs
'These have been added here to avoid creating a dependency on the normal mIID.bas/mPKEY.bas that usually goes with 
'All of these can be found in those modules, if you're using them and wanted to de-duplicate.


Private Sub DEFINE_UUID(Name As UUID, L As Long, w1 As Integer, w2 As Integer, B0 As Byte, b1 As Byte, b2 As Byte, B3 As Byte, b4 As Byte, b5 As Byte, b6 As Byte, b7 As Byte)
  With Name
    .Data1 = L
    .Data2 = w1
    .Data3 = w2
    .Data4(0) = B0
    .Data4(1) = b1
    .Data4(2) = b2
    .Data4(3) = B3
    .Data4(4) = b4
    .Data4(5) = b5
    .Data4(6) = b6
    .Data4(7) = b7
  End With
End Sub
Private Sub DEFINE_OLEGUID(Name As UUID, L As Long, w1 As Integer, w2 As Integer)
  DEFINE_UUID Name, L, w1, w2, &HC0, 0, 0, 0, 0, 0, 0, &H46
End Sub

'-----------------------------------------
'BHIDs
Private Function BHID_EnumItems() As UUID
'{0x94F60519, 0x2850, 0x4924, 0xAA,0x5A, 0xD1,0x5E,0x84,0x86,0x80,0x39}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H94F60519, &H2850, &H4924, &HAA, &H5A, &HD1, &H5E, &H84, &H86, &H80, &H39)
 BHID_EnumItems = iid
End Function
Private Function BHID_Stream() As UUID
'{0x1CEBB3AB, 0x7C10, 0x499A, 0xA4,0x17, 0x92,0xCA,0x16,0xC4,0xCB,0x83}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1CEBB3AB, &H7C10, &H499A, &HA4, &H17, &H92, &HCA, &H16, &HC4, &HCB, &H83)
 BHID_Stream = iid
End Function
Private Function BHID_SFObject() As UUID
'{0x3981E224, 0xF559, 0x11D3, 0x8E,0x3A, 0x00,0xC0,0x4F,0x68,0x37,0xD5}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3981E224, &HF559, &H11D3, &H8E, &H3A, &H0, &HC0, &H4F, &H68, &H37, &HD5)
 BHID_SFObject = iid
End Function
Private Function BHID_SFUIObject() As UUID
'{3981e225-f559-11d3-8e3a-00c04f6837d5}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3981E225, &HF559, &H11D3, &H8E, &H3A, &H0, &HC0, &H4F, &H68, &H37, &HD5)
  BHID_SFUIObject = iid
End Function
Private Function BHID_SFViewObject() As UUID
'{0x3981E226, 0xF559, 0x11D3, 0x8E,0x3A, 0x00,0xC0,0x4F,0x68,0x37,0xD5}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3981E226, &HF559, &H11D3, &H8E, &H3A, &H0, &HC0, &H4F, &H68, &H37, &HD5)
 BHID_SFViewObject = iid
End Function
Private Function BHID_PropertyStore() As UUID
'{0x0384E1A4, 0x1523, 0x439C, 0xA4,0xC8, 0xAB,0x91,0x10,0x52,0xF5,0x86}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H384E1A4, &H1523, &H439C, &HA4, &HC8, &HAB, &H91, &H10, &H52, &HF5, &H86)
 BHID_PropertyStore = iid
End Function
Private Function BHID_ThumbnailHandler() As UUID
'{0x7B2E650A, 0x8E20, 0x4F4A, 0xB0,0x9E, 0x65,0x97,0xAF,0xC7,0x2F,0xB0}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7B2E650A, &H8E20, &H4F4A, &HB0, &H9E, &H65, &H97, &HAF, &HC7, &H2F, &HB0)
 BHID_ThumbnailHandler = iid
End Function
Private Function BHID_DataObject() As UUID
'{0xB8C0BD9F, 0xED24, 0x455C, 0x83,0xE6, 0xD5,0x39,0x0C,0x4F,0xE8,0xC4}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB8C0BD9F, &HED24, &H455C, &H83, &HE6, &HD5, &H39, &HC, &H4F, &HE8, &HC4)
 BHID_DataObject = iid
End Function
Private Function BHID_LinkTargetItem() As UUID
'{0x3981E228, 0xF559, 0x11D3, 0x8E,0x3A, 0x00,0xC0,0x4F,0x68,0x37,0xD5}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3981E228, &HF559, &H11D3, &H8E, &H3A, &H0, &HC0, &H4F, &H68, &H37, &HD5)
 BHID_LinkTargetItem = iid
End Function
Private Function PKEY_Link_TargetSFGAOFlags() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB9B4B3FC, &H2B51, &H4A42, &HB5, &HD8, &H32, &H41, &H46, &HAF, &HCF, &H25, 8)
PKEY_Link_TargetSFGAOFlags = pkk
End Function
Private Function IID_IOleInPlaceActiveObject() As UUID
'{00000117-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H117, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IOleInPlaceActiveObject = iid
End Function
Private Function IID_IShellFolder() As UUID
  Static iid As UUID
  If (iid.Data1 = 0) Then Call DEFINE_OLEGUID(iid, &H214E6, 0, 0)
  IID_IShellFolder = iid
End Function
Private Function IID_IShellFolder2() As UUID
'{93F2F68C-1D1B-11D3-A30E-00C04F79ABD1}
Static iid As UUID
If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H93F2F68C, CInt(&H1D1B), CInt(&H11D3), &HA3, &HE, 0, &HC0, &H4F, &H79, &HAB, &HD1)
IID_IShellFolder2 = iid
End Function
Private Function IID_IShellItem() As UUID
Static iid As UUID
If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H43826D1E, CInt(&HE718), CInt(&H42EE), &HBC, &H55, &HA1, &HE2, &H61, &HC3, &H7B, &HFE)
IID_IShellItem = iid
End Function
Private Function IID_IShellItem2() As UUID
'7e9fb0d3-919f-4307-ab2e-9b1860310c93
Static iid As UUID
If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7E9FB0D3, CInt(&H919F), CInt(&H4307), &HAB, &H2E, &H9B, &H18, &H60, &H31, &HC, &H93)
IID_IShellItem2 = iid
End Function
Private Function IID_IExtractIconA() As UUID
'{000214EB-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H214EB, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IExtractIconA = iid
End Function
Private Function IID_IExtractIconW() As UUID
'{000214FA-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H214FA, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IExtractIconW = iid
End Function
Private Function IID_IShellLinkA() As UUID
'{000214EE-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H214EE, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IShellLinkA = iid
End Function
Private Function IID_IShellLinkW() As UUID
'{000214F9-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H214F9, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IShellLinkW = iid
End Function
Private Function IID_IShellItemImageFactory() As UUID
'{BCC18B79-BA16-442F-80C4-8A59C30C463B}
Static iid As UUID
If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBCC18B79, CInt(&HBA16), CInt(&H442F), &H80, &HC4, &H8A, &H59, &HC3, &HC, &H46, &H3B)
IID_IShellItemImageFactory = iid
End Function
Private Function IID_IShellView() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_OLEGUID(iid, &H214E3, 0, 0)
 IID_IShellView = iid
End Function
Private Function IID_IEnumShellItems() As UUID
'{70629033-e363-4a28-a567-0db78006e6d7}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H70629033, CInt(&HE363), CInt(&H4A28), &HA5, &H67, &HD, &HB7, &H80, &H6, &HE6, &HD7)
 IID_IEnumShellItems = iid
End Function
Private Function IID_IShellItemArray() As UUID
'{b63ea76d-1f85-456f-a19c-48159efa858b}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB63EA76D, CInt(&H1F85), CInt(&H456F), &HA1, &H9C, &H48, &H15, &H9E, &HFA, &H85, &H8B)
  IID_IShellItemArray = iid
End Function
Private Function IID_IDataObject() As UUID
'0000010e-0000-0000-C000-000000000046
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H10E, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
  IID_IDataObject = iid
End Function
Private Function IID_IUnknown() As UUID
'"{00000000-0000-0000-C000-000000000046}"
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
  IID_IUnknown = iid
End Function
Private Function IID_IStream() As UUID
'{0000000C-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
 IID_IStream = iid
End Function
Private Function IID_IDropTarget() As UUID
'{00000122-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H122, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
 IID_IDropTarget = iid
End Function
Private Function IID_IListView() As UUID
'{E5B16AF2-3990-4681-A609-1F060CD14269} WINDOWS 7+
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE5B16AF2, CInt(&H3990), CInt(&H4681), &HA6, &H9, &H1F, &H6, &HC, &HD1, &H42, &H69)
 IID_IListView = iid
End Function
Private Function IID_IListViewFooter() As UUID
'{F0034DA8-8A22-4151-8F16-2EBA76565BCC}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF0034DA8, CInt(&H8A22), CInt(&H4151), &H8F, &H16, &H2E, &HBA, &H76, &H56, &H5B, &HCC)
 IID_IListViewFooter = iid
End Function
Private Function IID_IVisualProperties() As UUID
'{e693cf68-d967-4112-8763-99172aee5e5a}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HE693CF68, CInt(&HD967), CInt(&H4112), &H87, &H63, &H99, &H17, &H2A, &HEE, &H5E, &H5A)
IID_IVisualProperties = iid
End Function
Private Function IID_IImageList() As UUID
'{46EB5926-582E-4017-9FDF-E8998DAA0950}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H46EB5926, CInt(&H582E), CInt(&H4017), &H9F, &HDF, &HE8, &H99, &H8D, &HAA, &H9, &H50)
 IID_IImageList = iid
End Function
Private Function IID_IImageList2() As UUID
'{192b9d83-50fc-457b-90a0-2b82a8b5dae1}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H192B9D83, CInt(&H50FC), CInt(&H457B), &H90, &HA0, &H2B, &H82, &HA8, &HB5, &HDA, &HE1)
 IID_IImageList2 = iid
End Function
Private Function CLSID_ImageList() As UUID
'{7C476BA2-02B1-48f4-8048-B24619DDC058}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7C476BA2, CInt(&H2B1), CInt(&H48F4), &H80, &H48, &HB2, &H46, &H19, &HDD, &HC0, &H58)
 CLSID_ImageList = iid
End Function
Private Function CLSID_InternetZoneManager() As UUID
'{7b8a2d95-0ac9-11d1-896c-00c04Fb6bfc4}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7B8A2D95, CInt(&HAC9), CInt(&H11D1), &H89, &H6C, &H0, &HC0, &H4F, &HB6, &HBF, &HC4)
 CLSID_InternetZoneManager = iid
End Function
Private Function IID_IInternetZoneManager() As UUID
'{79eac9ef-baf9-11ce-8c82-00aa004ba90b}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H79EAC9EF, CInt(&HBAF9), CInt(&H11CE), &H8C, &H82, &H0, &HAA, &H0, &H4B, &HA9, &HB)
IID_IInternetZoneManager = iid
End Function
Private Function IID_IExtractImage() As UUID
'{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBB2E617C, CInt(&H920), CInt(&H11D1), &H9A, &HB, &H0, &HC0, &H4F, &HC2, &HD6, &HC1)
  IID_IExtractImage = iid
End Function
Private Function IID_IThumbnailProvider() As UUID
'{e357fccd-a995-4576-b01f-234630154e96}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HE357FCCD, CInt(&HA995), CInt(&H4576), &HB0, &H1F, &H23, &H46, &H30, &H15, &H4E, &H96)
IID_IThumbnailProvider = iid
End Function
Private Function IID_IThumbnailHandlerFactory() As UUID
'{e35b4b2e-00da-4bc1-9f13-38bc11f5d417}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HE35B4B2E, CInt(&HDA), CInt(&H4BC1), &H9F, &H13, &H38, &HBC, &H11, &HF5, &HD4, &H17)
IID_IThumbnailHandlerFactory = iid
End Function
Private Function IID_IPreviewHandler() As UUID
'{8895b1c6-b41f-4c1c-a562-0d564250836f}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8895B1C6, CInt(&HB41F), CInt(&H4C1C), &HA5, &H62, &HD, &H56, &H42, &H50, &H83, &H6F)
 IID_IPreviewHandler = iid
End Function
Private Function IID_IPreviewHandlerVisuals() As UUID
'{196bf9a5-b346-4ef0-aa1e-5dcdb76768b1}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H196BF9A5, CInt(&HB346), CInt(&H4EF0), &HAA, &H1E, &H5D, &HCD, &HB7, &H67, &H68, &HB1)
 IID_IPreviewHandlerVisuals = iid
End Function
Private Function IID_IInitializeWithStream() As UUID
'{b824b49d-22ac-4161-ac8a-9916e8fa3f7f}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB824B49D, CInt(&H22AC), CInt(&H4161), &HAC, &H8A, &H99, &H16, &HE8, &HFA, &H3F, &H7F)
 IID_IInitializeWithStream = iid
End Function
Private Function IID_IInitializeWithItem() As UUID
'{7f73be3f-fb79-493c-a6c7-7ee14e245841}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7F73BE3F, CInt(&HFB79), CInt(&H493C), &HA6, &HC7, &H7E, &HE1, &H4E, &H24, &H58, &H41)
 IID_IInitializeWithItem = iid
End Function
Private Function IID_IInitializeWithFile() As UUID
'{b7d14566-0509-4cce-a71f-0a554233bd9b}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB7D14566, CInt(&H509), CInt(&H4CCE), &HA7, &H1F, &HA, &H55, &H42, &H33, &HBD, &H9B)
 IID_IInitializeWithFile = iid
End Function
Private Function IID_IQueryInfo() As UUID
'{00021500-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H21500, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IQueryInfo = iid
End Function
Private Function IID_IPropertyStore() As UUID
'DEFINE_GUID(IID_IPropertyStore,0x886d8eeb, 0x8cf2, 0x4446, 0x8d,0x02,0xcd,0xba,0x1d,0xbd,0xcf,0x99);
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H886D8EEB, CInt(&H8CF2), CInt(&H4446), &H8D, &H2, &HCD, &HBA, &H1D, &HBD, &HCF, &H99)
  IID_IPropertyStore = iid
End Function
Private Function IID_IPropertyEnumType() As UUID
'{11e1fbf9-2d56-4a6b-8db3-7cd193a471f2}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H11E1FBF9, CInt(&H2D56), CInt(&H4A6B), &H8D, &HB3, &H7C, &HD1, &H93, &HA4, &H71, &HF2)
IID_IPropertyEnumType = iid
End Function
Private Function IID_IPropertyEnumType2() As UUID
'{9b6e051c-5ddd-4321-9070-fe2acb55e794}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9B6E051C, CInt(&H5DDD), CInt(&H4321), &H90, &H70, &HFE, &H2A, &HCB, &H55, &HE7, &H94)
IID_IPropertyEnumType2 = iid
End Function
Private Function IID_IPropertyEnumTypeList() As UUID
'{a99400f4-3d84-4557-94ba-1242fb2cc9a6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA99400F4, CInt(&H3D84), CInt(&H4557), &H94, &HBA, &H12, &H42, &HFB, &H2C, &HC9, &HA6)
IID_IPropertyEnumTypeList = iid
End Function
Private Function IID_IPropertyDescription() As UUID
'(IID_IPropertyDescription, 0x6f79d558, 0x3e96, 0x4549, 0xa1,0xd1, 0x7d,0x75,0xd2,0x28,0x88,0x14
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6F79D558, CInt(&H3E96), CInt(&H4549), &HA1, &HD1, &H7D, &H75, &HD2, &H28, &H88, &H14)
  IID_IPropertyDescription = iid
End Function
Private Function IID_IPropertyDescription2() As UUID
'{57d2eded-5062-400e-b107-5dae79fe57a6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H57D2EDED, CInt(&H5062), CInt(&H400E), &HB1, &H7, &H5D, &HAE, &H79, &HFE, &H57, &HA6)
IID_IPropertyDescription2 = iid
End Function
Private Function IID_IPropertyDescriptionList() As UUID
'IID_IPropertyDescriptionList, 0x1f9fc1d0, 0xc39b, 0x4b26, 0x81,0x7f, 0x01,0x19,0x67,0xd3,0x44,0x0e
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1F9FC1D0, CInt(&HC39B), CInt(&H4B26), &H81, &H7F, &H1, &H19, &H67, &HD3, &H44, &HE)
  IID_IPropertyDescriptionList = iid
End Function
Private Function IID_IPropertySystem() As UUID
'IID_IPropertySystem, 0xca724e8a, 0xc3e6, 0x442b, 0x88,0xa4, 0x6f,0xb0,0xdb,0x80,0x35,0xa3
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCA724E8A, CInt(&HC3E6), CInt(&H442B), &H88, &HA4, &H6F, &HB0, &HDB, &H80, &H35, &HA3)
  IID_IPropertySystem = iid
End Function
Private Function IID_IPropertyBag() As UUID
'{55272A00-42CB-11CE-8135-00AA004BB851}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H55272A00, CInt(&H42CB), CInt(&H11CE), &H81, &H35, &H0, &HAA, &H0, &H4B, &HB8, &H51)
 IID_IPropertyBag = iid
End Function
Private Function IID_ICategoryProvider() As UUID
'{9af64809-5864-4c26-a720-c1f78c086ee3}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9AF64809, CInt(&H5864), CInt(&H4C26), &HA7, &H20, &HC1, &HF7, &H8C, &H8, &H6E, &HE3)
IID_ICategoryProvider = iid
End Function
Private Function IID_ICategorizer() As UUID
'{a3b14589-9174-49a8-89a3-06a1ae2b9ba7}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA3B14589, CInt(&H9174), CInt(&H49A8), &H89, &HA3, &H6, &HA1, &HAE, &H2B, &H9B, &HA7)
IID_ICategorizer = iid
End Function
Private Function IID_ICondition() As UUID
'{0FC988D4-C935-4b97-A973-46282EA175C8}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFC988D4, CInt(&HC935), CInt(&H4B97), &HA9, &H73, &H46, &H28, &H2E, &HA1, &H75, &HC8)
 IID_ICondition = iid
End Function
Private Function IID_IQueryParser() As UUID
'{2EBDEE67-3505-43f8-9946-EA44ABC8E5B0}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H2EBDEE67, CInt(&H3505), CInt(&H43F8), &H99, &H46, &HEA, &H44, &HAB, &HC8, &HE5, &HB0)
IID_IQueryParser = iid
End Function
Private Function IID_IObjectCollection() As UUID
'{5632b1a4-e38a-400a-928a-d4cd63230295}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H5632B1A4, CInt(&HE38A), CInt(&H400A), &H92, &H8A, &HD4, &HCD, &H63, &H23, &H2, &H95)
IID_IObjectCollection = iid
End Function
Private Function IID_IPortableDeviceValues() As UUID
'{6848F6F2-3155-4F86-B6F5-263EEEAB3143}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6848F6F2, CInt(&H3155), CInt(&H4F86), &HB6, &HF5, &H26, &H3E, &HEE, &HAB, &H31, &H43)
IID_IPortableDeviceValues = iid
End Function
Private Function IID_IContextMenu() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_OLEGUID(iid, &H214E4, 0, 0)
 IID_IContextMenu = iid
End Function
Private Function IID_IContextMenu2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_OLEGUID(iid, &H214F4, 0, 0)
 IID_IContextMenu2 = iid
End Function
Private Function IID_IContextMenu3() As UUID
'{BCFCE0A0-EC17-11d0-8D10-00A0C90F2719}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBCFCE0A0, CInt(&HEC17), CInt(&H11D0), &H8D, &H10, &H0, &HA0, &HC9, &HF, &H27, &H19)
 IID_IContextMenu3 = iid
End Function
Private Function IID_IShellIcon() As UUID
'{000214E5-0000-0000-C000-000000000046}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H214E5, CInt(&H0), CInt(&H0), &HC0, &H0, &H0, &H0, &H0, &H0, &H0, &H46)
IID_IShellIcon = iid
End Function
Private Function UUID_NULL() As UUID
Static bSet As Boolean
Static iid As UUID
If bSet = False Then
  With iid
    .Data1 = 0
    .Data2 = 0
    .Data3 = 0
    .Data4(0) = 0
    .Data4(1) = 0
    .Data4(2) = 0
    .Data4(3) = 0
    .Data4(4) = 0
    .Data4(5) = 0
    .Data4(6) = 0
    .Data4(7) = 0
  End With
End If
bSet = True
UUID_NULL = iid
End Function
Private Function PKEY_NULL() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, 0)
PKEY_NULL = pkk
End Function

'--------------------------------------------
'FOLDERIDs
Private Function FOLDERID_System() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1AC14E77, CInt(&H2E7), CInt(&H4E5D), &HB7, &H44, &H2E, &HB1, &HAE, &H51, &H98, &HB7)
 FOLDERID_System = iid
End Function
Private Function FOLDERID_SystemX86() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD65231B0, CInt(&HB2F1), CInt(&H4857), &HA4, &HCE, &HA8, &HE7, &HC6, &HEA, &H7D, &H27)
 FOLDERID_SystemX86 = iid
End Function
Private Function FOLDERID_Fonts() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFD228CB7, CInt(&HAE11), CInt(&H4AE3), &H86, &H4C, &H16, &HF3, &H91, &HA, &HB8, &HFE)
 FOLDERID_Fonts = iid
End Function
Private Function FOLDERID_ComputerFolder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HAC0837C, CInt(&HBBF8), CInt(&H452A), &H85, &HD, &H79, &HD0, &H8E, &H66, &H7C, &HA7)
 FOLDERID_ComputerFolder = iid
End Function
Private Function FOLDERID_Desktop() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB4BFCC3A, CInt(&HDB2C), CInt(&H424C), &HB0, &H29, &H7F, &HE9, &H9A, &H87, &HC6, &H41)
 FOLDERID_Desktop = iid
End Function
Private Function FOLDERID_Recent() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HAE50C081, CInt(&HEBD2), CInt(&H438A), &H86, &H55, &H8A, &H9, &H2E, &H34, &H98, &H7A)
 FOLDERID_Recent = iid
End Function
Private Function FOLDERID_SavedSearches() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7D1D3A04, CInt(&HDEBB), CInt(&H4115), &H95, &HCF, &H2F, &H29, &HDA, &H29, &H20, &HDA)
 FOLDERID_SavedSearches = iid
End Function
Private Function FOLDERID_ConnectionsFolder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6F0CD92B, CInt(&H2E97), CInt(&H45D1), &H88, &HFF, &HB0, &HD1, &H86, &HB8, &HDE, &HDD)
 FOLDERID_ConnectionsFolder = iid
End Function
Private Function FOLDERID_Profile() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5E6C858F, CInt(&HE22), CInt(&H4760), &H9A, &HFE, &HEA, &H33, &H17, &HB6, &H71, &H73)
 FOLDERID_Profile = iid
End Function
Private Function FOLDERID_Downloads() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H374DE290, CInt(&H123F), CInt(&H4565), &H91, &H64, &H39, &HC4, &H92, &H5E, &H46, &H7B)
 FOLDERID_Downloads = iid
End Function
Private Function FOLDERID_Documents() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFDD39AD0, CInt(&H238F), CInt(&H46AF), &HAD, &HB4, &H6C, &H85, &H48, &H3, &H69, &HC7)
 FOLDERID_Documents = iid
End Function
Private Function FOLDERID_Videos() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H18989B1D, CInt(&H99B5), CInt(&H455B), &H84, &H1C, &HAB, &H7C, &H74, &HE4, &HDD, &HFC)
 FOLDERID_Videos = iid
End Function
Private Function FOLDERID_Music() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4BD8D571, CInt(&H6D19), CInt(&H48D3), &HBE, &H97, &H42, &H22, &H20, &H8, &HE, &H43)
 FOLDERID_Music = iid
End Function
Private Function FOLDERID_Pictures() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33E28130, CInt(&H4E1E), CInt(&H4676), &H83, &H5A, &H98, &H39, &H5C, &H3B, &HC3, &HBB)
 FOLDERID_Pictures = iid
End Function
Private Function FOLDERID_Contacts() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56784854, CInt(&HC6CB), CInt(&H462B), &H81, &H69, &H88, &HE3, &H50, &HAC, &HB8, &H82)
 FOLDERID_Contacts = iid
End Function
Private Function FOLDERID_Favorites() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1777F761, CInt(&H68AD), CInt(&H4D8A), &H87, &HBD, &H30, &HB7, &H59, &HFA, &H33, &HDD)
 FOLDERID_Favorites = iid
End Function
Private Function FOLDERID_Links() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBFB9D5E0, CInt(&HC6A9), CInt(&H404C), &HB2, &HB2, &HAE, &H6D, &HB6, &HAF, &H49, &H68)
 FOLDERID_Links = iid
End Function
Private Function FOLDERID_RoamingAppData() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3EB685DB, CInt(&H65F9), CInt(&H4CF6), &HA0, &H3A, &HE3, &HEF, &H65, &H72, &H9F, &H3D)
 FOLDERID_RoamingAppData = iid
End Function
Private Function FOLDERID_Windows() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF38BF404, CInt(&H1D43), CInt(&H42F2), &H93, &H5, &H67, &HDE, &HB, &H28, &HFC, &H23)
 FOLDERID_Windows = iid
End Function
Private Function FOLDERID_Games() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCAC52C1A, CInt(&HB53D), CInt(&H4EDC), &H92, &HD7, &H6B, &H2E, &H8A, &HC1, &H94, &H34)
 FOLDERID_Games = iid
End Function
Private Function FOLDERID_Libraries() As UUID
'{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1B3EA5DC, CInt(&HB587), CInt(&H4786), &HB4, &HEF, &HBD, &H1D, &HC3, &H32, &HAE, &HAE)
FOLDERID_Libraries = iid
End Function
Private Function FOLDERID_PrintersFolder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H76FC4E2D, CInt(&HD6AD), CInt(&H4519), &HA6, &H63, &H37, &HBD, &H56, &H6, &H81, &H85)
 FOLDERID_PrintersFolder = iid
End Function
'WIN8 REQUIRED FOR FOLLOWING:
Private Function FOLDERID_AppsFolder() As UUID
'{1e87508d-89c2-42f0-8a7e-645a0f50ca58}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1E87508D, CInt(&H89C2), CInt(&H42F0), &H8A, &H7E, &H64, &H5A, &HF, &H50, &HCA, &H58)
FOLDERID_AppsFolder = iid
End Function
Private Function FOLDERID_SkyDrive() As UUID
'{A52BBA46-E9E1-435f-B3D9-28DAA648C0F6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA52BBA46, CInt(&HE9E1), CInt(&H435F), &HB3, &HD9, &H28, &HDA, &HA6, &H48, &HC0, &HF6)
FOLDERID_SkyDrive = iid
End Function
Private Function FOLDERID_CommonAdminTools() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD0384E7D, CInt(&HBAC3), CInt(&H4797), &H8F, &H14, &HCB, &HA2, &H29, &HB3, &H92, &HB5)
 FOLDERID_CommonAdminTools = iid
End Function


'----------------------------------------------
'PROPERTYKEYs
Private Sub DEFINE_PROPERTYKEY(Name As PROPERTYKEY, L As Long, w1 As Integer, w2 As Integer, B0 As Byte, b1 As Byte, b2 As Byte, B3 As Byte, b4 As Byte, b5 As Byte, b6 As Byte, b7 As Byte, pid As Long)
  With Name.fmtid
    .Data1 = L
    .Data2 = w1
    .Data3 = w2
    .Data4(0) = B0
    .Data4(1) = b1
    .Data4(2) = b2
    .Data4(3) = B3
    .Data4(4) = b4
    .Data4(5) = b5
    .Data4(6) = b6
    .Data4(7) = b7
  End With
  Name.pid = pid
End Sub
Private Function PKEY_DateCreated() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 15)
PKEY_DateCreated = pkk
End Function
Private Function PKEY_DateModified() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 14)
PKEY_DateModified = pkk
End Function
Private Function PKEY_DateAccessed() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 16)
PKEY_DateAccessed = pkk
End Function
Private Function PKEY_FileName() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H41CF5AE0, &HF75A, &H4806, &HBD, &H87, &H59, &HC7, &HD9, &H24, &H8E, &HB9, 100)
PKEY_FileName = pkk
End Function
Private Function PKEY_ParsingName() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H28636AA6, &H953D, &H11D2, &HB5, &HD6, &H0, &HC0, &H4F, &HD9, &H18, &HD0, 24)
PKEY_ParsingName = pkk
End Function
Private Function PKEY_ParsingPath() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H28636AA6, &H953D, &H11D2, &HB5, &HD6, &H0, &HC0, &H4F, &HD9, &H18, &HD0, 30)
PKEY_ParsingPath = pkk
End Function
Private Function PKEY_Link_TargetParsingPath() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB9B4B3FC, &H2B51, &H4A42, &HB5, &HD8, &H32, &H41, &H46, &HAF, &HCF, &H25, 2)
PKEY_Link_TargetParsingPath = pkk
End Function
Private Function PKEY_Link_TargetExtension() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H7A7D76F4, &HB630, &H4BD7, &H95, &HFF, &H37, &HCC, &H51, &HA9, &H75, &HC9, 2)
PKEY_Link_TargetExtension = pkk
End Function
Private Function PKEY_ThumbnailStream() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HF29F85E0, &H4FF9, &H1068, &HAB, &H91, &H8, &H0, &H2B, &H27, &HB3, &HD9, 27)
PKEY_ThumbnailStream = pkk
End Function
Private Function PKEY_StatusIcons() As PROPERTYKEY
'{7A55582B-BD8C-4475-B94C-B87A388A7899},100
Static iid As PROPERTYKEY
 If (iid.fmtid.Data1 = 0) Then Call DEFINE_PROPERTYKEY(iid, &H7A55582B, CInt(&HBD8C), CInt(&H4475), &HB9, &H4C, &HB8, &H7A, &H38, &H8A, &H78, &H99, 100)
 PKEY_StatusIcons = iid
End Function
Private Function PKEY_Image_VerticalSize() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H6444048F, &H4C8B, &H11D1, &H8B, &H70, &H8, &H0, &H36, &HB1, &H1A, &H3, 4)
PKEY_Image_VerticalSize = pkk
End Function
Private Function PKEY_Image_HorizontalSize() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H6444048F, &H4C8B, &H11D1, &H8B, &H70, &H8, &H0, &H36, &HB1, &H1A, &H3, 3)
PKEY_Image_HorizontalSize = pkk
End Function
Private Function PKEY_ItemTypeText() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 4)
PKEY_ItemTypeText = pkk
End Function
Private Function PKEY_ItemNameDisplay() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 10)
PKEY_ItemNameDisplay = pkk
End Function
Private Function PKEY_ItemFolderPathDisplayNarrow() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HDABD30ED, &H43, &H4789, &HA7, &HF8, &HD0, &H13, &HA4, &H73, &H66, &H22, 100)
PKEY_ItemFolderPathDisplayNarrow = pkk
End Function
Private Function PKEY_Size() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 12)
PKEY_Size = pkk
End Function
Private Function PKEY_FileAttributes() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HB725F130, &H47EF, &H101A, &HA5, &HF1, &H2, &H60, &H8C, &H9E, &HEB, &HAC, 13)
PKEY_FileAttributes = pkk
End Function
Private Function PKEY_SFGAOFlags() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H28636AA6, &H953D, &H11D2, &HB5, &HD6, &H0, &HC0, &H4F, &HD9, &H18, &HD0, 25)
PKEY_SFGAOFlags = pkk
End Function
Private Function PKEY_FileExtension() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HE4F10A3C, &H49E6, &H405D, &H82, &H88, &HA2, &H3B, &HD4, &HEE, &HAA, &H6C, 100)
PKEY_FileExtension = pkk
End Function
Private Function PKEY_PropList_PreviewDetails() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HC9944A21, &HA406, &H48FE, &H82, &H25, &HAE, &HC7, &HE2, &H4C, &H21, &H1B, 8)
PKEY_PropList_PreviewDetails = pkk
End Function
Private Function PKEY_PropList_InfoTip() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HC9944A21, &HA406, &H48FE, &H82, &H25, &HAE, &HC7, &HE2, &H4C, &H21, &H1B, 4)
PKEY_PropList_InfoTip = pkk
End Function
Private Function PKEY_PropList_FileOperationPrompt() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HC9944A21, &HA406, &H48FE, &H82, &H25, &HAE, &HC7, &HE2, &H4C, &H21, &H1B, 10)
PKEY_PropList_FileOperationPrompt = pkk
End Function
Private Function PKEY_PropList_TileInfo() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HC9944A21, &HA406, &H48FE, &H82, &H25, &HAE, &HC7, &HE2, &H4C, &H21, &H1B, 3)
PKEY_PropList_TileInfo = pkk
End Function
Private Function PKEY_PropList_FullDetails() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &HC9944A21, &HA406, &H48FE, &H82, &H25, &HAE, &HC7, &HE2, &H4C, &H21, &H1B, 2)
PKEY_PropList_FullDetails = pkk
End Function
Private Function PKEY_Kind() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H1E3EE840, &HBC2B, &H476C, &H82, &H37, &H2A, &HCD, &H1A, &H83, &H9B, &H22, 3)
PKEY_Kind = pkk
End Function
Private Function PKEY_Rating() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H64440492, &H4C8B, &H11D1, &H8B, &H70, &H8, &H0, &H36, &HB1, &H1A, &H3, 9)
PKEY_Rating = pkk
End Function
Private Function PKEY_PercentFull() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H9B174B35, &H40FF, &H11D2, &HA2, &H7E, &H0, &HC0, &H4F, &HC3, &H8, &H71, 5)
PKEY_PercentFull = pkk
End Function
Private Function PKEY_FreeSpace() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H9B174B35, &H40FF, &H11D2, &HA2, &H7E, &H0, &HC0, &H4F, &HC3, &H8, &H71, 2)
PKEY_FreeSpace = pkk
End Function
Private Function PKEY_Computer_DecoratedFreeSpace() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H9B174B35, &H40FF, &H11D2, &HA2, &H7E, &H0, &HC0, &H4F, &HC3, &H8, &H71, 7)
PKEY_Computer_DecoratedFreeSpace = pkk
End Function
Private Function WPD_CLIENT_NAME() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H204D9F0C, &H2292, &H4080, &H9F, &H42, &H40, &H66, &H4E, &H70, &HF8, &H59, 2)
 WPD_CLIENT_NAME = pkk
End Function
Private Function WPD_CLIENT_MAJOR_VERSION() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H204D9F0C, &H2292, &H4080, &H9F, &H42, &H40, &H66, &H4E, &H70, &HF8, &H59, 3)
 WPD_CLIENT_MAJOR_VERSION = pkk
End Function
Private Function WPD_CLIENT_MINOR_VERSION() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H204D9F0C, &H2292, &H4080, &H9F, &H42, &H40, &H66, &H4E, &H70, &HF8, &H59, 4)
 WPD_CLIENT_MINOR_VERSION = pkk
End Function
Private Function WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H204D9F0C, &H2292, &H4080, &H9F, &H42, &H40, &H66, &H4E, &H70, &HF8, &H59, 8)
 WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE = pkk
End Function
Private Function WPD_DEVICE_FRIENDLY_NAME() As PROPERTYKEY
Static pkk As PROPERTYKEY
 If (pkk.fmtid.Data1 = 0&) Then Call DEFINE_PROPERTYKEY(pkk, &H26D4979A, &HE643, &H4626, &H9E, &H2B, &H73, &H6D, &HC0, &HC9, &H2F, &HDC, 12)
 WPD_DEVICE_FRIENDLY_NAME = pkk
End Function

'=================================================================
'End IID Defs
'=================================================================



Private Function dbg_lkuph(hw As LongPtr) As String
Select Case hw
     Case hViewButton: dbg_lkuph = "cmdView"
     Case hBkmButton: dbg_lkuph = "cmdBkm"
     Case hUpButton: dbg_lkuph = "cmdUp"
     Case hSearchBox: dbg_lkuph = "hSearchBox"
     Case hCombo: dbg_lkuph = "hCombo"
     Case hCBEd: dbg_lkuph = "hCbEd"
     Case hLVS: dbg_lkuph = "hLVS"
End Select
End Function
Private Function IsIDE() As Boolean
   Dim buff As String
   Dim Success As Long
   
   buff = Space$(MAX_PATH)
   Success = GetModuleFileName(App.hInstance, buff, Len(buff))
   
   If Success > 0 Then
     'Change the VB exe name here as appropriate
     'for your version. The case change ensures this
     'works regardless as to how the exe is cased on
     'the machine.
      IsIDE = InStr(LCase$(buff), gVBExeName) > 0
   End If
End Function

Private Function GetLVItemlParam(hwndLV As LongPtr, iItem As Long) As LongPtr
  Dim lvi As LVITEM
  
  lvi.Mask = LVIF_PARAM
  lvi.iItem = iItem
  If ListView_GetItem(hwndLV, lvi) Then
    GetLVItemlParam = lvi.lParam
  End If

End Function
        

' ============================================================
' listview macros
Private Function ListView_ApproximateViewRect(hWnd As LongPtr, iWidth As Long, _
                                                iHeight As Long, iCount As Long) As LongPtr
  ListView_ApproximateViewRect = SendMessage(hWnd, _
                                            LVM_APPROXIMATEVIEWRECT, _
                                            ByVal iCount, _
                                            ByVal MAKELPARAM(iWidth, iHeight))
End Function
Private Function ListView_Arrange(hwndLV As LongPtr, code As LVA_Flags) As Boolean
  ListView_Arrange = SendMessage(hwndLV, LVM_ARRANGE, ByVal code, 0)
End Function
Private Function ListView_CreateDragImage(hWnd As LongPtr, i As Long, lpptUpLeft As POINT) As LongPtr
  ListView_CreateDragImage = SendMessage(hWnd, LVM_CREATEDRAGIMAGE, ByVal i, lpptUpLeft)
End Function
Private Function ListView_DeleteItem(hWnd As LongPtr, i As Long) As Boolean
  ListView_DeleteItem = SendMessage(hWnd, LVM_DELETEITEM, ByVal i, 0)
End Function
Private Function ListView_EditLabel(hwndLV As LongPtr, i As Long) As LongPtr
  ListView_EditLabel = SendMessage(hwndLV, LVM_EDITLABEL, ByVal i, 0)
End Function
Private Function ListView_GetBkColor(hWnd As LongPtr) As LongPtr
  ListView_GetBkColor = SendMessage(hWnd, LVM_GETBKCOLOR, 0, 0)
End Function
 
Private Function ListView_SetBkColor(hWnd As LongPtr, clrBk As Long) As Boolean
  ListView_SetBkColor = SendMessage(hWnd, LVM_SETBKCOLOR, 0, ByVal clrBk)
End Function
Private Function ListView_SetView(hWnd As LongPtr, iView As ucsb_LV_VIEW) As LongPtr
  ListView_SetView = SendMessage(hWnd, LVM_SETVIEW, iView, ByVal 0&)
End Function
Private Function ListView_SetWorkAreas(hWnd As LongPtr, nWorkAreas As Long, prc() As RECT) As Boolean
  ListView_SetWorkAreas = SendMessage(hWnd, LVM_SETWORKAREAS, ByVal nWorkAreas, prc(0))
End Function

Private Function ListView_GetWorkAreas(hWnd As LongPtr, nWorkAreas As Long, prc() As RECT) As Boolean
  ListView_GetWorkAreas = SendMessage(hWnd, LVM_GETWORKAREAS, ByVal nWorkAreas, prc(0))
End Function

Private Function ListView_GetNumberOfWorkAreas(hWnd As Long, pnWorkAreas As Long) As Boolean
  ListView_GetNumberOfWorkAreas = SendMessage(hWnd, LVM_GETNUMBEROFWORKAREAS, 0, pnWorkAreas)
End Function

Private Function ListView_GetSelectionMark(hWnd As LongPtr) As LongPtr
  ListView_GetSelectionMark = SendMessage(hWnd, LVM_GETSELECTIONMARK, 0, 0)
End Function

Private Function ListView_SetSelectionMark(hWnd As LongPtr, i As Long) As LongPtr
  ListView_SetSelectionMark = SendMessage(hWnd, LVM_SETSELECTIONMARK, 0, ByVal i)
End Function

Private Function ListView_SetHoverTime(hwndLV As LongPtr, dwHoverTimeMs As Long) As LongPtr
  ListView_SetHoverTime = SendMessage(hwndLV, LVM_SETHOVERTIME, 0, ByVal dwHoverTimeMs)
End Function

Private Function ListView_GetHoverTime(hwndLV As LongPtr) As LongPtr
  ListView_GetHoverTime = SendMessage(hwndLV, LVM_GETHOVERTIME, 0, 0)
End Function
Private Function ListView_GetStringWidth(hwndLV As LongPtr, psz As String) As LongPtr
  ListView_GetStringWidth = SendMessage(hwndLV, LVM_GETSTRINGWIDTH, 0, ByVal psz)
End Function
 Private Function ListView_GetSubItemRect(hWnd As LongPtr, iItem As Long, iSubItem As Long, _
                                                              code As LVIR_Flags, prc As RECT) As Boolean
  prc.Top = iSubItem
  prc.Left = code
  ListView_GetSubItemRect = SendMessage(hWnd, LVM_GETSUBITEMRECT, ByVal iItem, prc)
End Function
Private Function ListView_GetTextBkColor(hWnd As LongPtr) As LongPtr
  ListView_GetTextBkColor = SendMessage(hWnd, LVM_GETTEXTBKCOLOR, 0, 0)
End Function
 
Private Function ListView_SetTextBkColor(hWnd As LongPtr, ClrTextBk As Long) As Boolean
  ListView_SetTextBkColor = SendMessage(hWnd, LVM_SETTEXTBKCOLOR, 0, ByVal ClrTextBk)
End Function
Private Function ListView_GetTextColor(hWnd As LongPtr) As LongPtr
  ListView_GetTextColor = SendMessage(hWnd, LVM_GETTEXTCOLOR, 0, 0)
End Function
 
Private Function ListView_SetTextColor(hWnd As LongPtr, ClrText As Long) As Boolean
  ListView_SetTextColor = SendMessage(hWnd, LVM_SETTEXTCOLOR, 0, ByVal ClrText)
End Function
Private Function ListView_GetTopIndex(hwndLV As LongPtr) As LongPtr
  ListView_GetTopIndex = SendMessage(hwndLV, LVM_GETTOPINDEX, 0, 0)
End Function
 
Private Function ListView_SubItemHitTest(hWnd As LongPtr, plvhti As LVHITTESTINFO) As LongPtr
  ListView_SubItemHitTest = SendMessage(hWnd, LVM_SUBITEMHITTEST, 0, plvhti)
End Function


Private Function ListView_SetToolTips(hwndLV As LongPtr, hwndNewHwnd As LongPtr) As LongPtr
  ListView_SetToolTips = SendMessage(hwndLV, LVM_SETTOOLTIPS, ByVal hwndNewHwnd, 0)
End Function

Private Function ListView_GetToolTips(hwndLV As LongPtr) As LongPtr
  ListView_GetToolTips = SendMessage(hwndLV, LVM_GETTOOLTIPS, 0, 0)
End Function
Private Function ListView_GetISearchString(hwndLV As LongPtr, lpsz As String) As Boolean
  ListView_GetISearchString = SendMessage(hwndLV, LVM_GETISEARCHSTRING, 0, ByVal lpsz)
End Function


Private Function ListView_SetBkImage(hWnd As LongPtr, plvbki As LVBKIMAGE) As Boolean
  ListView_SetBkImage = SendMessage(hWnd, LVM_SETBKIMAGE, 0, plvbki)
End Function

Private Function ListView_GetBkImage(hWnd As LongPtr, plvbki As LVBKIMAGE) As Boolean
  ListView_GetBkImage = SendMessage(hWnd, LVM_GETBKIMAGE, 0, plvbki)
End Function
Private Function ListView_SetUnicodeFormat(hWnd As LongPtr, fUnicode As Boolean) As Boolean
  ListView_SetUnicodeFormat = SendMessage(hWnd, LVM_SETUNICODEFORMAT, ByVal fUnicode, 0)
End Function

Private Function ListView_GetUnicodeFormat(hWnd As LongPtr) As Boolean
  ListView_GetUnicodeFormat = SendMessage(hWnd, LVM_GETUNICODEFORMAT, 0, 0)
End Function

Private Function ListView_SetExtendedListViewStyleEx(hwndLV As LongPtr, dwMask As Long, dw As Long) As LongPtr
  ListView_SetExtendedListViewStyleEx = SendMessage(hwndLV, LVM_SETEXTENDEDLISTVIEWSTYLE, _
                                                                                    ByVal dwMask, ByVal dw)
End Function

Private Function ListView_SetColumnOrderArray(hWnd As LongPtr, iCount As Long, lpiArray As LongPtr) As Boolean
  ListView_SetColumnOrderArray = SendMessage(hWnd, LVM_SETCOLUMNORDERARRAY, ByVal iCount, lpiArray)
End Function

Private Function ListView_GetColumnOrderArray(hWnd As LongPtr, iCount As Long, lpiArray As LongPtr) As Boolean
  ListView_GetColumnOrderArray = SendMessage(hWnd, LVM_GETCOLUMNORDERARRAY, ByVal iCount, lpiArray)
End Function
Private Function ListView_SetImageList(hWnd As LongPtr, himl As LongPtr, iImageList As LV_ImageList) As LongPtr
  ListView_SetImageList = SendMessage(hWnd, LVM_SETIMAGELIST, ByVal iImageList, ByVal himl)
End Function
Private Function ListView_GetImageList(hWnd As LongPtr, iImageList As LV_ImageList) As LongPtr
  ListView_GetImageList = SendMessage(hWnd, LVM_GETIMAGELIST, ByVal iImageList, 0)
End Function
 
Private Function ListView_GetHeader(hWnd As LongPtr) As LongPtr
  ListView_GetHeader = SendMessage(hWnd, LVM_GETHEADER, 0, 0)
End Function
Private Function ListView_GetItem(hWnd As LongPtr, pItem As LVITEM) As Boolean
  ListView_GetItem = SendMessage(hWnd, LVM_GETITEM, 0, pItem)
End Function
 
Private Function ListView_SetItem(hWnd As LongPtr, pItem As LVITEM) As Boolean
  ListView_SetItem = SendMessage(hWnd, LVM_SETITEM, 0, pItem)
End Function
'
Private Function ListView_SetCallbackMask(hWnd As Long, Mask As Long) As Boolean
  ListView_SetCallbackMask = SendMessage(hWnd, LVM_SETCALLBACKMASK, ByVal Mask, 0)
End Function
Private Function ListView_GetCallbackMask(hWnd As LongPtr) As LongPtr   ' LVStyles
  ListView_GetCallbackMask = SendMessage(hWnd, LVM_GETCALLBACKMASK, 0, 0)
End Function
Private Function ListView_GetColumn(hWnd As LongPtr, iCol As Long, pcol As LVCOLUMN) As Boolean
  ListView_GetColumn = SendMessage(hWnd, LVM_GETCOLUMN, ByVal iCol, pcol)
End Function
 
Private Function ListView_SetColumn(hWnd As LongPtr, iCol As Long, pcol As LVCOLUMN) As Boolean
  ListView_SetColumn = SendMessage(hWnd, LVM_SETCOLUMN, ByVal iCol, pcol)
End Function
Private Function ListView_GetCountPerPage(hwndLV As LongPtr) As LongPtr
  ListView_GetCountPerPage = SendMessage(hwndLV, LVM_GETCOUNTPERPAGE, 0, 0)
End Function
 
Private Function ListView_GetOrigin(hwndLV As LongPtr, ppt As POINT) As Boolean
  ListView_GetOrigin = SendMessage(hwndLV, LVM_GETORIGIN, 0, ppt)
End Function
Private Function ListView_GetEditControl(hwndLV As LongPtr) As LongPtr
  ListView_GetEditControl = SendMessage(hwndLV, LVM_GETEDITCONTROL, 0, 0)
End Function
Private Function ListView_GetExtendedListViewStyle(hwndLV As LongPtr) As LongPtr
  ListView_GetExtendedListViewStyle = SendMessage(hwndLV, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
End Function
Private Function ListView_SetHotItem(hWnd As LongPtr, i As Long) As LongPtr
  ListView_SetHotItem = SendMessage(hWnd, LVM_SETHOTITEM, ByVal i, 0)
End Function
 
Private Function ListView_GetHotItem(hWnd As LongPtr) As LongPtr
  ListView_GetHotItem = SendMessage(hWnd, LVM_GETHOTITEM, 0, 0)
End Function
 
Private Function ListView_SetHotCursor(hWnd As LongPtr, hcur As LongPtr) As LongPtr
  ListView_SetHotCursor = SendMessage(hWnd, LVM_SETHOTCURSOR, 0, ByVal hcur)
End Function
 
Private Function ListView_GetHotCursor(hWnd As LongPtr) As LongPtr
  ListView_GetHotCursor = SendMessage(hWnd, LVM_GETHOTCURSOR, 0, 0)
End Function

Private Sub ListView_SetItemText(hwndLV As LongPtr, i As Long, iSubItem As Long, pszText As String)
  Dim lvi As LVITEM
  lvi.iSubItem = iSubItem
  lvi.pszText = pszText
  lvi.cchTextMax = Len(pszText) + 1
  SendMessage hwndLV, LVM_SETITEMTEXT, ByVal i, lvi
End Sub
Private Function ListView_SetIconSpacing(hwndLV As LongPtr, CX As Long, CY As Long) As LongPtr
  ListView_SetIconSpacing = SendMessage(hwndLV, LVM_SETICONSPACING, 0, ByVal MakeLong(CX, CY))
End Function
Private Sub ListView_SetItemCount(hwndLV As LongPtr, cItems As Long)
  SendMessage hwndLV, LVM_SETITEMCOUNT, ByVal cItems, 0
End Sub

Private Sub ListView_SetItemCountEx(hwndLV As LongPtr, cItems As Long, dwFlags As LVSIC_Flags)
  SendMessage hwndLV, LVM_SETITEMCOUNT, ByVal cItems, ByVal dwFlags
End Sub
'

' ListView_GetNextItem

Private Function ListView_GetNextItem(hWnd As LongPtr, i As Long, Flags As LVNI_Flags) As Long
  ListView_GetNextItem = CLng(SendMessage(hWnd, LVM_GETNEXTITEM, ByVal i, ByVal Flags))    ' ByVal MAKELPARAM(flags, 0))
End Function

' Returns the index of the item that is selected and has the focus rectangle (user-defined)

Private Function ListView_GetSelectedItem(hwndLV As LongPtr) As Long
  ListView_GetSelectedItem = ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED Or LVNI_SELECTED)
End Function
Private Function ListView_FindItem(hWnd As LongPtr, iStart As Long, plvfi As LVFINDINFOA) As LongPtr
  ListView_FindItem = SendMessage(hWnd, LVM_FINDITEM, ByVal iStart, plvfi)
End Function
Private Function ListView_FindItemW(hWnd As LongPtr, iStart As Long, plvfi As LVFINDINFOW) As LongPtr
  ListView_FindItemW = SendMessageW(hWnd, LVM_FINDITEM, ByVal iStart, plvfi)
End Function
Private Function ListView_GetItemRect(hWnd As LongPtr, i As Long, prc As RECT, code As LVIR_Flags) As Boolean
  prc.Left = code
  ListView_GetItemRect = SendMessage(hWnd, LVM_GETITEMRECT, ByVal i, prc)
End Function
Private Function ListView_GetCheckState(hwndLV As LongPtr, iIndex As Long) As Long   ' updated
  Dim dwState As Long
  dwState = CLng(SendMessage(hwndLV, LVM_GETITEMSTATE, ByVal iIndex, ByVal LVIS_STATEIMAGEMASK))
  ListView_GetCheckState = (dwState \ 2 ^ 12) - 1
  '((((UINT)(SendMessage(hwndLV, LVM_GETITEMSTATE, ByVal i, LVIS_STATEIMAGEMASK))) >> 12) -1)
End Function
Private Function ListView_SetCheckState(hwndLV As LongPtr, i As Long, fCheck As Long) As LongPtr
'#define ListView_SetCheckState(hwndLV, i, fCheck) \
'  ListView_SetItemState(hwndLV, i, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
ListView_SetCheckState = ListView_SetItemState(hwndLV, i, IndexToStateImageMask(IIf(fCheck, 2, 1)), LVIS_STATEIMAGEMASK)
End Function

Private Function ListView_GetItemCount(hWnd As LongPtr) As LongPtr
  ListView_GetItemCount = SendMessage(hWnd, LVM_GETITEMCOUNT, 0, 0)
End Function
Private Function ListView_GetItemPosition(hwndLV As LongPtr, i As Long, ppt As POINT) As Boolean
  ListView_GetItemPosition = SendMessage(hwndLV, LVM_GETITEMPOSITION, ByVal i, ppt)
End Function
Private Function ListView_SetItemPosition(hwndLV As LongPtr, i As Long, X As Long, Y As Long) As Boolean
  ListView_SetItemPosition = SendMessage(hwndLV, LVM_SETITEMPOSITION, ByVal i, ByVal MAKELPARAM(X, Y))
End Function
Private Sub ListView_SetItemPosition32(hwndLV As LongPtr, i As Long, X As Long, Y As Long)
  Dim ptNewPos As POINT
  ptNewPos.x = X
  ptNewPos.y = Y
  SendMessage hwndLV, LVM_SETITEMPOSITION32, ByVal i, ptNewPos
End Sub
Private Function ListView_SetSelectedItem(hwndLV As LongPtr, i As Long) As Boolean
  ListView_SetSelectedItem = ListView_SetItemState(hwndLV, i, LVIS_FOCUSED Or LVIS_SELECTED, _
                                                                                                     LVIS_FOCUSED Or LVIS_SELECTED)
End Function
Private Function ListView_Update(hwndLV As LongPtr, i As Long) As Boolean
  ListView_Update = SendMessage(hwndLV, LVM_UPDATE, ByVal i, 0)
End Function

Private Function ListView_GetItemSpacing(hwndLV As LongPtr, fSmall As Boolean) As LongPtr
  ListView_GetItemSpacing = SendMessage(hwndLV, LVM_GETITEMSPACING, ByVal fSmall, 0)
End Function
Private Function ListView_GetItemState(hwndLV As LongPtr, i As Long, Mask As LVITEM_state) As LongPtr   ' LVITEM_state
  ListView_GetItemState = SendMessage(hwndLV, LVM_GETITEMSTATE, ByVal i, ByVal Mask)
End Function
Private Sub ListView_GetItemText(hwndLV As LongPtr, i As Long, iSubItem As Long, _
                                                     pszText As LongPtr, cchTextMax As Long)
  Dim lvi As LVITEM
  lvi.iSubItem = iSubItem
  lvi.cchTextMax = cchTextMax
  lvi.pszText = pszText
  SendMessage hwndLV, LVM_GETITEMTEXT, ByVal i, lvi
  pszText = lvi.pszText   ' fills pszText w/ pointer
End Sub


Private Function ListView_HitTest(hwndLV As LongPtr, pInfo As LVHITTESTINFO) As LongPtr
  ListView_HitTest = SendMessage(hwndLV, LVM_HITTEST, 0, pInfo)
End Function
 
Private Function ListView_InsertItem(hWnd As LongPtr, pItem As LVITEM) As LongPtr
  ListView_InsertItem = SendMessage(hWnd, LVM_INSERTITEM, 0, pItem)
End Function

Private Function ListView_DeleteColumn(hWnd As LongPtr, iCol As Long) As Boolean
  ListView_DeleteColumn = SendMessage(hWnd, LVM_DELETECOLUMN, ByVal iCol, 0)
End Function

Private Function ListView_EnsureVisible(hwndLV As LongPtr, i As Long, fPartialOK As Long) As Boolean
  ListView_EnsureVisible = SendMessage(hwndLV, LVM_ENSUREVISIBLE, ByVal i, ByVal fPartialOK)   ' ByVal MAKELPARAM(Abs(fPartialOK), 0))
End Function

Private Function ListView_InsertColumn(hWnd As LongPtr, iCol As Long, pcol As LVCOLUMN) As LongPtr
  ListView_InsertColumn = SendMessage(hWnd, LVM_INSERTCOLUMN, ByVal iCol, pcol)
End Function
Private Function ListView_Scroll(hwndLV As LongPtr, DX As Long, DY As Long) As Boolean
  ListView_Scroll = SendMessage(hwndLV, LVM_SCROLL, ByVal DX, ByVal DY)
End Function
 

 Private Function ListView_DeleteAllItems(hWnd As LongPtr) As Boolean
  ListView_DeleteAllItems = SendMessage(hWnd, LVM_DELETEALLITEMS, 0, 0)
End Function

Private Function ListView_GetColumnWidth(hWnd As LongPtr, iCol As Long) As LongPtr
  ListView_GetColumnWidth = SendMessage(hWnd, LVM_GETCOLUMNWIDTH, ByVal iCol, 0)
End Function
 
Private Function ListView_SetColumnWidth(hWnd As LongPtr, iCol As Long, CX As Long) As Boolean
  ListView_SetColumnWidth = SendMessage(hWnd, LVM_SETCOLUMNWIDTH, ByVal iCol, ByVal MAKELPARAM(CX, 0))
End Function
Private Function ListView_RedrawItems(hwndLV As LongPtr, iFirst As Long, iLast As Long) As Boolean
  ListView_RedrawItems = SendMessage(hwndLV, LVM_REDRAWITEMS, ByVal iFirst, ByVal iLast)
End Function

Private Function ListView_GetSelectedCount(hwndLV As LongPtr) As LongPtr
  ListView_GetSelectedCount = SendMessage(hwndLV, LVM_GETSELECTEDCOUNT, 0, 0)
End Function
Private Function ListView_GetView(hWnd As LongPtr) As LongPtr

ListView_GetView = SendMessage(hWnd, LVM_GETVIEW, 0, ByVal 0&)

End Function
Private Function ListView_GetViewRect(hWnd As LongPtr, prc As RECT) As Boolean
  ListView_GetViewRect = SendMessage(hWnd, LVM_GETVIEWRECT, 0, prc)
End Function
' ListView_SetItemState

Private Function ListView_SetItemState(hwndLV As LongPtr, i As Long, State As LVITEM_state, Mask As LVITEM_state) As Boolean
  Dim lvi As LVITEM
  lvi.State = State
  lvi.StateMask = Mask
  ListView_SetItemState = SendMessage(hwndLV, LVM_SETITEMSTATE, ByVal i, lvi)
End Function

' Selects all listview items. The item with the focus rectangle maintains it (user-defined).

Private Function ListView_SelectAll(hwndLV As LongPtr) As Boolean
  ListView_SelectAll = ListView_SetItemState(hwndLV, -1, LVIS_SELECTED, LVIS_SELECTED)
End Function
Private Function ListView_SelectNone(hwndLV As LongPtr) As Boolean
  Dim lv As LVITEM
   
   With lv
      .Mask = LVIF_STATE
      .State = False
      .StateMask = LVIS_SELECTED
   End With
      
   ListView_SelectNone = SendMessage(hwndLV, LVM_SETITEMSTATE, -1, lv)

End Function
 
' Selects the specified item and gives it the focus rectangle.
' does not de-select any currently selected items (user-defined).

Private Function ListView_SetFocusedItem(hwndLV As LongPtr, i As Long) As Boolean
  ListView_SetFocusedItem = ListView_SetItemState(hwndLV, i, LVIS_FOCUSED Or LVIS_SELECTED, LVIS_FOCUSED Or LVIS_SELECTED)
End Function

Private Function ListView_SortItems(hwndLV As LongPtr, pfnCompare As LongPtr, lParamSort As LongPtr) As Boolean
  ListView_SortItems = SendMessage(hwndLV, LVM_SORTITEMS, ByVal lParamSort, ByVal pfnCompare)
End Function
Private Function ListView_SortItemsEx(hwndLV As LongPtr, pfnCompare As LongPtr, lParamSort As LongPtr) As Boolean
  ListView_SortItemsEx = SendMessage(hwndLV, LVM_SORTITEMSEX, ByVal lParamSort, ByVal pfnCompare)
End Function



Private Function ListView_SetExtendedStyle(hWnd As LongPtr, lST As ucsb_LVStylesEx) As LongPtr
Dim lStyle As LongPtr

lStyle = SendMessage(hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
lStyle = lStyle Or lST
Call SendMessage(hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, ByVal lStyle)

End Function
Private Function ListView_GetStyle(hWnd As LongPtr) As ucsb_LVStyles
ListView_GetStyle = CLng(GetWindowLong(hWnd, GWL_STYLE))
End Function
Private Function ListView_SetStyle(hWnd As LongPtr, dwStyle As ucsb_LVStyles) As LongPtr
ListView_SetStyle = SetWindowLong(hWnd, GWL_STYLE, dwStyle)
End Function

'THE MACROS BELOW ARE ONLY FOR VISTA AND HIGHER
Private Function ListView_CancelEditLabel(hWnd As LongPtr) As LongPtr

ListView_CancelEditLabel = SendMessage(hWnd, LVM_CANCELEDITLABEL, 0, ByVal 0&)
End Function
Private Function ListView_EnableGroupView(hWnd As LongPtr, fEnable As Long) As LongPtr

ListView_EnableGroupView = SendMessage(hWnd, LVM_ENABLEGROUPVIEW, fEnable, ByVal 0&)
End Function
Private Function ListView_GetEmptyText(hWnd As LongPtr, cchText As Long, pszText As String) As LongPtr

ListView_GetEmptyText = SendMessage(hWnd, LVM_GETEMPTYTEXT, cchText, ByVal pszText)
End Function

Private Function ListView_GetFocusedGroup(hWnd As LongPtr) As LongPtr
'#define ListView_GetFocusedGroup(hwnd) \
'    SNDMSG((hwnd), LVM_GETFOCUSEDGROUP, 0, 0)
ListView_GetFocusedGroup = SendMessage(hWnd, LVM_GETFOCUSEDGROUP, 0, ByVal 0&)
End Function

Private Function ListView_GetFooterInfo(hWnd As LongPtr, plvfi As LongPtr) As LongPtr
'#define ListView_GetFooterInfo(hwnd, plvfi) \
'    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERINFO, (WPARAM)(0), (LPARAM)(plvfi))
ListView_GetFooterInfo = SendMessage(hWnd, LVM_GETFOOTERINFO, 0, ByVal plvfi)
End Function
Private Function ListView_GetFooterItem(hWnd As LongPtr, iItem As Long, pfi As LVFOOTERITEM) As LongPtr
'#define ListView_GetFooterItem(hwnd, iItem, pfi) \
'    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERITEM, (WPARAM)(iItem), (LPARAM)(pfi))
ListView_GetFooterItem = SendMessage(hWnd, LVM_GETFOOTERITEM, iItem, pfi)
End Function
Private Function ListView_GetFooterItemRect(hWnd As LongPtr, iItem As Long, prc As RECT) As LongPtr
'#define ListView_GetFooterItemRect(hwnd, iItem, prc) \
'    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERITEMRECT, (WPARAM)(iItem), (LPARAM)(prc))
ListView_GetFooterItemRect = SendMessage(hWnd, LVM_GETFOOTERITEMRECT, iItem, prc)
End Function
Private Function ListView_GetFooterRect(hWnd As LongPtr, prc As RECT) As LongPtr
'#define ListView_GetFooterRect(hwnd, prc) \
'    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERRECT, (WPARAM)(0), (LPARAM)(prc))
ListView_GetFooterRect = SendMessage(hWnd, LVM_GETFOOTERRECT, 0, prc)
End Function
Private Function ListView_GetGroupHeaderImageList(hWnd As LongPtr) As LongPtr
'#define ListView_GetGroupHeaderImageList(hwnd) \
'    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)LVSIL_GROUPHEADER, 0L)
ListView_GetGroupHeaderImageList = SendMessage(hWnd, LVM_GETIMAGELIST, LVSIL_GROUPHEADER, ByVal 0&)
End Function
Private Function ListView_SetGroupHeaderImageList(hWnd As LongPtr, himl As LongPtr) As LongPtr
'#define ListView_GetGroupHeaderImageList(hwnd) \
'    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)LVSIL_GROUPHEADER, 0L)
ListView_SetGroupHeaderImageList = SendMessage(hWnd, LVM_SETIMAGELIST, LVSIL_GROUPHEADER, ByVal himl)
End Function
Private Function ListView_GetGroupInfo(hWnd As LongPtr, iGroupId As Long, pgrp As LVGROUP) As LongPtr
'#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) \
'    SNDMSG((hwnd), LVM_GETGROUPINFO, (WPARAM)(iGroupId), (LPARAM)(pgrp))
ListView_GetGroupInfo = SendMessage(hWnd, LVM_GETGROUPINFO, iGroupId, pgrp)
End Function
Private Function ListView_SetGroupInfo(hWnd As LongPtr, iGroupId As Long, pgrp As LVGROUP) As LongPtr
'#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) \
'    SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)(iGroupId), (LPARAM)(pgrp))
ListView_SetGroupInfo = SendMessage(hWnd, LVM_SETGROUPINFO, iGroupId, pgrp)
End Function
Private Function ListView_GetGroupInfoByIndex(hWnd As LongPtr, iIndex As Long, pgrp As LVGROUP) As LongPtr
'#define ListView_GetGroupInfoByIndex(hwnd, iIndex, pgrp) \
'    SNDMSG((hwnd), LVM_GETGROUPINFOBYINDEX, (WPARAM)(iIndex), (LPARAM)(pgrp))
ListView_GetGroupInfoByIndex = SendMessage(hWnd, LVM_GETGROUPINFOBYINDEX, iIndex, pgrp)
End Function
Private Function ListView_SetGroupMetrics(hWnd As LongPtr, pGroupMetrics As LVGROUPMETRICS) As LongPtr
'#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) \
'    SNDMSG((hwnd), LVM_SETGROUPMETRICS, 0, (LPARAM)(pGroupMetrics))
ListView_SetGroupMetrics = SendMessage(hWnd, LVM_SETGROUPMETRICS, 0, pGroupMetrics)
End Function
Private Function ListView_GetGroupMetrics(hWnd As LongPtr, pGroupMetrics As LVGROUPMETRICS) As LongPtr
'#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) \
'    SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)(pGroupMetrics))
ListView_GetGroupMetrics = SendMessage(hWnd, LVM_GETGROUPMETRICS, 0, pGroupMetrics)
End Function
Private Function ListView_GetGroupRect(hWnd As LongPtr, iGroup As Long, Item As LVGROUPRECT, rc As RECT) As LongPtr
        rc.Top = Item
        ListView_GetGroupRect = SendMessage(hWnd, LVM_GETGROUPRECT, iGroup, rc)
End Function
Private Function ListView_GetGroupCount(hWnd As LongPtr, iGroup As Long) As LongPtr
Dim LVG As LVGROUP
    LVG.Mask = LVGF_ITEMS
    LVG.cbSize = LenB(LVG)
    Call SendMessage(hWnd, LVM_GETGROUPINFO, iGroup, LVG)
ListView_GetGroupCount = LVG.cItems
End Function
Private Function ListView_GetGroupState(hWnd As LongPtr, dwGroupId As Long, dwMask As LVGROUPSTATE) As LongPtr
ListView_GetGroupState = SendMessage(hWnd, LVM_GETGROUPSTATE, dwGroupId, ByVal dwMask)
End Function

'#define ListView_SetGroupState(hwnd, dwGroupId, dwMask, dwState) \
'{ LVGROUP _macro_lvg;\
'  _macro_lvg.cbSize = sizeof(_macro_lvg);\
'  _macro_lvg.mask = LVGF_STATE;\
'  _macro_lvg.stateMask = dwMask;\
'  _macro_lvg.state = dwState;\
'  SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)(dwGroupId), (LPARAM)(LVGROUP *)&_macro_lvg);\
Private Function ListView_SetGroupState(hWnd As LongPtr, dwGroupId As Long, dwMask As LVGROUPSTATE, dwState As LVGROUPSTATE) As LongPtr
Dim LVG As LVGROUP
LVG.cbSize = LenB(LVG)
LVG.Mask = LVGF_STATE
LVG.StateMask = dwMask
LVG.State = dwState
ListView_SetGroupState = SendMessage(hWnd, LVM_SETGROUPINFO, dwGroupId, LVG)
End Function
Private Function ListView_GetInsertMark(hWnd As LongPtr, LVIM As LVINSERTMARK) As LongPtr
'#define ListView_GetInsertMark(hwnd, lvim) \
'    (BOOL)SNDMSG((hwnd), LVM_GETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
ListView_GetInsertMark = SendMessage(hWnd, LVM_GETINSERTMARK, 0, LVIM)
End Function
Private Function ListView_SetInsertMark(hWnd As LongPtr, LVIM As LVINSERTMARK) As LongPtr
'#define ListView_SetInsertMark(hwnd, lvim) \
'    (BOOL)SNDMSG((hwnd), LVM_SETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
ListView_SetInsertMark = SendMessage(hWnd, LVM_SETINSERTMARK, 0, LVIM)
End Function
Private Function ListView_GetInsertMarkColor(hWnd As LongPtr) As LongPtr
'#define ListView_GetInsertMarkColor(hwnd) \
'    (COLORREF)SNDMSG((hwnd), LVM_GETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)0)
ListView_GetInsertMarkColor = SendMessage(hWnd, LVM_GETINSERTMARKCOLOR, 0, ByVal 0&)
End Function
Private Function ListView_SetInsertMarkColor(hWnd As LongPtr, Color As Long) As LongPtr
'#define ListView_SetInsertMarkColor(hwnd, color) \
'    (COLORREF)SNDMSG((hwnd), LVM_SETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
ListView_SetInsertMarkColor = SendMessage(hWnd, LVM_SETINSERTMARKCOLOR, 0, ByVal Color)
End Function
Private Function ListView_GetInsertMarkRect(hWnd As LongPtr, rc As RECT) As LongPtr
'#define ListView_GetInsertMarkRect(hwnd, rc) \
'    (int)SNDMSG((hwnd), LVM_GETINSERTMARKRECT, (WPARAM)0, (LPARAM)(LPRECT)(rc))
ListView_GetInsertMarkRect = SendMessage(hWnd, LVM_GETINSERTMARKRECT, 0, rc)
End Function
Private Function ListView_InsertMarkHitTest(hWnd As LongPtr, POINT As POINT, LVIM As LVINSERTMARK) As LongPtr
'#define ListView_InsertMarkHitTest(hwnd, point, lvim) \
'    (int)SNDMSG((hwnd), LVM_INSERTMARKHITTEST, (WPARAM)(LPPOINT)(point), (LPARAM)(LPLVINSERTMARK)(lvim))
ListView_InsertMarkHitTest = SendMessage(hWnd, LVM_INSERTMARKHITTEST, VarPtr(POINT), LVIM)
End Function
Private Function ListView_GetItemIndexRect(hWnd As LongPtr, lvii As LVITEMINDEX, iSubItem As Long, code As Long, prc As RECT) As LongPtr
'#define ListView_GetItemIndexRect(hwnd, plvii, iSubItem, code, prc) \
'        (BOOL)SNDMSG((hwnd), LVM_GETITEMINDEXRECT, (WPARAM)(LVITEMINDEX*)(plvii), \
'                ((prc) ? ((((LPRECT)(prc))->top = (iSubItem)), (((LPRECT)(prc))->left = (code)), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))
prc.Top = iSubItem
prc.Left = code
ListView_GetItemIndexRect = SendMessage(hWnd, LVM_GETITEMINDEXRECT, VarPtr(lvii), prc)
End Function
Private Function ListView_GetNextItemIndex(hWnd As LongPtr, plvii As LVITEMINDEX, ByVal Flags As LVNI_Flags) As LongPtr
 '#define ListView_GetNextItemIndex(hwnd, plvii, flags) \
 '    (BOOL)SNDMSG((hwnd), LVM_GETNEXTITEMINDEX, (WPARAM)(LVITEMINDEX*)(plvii), MAKELPARAM((flags), 0))
 ListView_GetNextItemIndex = SendMessage(hWnd, LVM_GETNEXTITEMINDEX, VarPtr(plvii), ByVal Flags)
End Function
Private Function ListView_GetOutlineColor(hWnd As LongPtr) As LongPtr
'#define ListView_GetOutlineColor(hwnd) \
'    (COLORREF)SNDMSG((hwnd), LVM_GETOUTLINECOLOR, 0, 0)
ListView_GetOutlineColor = SendMessage(hWnd, LVM_GETOUTLINECOLOR, 0, ByVal 0&)
End Function
Private Function ListView_SetOutlineColor(hWnd As LongPtr, Color As Long) As LongPtr
'#define ListView_SetOutlineColor(hwnd, color) \
'    (COLORREF)SNDMSG((hwnd), LVM_SETOUTLINECOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
ListView_SetOutlineColor = SendMessage(hWnd, LVM_SETOUTLINECOLOR, 0, ByVal Color)
End Function
Private Function ListView_GetSelectedColumn(hWnd As LongPtr) As LongPtr
'#define ListView_GetSelectedColumn(hwnd) \
'    (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)
ListView_GetSelectedColumn = SendMessage(hWnd, LVM_GETSELECTEDCOLUMN, 0, ByVal 0&)
End Function
Private Function ListView_GetTileInfo(hWnd As LongPtr, pTI As LVTILEINFO) As LongPtr
'#define ListView_GetTileInfo(hwnd, pti) \
'    SNDMSG((hwnd), LVM_GETTILEINFO, 0, (LPARAM)(pti))
ListView_GetTileInfo = SendMessage(hWnd, LVM_GETTILEINFO, 0, pTI)
End Function
Private Function ListView_SetTileInfo(hWnd As LongPtr, pTI As LVTILEINFO) As LongPtr
'#define ListView_SetTileInfo(hwnd, pti) \
'    SNDMSG((hwnd), LVM_SETTILEINFO, 0, (LPARAM)(pti))
ListView_SetTileInfo = SendMessage(hWnd, LVM_SETTILEINFO, 0, pTI)
End Function
Private Function ListView_GetTileViewInfo(hWnd As LongPtr, ptvi As LVTILEVIEWINFO) As LongPtr
'#define ListView_GetTileViewInfo(hwnd, ptvi) \
'    SNDMSG((hwnd), LVM_GETTILEVIEWINFO, 0, (LPARAM)(ptvi))
ListView_GetTileViewInfo = SendMessage(hWnd, LVM_GETTILEVIEWINFO, 0, ptvi)
End Function
Private Function ListView_SetTileViewInfo(hWnd As LongPtr, ptvi As LVTILEVIEWINFO) As LongPtr
'#define ListView_SetTileViewInfo(hwnd, ptvi) \
'    SNDMSG((hwnd), LVM_SETTILEVIEWINFO, 0, (LPARAM)(ptvi))
ListView_SetTileViewInfo = SendMessage(hWnd, LVM_SETTILEVIEWINFO, 0, ptvi)
End Function
Private Function ListView_HasGroup(hWnd As LongPtr, dwGroupId As Long) As LongPtr
'#define ListView_HasGroup(hwnd, dwGroupId) \
'    SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)
ListView_HasGroup = SendMessage(hWnd, LVM_HASGROUP, dwGroupId, ByVal 0&)
End Function
Private Function ListView_HitTestEx(hwndLV As LongPtr, pInfo As LVHITTESTINFO) As LongPtr
'HitTestEx is used if you need the iGroup and iSubItem members filled
  ListView_HitTestEx = SendMessage(hwndLV, LVM_HITTEST, -1, pInfo)
End Function
Private Function ListView_InsertGroup(hWnd As LongPtr, Index As Long, pgrp As LVGROUP) As LongPtr
'#define ListView_InsertGroup(hwnd, index, pgrp) \
'    SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)(index), (LPARAM)(pgrp))
ListView_InsertGroup = SendMessage(hWnd, LVM_INSERTGROUP, Index, pgrp)
End Function
Private Function ListView_InsertGroupSorted(hWnd As LongPtr, structInsert As LVINSERTGROUPSORTED) As LongPtr
'#define ListView_InsertGroupSorted(hwnd, structInsert) \
'    SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)(structInsert), 0)
ListView_InsertGroupSorted = SendMessage(hWnd, LVM_INSERTGROUPSORTED, VarPtr(structInsert), ByVal 0&)
End Function
Private Function ListView_IsGroupViewEnabled(hWnd As LongPtr) As LongPtr
'#define ListView_IsGroupViewEnabled(hwnd) \
'    (BOOL)SNDMSG((hwnd), LVM_ISGROUPVIEWENABLED, 0, 0)
ListView_IsGroupViewEnabled = SendMessage(hWnd, LVM_ISGROUPVIEWENABLED, 0, ByVal 0&)
End Function
Private Function ListView_IsItemVisible(hWnd As LongPtr, Index As Long) As LongPtr
'#define ListView_IsItemVisible(hwnd, index) \
'    (UINT)SNDMSG((hwnd), LVM_ISITEMVISIBLE, (WPARAM)(index), (LPARAM)0)
ListView_IsItemVisible = SendMessage(hWnd, LVM_ISITEMVISIBLE, Index, ByVal 0&)
End Function
Private Function ListView_MapIDToIndex(hWnd As LongPtr, id As Long) As LongPtr
'#define ListView_MapIDToIndex(hwnd, id) \
'    (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)(id), (LPARAM)0)
ListView_MapIDToIndex = SendMessage(hWnd, LVM_MAPIDTOINDEX, id, ByVal 0&)
End Function
Private Function ListView_MapIndexToID(hWnd As LongPtr, Index As Long) As LongPtr
'#define ListView_MapIndexToID(hwnd, index) \
'    (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)(index), (LPARAM)0)
ListView_MapIndexToID = SendMessage(hWnd, LVM_MAPINDEXTOID, Index, ByVal 0&)
End Function
Private Function ListView_MoveGroup(hWnd As LongPtr, iGroupId As Long, toIndex As Long) As LongPtr
'NOT IMPLEMENTED
'#define ListView_MoveGroup(hwnd, iGroupId, toIndex) \
'    SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)(iGroupId), (LPARAM)(toIndex))
ListView_MoveGroup = SendMessage(hWnd, LVM_MOVEGROUP, iGroupId, ByVal toIndex)
End Function
Private Function ListView_MoveItemToGroup(hWnd As LongPtr, idItemFrom As Long, idGroupTo As Long) As LongPtr
'NOT IMPLEMENTED
'#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) \
'    SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)(idItemFrom), (LPARAM)(idGroupTo))
ListView_MoveItemToGroup = SendMessage(hWnd, LVM_MOVEITEMTOGROUP, idItemFrom, ByVal idGroupTo)
End Function
Private Function ListView_RemoveAllGroups(hWnd As LongPtr) As LongPtr
'#define ListView_RemoveAllGroups(hwnd) \
'    SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)
ListView_RemoveAllGroups = SendMessage(hWnd, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
End Function
Private Function ListView_RemoveGroup(hWnd As LongPtr, iGroupId As Long) As LongPtr
'#define ListView_RemoveGroup(hwnd, iGroupId) \
'    SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)(iGroupId), 0)
ListView_RemoveGroup = SendMessage(hWnd, LVM_REMOVEGROUP, iGroupId, ByVal 0&)

End Function
Private Function ListView_SetInfoTip(hWnd As LongPtr, plvInfoTip As LVSETINFOTIP) As LongPtr
'#define ListView_SetInfoTip(hwndLV, plvInfoTip)\
'        (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)(plvInfoTip))
ListView_SetInfoTip = SendMessage(hWnd, LVM_SETINFOTIP, 0, plvInfoTip)
End Function
Private Function ListView_SetItemIndexState(hwndLV As LongPtr, plvii As LVITEMINDEX, Data As Long, Mask As Long) As LongPtr
'#define ListView_SetItemIndexState(hwndLV, plvii, data, mask) \
'{ LV_ITEM _macro_lvi;\
'  _macro_lvi.stateMask = (mask);\
'  _macro_lvi.state = (data);\
'  SNDMSG((hwndLV), LVM_SETITEMINDEXSTATE, (WPARAM)(LVITEMINDEX*)(plvii), (LPARAM)(LV_ITEM *)&_macro_lvi);\}

Dim lvi As LVITEM
lvi.StateMask = Mask
lvi.State = Data
ListView_SetItemIndexState = SendMessage(hwndLV, LVM_SETITEMINDEXSTATE, VarPtr(plvii), lvi)
End Function
Private Function ListView_SetSelectedColumn(hWnd As LongPtr, iCol As Long) As LongPtr
'#define ListView_SetSelectedColumn(hwnd, iCol) \
'    SNDMSG((hwnd), LVM_SETSELECTEDCOLUMN, (WPARAM)(iCol), 0)
ListView_SetSelectedColumn = SendMessage(hWnd, LVM_SETSELECTEDCOLUMN, iCol, ByVal 0&)
End Function
'Private Function IID_IListViewFooter() As UUID
''{F0034DA8-8A22-4151-8F16-2EBA76565BCC}
'Static iid As UUID
' If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF0034DA8, CInt(&H8A22), CInt(&H4151), &H8F, &H16, &H2E, &HBA, &H76, &H56, &H5B, &HCC)
' IID_IListViewFooter = iid
'End Function
'

Private Function ListView_SetCheckStateEx(hwndLV As LongPtr, i As Long, nIndex As Long) As LongPtr
'#define ListView_SetCheckState(hwndLV, i, fCheck) \
'  ListView_SetItemState(hwndLV, i, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
ListView_SetCheckStateEx = ListView_SetItemState(hwndLV, i, IndexToStateImageMask(nIndex), LVIS_STATEIMAGEMASK)
End Function



Private Function Header_GetItem(hwndHD As LongPtr, iItem As Long, phdi As HDITEM) As Boolean
  Header_GetItem = SendMessage(hwndHD, HDM_GETITEM, iItem, phdi)
End Function

Private Function Header_SetItem(hwndHD As LongPtr, i As Long, phdi As HDITEM) As Boolean
  Header_SetItem = SendMessage(hwndHD, HDM_SETITEMW, ByVal i, phdi)
End Function
 
Private Function Header_GetItemCount(hWnd As LongPtr) As Long

Header_GetItemCount = CLng(SendMessage(hWnd, HDM_GETITEMCOUNT, 0, 0))
End Function

Private Function Header_InsertItem(hWnd As LongPtr, i As Long, phdi As HDITEMW) As LongPtr
'#define Header_InsertItem(hwndHD, i, phdi) \
'    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))
Header_InsertItem = SendMessage(hWnd, HDM_INSERTITEM, i, phdi)
End Function
Private Function Header_DeleteItem(hWnd As LongPtr, i As Long) As LongPtr
'#define Header_DeleteItem(hwndHD, i) \
'    (BOOL)SNDMSG((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)
Header_DeleteItem = SendMessage(hWnd, HDM_DELETEITEM, i, ByVal 0&)
End Function
Private Function Header_Layout(hWnd As LongPtr, playout As HDLAYOUT) As LongPtr
'#define Header_Layout(hwndHD, playout) \
'    (BOOL)SNDMSG((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT *)(playout))
Header_Layout = SendMessage(hWnd, HDM_LAYOUT, 0, playout)
End Function
Private Function Header_GetItemRect(hWnd As LongPtr, iItem As Long, lpRC As RECT) As LongPtr
'#define Header_GetItemRect(hwnd, iItem, lprc) \
'        (BOOL)SNDMSG((hwnd), HDM_GETITEMRECT, (WPARAM)(iItem), (LPARAM)(lprc))
Header_GetItemRect = SendMessage(hWnd, HDM_GETITEMRECT, iItem, lpRC)
End Function
Private Function Header_SetImageList(hWnd As LongPtr, himl As LongPtr) As LongPtr
'#define Header_SetImageList(hwnd, himl) \
'        (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, HDSIL_NORMAL, (LPARAM)(himl))
Header_SetImageList = SendMessage(hWnd, HDM_SETIMAGELIST, HDSIL_NORMAL, ByVal himl)
End Function
Private Function Header_SetStateImageList(hWnd As LongPtr, himl As LongPtr) As LongPtr
'#define Header_SetStateImageList(hwnd, himl) \
'        (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, HDSIL_STATE, (LPARAM)(himl))
Header_SetStateImageList = SendMessage(hWnd, HDM_SETIMAGELIST, HDSIL_STATE, ByVal himl)
End Function
Private Function Header_GetImageList(hWnd As LongPtr) As LongPtr
'#define Header_GetImageList(hwnd) \
'        (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, HDSIL_NORMAL, 0)
Header_GetImageList = SendMessage(hWnd, HDM_GETIMAGELIST, HDSIL_NORMAL, ByVal 0&)
End Function
Private Function Header_GetStateImageList(hWnd As LongPtr) As LongPtr
'#define Header_GetImageList(hwnd) \
'        (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, HDSIL_STATE, 0)
Header_GetStateImageList = SendMessage(hWnd, HDM_GETIMAGELIST, HDSIL_STATE, ByVal 0&)
End Function
Private Function Header_OrderToIndex(hWnd As LongPtr, i As Long) As LongPtr
'#define Header_OrderToIndex(hwnd, i) \
'        (int)SNDMSG((hwnd), HDM_ORDERTOINDEX, (WPARAM)(i), 0)
Header_OrderToIndex = SendMessage(hWnd, HDM_ORDERTOINDEX, i, ByVal 0&)
End Function
Private Function Header_CreateDragImage(hWnd As LongPtr, i As Long) As LongPtr
'#define Header_CreateDragImage(hwnd, i) \
'        (HIMAGELIST)SNDMSG((hwnd), HDM_CREATEDRAGIMAGE, (WPARAM)(i), 0)
Header_CreateDragImage = SendMessage(hWnd, HDM_CREATEDRAGIMAGE, i, ByVal 0&)
End Function
Private Function Header_GetOrderArray(hWnd As LongPtr, iCount As Long, lpi As LongPtr) As LongPtr
'#define Header_GetOrderArray(hwnd, iCount, lpi) \
'        (BOOL)SNDMSG((hwnd), HDM_GETORDERARRAY, (WPARAM)(iCount), (LPARAM)(lpi))
Header_GetOrderArray = SendMessage(hWnd, HDM_GETORDERARRAY, iCount, lpi)
End Function
Private Function Header_SetOrderArray(hWnd As LongPtr, iCount As Long, lpi As LongPtr) As LongPtr
'#define Header_SetOrderArray(hwnd, iCount, lpi) \
'        (BOOL)SNDMSG((hwnd), HDM_SETORDERARRAY, (WPARAM)(iCount), (LPARAM)(lpi))
'// lparam = int array of size HDM_GETITEMCOUNT
'// the array specifies the order that all items should be displayed.
'// e.g.  { 2, 0, 1}
'// says the index 2 item should be shown in the 0ths position
'//      index 0 should be shown in the 1st position
'//      index 1 should be shown in the 2nd position
'

Header_SetOrderArray = SendMessage(hWnd, HDM_SETORDERARRAY, iCount, ByVal lpi)
End Function
Private Function Header_SetHotDivider(hWnd As LongPtr, fPos As Long, dw As Long) As LongPtr
'#define Header_SetHotDivider(hwnd, fPos, dw) \
'        (int)SNDMSG((hwnd), HDM_SETHOTDIVIDER, (WPARAM)(fPos), (LPARAM)(dw))
Header_SetHotDivider = SendMessage(hWnd, HDM_SETHOTDIVIDER, fPos, ByVal dw)
End Function
Private Function Header_SetBitmapMargin(hWnd As LongPtr, iWidth As Long) As LongPtr
'#define Header_SetBitmapMargin(hwnd, iWidth) \
'        (int)SNDMSG((hwnd), HDM_SETBITMAPMARGIN, (WPARAM)(iWidth), 0)
Header_SetBitmapMargin = SendMessage(hWnd, HDM_SETBITMAPMARGIN, iWidth, ByVal 0&)
End Function
Private Function Header_GetBitmapMargin(hWnd As LongPtr) As LongPtr
'#define Header_GetBitmapMargin(hwnd) \
'        (int)SNDMSG((hwnd), HDM_GETBITMAPMARGIN, 0, 0)
Header_GetBitmapMargin = SendMessage(hWnd, HDM_GETBITMAPMARGIN, 0, ByVal 0&)
End Function
Private Function Header_SetUnicodeFormat(hWnd As LongPtr, fUnicode As Long) As LongPtr
'#define Header_SetUnicodeFormat(hwnd, fUnicode)  \
'    (BOOL)SNDMSG((hwnd), HDM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)
Header_SetUnicodeFormat = SendMessage(hWnd, HDM_SETUNICODEFORMAT, fUnicode, ByVal 0&)
End Function
Private Function Header_GetUnicodeFormat(hWnd As LongPtr) As LongPtr
'#define Header_GetUnicodeFormat(hwnd)  \
'    (BOOL)SNDMSG((hwnd), HDM_GETUNICODEFORMAT, 0, 0)
Header_GetUnicodeFormat = SendMessage(hWnd, HDM_GETUNICODEFORMAT, 0, ByVal 0&)
End Function
Private Function Header_SetFilterChangeTimeout(hWnd As LongPtr, i As Long) As LongPtr
'#define Header_SetFilterChangeTimeout(hwnd, i) \
'        (int)SNDMSG((hwnd), HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)(i))
Header_SetFilterChangeTimeout = SendMessage(hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, ByVal i)
End Function
Private Function Header_EditFilter(hWnd As LongPtr, i As Long, fDiscardChanges As Long) As LongPtr
'#define Header_EditFilter(hwnd, i, fDiscardChanges) \
'        (int)SNDMSG((hwnd), HDM_EDITFILTER, (WPARAM)(i), MAKELPARAM(fDiscardChanges, 0))
Header_EditFilter = SendMessage(hWnd, HDM_EDITFILTER, i, ByVal fDiscardChanges)
End Function
Private Function Header_ClearFilter(hWnd As LongPtr, i As Long) As LongPtr
'#define Header_ClearFilter(hwnd, i) \
'        (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)(i), 0)
Header_ClearFilter = SendMessage(hWnd, HDM_CLEARFILTER, i, ByVal 0&)
End Function
Private Function Header_ClearAllFilters(hWnd As LongPtr) As LongPtr
'#define Header_ClearAllFilters(hwnd) \
'        (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)-1, 0)
Header_ClearAllFilters = SendMessage(hWnd, HDM_CLEARFILTER, -1, ByVal 0&)
End Function
Private Function Header_GetItemDropDownRect(hWnd As LongPtr, iItem As Long, lpRC As RECT) As LongPtr
'#define Header_GetItemDropDownRect(hwnd, iItem, lprc) \
'        (BOOL)SNDMSG((hwnd), HDM_GETITEMDROPDOWNRECT, (WPARAM)(iItem), (LPARAM)(lprc))
Header_GetItemDropDownRect = SendMessage(hWnd, HDM_GETITEMDROPDOWNRECT, iItem, lpRC)
End Function
Private Function Header_GetOverflowRect(hWnd As LongPtr, lpRC As RECT) As LongPtr
'#define Header_GetOverflowRect(hwnd, lprc) \
'        (BOOL)SNDMSG((hwnd), HDM_GETOVERFLOWRECT, 0, (LPARAM)(lprc))
Header_GetOverflowRect = SendMessage(hWnd, HDM_GETOVERFLOWRECT, 0, lpRC)
End Function
Private Function Header_GetFocusedItem(hWnd As LongPtr) As LongPtr
'#define Header_GetFocusedItem(hwnd) \
'        (int)SNDMSG((hwnd), HDM_GETFOCUSEDITEM, (WPARAM)(0), (LPARAM)(0))
Header_GetFocusedItem = SendMessage(hWnd, HDM_GETFOCUSEDITEM, 0, ByVal 0&)
End Function
Private Function Header_SetFocusedItem(hWnd As LongPtr, iItem As Long) As LongPtr
'#define Header_SetFocusedItem(hwnd, iItem) \
'        (BOOL)SNDMSG((hwnd), HDM_SETFOCUSEDITEM, (WPARAM)(0), (LPARAM)(iItem))
Header_SetFocusedItem = SendMessage(hWnd, HDM_SETFOCUSEDITEM, 0, ByVal iItem)
End Function

'====================================================
'CUSTOM ENTRIES
'====================================================
Private Function Header_GetItemW(hwndHD As LongPtr, iItem As Long, phdi As HDITEMW) As Boolean
  Header_GetItemW = SendMessage(hwndHD, HDM_GETITEMW, iItem, phdi)
End Function
Private Function Header_SetItemW(hwndHD As LongPtr, i As Long, phdi As HDITEMW) As Boolean
  Header_SetItemW = SendMessageW(hwndHD, HDM_SETITEMW, ByVal i, phdi)
End Function

Private Function GetHDItemlParam(hwndHD As LongPtr, iItem As Long) As LongPtr
  Dim tHDI As HDITEMW
  tHDI.Mask = HDI_LPARAM
  Call SendMessage(hwndHD, HDM_GETITEMW, iItem, tHDI)
  GetHDItemlParam = tHDI.lParam
End Function

Private Function MAKELPARAM(wLow As Long, wHigh As Long) As LongPtr
  MAKELPARAM = MakeLong(wLow, wHigh)
End Function
Private Function MakeLong(wLow As Long, wHigh As Long) As Long
  MakeLong = LoWord(wLow) Or (&H10000 * LoWord(wHigh))
End Function
Private Function IndexToStateImageMask(ByVal Index As Long) As Long
IndexToStateImageMask = Index * (2 ^ 12)
End Function
Private Function LoWord(ByVal DWord As Long) As Integer
If DWord And &H8000& Then
    LoWord = DWord Or &HFFFF0000
Else
    LoWord = DWord And &HFFFF&
End If
End Function
Private Function HiWord(ByVal DWord As Long) As Integer
HiWord = (DWord And &HFFFF0000) \ &H10000
End Function

Private Function LPWSTRtoStr(lPtr As LongPtr, Optional ByVal fFree As Boolean = True) As String
SysReAllocString VarPtr(LPWSTRtoStr), lPtr
If fFree Then
    Call CoTaskMemFree(lPtr)
End If
End Function

Public Sub BrowserOpenItem(psi As IShellItem)
DebugAppend "BrowserOpenItem, bBlockLoad = " & bBlockLoad, 2000
If bBlockLoad = True Then Exit Sub
Dim lpPath As LongPtr, sPath As String
psi.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
sPath = LPWSTRtoStr(lpPath)
If sPath = m_sCurPath Then Exit Sub
If Left$(sPath, Len(mFldrSrch)) = mFldrSrch Then
    Set siDirect = psi
    LVLoadFolder "", True
Else
    If m_Mode = SBCTL_DrivesOnly Then
        If Len(sPath) > 3 Then
         If InStr(sPath, ":\") Then
          sPath = Left$(sPath, 3)
          Set psi = Nothing
          UpdateStatus mStrOpening
          Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, psi)
         End If
        End If
    End If
        
    
    If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
        If IsRootChild(, psi) = False Then
            UpdateStatus mStrForbidden
            If IsComCtl6 Then
                SimpleDialog mStrForbidden, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
            Else
                MsgBox mStrForbidden, vbOKOnly Or vbCritical, App.Title
            End If
            Exit Sub
        End If
    End If
    Dim lAtr As SFGAO_Flags
    psi.GetAttributes SFGAO_FOLDER Or SFGAO_STREAM, lAtr
    If m_BrowseZip Then
        If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) Then 'And ((lAtr And SFGAO_STREAM) = 0) Then '
            Set siDirect = psi
            LVLoadFolder "", True
        Else
            UpdateStatus mInvPathZip
            If mPlaySnd Then
                If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
            End If
            DebugAppend mInvPathZip
        End If
    Else
        If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0) Then 'Then '
            Set siDirect = psi
            LVLoadFolder "", True
        Else
            UpdateStatus mInvPath
            If mPlaySnd Then
                If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
            End If
            DebugAppend mInvPath
        End If
    End If
End If
End Sub
    '**********************************************************************************
    'CONTROL PROPERTIES
    '
    Public Property Get BrowserStartLastPath() As Boolean: BrowserStartLastPath = mStartLast: End Property
    Attribute BrowserStartLastPath.VB_Description = "On startup, navigate to the last directory from the previous session. Note: BrowserStartBlank will override this if set to True."
    Public Property Let BrowserStartLastPath(bVal As Boolean): mStartLast = bVal: End Property
    [ Hidden ]
    Public Property Let DPIScaleX(Value As Single): m_ScaleX = Value: End Property
    Public Property Get DPIScaleX() As Single: DPIScaleX = m_ScaleX: End Property
    Attribute DPIScaleX.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let DPIScaleY(Value As Single): m_ScaleY = Value: End Property
    Public Property Get DPIScaleY() As Single: DPIScaleY = m_ScaleY: End Property
    Attribute DPIScaleY.VB_MemberFlags = "400"
    Public Property Get ScaleHeight() As Single: ScaleHeight = UserControl.ScaleHeight: End Property
    Public Property Get ScaleWidth() As Single: ScaleWidth = UserControl.ScaleWidth: End Property
    Public Property Get BrowserStartBlank() As Boolean: BrowserStartBlank = m_StartEmpty: End Property
    Attribute BrowserStartBlank.VB_Description = "Do not open any location on startup."
    Public Property Let BrowserStartBlank(bVal As Boolean): m_StartEmpty = bVal: End Property
    Public Property Get EnableUserModeSwitch() As Boolean: EnableUserModeSwitch = mUserModeToggle: End Property
    Attribute EnableUserModeSwitch.VB_Description = "Allows the user to toggle the control bar via the 'Control bar' View Menu option (i.e. Switch between Files Only or Dir+Files)."
    Public Property Let EnableUserModeSwitch(bVal As Boolean): mUserModeToggle = bVal: End Property
    Public Property Get ShellTreeInLayout() As Boolean: ShellTreeInLayout = m_ShellTree: End Property
    Attribute ShellTreeInLayout.VB_Description = "If your project also has ucShellTree, you can use this option to add an entry to show/hide it in the Layout menu. The ShowShellTree event will be raised when clicked."
    Public Property Let ShellTreeInLayout(bVal As Boolean): m_ShellTree = bVal: End Property
    Public Property Get ShellTreeStatus() As Boolean: ShellTreeStatus = mShellTreeVis: End Property
    Attribute ShellTreeStatus.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let ShellTreeStatus(bVisible As Boolean): mShellTreeVis = bVisible: End Property
    Public Property Get CustomRoot() As String: CustomRoot = mCustomRoot: End Property
    Attribute CustomRoot.VB_Description = "Set a custom root for the directory dropdown. Leave blank to disable-- then the Desktop will be the root, or Computer if the ComputerAsRoot option is enabled."
    Public Property Let CustomRoot(sPath As String)
    mCustomRoot = sPath
    RefreshTree
    PropertyChanged "CustomRoot"
    End Property
    Public Property Get CustomRootLocked() As Boolean: CustomRootLocked = mCustomRootEnforce: End Property
    Attribute CustomRootLocked.VB_Description = "Sets whether to allow opening locations that are not within the path specific by CustomRoot. E.g. if you set C:\\ as your custom root, the user cannot load  anything on D:\\."
    Public Property Let CustomRootLocked(bVal As Boolean): mCustomRootEnforce = bVal: End Property
    Public Property Get BrowserPath() As String: BrowserPath = m_sCurPath: End Property
    Attribute BrowserPath.VB_Description = "The initial path of the browser. If this is blank, the path of the app will be used, or if a CustomRoot is specified, that location. Environmental variables like %WINDIR% or %ProgramFiles% are supported. If invalid, the app path is used. Superceded if Br"
    Public Property Let BrowserPath(sNewPath As String)
    
    If Ambient.UserMode Then
        If bBlockLoad = True Then Exit Property
        If sNewPath = m_sCurPath Then Exit Property
        
        Dim sPath As String: sPath = sNewPath
        
        If sNewPath = "*CUSTOM" Then
            If nCustomSet >= 0& Then
                PopulateCustomSet
            End If
            Exit Property
        End If
        
        If Left$(sPath, Len(mFldrSrch)) = mFldrSrch Then
            Dim nSIdx As Long
            Dim sTmp As String
            nSIdx = SearchFindIdxByDisp(sPath)
            If nSIdx >= 0& Then
                Set siDirect = psiSearch(nSIdx).siSearch
                LVLoadFolder "", True
            Else
                If IsComCtl6 Then
                    SimpleDialog mSrchFldrInvalid, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
                Else
                    MsgBox mSrchFldrInvalid, vbOKOnly Or vbCritical, App.Title
                End If
            End If
    skp:
        Else
            Dim siItem As IShellItem
            Dim i As Long
            Dim li As Long
            Dim lAtr As SFGAO_Flags
            Dim hr As Long
            If InStr(sPath, "%") Then
                sPath = ExpandEnvVars(sPath)
                DebugAppend "Expanded Environ shortcuts->" & sPath, 55
            End If
            Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siItem)
            If m_Mode = SBCTL_DrivesOnly Then
              If Len(sPath) > 3 Then
                If InStr(sPath, ":\") Then
                    sPath = Left$(sPath, 3)
                    Set siItem = Nothing
                    Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siItem)
                End If
              End If
            End If
            If siItem Is Nothing Then
                Dim testpidl As LongPtr
                testpidl = ILCreateFromPathW(StrPtr(sPath))
                If testpidl Then
                    SHCreateItemFromIDList testpidl, IID_IShellItem, siItem
                    CoTaskMemFree testpidl
                End If
            End If
            If (siItem Is Nothing) Then
                If sPath = sRecentPl Then
                    SHGetKnownFolderItem FOLDERID_Recent, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siItem
                End If
                DebugAppend sPath, 44
            End If
            If (siItem Is Nothing) Then
                'See if it's a folder name in the current path; particularly useful for typed navigation in the dir dropdown
                sPath = AddBackslash(m_sCurPath) & sPath
                Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siItem)
            End If
            If (siItem Is Nothing) And (Left$(sPath, 3) = "::{") Then
                'virtual item fallback
                Dim sh As String
                sh = "shell:" & sPath
                Call SHCreateItemFromParsingName(StrPtr(sh), Nothing, IID_IShellItem, siItem)
            End If
            If (siItem Is Nothing) = False Then
                If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
                    If IsRootChild(, siItem) = False Then
                        UpdateStatus mStrForbidden
                        If IsComCtl6 Then
                            SimpleDialog mStrForbidden, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
                        Else
                            MsgBox mStrForbidden, vbOKOnly Or vbCritical, App.Title
                        End If
                        Exit Property
                    End If
                End If
                siItem.GetAttributes SFGAO_FOLDER Or SFGAO_STREAM, lAtr
                If m_BrowseZip Then
                    If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) Then 'And ((lAtr And SFGAO_STREAM) = 0) Then '
                        bSuppress = True
                        i = AddStandardFSItem(siItem, li, True)
                        hr = CLng(SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&))
                        bSuppress = False
        '                m_sCurPath = sPath
                        LVLoadFolder sPath
                    End If
                Else
                    If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0) Then 'Then '
                        bSuppress = True
                        i = AddStandardFSItem(siItem, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
                        bSuppress = False
        '                m_sCurPath = sPath
                        LVLoadFolder sPath
                    End If
                End If
            Else
                UpdateStatus mLoadFail & sNewPath
                If IsComCtl6 Then
                    SimpleDialog mLoadFail & sNewPath, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
                Else
                    MsgBox mLoadFail & sNewPath, vbOKOnly Or vbCritical, App.Title
                End If
                If hCombo Then
                    bSuppress = True
                    Dim j As Long
                    If CBItemExists(m_sCurPath) And (m_sCurPath <> "") Then
                        i = GetItemIndex(m_sCurPath, j)
                        SendMessage hCombo, CB_SETCURSEL, i, ByVal 0&
                    End If
                    bSuppress = False
                End If
            End If
        End If
    Else
        m_sCurPath = sNewPath
    End If
    PropertyChanged "BrowserPath"
    End Property
    Public Property Get BrowserPathPidl() As LongPtr: BrowserPathPidl = pidlFQCur: End Property
    Attribute BrowserPathPidl.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let BrowserPathPidl(pidlFQ As LongPtr)
    If Ambient.UserMode Then
        If bBlockLoad = True Then Exit Property
        Dim siItem As IShellItem
        Dim lpPath As LongPtr, sPath As String
        Dim lAtr As SFGAO_Flags
        
        SHCreateItemFromIDList pidlFQ, IID_IShellItem, siItem
        If (siItem Is Nothing) = False Then
            siItem.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
            sPath = LPWSTRtoStr(lpPath)
            If sPath = m_sCurPath Then Exit Property
            If m_Mode = SBCTL_DrivesOnly Then
                If Len(sPath) > 3 Then
                 If InStr(sPath, ":\") Then
                  sPath = Left$(sPath, 3)
                  Set siItem = Nothing
                  Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siItem)
                 End If
                End If
            End If
            If (siItem Is Nothing) = False Then
                If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
                    If IsRootChild(, siItem) = False Then
                        UpdateStatus mStrForbidden
                        If IsComCtl6 Then
                            SimpleDialog mStrForbidden, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
                        Else
                            MsgBox mStrForbidden, vbOKOnly Or vbCritical, App.Title
                        End If
                        Exit Property
                    End If
                End If
                siItem.GetAttributes SFGAO_FOLDER Or SFGAO_STREAM, lAtr
                If m_BrowseZip Then
                    If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) Then 'And ((lAtr And SFGAO_STREAM) = 0) Then '
                        Set siDirect = siItem
                        LVLoadFolder "", True
                    Else
                        UpdateStatus mInvPathZip
                        DebugAppend mInvPathZip
                    End If
                Else
                    If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0) Then 'Then '
                        Set siDirect = siItem
                        LVLoadFolder "", True
                    Else
                        UpdateStatus mInvPath
                        DebugAppend mInvPath
                    End If
                End If
            Else
                If IsComCtl6 Then
                    SimpleDialog mLoadFail & sPath, TDCBF_OK_BUTTON, App.Title, , TD_ERROR_ICON, hLVS
                Else
                    MsgBox mLoadFail & sPath, vbOKOnly Or vbCritical, App.Title
                End If
            End If
        End If
    End If
    End Property
    Public Property Get BrowserPathItem() As IShellItem: Set BrowserPathItem = siCurPath: End Property
    Attribute BrowserPathItem.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let BrowserPathItem(pItem As IShellItem): BrowserOpenItem pItem: End Property
    Public Property Get HighPerformanceMode() As Boolean: HighPerformanceMode = mHighPerfMode: End Property
    Attribute HighPerformanceMode.VB_Description = "Use low-level APIs to load folders as quickly as possible. Only works on standard file system locations on local disks. Virtual locations, some special folders, and network locations are not supported. Will not be used if ColumnPreload is True. "
    Public Property Let HighPerformanceMode(bVal As Boolean): mHighPerfMode = bVal: End Property
    Public Property Get MultiSelect() As Boolean: MultiSelect = m_MultiSelect: End Property
    Attribute MultiSelect.VB_Description = "Sets whether more than one file can be selected in the browser."
    Public Property Let MultiSelect(bVal As Boolean)
    If bVal <> m_MultiSelect Then
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If bVal Then
            dwStyle = dwStyle And Not LVS_SINGLESEL
        Else
            dwStyle = dwStyle Or LVS_SINGLESEL
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    m_MultiSelect = bVal
    End Property
    Public Property Get AllowRename() As Boolean: AllowRename = m_AllowRename: End Property
    Attribute AllowRename.VB_Description = "Sets whether the Rename context menu item appears and if label edits can be started to rename items."
    Public Property Let AllowRename(bVal As Boolean)
    If bVal <> m_AllowRename Then
        m_AllowRename = bVal
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If m_AllowRename Then
            dwStyle = dwStyle Or LVS_EDITLABELS
        Else
            dwStyle = dwStyle And Not LVS_EDITLABELS
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    End Property
    Public Property Get AlignTop() As Boolean: AlignTop = mAlignTop: End Property
    Attribute AlignTop.VB_Description = "Sets the ListView alignment; if True, to AlignTop, and if False, to AlignLeft."
    Public Property Let AlignTop(bVal As Boolean)
    If mAlignTop <> bVal Then
        mAlignTop = bVal
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If mAlignTop Then
            dwStyle = dwStyle And Not LVS_ALIGNLEFT
            dwStyle = dwStyle Or LVS_ALIGNTOP
        Else
            dwStyle = dwStyle Or LVS_ALIGNLEFT
            dwStyle = dwStyle And Not LVS_ALIGNTOP
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    End Property
    Public Property Get NoLabelWrap() As Boolean: NoLabelWrap = mNoLblWrap: End Property
    Attribute NoLabelWrap.VB_Description = "Show the entire name for every item instead of wrapping long ones."
    Public Property Let NoLabelWrap(bVal As Boolean)
    If mNoLblWrap <> bVal Then
        mNoLblWrap = bVal
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If mNoLblWrap Then
            dwStyle = dwStyle Or LVS_NOLABELWRAP
        Else
            dwStyle = dwStyle And Not LVS_NOLABELWRAP
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    End Property
    Public Property Get ShowSelAlways() As Boolean: ShowSelAlways = mShowSelAlw: End Property
    Attribute ShowSelAlways.VB_Description = "Always show the selection even if the ListView doesn't have focus."
    Public Property Let ShowSelAlways(bVal As Boolean)
    If mShowSelAlw <> bVal Then
        mShowSelAlw = bVal
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If mShowSelAlw Then
            dwStyle = dwStyle Or LVS_SHOWSELALWAYS
        Else
            dwStyle = dwStyle And Not LVS_SHOWSELALWAYS
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    End Property
    Public Property Get AutoArrange() As Boolean: AutoArrange = mAutoArr: End Property
    Attribute AutoArrange.VB_Description = "Sets the AutoArrange style on the ListView."
    Public Property Let AutoArrange(bVal As Boolean)
    If mAutoArr <> bVal Then
        mAutoArr = bVal
        Dim dwStyle As ucsb_LVStyles
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        If mAutoArr Then
            dwStyle = dwStyle Or LVS_AUTOARRANGE
        Else
            dwStyle = dwStyle And Not LVS_AUTOARRANGE
        End If
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    End If
    End Property
    Public Property Get MonitorDirChanges() As Boolean: MonitorDirChanges = m_Monitor: End Property
    Attribute MonitorDirChanges.VB_Description = "Detect when files/folders in the current location are added, deleted, renamed, or otherwise changed, and update the view accordingly."
    Public Property Let MonitorDirChanges(bVal As Boolean)
    If bVal <> m_Monitor Then
        If bVal Then
            m_Monitor = True
            StartNotifyOnCurPath
        Else
            m_Monitor = False
            StopNotify
        End If
    End If
    End Property
    Public Property Get DisableWow64Redirect() As Boolean: DisableWow64Redirect = m_NoWow64: End Property
    Attribute DisableWow64Redirect.VB_Description = "Disables file system redirection for 32bit apps on 64-bit systems. Ignored in the 64bit version of this control."
    Public Property Let DisableWow64Redirect(bVal As Boolean)
    If bVal = m_NoWow64 Then Exit Property
    m_NoWow64 = bVal
    If m_NoWow64 Then
        DisableWow64Redir
    Else
        RevertWow64Redir
    End If
    End Property
    Public Property Get ExplorerStyle() As Boolean: ExplorerStyle = mExplorerStyle: End Property
    Attribute ExplorerStyle.VB_Description = "Determines whether or not the Explorer visual theme is applied."
    Public Property Let ExplorerStyle(bVal As Boolean)
    If bVal <> mExplorerStyle Then
        mExplorerStyle = bVal
        If mExplorerStyle Then
            SetWindowTheme hLVS, StrPtr("explorer"), 0&
        Else
            SetWindowTheme hLVS, StrPtr(" "), 0&
        End If
    End If
    End Property
    Public Property Get ExplorerStyleSelection() As Boolean: ExplorerStyleSelection = mExplSel: End Property
    Attribute ExplorerStyleSelection.VB_Description = "Toggle when in Details View with Multiselect enabled, start a multiselect marquee by dragging in the whitespace of the Name column."
    Public Property Let ExplorerStyleSelection(bVal As Boolean)
    If bVal <> mExplSel Then
        mExplSel = bVal
        LVSetExplSel mExplSel
    End If
    End Property
    Public Property Get ThumbnailSize() As Long: ThumbnailSize = m_ThumbCXY: End Property
    Attribute ThumbnailSize.VB_Description = "The x,y size, in pixels, of thumbnails when enabled."
    Public Property Let ThumbnailSize(cxy As Long)
    m_ThumbCXY = cxy
    If (cxy < 16) Or (cxy > 1024) Then
        m_ThumbCXY = m_def_ThumbCXY
    End If
    End Property
    Public Property Get ThumbnailScaleForDPI() As Boolean: ThumbnailScaleForDPI = m_ThumbScaleCXY: End Property
    Attribute ThumbnailScaleForDPI.VB_Description = "Scales GDI+ drawn thumbnails to DPI. System thumbnails are already scaled by the system."
    Public Property Let ThumbnailScaleForDPI(Value As Boolean): m_ThumbScaleCXY = Value: End Property
    Public Property Get ExtendedThumbnails() As Boolean: ExtendedThumbnails = m_ThumbExt: End Property
    Attribute ExtendedThumbnails.VB_Description = "Sets whether to show thumbnails for videos and similar."
    Public Property Let ExtendedThumbnails(bVal As Boolean): m_ThumbExt = bVal: End Property
    Public Property Get ExtendedOverlays() As Boolean: ExtendedOverlays = mExtOverlay: End Property
    Attribute ExtendedOverlays.VB_Description = "Show the extended overlays sometimes found in programs like TortoiseSVN, Dropbox, or Github. WARNING: Extreme performance cost, reduces folder load times by 10-100x."
    Public Property Let ExtendedOverlays(bVal As Boolean): mExtOverlay = bVal: End Property
    Public Property Get DisableOverlays() As Boolean: DisableOverlays = m_DisableOvr: End Property
    Attribute DisableOverlays.VB_Description = "Hide the Shortcut (arrow) and Share overlays on links and shared files. Also disables Extended Overlays (enabled separately)."
    Public Property Let DisableOverlays(bVal As Boolean)
    If m_DisableOvr <> bVal Then
        m_DisableOvr = bVal
        If Ambient.UserMode Then RefreshView
    End If
    End Property
    Public Property Get CustomIconsEnabled() As Boolean: CustomIconsEnabled = mCustomInMenu: End Property
    Attribute CustomIconsEnabled.VB_Description = "Show the View Menu option for Custom Icons. You must respond to the QueryCustomIcon event to supply these for each item. "
    Public Property Let CustomIconsEnabled(bVal As Boolean): mCustomInMenu = bVal: End Property
    Public Property Get CustomIconsSize() As Long: CustomIconsSize = mcxyCustom: End Property
    Attribute CustomIconsSize.VB_Description = "The size of custom icons if SB_VIEW_CUSTOM is set."
    Public Property Let CustomIconsSize(cxy As Long): mcxyCustom = cxy: End Property
    Public Property Get CustomIconsCaption() As String: CustomIconsCaption = mCustomMenuCap: End Property
    Attribute CustomIconsCaption.VB_Description = "If CustomIconsEnabled is True, this sets the caption of the menu item."
    Public Property Let CustomIconsCaption(strCaption As String): mCustomMenuCap = strCaption: End Property
    Public Property Get TileWidth() As Long: TileWidth = mTileWidth: End Property
    Attribute TileWidth.VB_Description = "You can specify a fixed width for the tiles in Tile View. This value will be multiplied by the DPI scale. Set to 0 for automatic width."
    Public Property Let TileWidth(cx As Long)
    mTileWidth = cx
    If m_ViewMode = SB_VIEW_TILE Then
        SwitchView LV_VIEW_LIST
        SwitchView LV_VIEW_TILE
    End If
    End Property
    Public Property Get AlwaysSortWithISF() As Boolean: AlwaysSortWithISF = mAlwaysSortWithISF: End Property
    Attribute AlwaysSortWithISF.VB_Description = "Use IShellFolder.CompareIDs for supported columns instead of the control's algorithm. This comes with a significant performance cost, but may be helpful for certain sorts. Note that folders are now separated without this option enabled."
    Public Property Let AlwaysSortWithISF(bVal As Boolean): mAlwaysSortWithISF = bVal: End Property
    Public Property Get ThumbnailPreload() As Boolean: ThumbnailPreload = m_ThumbPreload: End Property
    Attribute ThumbnailPreload.VB_Description = "Sets whether to load all thumbnails in advance when opening a folder, or not until each item is visible."
    Public Property Let ThumbnailPreload(bVal As Boolean): m_ThumbPreload = bVal: End Property
    Public Property Get IconPreload() As Boolean: IconPreload = m_IconPreload: End Property
    Attribute IconPreload.VB_Description = "For Medium, Large, and Extra Large Icon views, thumbnails will be loaded when an item scrolls into view if this option is False, or ahead of time during the initial folder load if True."
    Public Property Let IconPreload(bVal As Boolean): m_IconPreload = bVal: End Property
    Public Property Get ColumnPreload() As Boolean: ColumnPreload = mExtColPreload: End Property
    Attribute ColumnPreload.VB_Description = "Load the values for columns besides Name for all items when opening a folder instead of as each item is scrolled into view. Increases folder load time, but avoids delays the first time items are scrolled into view. NOTE: High Performance Mode will not be"
    Public Property Let ColumnPreload(bVal As Boolean)
    mExtColPreload = bVal
    If Ambient.UserMode Then
        If mExtColPreload Then 'Switching to preloaded during runtime; need to read data
            RefreshView
        End If
    End If
    End Property
    Public Property Get FoldersOnly() As Boolean: FoldersOnly = mFoldersOnly: End Property
    Attribute FoldersOnly.VB_Description = "In the full file area (not the dropdown), sets whether to only show folders. If this is True, then FilesOnly must be False."
    Public Property Let FoldersOnly(bVal As Boolean)
    If bVal <> mFoldersOnly Then
        mFoldersOnly = bVal
        If (mFoldersOnly = True) And (mFilesOnly = True) Then
            Me.FilesOnly = False
        End If
        RefreshView
    End If
    End Property
    Public Property Get FilesOnly() As Boolean: FilesOnly = mFilesOnly: End Property
    Attribute FilesOnly.VB_Description = "Toggles whether or not folders are shown in the ListView. If this is True, the FoldersOnly option must be False."
    Public Property Let FilesOnly(bVal As Boolean)
    If bVal <> mFilesOnly Then
        mFilesOnly = bVal
        If (mFilesOnly = True) And (mFoldersOnly = True) Then
            Me.FoldersOnly = False
        End If
        RefreshView
    End If
    End Property
    Public Property Get ShowParentTreeInList() As Boolean: ShowParentTreeInList = mDispParAndIndt: End Property
    Attribute ShowParentTreeInList.VB_Description = "In Details View, creates an indented tree showing the parent folders of the current location. In other views, items are present but not visually distinguished."
    Public Property Let ShowParentTreeInList(bVal As Boolean)
    If bVal <> mDispParAndIndt Then
        mDispParAndIndt = bVal
        RefreshView
    End If
    End Property
    Public Property Get ShowHiddenItems() As SB_HDN_PREF: ShowHiddenItems = m_HiddenPref: End Property
    Attribute ShowHiddenItems.VB_Description = "Controls whether hidden items appear in the file list or not."
    Public Property Let ShowHiddenItems(lVal As SB_HDN_PREF): m_HiddenPref = lVal: End Property
    Public Property Get ShowSuperHidden() As SB_SPRHDN_PREF: ShowSuperHidden = m_SuperHiddenPref: End Property
    Attribute ShowSuperHidden.VB_Description = "Sets whether to show superhidden files (in Explorer, the 'Hide protected operating system files' setting, or attribs Hidden+System)"
    Public Property Let ShowSuperHidden(lVal As SB_SPRHDN_PREF): m_SuperHiddenPref = lVal: End Property
    Public Property Get ShowAltDataStreams() As Boolean: ShowAltDataStreams = mShowDataStreams: End Property
    Attribute ShowAltDataStreams.VB_Description = "Adds entries for NTFS alternative data streams, such as the Security Zone Identifier for internet downloads. Basic display only; you won't be able to execute context menu commands on these items. "
    Public Property Let ShowAltDataStreams(bVal As Boolean): mShowDataStreams = bVal: End Property
    Public Property Get FollowLinks() As Boolean: FollowLinks = m_FollowLinks: End Property
    Attribute FollowLinks.VB_Description = "Sets whether to navigate to the location of a link to a folder when double-clicked, or to just select the shortcut file."
    Public Property Let FollowLinks(bVal As Boolean): m_FollowLinks = bVal: End Property
    Public Property Get FoldersOnlyIncludeLinks() As Boolean: FoldersOnlyIncludeLinks = mIncludeFldrLnkInFldrOnly: End Property
    Attribute FoldersOnlyIncludeLinks.VB_Description = "Include links if they're to folders. This is for standard loading if high performance mode is disabled or unavailable for the current folder."
    Public Property Let FoldersOnlyIncludeLinks(bVal As Boolean): mIncludeFldrLnkInFldrOnly = bVal: End Property
    Public Property Get FoldersOnlyIncludeLinksHPF() As Boolean: FoldersOnlyIncludeLinksHPF = mIncludeFldrLnkInFldrOnlyHPF: End Property
    Attribute FoldersOnlyIncludeLinksHPF.VB_Description = "Include links if they're to folders in high-performance mode (this may have a significant performance cost). "
    Public Property Let FoldersOnlyIncludeLinksHPF(bVal As Boolean): mIncludeFldrLnkInFldrOnlyHPF = bVal: End Property
    Public Property Get PlaySounds() As Boolean: PlaySounds = mPlaySnd: End Property
    Attribute PlaySounds.VB_Description = "Play the standard Explorer sounds when navigation or for an error beep. You can set individual sounds off/on in the UserOptions code section."
    Public Property Let PlaySounds(bVal As Boolean): mPlaySnd = bVal: End Property
    Public Property Get AlwaysShowExtendedVerbs() As Boolean: AlwaysShowExtendedVerbs = mAlwaysShowExtVerbs: End Property
    Attribute AlwaysShowExtendedVerbs.VB_Description = "Always show extended verbs in the shell context menu, otherwise Shift must be pressed when bringing up the menu."
    Public Property Let AlwaysShowExtendedVerbs(bVal As Boolean): mAlwaysShowExtVerbs = bVal: End Property
    Public Property Get NoNavigateOnSelect() As Boolean: NoNavigateOnSelect = m_NoDblClkNav: End Property
    Attribute NoNavigateOnSelect.VB_Description = "Raise the FileExecute event on a folder when double-clicked/pressed return instead of navigating to it."
    Public Property Let NoNavigateOnSelect(bVal As Boolean): m_NoDblClkNav = bVal: End Property
    Public Property Get MaxComboWidth() As Long: MaxComboWidth = m_MaxComboCX: End Property
    Attribute MaxComboWidth.VB_Description = "The maximum width of the folder dropdown."
    Public Property Let MaxComboWidth(lVal As Long): m_MaxComboCX = lVal: End Property
    Public Property Get ListModeMaxWidth() As Long: ListModeMaxWidth = mLMMaxCX: End Property
    Attribute ListModeMaxWidth.VB_Description = "When the View Mode is List, it sets every item width to the very largest width of the entire folder. This limits it to a more sane value in the event items come up with dozens of letters in the name. You can set this to 0 to disable this feature."
    Public Property Let ListModeMaxWidth(cx As Long)
    mLMMaxCX = cx
    LVAdjustLabelWidth
    End Property
    Public Property Get DefaultColumns() As String: DefaultColumns = m_DefCol: End Property
    Attribute DefaultColumns.VB_Description = "1=Size, 2=Type, 3=Date Mod, 4=Date Crd, 5=Date Acc. Example: 1,2,3. Delete this field to show Name only. Does not apply if LockColumns is set to 0 (No lock). "
    Public Property Let DefaultColumns(sVal As String): m_DefCol = sVal: End Property
    Public Property Get AutosizeColumns() As Boolean: AutosizeColumns = m_AutoSzCol: End Property
    Attribute AutosizeColumns.VB_Description = "If enabled, sizes columns to fit in the current ListView width."
    Public Property Let AutosizeColumns(bVal As Boolean)
    If bVal <> m_AutoSzCol Then
        Dim dwEXS As ucsb_LVStylesEx
        dwEXS = CLng(SendMessage(hLVS, LVM_GETEXTENDEDLISTVIEWSTYLE, 0&, ByVal 0&))
        If bVal Then
            dwEXS = dwEXS Or LVS_EX_AUTOSIZECOLUMNS
            Call SendMessage(hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0&, ByVal dwEXS)
        Else
            dwEXS = dwEXS And Not LVS_EX_AUTOSIZECOLUMNS
            Call SendMessage(hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0&, ByVal dwEXS)
        End If
        m_AutoSzCol = bVal
    End If
    End Property
    Public Property Get LockColumns() As SB_COL_LOCK: LockColumns = m_ColLock: End Property
    Attribute LockColumns.VB_Description = "0=No lock, each folder's column setup queried and set automatically. 1=Use only the columns from DefaultColumns. 2=That and also disable run-time add/remove by the user."
    Public Property Let LockColumns(lVal As SB_COL_LOCK): m_ColLock = lVal: End Property
    Public Property Get ComputerAsRoot() As Boolean: ComputerAsRoot = m_CompAsRoot: End Property
    Attribute ComputerAsRoot.VB_Description = "Use 'Computer' as the root of the directory dropdown instead of Desktop."
    Public Property Let ComputerAsRoot(bVal As Boolean)
    m_CompAsRoot = bVal
    RefreshTree
    PropertyChanged "ComputerAsRoot"
    End Property
    Public Property Get ShowSecurityZone() As Boolean: ShowSecurityZone = mDispSecZn: End Property
    Attribute ShowSecurityZone.VB_Description = "Adds a StatusBar panel that shows the Security Zone icon+label for the current location; both are loaded from Windows."
    Public Property Let ShowSecurityZone(bVal As Boolean)
    If bVal <> mDispSecZn Then
        mDispSecZn = bVal
        DestroyWindow m_hStatusBar
        m_hStatusBar = 0&
        m_lPanelCount = 0&
        ReDim m_uPanelInfo(0)
        pvCreateStatusBar
        If Ambient.UserMode Then
            If mDispSecZn = True Then
                Dim zn As URLZONE
                zn = GetFileEffectiveZone(m_sCurPath)
                UpdateZonePanel zn
            End If
            Dim sFN As String
            If nCurFolders = 1 Then
                sFN = " " & mFolderStr & ", "
            Else
                sFN = " " & mFoldersStr & ", "
            End If
            Dim sfn2 As String
            If nCurFiles = 1 Then
                sfn2 = " " & mFileStr & " ("
            Else
                sfn2 = " " & mFilesStr & " ("
            End If
            UpdateStatus mReadyStr
            If (nCurFiles + nCurFolders) = 0 Then
                UpdateStatus mNoItemsStr, idxSizePanel
            Else
                UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2 & _
                                                            FormatFileSizeCurExB(m_CurSize, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                           False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb) & ")", idxSizePanel
            End If
        End If
    End If
    End Property
    Public Property Get FileDragDropMode() As SB_DDMODE: FileDragDropMode = m_DDMode: End Property
    Attribute FileDragDropMode.VB_Description = "Sets the type of drag/drop actions allowed in the ListView."
    Public Property Let FileDragDropMode(lVal As SB_DDMODE)
    If lVal <> m_DDMode Then
        If (lVal = SBDD_Disabled) Or (lVal = SBDD_DragOnly) Then Call Detach
        If (lVal = SBDD_DragDrop) Or (lVal = SBDD_DropOnly) Then Call Attach(hLVS)
        m_DDMode = lVal
    End If
    End Property
    Public Property Get ActiveDrop() As Boolean: ActiveDrop = m_ActiveDrop: End Property
    Attribute ActiveDrop.VB_Description = "Enables highlighting and dropping on individual folders (or some files like Zip) in the file view."
    Public Property Let ActiveDrop(bVal As Boolean): m_ActiveDrop = bVal: End Property
    Public Property Get ActiveDropHoverTime() As Long: ActiveDropHoverTime = lRaiseHover: End Property
    Attribute ActiveDropHoverTime.VB_Description = "The length of time (in milliseconds) for a hover event to be raised during drag-drop."
    Public Property Let ActiveDropHoverTime(lVal As Long): lRaiseHover = lVal: End Property
    Public Property Get HideIcons() As Boolean: HideIcons = m_HideIcons: End Property
    Attribute HideIcons.VB_Description = "Show filenames without the icon next to them."
    Public Property Let HideIcons(bVal As Boolean)
    If m_HideIcons <> bVal Then
        m_HideIcons = bVal
        If m_HideIcons Then
            Call ListView_SetImageList(hLVS, 0&, LVSIL_NORMAL)
            Call ListView_SetImageList(hLVS, 0&, LVSIL_SMALL)
            Call ListView_SetImageList(hLVS, 0&, LVSIL_GROUPHEADER)
            
            Dim lCt As Long
            lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
            Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&)
            If m_ViewMode = SB_VIEW_DETAILS Then
                SwitchView LV_VIEW_LIST
                SwitchView LV_VIEW_DETAILS
            ElseIf m_ViewMode = SB_VIEW_LIST Then
                SwitchView LV_VIEW_DETAILS
                SwitchView LV_VIEW_LIST
            Else 'Only Details and List are supported
                Me.ViewMode = SB_VIEW_LIST
            End If
            Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
    
        Else
            Call ListView_SetImageList(hLVS, ObjPtr(imlSys32), LVSIL_NORMAL)
            Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_SMALL)
            Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_GROUPHEADER)
        End If
    End If
    End Property
    Public Property Get HideDropdownIcons() As Boolean: HideDropdownIcons = m_HideComboIcons: End Property
    Attribute HideDropdownIcons.VB_Description = "Show or hide icons in the directory dropdown."
    Public Property Let HideDropdownIcons(bVal As Boolean)
    If m_HideComboIcons <> bVal Then
        m_HideComboIcons = bVal
        If m_HideComboIcons Then
            Call SendMessageW(hCombo, CBEM_SETIMAGELIST, 0, ByVal 0&)
        Else
            Call SendMessageW(hCombo, CBEM_SETIMAGELIST, 0, ByVal ObjPtr(imlSys16))
        End If
    End If
    End Property
    Public Property Get InfoTipMode() As SB_INFOTIPMODE: InfoTipMode = mInfoTipMode: End Property
    Attribute InfoTipMode.VB_Description = "Sets the tip that pops up when hovering over a list item. Label Tips show only the item name, Extended shows Explorer-style tips with several item properties, or you can supply a custom tip via the QueryCustomInfoTip event."
    Public Property Let InfoTipMode(nMode As SB_INFOTIPMODE)
    If mInfoTipMode <> nMode Then
        mInfoTipMode = nMode
        Select Case mInfoTipMode
            Case SBITM_Disable
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, ByVal 0&
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_LABELTIP, ByVal 0&
            Case SBITM_LabelTipOnly
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, ByVal 0&
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_LABELTIP, ByVal LVS_EX_LABELTIP
            Case SBITM_Extended, SBITM_Custom
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, ByVal LVS_EX_INFOTIP
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_LABELTIP, ByVal LVS_EX_LABELTIP
        End Select
    End If
    End Property
    Public Property Get InfoTipsLimitForHPF() As Boolean: InfoTipsLimitForHPF = mInfoTipLimitHPF: End Property
    Attribute InfoTipsLimitForHPF.VB_Description = "Don't use QITIPF_USESLOWTIP or QITIPF_LINKUSETARGET in HighPerf mode. Mainly affects showing Size/Files/Folders on folder tips."
    Public Property Let InfoTipsLimitForHPF(bVal As Boolean): mInfoTipLimitHPF = bVal: End Property
    Public Property Get BrowseZip() As Boolean: BrowseZip = m_BrowseZip: End Property
    Attribute BrowseZip.VB_Description = "Treat .zip and .cab files like a folder. If enabled you can browse their contents and excluded from any filters that apply to files. "
    Public Property Let BrowseZip(bVal As Boolean): m_BrowseZip = bVal: End Property
    Public Property Get FileExtensions() As SB_EXT_PREF: FileExtensions = m_ForceExt: End Property
    Attribute FileExtensions.VB_Description = "Sets whether to always show file extensions or use Explorer's setting."
    Public Property Let FileExtensions(lVal As SB_EXT_PREF): m_ForceExt = lVal: End Property
    Public Property Get SimpleSelect() As Boolean: SimpleSelect = mSimpSel: End Property
    Attribute SimpleSelect.VB_Description = "For Icon views, when checkboxes are enabled, sets whether the spacebar checks/unchecks all selected items (True), or just the focused item (False). Other views are uneffected and change all."
    Public Property Let SimpleSelect(bVal As Boolean)
    If bVal <> mSimpSel Then
        mSimpSel = bVal
        If mSimpSel Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_SIMPLESELECT, ByVal LVS_EX_SIMPLESELECT
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_SIMPLESELECT, ByVal 0&
        End If
    End If
    End Property
    Public Property Get Checkboxes() As Boolean: Checkboxes = m_Checkboxes: End Property
    Attribute Checkboxes.VB_Description = "Use checkboxes to select files."
    Public Property Let Checkboxes(bVal As Boolean)
    If bVal <> m_Checkboxes Then
        m_Checkboxes = bVal
        If hLVS <> 0& Then
            Dim dwStyle As ucsb_HeaderStyles
            dwStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
            Dim HDI As HDITEMW
            If m_Checkboxes = True Then
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_CHECKBOXES, ByVal LVS_EX_CHECKBOXES
                dwStyle = dwStyle Or HDS_CHECKBOXES
                Call SetWindowLong(hLVSHdr, GWL_STYLE, dwStyle)
                HDI.Mask = HDI_FORMAT
                Header_GetItemW hLVSHdr, 0&, HDI
                HDI.fmt = HDI.fmt Or HDF_CHECKBOX
                Header_SetItemW hLVSHdr, 0&, HDI
            Else
                SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_CHECKBOXES, ByVal 0&
                HDI.Mask = HDI_FORMAT
                Header_GetItemW hLVSHdr, 0&, HDI
                HDI.fmt = HDI.fmt And Not HDF_CHECKBOX
                Header_SetItemW hLVSHdr, 0&, HDI
            End If
        End If
        UserControl.PropertyChanged "Checkboxes"
    End If
    End Property
    Public Property Get EnablePreview() As Boolean: EnablePreview = m_EnablePreview: End Property
    Attribute EnablePreview.VB_Description = "Determines whether the Preview Pane option appears on the View menu."
    Public Property Let EnablePreview(bVal As Boolean): m_EnablePreview = bVal: End Property
    Public Property Get EnableDetails() As Boolean: EnableDetails = m_EnableDetails: End Property
    Attribute EnableDetails.VB_Description = "Determines whether the Details Pane option appears on the view menu."
    Public Property Let EnableDetails(bVal As Boolean): m_EnableDetails = bVal: End Property
    Public Property Get EnableSearch() As Boolean: EnableSearch = m_EnableSearchBox: End Property
    Attribute EnableSearch.VB_Description = "Determines whether the Search Box option appears on the View Menu."
    Public Property Let EnableSearch(bVal As Boolean): m_EnableSearchBox = bVal: End Property
    Public Property Get EnableStatusBar() As Boolean: EnableStatusBar = m_EnableStatusBar: End Property
    Attribute EnableStatusBar.VB_Description = "Determines whether the Status Bar option appears on the View Menu."
    Public Property Let EnableStatusBar(bVal As Boolean): m_EnableStatusBar = bVal: End Property
    Public Property Get EnableViewMenu() As Boolean: EnableViewMenu = m_EnableViewMenu: End Property
    Attribute EnableViewMenu.VB_Description = "Enable or disable the View menu popup when right-clicking on the file list background."
    Public Property Let EnableViewMenu(bVal As Boolean)
    m_EnableViewMenu = bVal
    'UserControl.PropertyChanged "EnableViewMenu"
    End Property
    Public Property Get EnableShellMenu() As Boolean: EnableShellMenu = m_EnableShellMenu: End Property
    Attribute EnableShellMenu.VB_Description = "Controls whether the Explorer right-click menu appears when you right-click a file or folder."
    Public Property Let EnableShellMenu(bVal As Boolean)
    m_EnableShellMenu = bVal
    'UserControl.PropertyChanged "EnableShellMenu"
    End Property
    Public Property Get EnableLayout() As Boolean: EnableLayout = mEnableLayout: End Property
    Attribute EnableLayout.VB_Description = "Sets whether to show the Layout submenu in the View Menu."
    Public Property Let EnableLayout(bVal As Boolean): mEnableLayout = bVal: End Property
    Public Property Get EnableBookmarks() As Boolean: EnableBookmarks = mEnableBookmark: End Property
    Attribute EnableBookmarks.VB_Description = "Sets whether the bookmark menu item appears in the view menu on a background click. Note that this does not effect the Bookmark Button in the control box."
    Public Property Let EnableBookmarks(bVal As Boolean): mEnableBookmark = bVal: End Property
    Public Property Get EnableNewFolder() As Boolean: EnableNewFolder = mEnableNewFolder: End Property
    Attribute EnableNewFolder.VB_Description = "Sets whether the New Folder item appears in the View Menu when the folder background is clicked, or if the keyboard shortcut for a new folder is available."
    Public Property Let EnableNewFolder(bVal As Boolean): mEnableNewFolder = bVal: End Property
    Public Property Get LockView() As Boolean: LockView = m_LockView: End Property
    Attribute LockView.VB_Description = "Show or hide the options to switch view (Details, Large Icons, etc, and Group View) from the View menu."
    Public Property Let LockView(bVal As Boolean): m_LockView = bVal: End Property
    Public Property Get ListControlBox() As Boolean: ListControlBox = m_ControlBox: End Property
    Attribute ListControlBox.VB_Description = "Sets whether the control box ('Up', 'View', the Bookmarks, search box, and depending on their mode, Back/Fwd) is visible. This is a master switch for the box itself-- it must be visible for any of those items to be visible, regardless of their individual"
    Public Property Let ListControlBox(bVal As Boolean): m_ControlBox = bVal: pbControlBox.Visible = bVal: SetNavInitPos: End Property
    Public Property Get AutoHideControlBox() As Boolean: AutoHideControlBox = mAutoHideCtlBox: End Property
    Attribute AutoHideControlBox.VB_Description = "Automatically hide the Control Box (Up, View, etc) to prevent the Directory Dropdown from becoming too small while still allowing the control to get smaller."
    Public Property Let AutoHideControlBox(bVal As Boolean): mAutoHideCtlBox = bVal: End Property
    Public Property Get ShowStatusBar() As Boolean: ShowStatusBar = m_StatusBar: End Property
    Attribute ShowStatusBar.VB_Description = "Toggles the status bar at the bottom that shows file counts and menu tips."
    Public Property Let ShowStatusBar(bShow As Boolean)
    If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then bShow = False
    m_StatusBar = bShow
    If m_StatusBar Then
        ShowWindow m_hStatusBar, SW_SHOW
    Else
        ShowWindow m_hStatusBar, SW_HIDE
    End If
    UserControl_Resize
    UserControl_Resize
    RaiseEvent ToggleStatusBar(bShow)
    End Property
    Public Property Get StatusSinglePanel() As Boolean: StatusSinglePanel = m_StatusSP: End Property
    Attribute StatusSinglePanel.VB_Description = "Show/hide the second StatusBar panel that shows file/folder count and total size."
    Public Property Let StatusSinglePanel(bVal As Boolean)
    If m_StatusSP <> bVal Then
        m_StatusSP = bVal
        DestroyWindow m_hStatusBar
        pvCreateStatusBar
    End If
    End Property
    Public Property Get StatusBarHeight() As Long
    Attribute StatusBarHeight.VB_MemberFlags = "400"
    If m_StatusBar Then
        StatusBarHeight = cyStatusBar
    Else
        StatusBarHeight = 0&
    End If
    End Property
    [ Hidden ]
    Public Property Let StatusBarHeight(cy As Long)
    cyStatusBar = cy
    SendMessage m_hStatusBar, SB_SETMINHEIGHT, cyStatusBar, ByVal 0&
    End Property
    Public Property Get GridLines() As Boolean: GridLines = m_GridLines: End Property
    Attribute GridLines.VB_Description = "Show or hide gridlines in Details view."
    Public Property Let GridLines(ByVal Value As Boolean)
    m_GridLines = Value
    If hLVS <> 0 Then
        If m_GridLines = True Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_GRIDLINES, ByVal LVS_EX_GRIDLINES
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_GRIDLINES, ByVal 0&
        End If
    End If
    UserControl.PropertyChanged "GridLines"
    End Property
    Public Property Get HideLabels() As Boolean: HideLabels = m_HideLabels: End Property
    Attribute HideLabels.VB_Description = "Hides the file name label in the ListView. "
    Public Property Let HideLabels(bVal As Boolean)
    If m_HideLabels <> bVal Then
        m_HideLabels = bVal
        If m_HideLabels Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HIDELABELS, ByVal LVS_EX_HIDELABELS
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HIDELABELS, ByVal 0&
        End If
    End If
    End Property
    Public Property Get ControlType() As SB_CTL_TYPE: ControlType = m_Mode: End Property
    Attribute ControlType.VB_Description = "Show the folder dropdown, file list, or both. This cannot be changed during runtime. "
    Public Property Let ControlType(lVal As SB_CTL_TYPE)
    If lVal <> m_Mode Then
        DebugAppend "ControlType.Enter (Old=" & m_Mode & ",New=" & lVal & ")"
        Dim nOld As SB_CTL_TYPE
        nOld = m_Mode
        m_Mode = lVal
        If (m_ControlBox = True) And (m_Mode = SBCTL_DirAndFiles) Then
            fraPreview.Top = cyCombo + (5 * m_ScaleY)
            pbControlBox.Visible = True
        Else
            If (m_Mode <> SBCTL_DirOnlyWithCtls) Then pbControlBox.Visible = False
            fraPreview.Top = 4 * m_ScaleY
        End If
        
        If m_Mode = SBCTL_FilesOnly Then
            ShowWindow hCombo, SW_HIDE
            DebugAppend "ControlType.HidCombo    "
            cyCombo = 0&
            ShowWindow m_hFwdBtn, SW_HIDE
            ShowWindow m_hBackBtn, SW_HIDE
            DebugAppend "ControlType.DestroyBackFwd"
            pbBackBtnAlt.Visible = False
            pbFwdBtnAlt.Visible = False
        Else
            ShowWindow hCombo, SW_SHOW
            Dim rc As RECT
            Call GetClientRect(hCombo, rc)
            cyCombo = rc.Bottom + (4 * m_ScaleY)
        End If
    
        If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Then
            If hLVS Then
                DebugAppend "Destroy hLVS"
                DestroyWindow hLVS
                hLVS = 0
                UserControl.Refresh
            End If
            DestroyWindow hCombo
            pvCreateCombo
                
            ShowWindow m_hStatusBar, SW_HIDE
            fraPreview.Visible = False
            pbDetailPane.Visible = False
            pbControlBox.Visible = False
            pbPreviewSizer.Visible = False
            pbDetailSizer.Visible = False
            ShowWindow m_hFwdBtn, SW_HIDE
            ShowWindow m_hBackBtn, SW_HIDE
            pbBackBtnAlt.Visible = False
            pbFwdBtnAlt.Visible = False
            SetWindowPos hCombo, 0&, 2 * m_ScaleX, 3 * m_ScaleY, 0&, 0&, SWP_NOSIZE
        ElseIf (m_Mode = SBCTL_DirOnlyWithCtls) Then
            If hLVS Then
                DebugAppend "Destroy hLVS"
                DestroyWindow hLVS
                hLVS = 0
                UserControl.Refresh
            End If
            DestroyWindow hCombo
            pvCreateCombo
            ShowWindow m_hStatusBar, SW_HIDE
            fraPreview.Visible = False
            pbDetailPane.Visible = False
            pbPreviewSizer.Visible = False
            pbDetailSizer.Visible = False
            InitControlBox
            If m_NavBtnType = SBNB_ThemeButton Then
                ShowWindow m_hFwdBtn, SW_SHOW
                ShowWindow m_hBackBtn, SW_SHOW
            End If
            SetWindowPos hCombo, 0&, (lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX), 3 * m_ScaleY, 0&, 0&, SWP_NOSIZE
        Else
            If m_CbType = SBCT_Simple Then Me.ComboType = SBCT_Dropdown
            If hLVS = 0 Then InitLV
            If Ambient.UserMode Then
                If m_sCurPath <> "" Then
                    RefreshView
                End If
            End If
        End If
        
        If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Then
            Me.ShowStatusBar = m_StatusBar
            Me.PreviewPane = m_PvPane
            Me.DetailsPane = m_DtPane
            fraPreview.Top = cyCombo + (5 * m_ScaleY)
        End If
        If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then
            If m_NavBtnType = SBNB_ThemeButton Then
                pbBackBtn.Visible = True
                pbFwdBtn.Visible = True
                lOffBkBtn = cxThemeButtonB
                If bBackEnable Then
                    pvDrawBack NAV_BB_NORMAL
                Else
                    pvDrawBack NAV_BB_DISABLED
                End If
                lOffFwBtn = cxThemeButtonF
                If bEnableFwd Then
                    pvDrawFwd NAV_FB_NORMAL
                Else
                    pvDrawFwd NAV_FB_DISABLED
                End If
                ShowWindow m_hFwdBtn, SW_SHOW
                ShowWindow m_hBackBtn, SW_SHOW
                DebugAppend "NavState=" & iNavStateCur & "," & iFwdNavStateCur & " (normal=" & NAV_FB_NORMAL & ")"
            ElseIf m_NavBtnType = SBNB_ThemeBtnInBox Then
                m_hFwdBtn = pbFwdBtnAlt.hWnd
                m_hdcFwdBtn = pbFwdBtnAlt.hDC
                m_hBackBtn = pbBackBtnAlt.hWnd
                m_hdcBackBtn = pbBackBtnAlt.hDC
                If bBackEnable Then
                    pvDrawBack NAV_BB_NORMAL
                Else
                    pvDrawBack NAV_BB_DISABLED
                End If
                If bEnableFwd Then
                    pvDrawFwd NAV_FB_NORMAL
                Else
                    pvDrawFwd NAV_FB_DISABLED
                End If
                DebugAppend "NavState=" & iNavStateCur & "," & iFwdNavStateCur & " (normal=" & NAV_FB_NORMAL & ")"
            End If
            InitControlBox
            SetWindowPos hCombo, 0&, (lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX), 3 * m_ScaleY, 0&, 0&, SWP_NOSIZE
            RepositionControlBox
        End If
        RaiseEvent ControlTypeChange(nOld, m_Mode)
        UserControl_Resize
        UserControl.PropertyChanged "ControlType"
        DebugAppend "ControlType.Out"
    End If
    End Property
    Public Property Get ComboCanEdit() As Boolean: ComboCanEdit = m_EditCB: End Property
    Attribute ComboCanEdit.VB_Description = "When True, allows typing in the ComboBox's Edit control. Entering a full path or folder name from the current file view, then pressing enter, will navigate to that location. Double-clicking will autofill the full path of the current location."
    Public Property Let ComboCanEdit(bVal As Boolean)
    If m_EditCB <> bVal Then
        m_EditCB = bVal
        If m_CbType = SBCT_DropdownList Then
            m_EditCB = False
        End If
        If m_EditCB Then
            SendMessage hCBEd, EM_SETREADONLY, 0&, ByVal 0&
        Else
            SendMessage hCBEd, EM_SETREADONLY, 1&, ByVal 0&
        End If
    End If
    End Property
    Public Property Get ComboHideIcons() As Boolean: ComboHideIcons = m_CBXNoIcons: End Property
    Attribute ComboHideIcons.VB_Description = "Sets whether to hide the icon displayed for the current folder in the dropdown."
    Public Property Let ComboHideIcons(bVal As Boolean): m_CBXNoIcons = bVal: End Property 'Can't be set during runtime
    Public Property Get ControlBarHeight() As Long: ControlBarHeight = cyCombo + (5 * m_ScaleY): End Property
    Attribute ControlBarHeight.VB_MemberFlags = "400"
    Public Property Get Autocomplete() As Boolean: Autocomplete = mAutoComp: End Property
    Attribute Autocomplete.VB_Description = "If the ComboBox type is Simple or Dropdown, and ComboCanEdit is enabled, turns on/off autocompletion of paths. "
    Public Property Let Autocomplete(bVal As Boolean)
    mAutoComp = bVal
    If Ambient.UserMode Then
        If (m_CbType = SBCT_Dropdown) Or (m_CbType = SBCT_Simple) Then
            If mAutoComp = True Then
                If (pAutoComp Is Nothing) Then InitAutoComplete
                pAutoComp.Enable 1&
            Else
                If (pAutoComp Is Nothing) = False Then
                    pAutoComp.Enable 0&
                End If
            End If
        End If
    End If
    End Property
    Public Property Get ComboType() As SB_COMBO_TYPE: ComboType = m_CbType: End Property
    Attribute ComboType.VB_Description = "Sets the style of the directory dropdown. SBCT_Simple is only available in DirOnly or DrivesOnly mode."
    Public Property Let ComboType(nType As SB_COMBO_TYPE)
    If (nType = SBCT_Simple) And ((m_Mode <> SBCTL_DirOnly) And (m_Mode <> SBCTL_DrivesOnly) And (m_Mode <> SBCTL_DirOnlyWithCtls)) Then nType = m_def_CbType
    If m_CbType <> nType Then
        m_CbType = nType
        If Ambient.UserMode = False Then 'This can't currently be changed at runtime
            DestroyWindow hCombo
            pvCreateCombo
            SetNavInitPos
        Else
            RefreshTree
        End If
    End If
    End Property
    Public Property Get LockNavigation() As Boolean: LockNavigation = m_LockNav: End Property
    Attribute LockNavigation.VB_Description = "Prevent the user from changing location. Does not effect setting it by .BrowserPath."
    Public Property Let LockNavigation(bVal As Boolean)
    If bVal Then
        m_LockNav = True
        EnableWindow hCombo, 0
    Else
        m_LockNav = False
        EnableWindow hCombo, 1
    End If
    End Property
    Private Sub ApplyCtlBorder()
    If (m_CtlBorder = SBCBS_None) Or (m_CtlBorder = SBCBS_Single) Then
        'Standard types
        UserControl.BorderStyle = m_CtlBorder
    Else
        If Ambient.UserMode Then
            Dim dwStyle As WindowStyles, dwExStyle As WindowStylesEx
            dwStyle = CLng(GetWindowLong(UserControl.hWnd, GWL_STYLE))
            dwExStyle = CLng(GetWindowLong(UserControl.hWnd, GWL_EXSTYLE))
            Select Case m_CtlBorder
                Case SBCBS_Thick
                    dwStyle = dwStyle Or WS_BORDER
                    dwStyle = dwStyle And Not WS_THICKFRAME
                    dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
                Case SBCBS_Thicker
                    dwStyle = dwStyle Or WS_BORDER
                    dwStyle = dwStyle Or WS_THICKFRAME
                    dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
            End Select
            Call SetWindowLong(UserControl.hWnd, GWL_STYLE, dwStyle)
            Call SetWindowLong(UserControl.hWnd, GWL_EXSTYLE, dwExStyle)
            SetWindowPos UserControl.hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
        End If
    End If
    End Sub
    Public Property Get BorderStyleControl() As SB_CTLBORDER: BorderStyleControl = m_CtlBorder: End Property
    Attribute BorderStyleControl.VB_Description = "Sets the border style around the entire control (the BorderStyle property applies only to the ListView). NOTE: The Thick and Thicker style are only visible at runtime."
    Public Property Let BorderStyleControl(lVal As SB_CTLBORDER)
    If m_CtlBorder <> lVal Then
        m_CtlBorder = lVal
        ApplyCtlBorder
    End If
    End Property
    Public Property Get BorderStyle() As SB_BORDERSTYLE: BorderStyle = m_Border: End Property
    Attribute BorderStyle.VB_Description = "Sets the border style of the shell browser ListView."
    Public Property Let BorderStyle(lVal As SB_BORDERSTYLE)
    If lVal <> m_Border Then
        m_Border = lVal
        Dim dwStyle As WindowStyles, dwExStyle As WindowStylesEx
        dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
        dwExStyle = CLng(GetWindowLong(hLVS, GWL_EXSTYLE))
        Select Case m_Border
            Case SBBS_None
                dwStyle = dwStyle And Not WS_BORDER
                dwStyle = dwStyle And Not WS_THICKFRAME
                dwExStyle = dwExStyle And Not WS_EX_CLIENTEDGE
            Case SBBS_Standard
                dwStyle = dwStyle Or WS_BORDER
                dwStyle = dwStyle And Not WS_THICKFRAME
                dwExStyle = dwExStyle And Not WS_EX_CLIENTEDGE
            Case SBBS_Thick
                dwStyle = dwStyle Or WS_BORDER
                dwStyle = dwStyle And Not WS_THICKFRAME
                dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
            Case SBBS_Thicker
                dwStyle = dwStyle Or WS_BORDER
                dwStyle = dwStyle Or WS_THICKFRAME
                dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
        End Select
        Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
        Call SetWindowLong(hLVS, GWL_EXSTYLE, dwExStyle)
        SetWindowPos hLVS, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
        If m_StatusBar Then
            DestroyWindow m_hStatusBar
            m_hStatusBar = 0&
            pvCreateStatusBar
        End If
    End If
    End Property
    Public Property Get Enabled() As Boolean: Enabled = UserControl.Enabled: End Property
    Attribute Enabled.VB_Description = "Sets enabled/disabled for the entire control."
    Public Property Let Enabled(ByVal Value As Boolean)
    If Value <> mMasterEnabled Then
        mMasterEnabled = Value
        UserControl.Enabled = mMasterEnabled
        EnableWindow hLVS, IIf(mMasterEnabled = True, 1, 0)
        EnableWindow hCombo, IIf(mMasterEnabled = True, 1, 0)
        UserControl.PropertyChanged "Enabled"
    End If
    End Property
    Public Property Get DisableWhileLoading() As Boolean: DisableWhileLoading = m_DisableWhileLoading: End Property
    Attribute DisableWhileLoading.VB_Description = "Temporarily disable the ListView while a new folder is being loaded (the items will still be shown, just grayed and unable to be clicked). "
    Public Property Let DisableWhileLoading(bVal As Boolean): m_DisableWhileLoading = bVal: End Property
    Public Property Get LoadingMarquee() As Boolean: LoadingMarquee = mEditMarq: End Property
    Attribute LoadingMarquee.VB_Description = "Show a progress marquee in the combo edit box while loading folders."
    Public Property Let LoadingMarquee(bVal As Boolean): mEditMarq = bVal: End Property
    Public Property Get ViewMode() As ShellBrowseView: ViewMode = m_ViewMode: End Property
    Attribute ViewMode.VB_Description = "Switches the file view appearance between the standard ListView modes."
    Public Property Let ViewMode(lView As ShellBrowseView)
    If lView <> m_ViewMode Then
        SwitchView lView
        RaiseEvent ViewChanged(lView)
    End If
    m_ViewMode = lView
    End Property
    Public Property Get RestrictViewModes() As String: RestrictViewModes = mStrRVM: End Property
    Attribute RestrictViewModes.VB_Description = "Hide certain view modes from the View menu and prevent them from being switched to in code. This string is checked for whether it contains the numbers 0 to 8: 0=XLIcon, 1=LgIcon, 2=MedIcon, 3=SmIcon, 4=List, 5=Detail, 6=Tile, 7=Content, 8=Thumbnail"
    Public Property Let RestrictViewModes(sList As String)
    mStrRVM = sList
    InitRVM
    End Property
    Public Property Get ViewButton() As Boolean: ViewButton = m_ViewButton: End Property
    Attribute ViewButton.VB_Description = "Show/hide the 'View' button at the top of the control. Options are always available on folder right-click."
    Public Property Let ViewButton(bShow As Boolean)
    If m_ViewButton <> bShow Then
        m_ViewButton = bShow
        If m_ControlBox = True Then
            InitControlBox
            UserControl_Resize
        End If
    End If
    End Property
    Public Property Get UpButton() As Boolean: UpButton = m_UpButton: End Property
    Attribute UpButton.VB_Description = "Toggles the inclusion of the 'Up' button in the list control box at the top of the control."
    Public Property Let UpButton(bShow As Boolean)
    If m_UpButton <> bShow Then
        m_UpButton = bShow
        If m_ControlBox = True Then
            InitControlBox
            UserControl_Resize
        End If
    End If
    End Property
    Public Property Get NavigationButtons() As SB_NAV_BUTTONS: NavigationButtons = m_NavBtnType: End Property
    Attribute NavigationButtons.VB_Description = "Set the type of Back/Forward buttons you want: 0=None, 1=Normal buttons next to Up, 2=Explorer-style themed buttons to the left of the dropdown. 3=The Explorer-style themed buttons, but placed in the control box on the right."
    Public Property Let NavigationButtons(nType As SB_NAV_BUTTONS)
    If m_NavBtnType <> nType Then
        'First, switch off any themed buttons
        If (m_NavBtnType = SBNB_ThemeButton) Or (m_NavBtnType = SBNB_ThemeBtnInBox) Then
            lOffBkBtn = 0&
            lOffFwBtn = 0&
            If pbBackBtnAlt.Visible = True Then
                If Ambient.UserMode Then
                    ' ssc_UnSubclass pbBackBtnAlt.hWnd
                    UnSubclass2 pbBackBtnAlt.hWnd, AddressOf BKWndProc, pbBackBtnAlt.hWnd
                End If
                pbBackBtnAlt.Visible = False
            End If
            If pbFwdBtnAlt.Visible = True Then
                If Ambient.UserMode Then
                    ' ssc_UnSubclass pbFwdBtnAlt.hWnd
                    UnSubclass2 pbFwdBtnAlt.hWnd, AddressOf FWWndProc, pbFwdBtnAlt.hWnd
                End If
                pbFwdBtnAlt.Visible = False
            End If
            If pbBackBtn.Visible = True Then
                If Ambient.UserMode Then
                    'ssc_UnSubclass pbBackBtn.hWnd
                    UnSubclass2 pbBackBtn.hWnd, AddressOf BKWndProc, pbBackBtn.hWnd
                End If
                pbBackBtn.Visible = False
            End If
            If pbFwdBtn.Visible = True Then
                If Ambient.UserMode Then
                    'ssc_UnSubclass pbFwdBtn.hWnd
                    UnSubclass2 pbFwdBtn.hWnd, AddressOf FWWndProc, pbFwdBtn.hWnd
                End If
                pbFwdBtn.Visible = False
            End If
        End If
        
        'Now, turn on new mode.
        m_NavBtnType = nType
        If m_NavBtnType = SBNB_ThemeButton Then
            lOffBkBtn = cxThemeButtonB
            lOffFwBtn = cxThemeButtonF
            m_hFwdBtn = pbFwdBtn.hWnd
            m_hdcFwdBtn = pbFwdBtn.hDC
            m_hBackBtn = pbBackBtn.hWnd
            m_hdcBackBtn = pbBackBtn.hDC
            pbBackBtn.Visible = True
            pbFwdBtn.Visible = True
            pbBackBtnAlt.Visible = False
            DebugAppend pbBackBtn.Visible
            pbFwdBtnAlt.Visible = False
            pbBackBtn.Left = 0
            pbBackBtn.Top = 0
            pbFwdBtn.Left = (cxThemeButtonF) + 1
            pbFwdBtn.Top = 0
            If bBackEnable Then
                pbBackBtn.Top = pbFwdBtn.Top
                DebugAppend pbBackBtn.Top & "," & pbFwdBtn.Top
                DebugAppend pbBackBtn.Left & "," & pbFwdBtn.Left
                
                pvDrawBack NAV_BB_NORMAL, True
            Else
                pvDrawBack NAV_BB_DISABLED, True
            End If
            If bEnableFwd Then
                pvDrawFwd NAV_FB_NORMAL, True
            Else
                pvDrawFwd NAV_FB_DISABLED, True
            End If
            
            If Ambient.UserMode Then
                ' If ssc_Subclass(pbBackBtn.hWnd, , 9, , , True) Then
                '  Call ssc_AddMsg(pbBackBtn.hWnd, MSG_BEFORE, ALL_MESSAGES)
                ' End If
                ' If ssc_Subclass(pbFwdBtn.hWnd, , 10, , , True) Then
                '  Call ssc_AddMsg(pbFwdBtn.hWnd, MSG_BEFORE, ALL_MESSAGES)
                ' End If
                Subclass2 pbBackBtn.hWnd, AddressOf BKWndProc, pbBackBtn.hWnd
                Subclass2 pbFwdBtn.hWnd, AddressOf FWWndProc, pbFwdBtn.hWnd
            End If
    
        End If
        
        If (m_Mode <> SBCTL_DirAndFiles) And (m_Mode <> SBCTL_DirOnlyWithCtls) Then
            lOffBkBtn = 0&: lOffFwBtn = 0&
        End If
    
        If hCombo Then
            SetWindowPos hCombo, 0&, (lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX), 1&, 0&, 0&, SWP_NOSIZE
        End If
        If m_ControlBox = True Then
            InitControlBox
        End If
        If m_NavBtnType = SBNB_ThemeBtnInBox Then
            m_hFwdBtn = pbFwdBtnAlt.hWnd
            m_hdcFwdBtn = pbFwdBtnAlt.hDC
            m_hBackBtn = pbBackBtnAlt.hWnd
            m_hdcBackBtn = pbBackBtnAlt.hDC
            If bBackEnable Then
                pvDrawBack NAV_BB_NORMAL, True
            Else
                pvDrawBack NAV_BB_DISABLED, True
            End If
            If bEnableFwd Then
                pvDrawFwd NAV_FB_NORMAL, True
            Else
                pvDrawFwd NAV_FB_DISABLED, True
            End If
            If Ambient.UserMode Then
                ' If ssc_Subclass(pbBackBtnAlt.hWnd, , 9, , , True) Then
                '  Call ssc_AddMsg(pbBackBtnAlt.hWnd, MSG_BEFORE, ALL_MESSAGES)
                ' End If
                Subclass2 pbBackBtnAlt.hWnd, AddressOf BKWndProc, pbBackBtnAlt.hWnd
            End If
            If Ambient.UserMode Then
                ' If ssc_Subclass(pbFwdBtnAlt.hWnd, , 10, , , True) Then
                '  Call ssc_AddMsg(pbFwdBtnAlt.hWnd, MSG_BEFORE, ALL_MESSAGES)
                ' End If
                Subclass2 pbFwdBtnAlt.hWnd, AddressOf FWWndProc, pbFwdBtnAlt.hWnd
            End If
        End If
    
        If (m_ControlBox = True) And ((m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_DirOnlyWithCtls)) Then
            fraPreview.Top = cyCombo + (5 * m_ScaleY)
            pbControlBox.Visible = True
        Else
            pbControlBox.Visible = False
            fraPreview.Top = 4 * m_ScaleY
        End If
    
        UserControl_Resize
        UserControl.PropertyChanged "NavigationButtons"
    End If
    End Property
    Public Property Get NavShowOnFilesOnlyCtxMenu() As Boolean: NavShowOnFilesOnlyCtxMenu = mBkFwInCtx: End Property
    Attribute NavShowOnFilesOnlyCtxMenu.VB_Description = "Show Back/Forward menu items in the background context menu when the control is in Files Only mode."
    Public Property Let NavShowOnFilesOnlyCtxMenu(bVal As Boolean): mBkFwInCtx = bVal: End Property
    Public Property Get BookmarkButton() As Boolean: BookmarkButton = m_BookmarkButton: End Property
    Attribute BookmarkButton.VB_Description = "Show/hide a button in the control box with a list of bookmarks."
    Public Property Let BookmarkButton(bShow As Boolean)
    If m_BookmarkButton <> bShow Then
        m_BookmarkButton = bShow
        If m_ControlBox = True Then
            InitControlBox
            UserControl_Resize
        End If
        UserControl.PropertyChanged "BookmarkButton"
    End If
    End Property
    Public Property Get Bookmarks() As String: Bookmarks = m_Bookmarks: End Property
    Attribute Bookmarks.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let Bookmarks(sBkmSet As String)
    m_Bookmarks = sBkmSet
    SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
    End Property
    Public Property Get SpecialFoldersInBookmarks() As Boolean: SpecialFoldersInBookmarks = mSFinBKM: End Property
    Attribute SpecialFoldersInBookmarks.VB_Description = "Show a submenu with a set of Special Folders (e.g. Downloads, Documents, Recent Places, etc) in the bookmarks menu. Only available if bookmarks menu is enabled (BookmarkButton property). "
    Public Property Let SpecialFoldersInBookmarks(bVal As Boolean): mSFinBKM = bVal: End Property
    Public Property Get MaxHistoryDisplayed() As Long: MaxHistoryDisplayed = mMaxHist: End Property
    Attribute MaxHistoryDisplayed.VB_Description = "The maximum number of history entries displayed in the back/forward history menu."
    [ Description ("The maximum number of history entries displayed in the back/forward history menu.") ]
    Public Property Let MaxHistoryDisplayed(lVal As Long): mMaxHist = lVal: End Property
    Public Property Get ShowFooterAfterSearch() As Boolean: ShowFooterAfterSearch = mFtrPostSearch: End Property
    Attribute ShowFooterAfterSearch.VB_Description = "Automatically display a footer bar after a search is completed, with options to repeat the search in several other places."
    Public Property Let ShowFooterAfterSearch(bVal As Boolean): mFtrPostSearch = bVal: End Property
    Public Property Get SearchBox() As Boolean: SearchBox = mShowSearch: End Property
    Attribute SearchBox.VB_Description = "Toggles the display of the Search Box in the control box."
    Public Property Let SearchBox(bShow As Boolean)
    If mShowSearch <> bShow Then
        mShowSearch = bShow
        If m_ControlBox = True Then
            InitControlBox
            UserControl_Resize
            If mShowSearch Then
                pvCreateSearchBox
                If Ambient.UserMode Then SetSearchBoxCue
            Else
                DestroyWindow hSearchBox
                hSearchBox = 0&
            End If
        End If
        UserControl.PropertyChanged "SearchBox"
    End If
    End Property
    Public Property Get SearchPopupInMenu() As Boolean: SearchPopupInMenu = mSearchPopupInMenu: End Property
    Attribute SearchPopupInMenu.VB_Description = "Add a menu item in the Layout submenu to directly show the Search Options popup. "
    Public Property Let SearchPopupInMenu(bVal As Boolean): mSearchPopupInMenu = bVal: End Property
    Public Property Get SearchAutoGroup() As Boolean: SearchAutoGroup = mSearchAutoGroup: End Property
    Public Property Let SearchAutoGroup(bVal As Boolean): mSearchAutoGroup = bVal: End Property
    Public Property Get SearchBoxWidth() As Long: SearchBoxWidth = mCXSearch: End Property
    Attribute SearchBoxWidth.VB_Description = "Sets the width (in pixels) of the search box. This value is automatically scaled for DPI."
    Public Property Let SearchBoxWidth(cx As Long)
    If mCXSearch <> cx Then
        mCXSearch = cx
        pbSearchContainer.Width = mCXSearch * m_ScaleX
        Dim cyOff As Long
        If m_ScaleY > 1 Then
            cyOff = 7 * m_ScaleY
        Else
            cyOff = 8 * m_ScaleY
        End If
        SetWindowPos hSearchBox, 0&, 0&, 0&, pbSearchContainer.ScaleWidth - 4, Abs(m_cyFontDtTxt) + cyOff, SWP_NOMOVE Or SWP_NOZORDER
        If m_ControlBox Then
            InitControlBox
            UserControl_Resize
        End If
        UserControl.PropertyChanged "SearchBoxWidth"
        DebugAppend "cxsearch=" & pbSearchContainer.ScaleWidth
    End If
    End Property
    Public Property Get PreviewPane() As Boolean: PreviewPane = m_PvPane: End Property
    Attribute PreviewPane.VB_Description = "Shows a pane that displays a preview of the selected file."
    Public Property Let PreviewPane(bShow As Boolean)
    If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then bShow = False
    m_PvPane = bShow
    If m_PvPane = False Then
        fraPreview.Visible = False
        pbPreviewSizer.Visible = False
    Else
        pbPreviewSizer.Visible = True
        SetPVInitPos
        SetLVInitPos
    End If
    RaiseEvent PreviewPaneWidthChanged
    UserControl_Resize
    If bPvLockCX Then
        pbPreviewSizer.Visible = False
    End If
    UserControl.PropertyChanged "PreviewPane"
    End Property
    Public Property Get PreviewPaneHeight() As Long
    Attribute PreviewPaneHeight.VB_MemberFlags = "400"
    If m_PvPane Then
        PreviewPaneHeight = pbPreviewPane.ScaleHeight
    Else
        PreviewPaneHeight = 0&
    End If
    End Property
    Public Property Get PreviewPaneWidth() As Long
    Attribute PreviewPaneWidth.VB_MemberFlags = "400"
    If m_PvPane Then
        PreviewPaneWidth = pbPreviewPane.ScaleWidth
    Else
        PreviewPaneWidth = 0&
    End If
    End Property
    [ Hidden ]
    Public Property Let PreviewPaneWidth(cx As Long)
    '(note: there's no Let for height, just adjust the usercontrol height to change that)
    'easiest way: mimic the sizer move
    If m_PvPane Then
        bPMove = True
        cx = cx + 18 'Account for the difference between how we trigger resize (with the sizer) and the desired width of the pane itself
        pbPreviewSizer.Left = (UserControl.ScaleWidth - cx)
        If pbPreviewSizer.Left > (UserControl.ScaleWidth - 38) Then
            pbPreviewSizer.Left = (UserControl.ScaleWidth - 38)
        End If
        If pbPreviewSizer.Left < 30 Then pbPreviewSizer.Left = 30
        
        UserControl_Resize
        bPMove = False
        
        Dim rc As RECT
        rc.Top = 2
        rc.Bottom = (pbPreviewPane.Height / Screen.TwipsPerPixelY) - 2
        rc.Left = 2
        rc.Right = (pbPreviewPane.Width / Screen.TwipsPerPixelX) - 2
        ShowPreviewForFile siFocus, pbPreviewPane.hWnd, rc, pbPreviewPane
        UserControl.PropertyChanged "PreviewPaneWidth"
    End If
    End Property
    Public Property Get PreviewPaneWidthLocked() As Boolean: PreviewPaneWidthLocked = bPvLockCX: End Property
    Attribute PreviewPaneWidthLocked.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let PreviewPaneWidthLocked(bVal As Boolean)
    If bVal = False Then
        bPvLockCX = False
        pbPreviewSizer.Visible = True
        pbPreviewSizer.Top = fraPreview.Top + 5
        pbPreviewSizer.Height = fraPreview.Height - 10
        pbPreviewSizer.Left = fraPreview.Left - 2
        SetWindowPos pbPreviewSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    Else
        bPvLockCX = True
        pbPreviewSizer.Visible = False
    End If
    End Property
    Public Property Get PreviewVideoAsThumb() As Boolean: PreviewVideoAsThumb = m_PreviewVidThumb: End Property
    Attribute PreviewVideoAsThumb.VB_Description = "Display a thumbnail of video files in the Preview Pane instead of a video player."
    Public Property Let PreviewVideoAsThumb(bVal As Boolean): m_PreviewVidThumb = bVal: End Property
    Public Property Get DetailsPane() As Boolean: DetailsPane = m_DtPane: End Property
    Attribute DetailsPane.VB_Description = "Show/hide a bar at the bottom with details (size, date modified, etc) of the selected file. Can edit properties where supported."
    Public Property Let DetailsPane(bShow As Boolean)
    If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or m_Mode = SBCTL_DirOnlyWithCtls Then bShow = False
    m_DtPane = bShow
    pbDetailPane.Visible = bShow
    pbDetailSizer.Visible = bShow
    pbDetailSizer.Top = pbDetailPane.Top
    pbDetailSizer.Width = pbDetailPane.Width - 10
    RaiseEvent DetailPaneHeightChanged
    UserControl_Resize
    If bDtLockCY Then
        pbDetailSizer.Visible = False
    End If
    If m_DtPane Then pvCreateDetailPaneBkg
    RaiseEvent ToggleDetailsPane(bShow)
    UserControl.PropertyChanged "DetailsPane"
    End Property
    Public Property Get DetailsPaneWidth() As Long
    If m_DtPane Then
        DetailsPaneWidth = pbDetailPane.ScaleWidth
    Else
        DetailsPaneWidth = 0&
    End If
    End Property
    Public Property Get DetailsPaneHeight() As Long
    Attribute DetailsPaneHeight.VB_MemberFlags = "400"
    If m_DtPane Then
        DetailsPaneHeight = pbDetailPane.ScaleHeight
    Else
        DetailsPaneHeight = 0&
    End If
    End Property
    [ Hidden ]
    Public Property Let DetailsPaneHeight(cy As Long)
    If m_DtPane Then
        bSMove = True
        pbDetailSizer.Top = (UserControl.ScaleHeight - cy)
        If pbDetailSizer.Top < (cyMinListView + cyCombo + 6) Then
            pbDetailSizer.Top = (cyMinListView + cyCombo + 6)
        End If
        UserControl_Resize
        bSMove = False
        RedrawLastDetailPane
        UserControl.PropertyChanged "DetailsPaneHeight"
    End If
    End Property
    Public Property Get DetailsPaneHeightLocked() As Boolean: DetailsPaneHeightLocked = bDtLockCY: End Property
    Attribute DetailsPaneHeightLocked.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let DetailsPaneHeightLocked(bVal As Boolean)
    If bVal = False Then
        bDtLockCY = False
        pbDetailSizer.Visible = True
        pbDetailSizer.Top = pbDetailPane.Top
        pbDetailSizer.Width = pbDetailPane.Width - 10
        SetWindowPos pbDetailSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    Else
        bDtLockCY = True
        pbDetailSizer.Visible = False
    End If
    End Property
    Public Property Get DetailsPaneNoResizing() As Boolean: DetailsPaneNoResizing = mDtPaneNoRS: End Property
    Attribute DetailsPaneNoResizing.VB_Description = "The Details Pane size is locked and the menu to unlock it is disabled."
    Public Property Let DetailsPaneNoResizing(bVal As Boolean)
    mDtPaneNoRS = bVal
    If bVal = True Then
        Me.DetailsPaneHeightLocked = True
    Else
        Me.DetailsPaneHeightLocked = False
    End If
    End Property
    Public Property Get PreviewPaneNoResizing() As Boolean: PreviewPaneNoResizing = mPvPaneNoRS: End Property
    Attribute PreviewPaneNoResizing.VB_Description = "The Preview Pane size is locked and the menu to unlock it is disabled."
    Public Property Let PreviewPaneNoResizing(bVal As Boolean)
    mPvPaneNoRS = bVal
    Me.PreviewPaneWidthLocked = True
    End Property
    Public Property Get GroupMode() As ShellBrowseGroupBy: GroupMode = m_GroupMode: End Property
    Attribute GroupMode.VB_Description = "The column to group by. Extended is for runtime only."
    Public Property Let GroupMode(lMode As ShellBrowseGroupBy)
    If lMode <> m_GroupMode Then
        SetGroupMode lMode
    End If
    m_GroupMode = lMode
    End Property
    Public Property Get GroupSubsetCount() As Long: GroupSubsetCount = m_GroupSubset: End Property
    Attribute GroupSubsetCount.VB_Description = "When Group Mode is enabled, only show this many items, with a link to show more. Set to 0 to disable."
    Public Property Let GroupSubsetCount(ByVal Value As Long)
    If Value < 0 Then Exit Property
    m_GroupSubset = Value
    If m_GroupMode <> SBGB_None Then
        SendMessage hLVS, LVM_SETGROUPSUBSETCOUNT, 0, ByVal m_GroupSubset
    End If
    UserControl.PropertyChanged "GroupSubsetCount"
    End Property
    Public Property Get GroupSubsetLinkText() As String: GroupSubsetLinkText = m_GroupSubsetLinkText: End Property
    Attribute GroupSubsetLinkText.VB_Description = "The text of the link to show more items when a group is subsetted."
    Public Property Let GroupSubsetLinkText(ByVal Value As String)
    If Value = "" Then Exit Property
    m_GroupSubsetLinkText = Value
    GroupUpdateSubsetText hLVS
    UserControl.PropertyChanged "GroupSubsetCountLinkText"
    End Property
    Public Property Get GroupStartCollapsed() As Boolean: GroupStartCollapsed = m_InsColp: End Property
    Attribute GroupStartCollapsed.VB_Description = "Sets whether groups start out collapsed instead of expanded."
    Public Property Let GroupStartCollapsed(bVal As Boolean): m_InsColp = bVal: End Property
    Public Property Get FullRowSelect() As Boolean: FullRowSelect = m_FullRowSel: End Property
    Attribute FullRowSelect.VB_Description = "Highlight the entire row in Details view instead of just the name."
    Public Property Let FullRowSelect(bVal As Boolean)
    If Ambient.UserMode Then
        If bVal <> m_FullRowSel Then
            If bVal Then
                Call SendMessage(hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, ByVal LVS_EX_FULLROWSELECT)
            Else
                Call SendMessage(hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, ByVal 0&)
            End If
        End If
    End If
    m_FullRowSel = bVal
    End Property
    Public Property Get SnapToGrid() As Boolean: SnapToGrid = m_SnapToGrid: End Property
    Attribute SnapToGrid.VB_Description = "Automatically snap icons into a grid position. Applies to Large Icon, Small Icon, and Tile/Content Views."
    Public Property Let SnapToGrid(ByVal Value As Boolean)
    If Value = m_SnapToGrid Then Exit Property
    m_SnapToGrid = Value
    If m_SnapToGrid Then
        SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_SNAPTOGRID, ByVal LVS_EX_SNAPTOGRID
    Else
        SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_SNAPTOGRID, ByVal 0&
    End If
    UserControl.PropertyChanged "SnapToGrid"
    End Property
    Public Property Get FileNameColors() As SB_COLOR_PREF: FileNameColors = m_NameColors: End Property
    Attribute FileNameColors.VB_Description = "If enabled, encrypted files are shown in green and compressed files are shown in blue."
    Public Property Let FileNameColors(lVal As SB_COLOR_PREF): m_NameColors = lVal: End Property
    Public Property Get ItemFilter() As String: ItemFilter = m_Filter: End Property
    Attribute ItemFilter.VB_Description = "Shows only files matching the pattern. The FilterFile event is also raised to override the pattern filter; completely erase this property to disable. * or *.* to show all."
    Public Property Let ItemFilter(sSpec As String)
    If sSpec <> m_Filter Then
        m_Filter = sSpec
        bSuppress = True
        RefreshView
        bSuppress = False
    End If
    PropertyChanged "ItemFilter"
    End Property
    Public Property Get ItemFilterFolder() As String: ItemFilterFolder = m_FolderFilter: End Property
    Attribute ItemFilterFolder.VB_Description = "Shows only folders matching the pattern. The FilterFolder event is also raised to override the pattern filter; completely erase this property to disable. Enter * or *.* to show all."
    Public Property Let ItemFilterFolder(sSpec As String)
    If sSpec <> m_FolderFilter Then
        m_FolderFilter = sSpec
        bSuppress = True
        RefreshView
        bSuppress = False
    End If
    End Property
    Public Property Get AllowSorting() As Boolean: AllowSorting = m_AllowSorting: End Property
    Attribute AllowSorting.VB_Description = "If sorting is not allowed, the Sort menu is disabled and column headers in Details View cannot be clicked."
    Public Property Let AllowSorting(bVal As Boolean)
    If bVal = m_AllowSorting Then Exit Property
    m_AllowSorting = bVal
    Dim hdrStyle As ucsb_HeaderStyles
    hdrStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
    If m_AllowSorting Then
        hdrStyle = hdrStyle Or HDS_BUTTONS
    Else
        hdrStyle = hdrStyle And Not HDS_BUTTONS
    End If
    SetWindowLong hLVSHdr, GWL_STYLE, hdrStyle
    End Property
    Public Property Get AllowGroups() As Boolean: AllowGroups = mEnableGrp: End Property
    Attribute AllowGroups.VB_Description = "Sets whether Groups appear on the View Menu."
    Public Property Let AllowGroups(bVal As Boolean): mEnableGrp = bVal: End Property
    Public Property Get AllowPasting() As Boolean: AllowPasting = mEnablePaste: End Property
    Attribute AllowPasting.VB_Description = "Sets whether pasting is allowed and appears on the View Menu."
    Public Property Let AllowPasting(bVal As Boolean): mEnablePaste = bVal: End Property
    Public Property Get HeaderNoSizing() As Boolean: HeaderNoSizing = m_NoHdrSize: End Property
    Attribute HeaderNoSizing.VB_Description = "Toggle the ability for the user to resize column headers during runtime."
    Public Property Let HeaderNoSizing(bVal As Boolean)
    If bVal = m_NoHdrSize Then Exit Property
    m_NoHdrSize = bVal
    Dim hdrStyle As ucsb_HeaderStyles
    hdrStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
    If m_NoHdrSize Then
        hdrStyle = hdrStyle Or HDS_NOSIZING
    Else
        hdrStyle = hdrStyle And Not HDS_NOSIZING
    End If
    SetWindowLong hLVSHdr, GWL_STYLE, hdrStyle
    End Property
    Public Property Get HeaderMinWidth() As Long: HeaderMinWidth = m_HdrMinCX: End Property
    Attribute HeaderMinWidth.VB_Description = "Enforce an absolute minimum width for all column headers. 0 to disable."
    Public Property Let HeaderMinWidth(cx As Long)
    m_HdrMinCX = cx
    If m_HdrMinCX < 0& Then m_HdrMinCX = 0&
    End Property
    Public Property Get HeaderInAllViews() As Boolean: HeaderInAllViews = m_HeaderInAll: End Property
    Attribute HeaderInAllViews.VB_Description = "For the ListView, sets whether to show the details column header (Name, Size, etc) in the view modes besides Details."
    Public Property Let HeaderInAllViews(bVal As Boolean)
    If m_HeaderInAll <> bVal Then
        m_HeaderInAll = bVal
        If m_HeaderInAll Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HEADERINALLVIEWS, ByVal LVS_EX_HEADERINALLVIEWS
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HEADERINALLVIEWS, ByVal 0&
        End If
    End If
    End Property
    Public Property Get SelectColumnOnSort() As Boolean: SelectColumnOnSort = mAutoSelCol: End Property
    Attribute SelectColumnOnSort.VB_Description = "Automatically highlight the background of a column when you sort by it."
    Public Property Let SelectColumnOnSort(bVal As Boolean): mAutoSelCol = bVal: End Property
    Public Property Get MinWidthDropdown() As Long: MinWidthDropdown = m_MinDropCX: End Property
    Attribute MinWidthDropdown.VB_Description = "The minimum width of the directory dropdown."
    Public Property Let MinWidthDropdown(lVal As Long)
    m_MinDropCX = lVal
    Call SendMessageW(hCombo, CB_SETDROPPEDWIDTH, m_MinDropCX, ByVal 0&)
    End Property
    Public Property Get MinHeightDropdown() As Long: MinHeightDropdown = m_MinDropCY: End Property
    Attribute MinHeightDropdown.VB_Description = "Specify the minimum height of the Directory Dropdown. This will be multiplied by the monitor's zoom. "
    Public Property Let MinHeightDropdown(lVal As Long)
    m_MinDropCY = lVal
    UserControl_Resize
    End Property
    Public Property Get DropdownFixedHeight() As Long: DropdownFixedHeight = mFixedDropHeight: End Property
    Attribute DropdownFixedHeight.VB_Description = "Specify the height of the Directory Dropdown. If this value is 0, the height is set to the UserControl height, or the value of MinHeightDropdown, whichever is larger."
    Public Property Let DropdownFixedHeight(lVal As Long)
    mFixedDropHeight = lVal
    UserControl_Resize
    End Property
    Public Property Get DropdownExpandChildren() As SB_EXPDDMODE: DropdownExpandChildren = nExpandSelectedFolderInDropdown: End Property
    Attribute DropdownExpandChildren.VB_Description = "Add the child folders of the selected item in the Directory Dropdown. This is normally done for Directory Mode and Dir Mode w/ Controls, but can be set to all modes or disabled entirely. Folders loaded where this applies cannot use the High Performance L"
    Public Property Let DropdownExpandChildren(nVal As SB_EXPDDMODE): nExpandSelectedFolderInDropdown = nVal: End Property
    Public Property Get ListViewOffsetX() As Long: ListViewOffsetX = mLVOffX: End Property
    Attribute ListViewOffsetX.VB_Description = "Add an X offset to the ListView within the control. "
    Public Property Let ListViewOffsetX(lVal As Long)
    mLVOffX = lVal
    UserControl_Resize
    End Property
    Public Property Get DetailsPaneOffsetX() As Long: DetailsPaneOffsetX = mDTOffsetX: End Property
    Attribute DetailsPaneOffsetX.VB_Description = "Add an X offset to the Details Pane within the control. "
    Public Property Let DetailsPaneOffsetX(lVal As Long)
    mDTOffsetX = lVal
    UserControl_Resize
    End Property
    Public Property Get HideColumnHeader() As Boolean: HideColumnHeader = m_HideColumnHeader: End Property
    Attribute HideColumnHeader.VB_Description = "Hide the column header when the file list is in Details view."
    Public Property Let HideColumnHeader(bVal As Boolean)
    m_HideColumnHeader = bVal
    Dim dwStyle As ucsb_LVStyles
    dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
    Dim dwHdrS As ucsb_HeaderStyles
    dwHdrS = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
    
    DebugAppend "HideColumnHeader style present=" & (dwHdrS And HDS_HIDDEN)
    If m_HideColumnHeader Then
        dwStyle = dwStyle Or LVS_NOCOLUMNHEADER
    Else
        If (dwStyle And LVS_NOCOLUMNHEADER) = LVS_NOCOLUMNHEADER Then
            dwStyle = dwStyle And Not LVS_NOCOLUMNHEADER
        End If
    End If
    SetWindowLong hLVS, GWL_STYLE, dwStyle
    UserControl.PropertyChanged "HideColumnHeader"
    End Property
    Public Property Get StatusText() As String: StatusText = mStatusText: End Property
    Attribute StatusText.VB_Description = "The current text of the status bar."
    Attribute StatusText.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let StatusText(sText As String): UpdateStatus sText: End Property
    Public Property Get StatusTextStart() As String: StatusTextStart = mDefStatusText: End Property
    Attribute StatusTextStart.VB_Description = "Display a startup message in the Status Bar."
    Public Property Let StatusTextStart(sText As String): mDefStatusText = sText: End Property
    Public Property Get hWndUserControl() As LongPtr: hWndUserControl = UserControl.hWnd: End Property
    Public Property Get hWndCombo() As LongPtr: hWndCombo = hCombo: End Property
    Public Property Get hWndComboEdit() As LongPtr: hWndComboEdit = hCBEd: End Property
    Public Property Get hWndListView() As LongPtr: hWndListView = hLVS: End Property
    Public Property Get hWndListViewHeader() As LongPtr: hWndListViewHeader = hLVSHdr: End Property
    Public Property Get hWndStatusBar() As LongPtr: hWndStatusBar = m_hStatusBar: End Property
    Public Property Get hWndPreviewBox() As LongPtr: hWndPreviewBox = pbPreviewPane.hWnd: End Property
    Public Property Get hWndDetailBox() As LongPtr: hWndDetailBox = pbDetailPane.hWnd: End Property
    Public Property Get hWndControlBox() As LongPtr: hWndControlBox = pbControlBox.hWnd: End Property
    Public Property Get SelCount() As Long
    SelCount = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    End Property
    Public Property Get SelectedFilePath() As String
    SelectedFilePath = sSelectedFile
    End Property
    Public Property Get SelectedFile() As String
    Attribute SelectedFile.VB_MemberFlags = "400"
    SelectedFile = tSelectedFile.sName
    End Property
    [ Hidden ]
    Public Property Let SelectedFile(sName As String)
    Dim i As Long
    ' Dim lp As Long
    ' Dim lCnt As Long
    Dim idx As Long
    
    'lCnt = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    ListView_SetItemState hLVS, -1, 0&, LVIS_FOCUSED Or LVIS_SELECTED
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
    '    lp = GetLVItemlParam(hLVS, i)
            If LCase$(LVEntries(i).sName) = LCase$(sName) Then
                idx = CLng(SendMessage(hLVS, LVM_MAPIDTOINDEX, LVEntries(i).dwID, ByVal 0&))
                ListView_SetSelectedItem hLVS, idx
                Exit For
            End If
    '        ListView_SetSelectedItem hLVS, i
        End If
    Next i
    LVSetSelection
    End Property
     
    Public Property Get SelectedItem() As IShellItem
    Set SelectedItem = siFocus
    End Property
    Public Property Get SelectedFilesPaths() As String()
    SelectedFilesPaths = sSelectedFiles
    End Property
    Public Property Get SelectedFilesCount() As Long
    Attribute SelectedFilesCount.VB_MemberFlags = "40"
    SelectedFilesCount = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    End Property
    Public Property Get SelectedFiles() As Variant
    SelectedFiles = sSelectedFileNames
    End Property
    [ Hidden ]
    Public Property Let SelectedFiles(sNames As Variant)
    Dim i As Long
    'Dim lp As Long
    'Dim lCnt As Long
    Dim idx As Long
    
    DebugAppend sNames(0)
    'lCnt = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    ListView_SetItemState hLVS, -1, 0&, LVIS_FOCUSED Or LVIS_SELECTED
    For i = 0 To UBound(LVEntries) '(lCnt - 1)
    '    lp = GetLVItemlParam(hLVS, i)
        If LVEntries(i).bDeleted = False Then
        If IsInArray(LVEntries(i).sName, sNames) Then
            idx = CLng(SendMessage(hLVS, LVM_MAPIDTOINDEX, LVEntries(i).dwID, ByVal 0&))
            ListView_SetItemState hLVS, idx, LVIS_SELECTED, LVIS_SELECTED
        End If
        End If
    Next i
    End Property
    Public Property Get SelectedItems() As IShellItemArray
    'Not used internally, so generate only when requested to speed up
    'complicated selection setting functionality
    
    SetSelectedItemArray
    
    Set SelectedItems = siaSelected
    End Property
    
    Public Property Get SelectedColumn() As Long: SelectedColumn = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOLUMN, 0, ByVal 0&)): End Property
    Attribute SelectedColumn.VB_Description = "Set the active column."
    Attribute SelectedColumn.VB_MemberFlags = "400"
    [ Hidden ]
    Public Property Let SelectedColumn(ByVal lVal As Long)
    If (PropPicture Is Nothing) = False Then
     If PropPictureAlignment = SBPicAlignTile And PropPictureWatermark = False Then Exit Property
     SendMessage hLVS, LVM_SETSELECTEDCOLUMN, lVal, ByVal 0&
    End If
    End Property
    Public Property Get HeaderDragDrop() As Boolean: HeaderDragDrop = m_HdrDD: End Property
    Attribute HeaderDragDrop.VB_Description = "Sets whether or not columns can be reordered by dragdrop."
    Public Property Let HeaderDragDrop(ByVal bVal As Boolean)
    If m_HdrDD <> bVal Then
        m_HdrDD = bVal
        If m_HdrDD Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HEADERDRAGDROP, ByVal LVS_EX_HEADERDRAGDROP
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_HEADERDRAGDROP, ByVal 0&
        End If
    End If
    End Property
    Public Property Get HeaderHotTracking() As Boolean: HeaderHotTracking = m_HdrHotTrack: End Property
    Attribute HeaderHotTracking.VB_Description = "Toggles highlighting of ListView Header Columns when the mouse is over them. No effect if a Common Controls 6 manifest is present, but if it is, there's a similar effect."
    Public Property Let HeaderHotTracking(bVal As Boolean)
    If m_HdrHotTrack <> bVal Then
        m_HdrHotTrack = bVal
        Dim dwStyle As ucsb_HeaderStyles
        dwStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
        If m_HdrHotTrack Then
            dwStyle = dwStyle Or HDS_HOTTRACK
        Else
            dwStyle = dwStyle And Not HDS_HOTTRACK
        End If
        SetWindowLong hLVSHdr, GWL_STYLE, dwStyle
    End If
    End Property
    Public Property Get HeaderOverflowButton() As Boolean: HeaderOverflowButton = m_HdrOverflow: End Property
    Attribute HeaderOverflowButton.VB_Description = "Shows an overflow button on the Details header if there's more columns, and scrolls the next one into full view when clicked."
    Public Property Let HeaderOverflowButton(bVal As Boolean)
    If m_HdrOverflow <> bVal Then
        m_HdrOverflow = bVal
        Dim dwStyle As ucsb_HeaderStyles
        dwStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
        If m_HdrOverflow Then
            dwStyle = dwStyle Or HDS_OVERFLOW
        Else
            dwStyle = dwStyle And Not HDS_OVERFLOW
        End If
        SetWindowLong hLVSHdr, GWL_STYLE, dwStyle
    End If
    End Property
    Public Property Get FilterBar() As Boolean: FilterBar = m_FilterBar: End Property
    Attribute FilterBar.VB_Description = "Shows filter bars in the column headers, where you can enter a string to only show files matching it."
    Public Property Let FilterBar(bVal As Boolean)
    If bVal <> m_FilterBar Then
        m_FilterBar = bVal
        Dim dwStyle As ucsb_HeaderStyles
        dwStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
        If m_FilterBar Then
            dwStyle = dwStyle Or HDS_FILTERBAR
        Else
            FilterResetItems
            dwStyle = dwStyle And Not HDS_FILTERBAR
        End If
        SetWindowLong hLVSHdr, GWL_STYLE, dwStyle
        UserControl.Height = UserControl.Height + 8
        UserControl.Height = UserControl.Height - 8
        'If you know any other way of getting the damn thing to redraw please let me know!
        'RedrawWindow, UpdateWindow, LVM_UPDATE, all don't work
    End If
    End Property
    Public Property Get FilterCaseSensitive() As Boolean: FilterCaseSensitive = m_FilterCase: End Property
    Attribute FilterCaseSensitive.VB_Description = "Sets whether the FilterBar matching is case sensitive or not."
    Public Property Let FilterCaseSensitive(bVal As Boolean): m_FilterCase = bVal: End Property
    Public Property Get TrackSelect() As Boolean: TrackSelect = m_TrackSel: End Property
    Attribute TrackSelect.VB_Description = "Sets whether the selected item follows the mouse pointer. "
    Public Property Let TrackSelect(ByVal bVal As Boolean)
    If m_TrackSel <> bVal Then
        m_TrackSel = bVal
        If m_TrackSel Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_TRACKSELECT, ByVal LVS_EX_TRACKSELECT
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_TRACKSELECT, ByVal 0&
        End If
    End If
    End Property
    Public Property Get OneClickActivate() As Boolean: OneClickActivate = m_OneClickAct: End Property
    Attribute OneClickActivate.VB_Description = "Sets the One Click Activate style; also enables hot tracking."
    Public Property Let OneClickActivate(ByVal bVal As Boolean)
    If m_OneClickAct <> bVal Then
        m_OneClickAct = bVal
        If m_OneClickAct Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_ONECLICKACTIVATE, ByVal LVS_EX_ONECLICKACTIVATE
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_ONECLICKACTIVATE, ByVal 0&
        End If
    End If
    End Property
    Public Property Get TwoClickActivate() As Boolean: TwoClickActivate = m_TwoClickAct: End Property
    Attribute TwoClickActivate.VB_Description = "Sets the Two Click Activate style; also enables hot tracking."
    Public Property Let TwoClickActivate(ByVal bVal As Boolean)
    If m_TwoClickAct <> bVal Then
        m_TwoClickAct = bVal
        If m_TwoClickAct Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_TWOCLICKACTIVATE, ByVal LVS_EX_TWOCLICKACTIVATE
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_TWOCLICKACTIVATE, ByVal 0&
        End If
    End If
    End Property
    Public Property Get UnderlineHot() As Boolean: UnderlineHot = m_ULHot: End Property
    Attribute UnderlineHot.VB_Description = "If One or Two Click Activate is set, underlines hot items."
    Public Property Let UnderlineHot(ByVal bVal As Boolean)
    If m_ULHot <> bVal Then
        m_ULHot = bVal
        If m_ULHot Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_UNDERLINEHOT, ByVal LVS_EX_UNDERLINEHOT
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_UNDERLINEHOT, ByVal 0&
        End If
    End If
    End Property
    Public Property Get UnderlineCold() As Boolean: UnderlineCold = m_ULCold: End Property
    Attribute UnderlineCold.VB_Description = "If One or Two Click Activate is set, underlines activated items that are not hot items."
    Public Property Let UnderlineCold(ByVal bVal As Boolean)
    If m_ULCold <> bVal Then
        m_ULCold = bVal
        If m_ULCold Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_UNDERLINECOLD, ByVal LVS_EX_UNDERLINECOLD
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_UNDERLINECOLD, ByVal 0&
        End If
    End If
    End Property
    Public Property Get AutoCheckSelect() As Boolean: AutoCheckSelect = m_CheckSel: End Property
    Attribute AutoCheckSelect.VB_Description = "If enabled while Checkboxes are enabled, selected items are automatically checked, and unchecked when unselected."
    Public Property Let AutoCheckSelect(bVal As Boolean)
    If m_CheckSel <> bVal Then
        m_CheckSel = bVal
        If m_CheckSel Then
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_AUTOCHECKSELECT, ByVal LVS_EX_AUTOCHECKSELECT
        Else
            SendMessage hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_AUTOCHECKSELECT, ByVal 0&
        End If
    End If
    End Property
    Public Property Get BackColor() As stdole.OLE_COLOR: BackColor = clrBack: End Property
    Attribute BackColor.VB_Description = "Sets the background color of the ListView."
    Public Property Let BackColor(ByVal val As stdole.OLE_COLOR)
    If val = CLR_NONE Then Exit Property
    clrBack = val
    Dim clrt As Long
    OleTranslateColor clrBack, 0&, clrt
    SendMessageW hLVS, LVM_SETBKCOLOR, 0, ByVal clrt
    SendMessageW hLVS, LVM_SETTEXTBKCOLOR, 0, ByVal CLR_NONE
    If hLVC Then SendMessageW hLVC, LVM_SETBKCOLOR, 0, ByVal clrt
    If hLVC Then SendMessageW hLVC, LVM_SETTEXTBKCOLOR, 0, ByVal CLR_NONE
    UserControl.Refresh
    RedrawWindow UserControl.hWnd, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    If Not PropPicture Is Nothing Then
        If PropPicture.Type = vbPicTypeIcon Then Set Me.Picture = PropPicture
    End If
    UserControl.PropertyChanged "BackColor"
    End Property
    Public Property Get DetailsPaneBackColor() As stdole.OLE_COLOR: DetailsPaneBackColor = clrDtBack: End Property
    Attribute DetailsPaneBackColor.VB_Description = "Sets the background color of the Details Pane. (Default &H00FBF5F1&)"
    Public Property Let DetailsPaneBackColor(ByVal val As stdole.OLE_COLOR)
    If val = CLR_NONE Then Exit Property
    clrDtBack = val
    pbDetailPane.BackColor = val
    pbDetailPane.Refresh
    'RedrawWindow UserControl.hWnd, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    'If Not PropPicture Is Nothing Then
    '    If PropPicture.type = vbPicTypeIcon Then Set Me.Picture = PropPicture
    'End If
    UserControl.PropertyChanged "DetailsPaneBackColor"
    End Property
    Public Property Get DetailsPaneForeColor() As stdole.OLE_COLOR: DetailsPaneForeColor = clrDtFore: End Property
    Attribute DetailsPaneForeColor.VB_Description = "Changes the color of the Type and property names in the Details Pane; but not the values, the color of those cannot be changed. (Default: &H0079675A&)"
    Public Property Let DetailsPaneForeColor(ByVal val As stdole.OLE_COLOR)
    If val = CLR_NONE Then Exit Property
    clrDtFore = val
    UserControl.PropertyChanged "DetailsPaneForeColor"
    End Property
    Public Property Get DetailsPaneFileNameColor() As stdole.OLE_COLOR: DetailsPaneFileNameColor = clrDtName: End Property
    Attribute DetailsPaneFileNameColor.VB_Description = "Changes the color of the filename in the Details Pane. (Default: &HC)"
    Public Property Let DetailsPaneFileNameColor(ByVal val As stdole.OLE_COLOR)
    If val = CLR_NONE Then Exit Property
    clrDtName = val
    UserControl.PropertyChanged "DetailsPaneFileNameColor"
    End Property
    Public Property Get ForeColor() As stdole.OLE_COLOR: ForeColor = clrFore: End Property
    Attribute ForeColor.VB_Description = "Sets the forecolor of the item names in the ListView. In modes with subitems, only the Name item is changed- use ForeColorSubItem to change the default forecolor of the other subitems."
    Public Property Let ForeColor(ByVal val As stdole.OLE_COLOR)
    clrFore = val
    Dim clrt As Long
    OleTranslateColor clrFore, 0&, clrt
    SendMessage hLVS, LVM_SETTEXTCOLOR, 0, ByVal clrt
    If hLVC Then SendMessage hLVC, LVM_SETTEXTCOLOR, 0, ByVal clrt
    UserControl.Refresh
    RedrawWindow UserControl.hWnd, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    UserControl.PropertyChanged "ForeColor"
    End Property
    Public Property Get ForeColorSubitem() As stdole.OLE_COLOR: ForeColorSubitem = clrForeSubitem: End Property
    Attribute ForeColorSubitem.VB_Description = "In modes with subitems in the ListView, sets the default fore color of all the subitems besides the file name."
    Public Property Let ForeColorSubitem(ByVal val As stdole.OLE_COLOR)
    clrForeSubitem = val
    UserControl.Refresh
    RedrawWindow UserControl.hWnd, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    UserControl.PropertyChanged "ForeColorSubitem"
    End Property
    Public Property Get SearchBoxForeColor() As stdole.OLE_COLOR: SearchBoxForeColor = clrSbFore: End Property
    Attribute SearchBoxForeColor.VB_Description = "Set the text color in the Search Box."
    Public Property Let SearchBoxForeColor(ByVal val As stdole.OLE_COLOR)
    clrSbFore = val
    Dim clrt As Long
    OleTranslateColor clrSbFore, 0&, clrt
    RedrawWindow hSearchBox, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    End Property
    Public Property Get SearchBoxBackColor() As stdole.OLE_COLOR: SearchBoxBackColor = clrSbBack: End Property
    Attribute SearchBoxBackColor.VB_Description = "Set the background color of the Search Box."
    Public Property Let SearchBoxBackColor(ByVal val As stdole.OLE_COLOR)
    clrSbBack = val
    Dim clrt As Long
    OleTranslateColor clrSbBack, 0&, clrt
    RedrawWindow hSearchBox, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    End Property
    Public Property Get ControlBackColor() As stdole.OLE_COLOR: ControlBackColor = clrCtBack: End Property
    Attribute ControlBackColor.VB_Description = "The background color of the control itself, as opposed to the ListView (BackColor). "
    Public Property Let ControlBackColor(ByVal val As stdole.OLE_COLOR)
    clrCtBack = val
    UserControl.BackColor = clrCtBack
    pbControlBox.BackColor = clrCtBack
    pbControlBox.Refresh
    pbBackBtn.BackColor = clrCtBack
    pbBackBtn.Refresh
    pbFwdBtn.BackColor = clrCtBack
    pbFwdBtn.Refresh
    If m_NavBtnType = SBNB_ThemeButton Then
        pvDrawBack iNavStateCur, True
        pvDrawFwd iFwdNavStateCur, True
    End If
    fraPreview.BackColor = clrCtBack
    pbPreviewPane.BackColor = clrCtBack
    fraPreview.Refresh
    pbPreviewPane.Refresh
    UserControl.Refresh
    UserControl.PropertyChanged "ControlBackColor"
    End Property
    Public Property Get ColumnSelectColor() As stdole.OLE_COLOR: ColumnSelectColor = clrColSel: End Property
    Attribute ColumnSelectColor.VB_Description = "Sets the default background color for a column selected though SelectedColumn or SelectColumnOnSort."
    Public Property Let ColumnSelectColor(ByVal Value As stdole.OLE_COLOR)
    If Value <> clrColSel Then
        clrColSel = Value
        ColumnSetSelColor clrColSel
    End If
    End Property
    Public Property Get Picture() As IPictureDisp: Set Picture = PropPicture: End Property
    Attribute Picture.VB_Description = "Sets a background image in the browser. Subs to set a hBmp or URL are available as an alternative."
    Public Property Let Picture(ByVal pIPD As IPictureDisp): Set Me.Picture = pIPD: End Property
    Public Property Set Picture(ByVal pIPD As IPictureDisp)
    'More shameless reuse of perfectly good code from Krool's ListView :D
    Dim LVBKI As LVBKIMAGE
    With LVBKI
    If pIPD Is Nothing Then
        Set PropPicture = Nothing
        .hBm = 0
        .ulFlags = LVBKIF_SOURCE_NONE
        SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
        .ulFlags = LVBKIF_TYPE_WATERMARK
        SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
    Else
        Set UserControl.Picture = pIPD
        Set PropPicture = UserControl.Picture
        Set UserControl.Picture = Nothing
            .hBm = 0
            .ulFlags = LVBKIF_SOURCE_NONE
            SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            .ulFlags = LVBKIF_TYPE_WATERMARK
            SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            .ulFlags = LVBKIF_STYLE_NORMAL
            If pIPD.Handle <> 0 Then
                .hBm = BitmapHandleFromPicture(PropPicture, clrBack)
                If PropPictureWatermark = False Then
                    ' There is a much better result without LVS_EX_DOUBLEBUFFER
                    ' when loading picture by 'hBmp'. (Weighing the pros and cons)
                    SendMessageW hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_DOUBLEBUFFER, ByVal 0&
                    Select Case PropPictureAlignment
                        Case SBPicAlignTopLeft
                            .XOffsetPercent = 0
                            .YOffsetPercent = 0
                        Case SBPicAlignTopRight
                            .XOffsetPercent = 100
                            .YOffsetPercent = 0
                        Case SBPicAlignBottomLeft
                            .XOffsetPercent = 0
                            .YOffsetPercent = 100
                        Case SBPicAlignBottomRight
                            .XOffsetPercent = 100
                            .YOffsetPercent = 100
                        Case SBPicAlignCenter
                            .XOffsetPercent = 50
                            .YOffsetPercent = 50
                        Case SBPicAlignTile
                            ' There is a better result when no column is selected.
                            SendMessageW hLVS, LVM_SETSELECTEDCOLUMN, -1, ByVal 0&
                            .ulFlags = .ulFlags Or LVBKIF_STYLE_TILE
                            If m_ViewMode = SB_VIEW_DETAILS Then
                                If hLVSHdr <> 0 Then
                                    .ulFlags = .ulFlags Or LVBKIF_FLAG_TILEOFFSET
                                    Dim rc As RECT
                                    GetWindowRect hLVSHdr, rc
                                    .YOffsetPercent = -(rc.Bottom - rc.Top)
                                End If
                            End If
                    End Select
                    .ulFlags = .ulFlags Or LVBKIF_SOURCE_HBITMAP
                Else
                    ' Here it does not matter whether LVS_EX_DOUBLEBUFFER is set or not.
                    ' Though it is better to set it as it reduces flicker, especially
                    ' when a watermark is in place.
                    SendMessageW hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_DOUBLEBUFFER, ByVal LVS_EX_DOUBLEBUFFER
                    .ulFlags = .ulFlags Or LVBKIF_TYPE_WATERMARK
                End If
                SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            End If
    End If
    End With
    UserControl.PropertyChanged "Picture"
    End Property
    Public Sub PictureSetByHBITMAP(hBitmap As LongPtr)
    LVSetBkLong hBitmap, 0&
    End Sub
    Public Sub PictureSetByURL(ByVal szURL As String)
    szLVBKUrl = szURL
    LVSetBkLong StrPtr(szLVBKUrl), 1&
    End Sub
    Private Sub LVSetBkLong(lptr As LongPtr, fMode As Long)
    Dim LVBKI As LVBKIMAGE
    With LVBKI
    If lptr = 0 Then
        .ulFlags = LVBKIF_SOURCE_NONE
        SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
        .ulFlags = LVBKIF_TYPE_WATERMARK
        SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
    Else
            .hBm = 0
            .ulFlags = LVBKIF_SOURCE_NONE
            SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            .ulFlags = LVBKIF_TYPE_WATERMARK
            SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            .ulFlags = LVBKIF_STYLE_NORMAL
            If lptr Then
                If fMode = 0& Then
                    .hBm = lptr
                ElseIf fMode = 1& Then
                    .cchImageMax = Len(szLVBKUrl)
                    .pszImage = lptr
                End If
                If PropPictureWatermark = False Then
                    ' There is a much better result without LVS_EX_DOUBLEBUFFER
                    ' when loading picture by 'hBmp'. (Weighing the pros and cons)
                    SendMessageW hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_DOUBLEBUFFER, ByVal 0&
                    Select Case PropPictureAlignment
                        Case SBPicAlignTopLeft
                            .XOffsetPercent = 0
                            .YOffsetPercent = 0
                        Case SBPicAlignTopRight
                            .XOffsetPercent = 100
                            .YOffsetPercent = 0
                        Case SBPicAlignBottomLeft
                            .XOffsetPercent = 0
                            .YOffsetPercent = 100
                        Case SBPicAlignBottomRight
                            .XOffsetPercent = 100
                            .YOffsetPercent = 100
                        Case SBPicAlignCenter
                            .XOffsetPercent = 50
                            .YOffsetPercent = 50
                        Case SBPicAlignTile
                            ' There is a better result when no column is selected.
                            SendMessageW hLVS, LVM_SETSELECTEDCOLUMN, -1, ByVal 0&
                            .ulFlags = .ulFlags Or LVBKIF_STYLE_TILE
                            If m_ViewMode = SB_VIEW_DETAILS Then
                                If hLVSHdr <> 0 Then
                                    .ulFlags = .ulFlags Or LVBKIF_FLAG_TILEOFFSET
                                    Dim rc As RECT
                                    GetWindowRect hLVSHdr, rc
                                    .YOffsetPercent = -(rc.Bottom - rc.Top)
                                End If
                            End If
                    End Select
                    If fMode = 0& Then
                        .ulFlags = .ulFlags Or LVBKIF_SOURCE_HBITMAP
                    ElseIf fMode = 1& Then
                        .ulFlags = .ulFlags Or LVBKIF_SOURCE_URL
                    End If
                Else
                    ' Here it does not matter whether LVS_EX_DOUBLEBUFFER is set or not.
                    ' Though it is better to set it as it reduces flicker, especially
                    ' when a watermark is in place.
                    SendMessageW hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_DOUBLEBUFFER, ByVal LVS_EX_DOUBLEBUFFER
                    .ulFlags = .ulFlags Or LVBKIF_TYPE_WATERMARK
                End If
                SendMessageW hLVS, LVM_SETBKIMAGE, 0, ByVal VarPtr(LVBKI)
            End If
    End If
    End With
    End Sub
    
    Public Property Get PictureAlignment() As SBPictureAlignmentConstants: PictureAlignment = PropPictureAlignment: End Property
    Attribute PictureAlignment.VB_Description = "Alignment options for the browser background image."
    Public Property Let PictureAlignment(ByVal Value As SBPictureAlignmentConstants)
    Select Case Value
        Case SBPicAlignTopLeft, SBPicAlignTopRight, SBPicAlignBottomLeft, SBPicAlignBottomRight, SBPicAlignCenter, SBPicAlignTile
            PropPictureAlignment = Value
        Case Else: Exit Property
    End Select
    Set Me.Picture = PropPicture
    UserControl.PropertyChanged "PictureAlignment"
    End Property
    
    Public Property Get PictureWatermark() As Boolean: PictureWatermark = PropPictureWatermark: End Property
    Attribute PictureWatermark.VB_Description = "Sets the ListView background Picture type to watermark."
    Public Property Let PictureWatermark(ByVal Value As Boolean)
    PropPictureWatermark = Value
    Set Me.Picture = PropPicture
    UserControl.PropertyChanged "PictureWatermark"
    End Property
    
    Public Property Get FontScaleForDPI() As Boolean: FontScaleForDPI = m_FontScaleCXY: End Property
    Attribute FontScaleForDPI.VB_Description = "Scale font size according to DPI."
    Public Property Let FontScaleForDPI(Value As Boolean)
    If Value <> m_FontScaleCXY Then
        m_FontScaleCXY = Value
        Dim TmpFont As StdFont
        TmpFont = Me.Font
        Set Me.Font = TmpFont
    End If
    End Property
    Public Property Get FontDetails() As StdFont: Set FontDetails = PropFontDt: End Property
    Attribute FontDetails.VB_Description = "Set the font for the Details Pane."
    Public Property Let FontDetails(ByVal NewFont As StdFont): Set Me.FontDetails = NewFont: End Property
    Public Property Set FontDetails(ByVal NewFont As StdFont)
    Set PropFontDt = Nothing
    Set PropFontDt = CloneOLEFont(NewFont)
    Dim old1 As LongPtr, old2 As LongPtr
    old1 = m_hFontDtAlt
    old2 = m_hFontDtHdrAlt
    Set pbDetailPane.Font = PropFontDt
    Set mIFTmp = PropFontDt
    If mIFTmp Is Nothing Then
        DebugAppend "mIFTmp is nothing"
    End If
    mIFTmp.SetRatio 96 * m_ScaleX, 2540
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(mIFTmp.hFont), LenB(lftmp), lftmp
    
    m_hFontDtAlt = CreateFontIndirectW(lftmp)
    Set Temp2Font = CloneOLEFont(PropFontDt)
    Temp2Font.Size = Temp2Font.Size + 1
    Dim lfdt As LOGFONTW
    Set mIFTmp2 = Temp2Font
    GetObjectW CLngPtr(mIFTmp2.hFont), LenB(lfdt), lfdt
    m_hFontDtHdrAlt = CreateFontIndirectW(lfdt)
    cyDtName = PropFontDt.Size * 2
    m_cyFontDtTxt = PropFontDt.Size
    If m_FontScaleCXY Then
        m_cyFontDtTxt = TextHeightW(pbDetailPane.hDC, "|1T") ' pbDetailPane.TextHeight("|1T")
        DebugAppend "ScaledDtFontHeight=" & m_cyFontDtTxt, 444
    '        m_cyFontDtTxt = m_cyFontDtTxt + (4 * m_ScaleY)
    '    Else
    '        m_cyFontDtTxt = m_cyFontDtTxt + 4
    End If
    DebugAppend "FontDetailsPropset DtFont=" & m_hFontDtAlt, 444
    
    If old1 Then DeleteObject old1
    If old2 Then DeleteObject old2
    
    UserControl.PropertyChanged "FontDetails"
    End Property
    Public Property Get FontFileControls() As StdFont: Set FontFileControls = PropFontLV: End Property
    Attribute FontFileControls.VB_Description = "Set the font for the ListView and Dropdown (ComboBox)."
    Public Property Let FontFileControls(ByVal NewFont As StdFont): Set Me.FontFileControls = NewFont: End Property
    Public Property Set FontFileControls(ByVal NewFont As StdFont)
    If NewFont Is Nothing Then Set NewFont = Ambient.Font
    Set PropFontLV = Nothing
    Set PropFontLV = CloneOLEFont(NewFont)
    
    Dim old1 As LongPtr, old2 As LongPtr, old3 As LongPtr
    old1 = hFontLVMain
    old2 = hFontDropdown
    old3 = hFontLVHdrMain
    Set mIFLV = PropFontLV
    mIFLV.SetRatio 96 * m_ScaleX, 2540
    Dim lftmp As LOGFONTW
    GetObjectW mIFLV.hFont, LenB(lftmp), lftmp
    hFontLVMain = CreateFontIndirectW(lftmp)
    hFontDropdown = hFontLVMain
    hFontLVHdrMain = hFontLVMain
    DebugAppend "SetFontFileControls " & PropFontLV.Name & ",hLVS=" & hLVS, 444
    If hLVS <> 0 Then SendMessage hLVS, WM_SETFONT, hFontLVMain, ByVal 1&
    If hLVSHdr <> 0 Then SendMessage hLVSHdr, WM_SETFONT, hFontLVMain, ByVal 1&
    If hCombo <> 0 Then SendMessageW hCombo, WM_SETFONT, hFontLVMain, ByVal 1&
    If hSearchBox <> 0 Then SendMessageW hSearchBox, WM_SETFONT, hFontLVMain, ByVal 1&
    If (hIcoSearchBox16 <> 0) Or (hIcoSearchBox20 <> 0) Or (hIcoSearchBox24 <> 0) Then
        SetEditControlMargin hSearchBox, 0, 22 + (4 * (m_ScaleX - 1))
    End If
    Dim rc As RECT
    Call GetClientRect(hCombo, rc)
    Dim rcsb As RECT, rccb As RECT
    Call GetClientRect(hSearchBox, rcsb)
    Call GetClientRect(pbControlBox.hWnd, rccb)
    Dim lDif As Long
    lDif = (rc.Bottom + (4 * m_ScaleY)) - cyDefCbo
    rccb.Bottom = rccb.Bottom + lDif
    'SetWindowPos pbControlBox.hWnd, 0&, 0&, 0&, rccb.Right + 2, rccb.Bottom + 2, SWP_NOMOVE Or SWP_NOZORDER
    'SetWindowPos pbSearchContainer.hWnd, 0&, 0&, 0&, rcsb.Right + 2, rc.Bottom - (2 * m_ScaleY), SWP_NOMOVE Or SWP_NOZORDER
    '    SetWindowPos hSearchBox, 0&, 0&, 0&, rcsb.Right, rc.Bottom - (4 * m_ScaleY), SWP_NOMOVE Or SWP_NOZORDER
    
    If old1 Then DeleteObject old1
    If old2 Then DeleteObject old2
    If old3 Then DeleteObject old3
    
    UserControl.PropertyChanged "FontFileControls"
    
    End Property
    Public Property Get Font() As StdFont: Set Font = PropFont: End Property
    Attribute Font.VB_Description = "Sets the main font for the control. All buttons and textboxes will use this font. The font for the ListView and ComboBox are set via FontFileControls, and the Details Pane via FontDetails; everything else uses this font."
    Public Property Let Font(ByVal NewFont As StdFont): Set Me.Font = NewFont: End Property
    Public Property Set Font(ByVal NewFont As StdFont)
    Dim OldFontHandle As LongPtr, OldBoldFontHandle As LongPtr, OldUnderlineFontHandle As LongPtr, OldBoldUnderlineFontHandle As LongPtr
    If NewFont Is Nothing Then Set NewFont = Ambient.Font
    Set PropFont = Nothing
    Set PropFont = CloneOLEFont(NewFont)
    
    OldFontHandle = m_hFontMain
    
    If m_FontScaleCXY Then
        Set mIFMain = PropFont
        mIFMain.SetRatio 96 * m_ScaleX, 2540
    End If
    
    'm_hFontMain = mIFMain.hFont 'CreateGDIFontFromOLEFont(PropFont, True)
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(mIFMain.hFont), LenB(lftmp), lftmp
    m_hFontMain = CreateFontIndirectW(lftmp)
    
    'hFontLVMain = m_hFontMain
    'hFontDropdown = m_hFontMain
    DebugAppend "Set Font->Size=" & PropFont.Size
    'If hLVS <> 0 Then SendMessage hLVS, WM_SETFONT, m_hFontMain, ByVal 1&
    'If hCombo <> 0 Then SendMessageW hCombo, WM_SETFONT, m_hFontMain, ByVal 1&
    'If hLVSHdr <> 0 Then SendMessageW hLVSHdr, WM_SETFONT, m_hFontMain, ByVal 1&
    If hSearchBox <> 0 Then SendMessageW hSearchBox, WM_SETFONT, hFontLVMain, ByVal 1&
    If (hIcoSearchBox16 <> 0) Or (hIcoSearchBox20 <> 0) Or (hIcoSearchBox24 <> 0) Then
        SetEditControlMargin hSearchBox, 0, 22 + (4 * (m_ScaleX - 1))
    End If
    
    
    
    Set CtlFont = CloneOLEFont(PropFont)
    Set mIFCtl = CtlFont
    If CtlFont.Size > nLimitPointSizeForButtons Then
        CtlFont.Size = nLimitPointSizeForButtons
    End If
    Dim lftmp2 As LOGFONTW
    GetObjectW CLngPtr(mIFCtl.hFont), LenB(lftmp2), lftmp2
    hFontCtl = CreateFontIndirectW(lftmp2)
    Set cmdColOK.Font = CtlFont
    Set lblColCX.Font = CtlFont
    Set lblColCap.Font = CtlFont
    Set cmdColCancel.Font = CtlFont
    Set chkColFilter.Font = CtlFont
    Set txtColCX.Font = CtlFont
    Set cbDateCmp1.Font = CtlFont
    Set cbDateType.Font = CtlFont
    Set cbShType.Font = CtlFont
    Set cbSrSize1.Font = CtlFont
    Set chkDate.Font = CtlFont
    Set chkShFldr.Font = CtlFont
    Set chkSrSz.Font = CtlFont
    Set cmdSrClr.Font = CtlFont
    Set cmdSrCn.Font = CtlFont
    Set cmdStartSearch.Font = CtlFont
    Set fraPreview.Font = CtlFont
    Set fraSrDate.Font = CtlFont
    Set lblKB1.Font = CtlFont
    Set lblShSz.Font = CtlFont
    Set lblShType.Font = CtlFont
    Set lblSrch.Font = CtlFont
    Set txtSrSize1.Font = CtlFont
    
    SendMessage hUpButton, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage hViewButton, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage hBkmButton, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage hStdBackButton, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage hStdFwdButton, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage m_hStatusBar, WM_SETFONT, hFontCtl, ByVal 1&
    
    SendMessage cmdColOK.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cmdColCancel.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage chkColFilter.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage txtColCX.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cbDateCmp1.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cbDateType.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cbShType.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cbSrSize1.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage chkDate.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage chkShFldr.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage chkSrSz.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cmdSrClr.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cmdSrCn.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage cmdStartSearch.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage fraPreview.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage fraSrDate.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    SendMessage txtSrSize1.hWnd, WM_SETFONT, hFontCtl, ByVal 1&
    
    If hSearchBoxAlt Then SendMessage hSearchBoxAlt, WM_SETFONT, hFontCtl, ByVal 1&
    If hDTSearch1 Then SendMessage hDTSearch1, WM_SETFONT, hFontCtl, ByVal 1&
    Set UserControl.Font = PropFont
    UserControl.Refresh
    Dim cyUCTxt As Long
    cyUCTxt = UserControl.TextHeight("|T1")
    Dim rc As RECT
    Call GetClientRect(hCombo, rc)
    cyCombo = rc.Bottom + (4 * m_ScaleY)
    DebugAppend "SetFont.Out cyCombo=" & cyCombo
    'A larger font could change the height of the combobox
    Dim lDif As Long
    lDif = cyCombo - cyDefCbo
    SetWindowPos hUpButton, 0&, 0&, 0&, cxUpBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hViewButton, 0&, 0&, 0&, cxViewBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hBkmButton, 0&, 0&, 0&, cxBkmBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hStdBackButton, 0&, 0&, 0&, cxHistBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    SetWindowPos hStdFwdButton, 0&, 0&, 0&, cxHistBtn, cyCombo, SWP_NOMOVE Or SWP_NOZORDER
    
    If m_Mode = SBCTL_FilesOnly Then cyCombo = 0&
    
        Dim rcsb As RECT, rccb As RECT
        Dim cytt As Single
        Call GetClientRect(hSearchBox, rcsb)
        rcsb.Bottom = cyDefSBox + lDif
        Call GetClientRect(pbControlBox.hWnd, rccb)
        rccb.Bottom = rccb.Bottom + lDif
        
    If hSearchBox Then
        SetWindowPos pbControlBox.hWnd, 0&, 0&, 0&, rccb.Right + 2, (cyCombo), SWP_NOMOVE Or SWP_NOZORDER
        SetWindowPos pbSearchContainer.hWnd, 0&, 0&, 0&, rcsb.Right + 2, (cyCombo - (4 * m_ScaleY)), SWP_NOMOVE Or SWP_NOZORDER
        SetWindowPos hSearchBox, 0&, 0&, 0&, rcsb.Right, (cyCombo - (6 * m_ScaleY)), SWP_NOMOVE Or SWP_NOZORDER
    Else
        Call GetClientRect(pbControlBox.hWnd, rccb)
        rccb.Bottom = cyCombo + (6 * m_ScaleY)
        SetWindowPos pbControlBox.hWnd, 0&, 0&, 0&, rccb.Right, rccb.Bottom, SWP_NOMOVE Or SWP_NOZORDER
    
    End If
        
    
    If OldFontHandle <> 0 Then DeleteObject OldFontHandle
    
    UserControl.PropertyChanged "Font"
    End Property
    
    
    Private Sub PropFont_FontChanged(ByVal PropertyName As String)
    Dim OldFontHandle As LongPtr
    Dim TempFont As StdFont
    
    OldFontHandle = m_hFontMain
    
    Set mIFMain = PropFont
    
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(mIFMain.hFont), LenB(lftmp), lftmp
    lftmp.LFQuality = CLEARTYPE_NATURAL_QUALITY
    m_hFontMain = CreateFontIndirectW(lftmp)
    
    If m_hStatusBar <> 0 Then Call SendMessageW(m_hStatusBar, WM_SETFONT, m_hFontMain, ByVal 1&)
    
    Set UserControl.Font = PropFont
    
    If OldFontHandle <> 0 Then DeleteObject OldFontHandle
    
    UserControl.PropertyChanged "Font"
    End Sub
    
    Public Property Get DialogGUID() As String: DialogGUID = mDlgGuid: End Property
    Attribute DialogGUID.VB_MemberFlags = "440"
    Public Property Let DialogGUID(sGUID As String): mDlgGuid = sGUID: End Property
    
    'End Properties
    '**********************************************************************

    Private Function LVFontHeight() As Long
    Dim lf As LOGFONTW
    GetObject hFontLVMain, LenB(lf), lf
    LVFontHeight = Abs(lf.LFHeight)
    End Function
    
    
    Private Sub SetRegKeyName()
    On Error Resume Next
    mParentObjName = Parent.Name
    If InStr(App.Path, "\") Then
        mAppFolderName = Right$(App.Path, Len(App.Path) - InStrRev(App.Path, "\"))
    Else
        mAppFolderName = App.Path
    End If
    Dim adn As String
    adn = Ambient.DisplayName
    mRegDataName = mAppFolderName & "." & App.Title & "." & mParentObjName & "." & adn
    
    End Sub
    
    Private Function IsComCtl6() As Boolean
    Static bHasRun As Boolean
    Static bVal As Boolean
    On Error Resume Next
    If bHasRun = False Then
        Dim tDVI As DLLVERSIONINFO
        tDVI.cbSize = LenB(tDVI)
        Dim hr As Long
        hr = DllGetVersion(tDVI)
        DebugAppend "ComCtlDGV hr=0x" & Hex$(hr)
        If hr = S_OK Then
            If tDVI.dwMajor >= 6 Then
                bVal = True
            End If
            DebugAppend "ComCtl major=" & tDVI.dwMajor & ",minor=" & tDVI.dwMinor
        End If
        bHasRun = True
    End If
    IsComCtl6 = bVal
    On Error GoTo 0
    End Function
    
    Private Function pvCreatePropComboCtl(hFor As LongPtr, idxFor As Long) As LongPtr
    Dim rc As RECT
    Dim hCB As LongPtr
    Dim hFont As LongPtr
    Dim i As Long
    Dim cx As Long, tw As Long
    Dim cxcb As Long
    Dim Y As Long
    GetWindowRect hFor, rc
    MapWindowPoints HWND_DESKTOP, pbDetailPane.hWnd, rc, 2&
    ShowWindow hFor, SW_HIDE
    cxcb = (rc.Right - rc.Left) + 4
    If m_ScaleY = 1 Then
        Y = rc.Top - 2
    Else
        Y = rc.Top
    End If
    PropDispDestroyPrevAlt
    hCB = CreateWindowExW(WS_EX_CLIENTEDGE, _
                          StrPtr(WC_COMBOBOX), StrPtr(""), _
                          WS_CHILD Or WS_OVERLAPPED Or WS_VISIBLE Or CBS_DROPDOWNLIST, _
                          rc.Left, Y, cxcb, 20 * m_ScaleY, _
                          pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
    hFont = GetStockObject(DEFAULT_GUI_FONT)
    If hFont Then
        SendMessageW hCB, WM_SETFONT, hFont, ByVal 0&
    End If
                          
    For i = 0 To UBound(tDispProps(idxFor).sEnumerated)
        Call SendMessageW(hCB, CB_ADDSTRING, 0&, ByVal StrPtr(tDispProps(idxFor).sEnumerated(i)))
        tw = pbDetailPane.TextWidth(tDispProps(idxFor).sEnumerated(i))
        If tw > cx Then cx = tw
    Next i
    If cx > cxcb Then
        SendMessageW hCB, CB_SETDROPPEDWIDTH, cx, ByVal 0&
    End If
    DebugAppend "pvCreatePropComboCtl defwidth=" & cxcb & ",changeto=" & cx
    If tDispProps(idxFor).vEnumeratedIsEmpty = False Then
        If tDispProps(idxFor).bEnumeratedUseNewIndex Then
            Call SendMessageW(hCB, CB_SETCURSEL, tDispProps(idxFor).lEnumeratedNewIndex, ByVal 0&)
        Else
            Call SendMessageW(hCB, CB_SETCURSEL, tDispProps(idxFor).lEnumeratedInitialIndex, ByVal 0&)
        End If
    End If
    DebugAppend "CreatePropCombo.SetInitIndex=" & tDispProps(idxFor).lEnumeratedInitialIndex
    ' If ssc_Subclass(hCB, , 22, , , True, True) Then
    '  Call ssc_AddMsg(hCB, MSG_BEFORE, WM_SETFOCUS) 'ALL_MESSAGES)
    ' End If
    Subclass2 hCB, AddressOf CBDTWndProc, hCB
    
    pvCreatePropComboCtl = hCB
    End Function
    
    Private Function pvCreateDateTimeCtl(hFor As LongPtr, idxFor As Long) As LongPtr
    Dim rc As RECT
    Dim stInitial As SYSTEMTIME
    Dim dtInitial As Date
    Dim hDT As LongPtr
    Dim hFont As LongPtr
    Dim cxOff As Long, cyOff As Long
    Dim yOff As Long
    GetWindowRect hFor, rc
    MapWindowPoints HWND_DESKTOP, pbDetailPane.hWnd, rc, 2&
    ShowWindow hFor, SW_HIDE
    If m_ScaleY > 1 Then
        yOff = 0
        cxOff = 7 * m_ScaleX
        cyOff = 4 * m_ScaleY
    Else
        yOff = 3 * m_ScaleY
        cxOff = 4
        cyOff = 8 * m_ScaleY
    End If
    PropDispDestroyPrevAlt
    hDT = CreateWindowExW(WS_EX_CLIENTEDGE Or WS_EX_LEFT Or WS_EX_LTRREADING Or WS_EX_RIGHTSCROLLBAR, _
                          StrPtr(DATETIMEPICK_CLASS), StrPtr(""), _
                          WS_CHILD Or WS_VISIBLE Or WS_OVERLAPPED Or DTS_SHORTDATEFORMAT, _
                          rc.Left, rc.Top - yOff, (rc.Right - rc.Left) + cxOff, Abs(m_cyFontDtTxt) + cyOff, _
                          pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
    DebugAppend "DateTime hwnd=" & hDT & ",x=" & rc.Left & ",y=" & rc.Top & ",cx=" & (rc.Right - rc.Left) + 4 & ",cy=" & (24 * m_ScaleY)
    hFont = m_hFontDtTxt
    Dim lpw As Long
    lpw = PackWords(1, 0)
    If hFont Then
        SendMessageW hDT, WM_SETFONT, hFont, ByVal lpw
    End If
    Dim tsz As SIZE
    SendMessage hDT, DTM_GETIDEALSIZE, 0&, tsz
    DebugAppend "DT ideal cx=" & tsz.cx & ",cy=" & tsz.cy & ",old cx=" & CStr((rc.Right - rc.Left) + 4) & ",old cy=" & CStr(Abs(m_cyFontDtTxt) + cyOff)
    'SetWindowPos hDT, 0&, 0&, 0&, tSz.CX, tSz.CY, SWP_NOMOVE Or SWP_NOZORDER
    
    If tDispProps(idxFor).bUseNewST Then
        stInitial = tDispProps(idxFor).stNewForDT
    Else
        If tDispProps(idxFor).sOrig = "" Then
            dtInitial = Now
        Else
            dtInitial = CDate(tDispProps(idxFor).vOrigForDT)
        End If
        stInitial = DateToSystemTime(dtInitial)
    End If
    
    SendMessageW hDT, DTM_SETSYSTEMTIME, GDT_VALID, stInitial
    SetFocusAPI hDT
    pvSetIPAO
    pvCreateDateTimeCtl = hDT
    End Function
    
    Private Function DateToSystemTime(dt As Date) As SYSTEMTIME
        With DateToSystemTime
            .wDay = VBA.DateTime.Day(dt)
            .wMonth = VBA.DateTime.Month(dt)
            .wYear = VBA.DateTime.Year(dt)
            .wHour = VBA.DateTime.Hour(dt)
            .wMinute = VBA.DateTime.Minute(dt)
            .wSecond = VBA.DateTime.Second(dt)
        End With
    End Function
    
    Private Function SystemTimeToDate(ST As SYSTEMTIME) As Date
    SystemTimeToDate = DateSerial(ST.wYear, ST.wMonth, ST.wDay) + TimeSerial(ST.wHour, ST.wMinute, ST.wSecond)
    End Function
    
    Private Function PropDispByHandle(hEdit As LongPtr) As Long
    Dim i As Long
    For i = 0 To UBound(tDispProps)
        If tDispProps(i).hEdit = hEdit Then
            PropDispByHandle = i
            Exit Function
        End If
    Next
    PropDispByHandle = -1
    End Function
    
    Private Function PropDispByAlt(hAlt As LongPtr) As Long
    Dim i As Long
    For i = 0 To UBound(tDispProps)
        If tDispProps(i).hAlt = hAlt Then
            PropDispByAlt = i
            Exit Function
        End If
    Next
    PropDispByAlt = -1
    End Function
    
    Private Function PropDispDestroyPrevAlt() As Long
    'Only displaying one alternate control (DateTime or Dropdown) at a time, so call this when oprning a new one
    'This will destroy any previous alt control, and display either the original value for the property, or the
    'new one that has been selected (but not saved yet; Cancel will revert).
    Dim i As Long, j As Long
    For i = 0 To UBound(tDispProps)
        If tDispProps(i).hAlt Then
            If DestroyWindow(tDispProps(i).hAlt) Then
                tDispProps(i).hAlt = 0&
                
                ShowWindow tDispProps(i).hEdit, SW_SHOW
                If tDispProps(i).dwDispType = PDDT_ENUMERATED Then
                    If tDispProps(i).bEnumeratedUseNewIndex Then
                        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sEnumerated(tDispProps(i).lEnumeratedNewIndex))
                    Else
                        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sOrig)
                    End If
                ElseIf tDispProps(i).dwDispType = PDDT_DATETIME Then
                    If tDispProps(i).bUseNewST Then
                        Dim dtNew As Date
                        dtNew = SystemTimeToDate(tDispProps(i).stNewForDT)
                        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(CStr(dtNew))
                        DebugAppend "DtShouldShow=" & CStr(dtNew)
                    Else
                        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sOrig)
                    End If
                End If
                    
                    
                j = j + 1
            End If
        End If
    Next i
    PropDispDestroyPrevAlt = j
    End Function
    ' Initialises GDI Plus
    Private Function InitGDIPlus() As LongPtr
        Dim Token    As LongPtr
        Dim gdipInit As GdiplusStartupInput
        
        gdipInit.GdiplusVersion = 1
        GdiplusStartup Token, gdipInit, ByVal 0&
        InitGDIPlus = Token
    End Function
    
    ' Frees GDI Plus
    Private Sub FreeGDIPlus(Token As LongPtr)
        GdiplusShutdown Token
    End Sub
    Private Function ImageList_AddIcon(himl As LongPtr, hIcon As LongPtr) As Long
      ImageList_AddIcon = ImageList_ReplaceIcon(himl, -1, hIcon)
    End Function
    
    Private Function hBitmapFromStream(ByVal ImageSteam As IStream) As LongPtr
        Dim GdipBitmap As LongPtr
        Dim hBitmap As LongPtr 'GDI Bitmap handle.
    
        If gdipInitToken Then
            If GdipCreateBitmapFromStream(ImageSteam, GdipBitmap) = 0 Then 'GDIP_OK Then
                If GdipCreateHBITMAPFromBitmap(GdipBitmap, hBitmap, 0) = 0 Then 'GDIP_OK Then
                    hBitmapFromStream = hBitmap
                    
                Else
                    DebugAppend "hBitmapFromStream failed at hbmpfrombmp|"
                End If
            Else
                DebugAppend "hBitmapFromStream failed at bmpFromStream"
            End If
        Else
            DebugAppend "GDIP not initialized|"
        End If
    
    End Function
    
    Private Function GetHandlerCLSID(ByVal sExt As String, tID As UUID) As Long
    Dim nBuf As Long
    Dim szBuf As String
    Dim siid As String
    Dim sRes As String
    siid = "{8895b1c6-b41f-4c1c-a562-0d564250836f}"
    szBuf = String$(MAX_PATH, 0)
    nBuf = Len(szBuf)
    Call AssocQueryString(0, ASSOCSTR_SHELLEXTENSION, sExt, siid, szBuf, nBuf)
    
    If InStr(szBuf, vbNullChar) > 1 Then
         sRes = Left$(szBuf, InStr(szBuf, vbNullChar) - 1)
         Call CLSIDFromString(StrPtr(sRes), tID)
         GetHandlerCLSID = 1
    Else
        sExt = Mid$(sExt, 2)
        sExt = sExt & "file"
        DebugAppend "No handler returned for extension; trying alternate, " & sExt
        Call AssocQueryString(0, ASSOCSTR_SHELLEXTENSION, sExt, siid, szBuf, nBuf)
        If InStr(szBuf, vbNullChar) > 1 Then
             sRes = Left$(szBuf, InStr(szBuf, vbNullChar) - 1)
             Call CLSIDFromString(StrPtr(sRes), tID)
             GetHandlerCLSID = 1
        End If
    End If
    
    End Function
    
    Private Function GetFileThumbnail(siItem As IShellItem, sFile As String, pidlFQ As LongPtr, cx As Long, cy As Long, Optional dwFlags As SIIGBF = SIIGBF_THUMBNAILONLY Or SIIGBF_RESIZETOFIT) As LongPtr
    Dim isiif As IShellItemImageFactory
    On Error GoTo e0
    If (siItem Is Nothing) Then
        If pidlFQ Then
            Call SHCreateItemFromIDList(pidlFQ, IID_IShellItemImageFactory, isiif)
        Else
            SHCreateItemFromParsingName StrPtr(sFile), Nothing, IID_IShellItemImageFactory, isiif
        End If
    Else
        Set isiif = siItem
    End If
    Dim cxy As LongLong
    Dim sztmp As SIZE
    sztmp.cx = cx: sztmp.cy = cy
    CopyMemory cxy, sztmp, 8
    isiif.GetImage cxy, dwFlags, GetFileThumbnail
    Set isiif = Nothing
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "GetFileThumbnail.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function GetIconThumbnail(siItem As IShellItem, sFile As String, pidlFQ As LongPtr, cx As Long, cy As Long, Optional dwFlags As SIIGBF = SIIGBF_THUMBNAILONLY Or SIIGBF_RESIZETOFIT) As LongPtr
    Dim isiif As IShellItemImageFactory
    On Error GoTo e0
    If (siItem Is Nothing) Then
        If pidlFQ Then
            Call SHCreateItemFromIDList(pidlFQ, IID_IShellItemImageFactory, isiif)
        Else
            SHCreateItemFromParsingName StrPtr(sFile), Nothing, IID_IShellItemImageFactory, isiif
        End If
    Else
        Set isiif = siItem
    End If
    
    Dim cxy As LongLong
    Dim sztmp As SIZE
    If cx < cy Then

        sztmp.cx = cx: sztmp.cy = cx
        CopyMemory cxy, sztmp, 8
        isiif.GetImage cxy, dwFlags, GetIconThumbnail
    Else
        sztmp.cx = cy: sztmp.cy = cy
        CopyMemory cxy, sztmp, 8
        isiif.GetImage cxy, dwFlags, GetIconThumbnail
    End If
    Set isiif = Nothing
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "GeticonThumbnail.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function GetFileThumbnail2(siItem As IShellItem, sFile As String, pidlFQ As LongPtr, cx As Long, cy As Long) As LongPtr
    'alternate method
    Dim isi As IShellItem
    Dim iei As IExtractImage
    Dim hBmp As LongPtr
    Dim uThumbSize As SIZE
        uThumbSize.cx = cx
        uThumbSize.cy = cy
    Dim sRet As String
    Dim uThumbFlags As IEIFlags
    On Error GoTo e0
    DebugAppend "GetFileThumbnail2::Dim=" & cx & "," & cy
    If (siItem Is Nothing) Then
        If pidlFQ Then
            Call SHCreateItemFromIDList(pidlFQ, IID_IShellItem, isi)
        Else
            SHCreateItemFromParsingName StrPtr(sFile), Nothing, IID_IShellItem, isi
        End If
    Else
        Set isi = siItem
    End If
    
    isi.BindToHandler ByVal 0&, BHID_ThumbnailHandler, IID_IExtractImage, iei
    If (iei Is Nothing) Then
        DebugAppend "GetFileThumbnail2.Failed to create IExtractImage"
        Exit Function
    End If
    
    '            uThumbFlags = IEIFLAG_ASPECT
                sRet = String$(MAX_PATH, 0)
                DebugAppend "cx=" & cx, 11
                iei.GetLocation StrPtr(sRet), MAX_PATH, 0&, uThumbSize, 32, uThumbFlags
    hBmp = iei.Extract()
    GetFileThumbnail2 = hBmp
    Set iei = Nothing
    
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "GetFileThumbnail2.Error->" & Err.Description & " (" & Err.Number & ")"
    End Function
    
    Private Function GetFileThumbnail3(siFile As IShellItem, hDC As LongPtr, cx As Long, cy As Long) As LongPtr
    Dim pStrm As IStream
    Dim hImage As LongPtr
    Dim hr As Long
    DebugAppend "GetFileThumbnail3->Entry, cx=" & cx ', 11
    'siFile.BindToHandler 0&, BHID_Stream, IID_IStream, pPvwStrm
    Dim sPath As String, lpPath As LongPtr
    siFile.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
    sPath = LPWSTRtoStr(lpPath)
    If sPath = "" Then
        siFile.GetDisplayName SIGDN_FILESYSPATH, lpPath
        sPath = LPWSTRtoStr(lpPath)
    End If
    
    If sPath = "" Then
        GetFileThumbnail3 = 5
        Exit Function
    End If
    
    Dim hFile   As LongPtr
    Dim btFile() As Byte
    Dim lSize     As Long
    Dim mf2 As Long
    
    hFile = CreateFileW(StrPtr(sPath), FILE_READ_DATA, FILE_SHARE_READ, ByVal 0&, OPEN_EXISTING, 0, 0)
    
    If hFile <> -1 Then
        lSize = GetFileSize(hFile, mf2)
        ReDim btFile(lSize - 1)
        ReadFile hFile, btFile(0), lSize, mf2, 0&
        CloseHandle hFile
        Set pStrm = pvStreamFromArray(VarPtr(btFile(0)), lSize)
        If (pStrm Is Nothing) = False Then
            hr = GdipLoadImageFromStream(pStrm, hImage)
            If hImage Then
                gdipResize2 hImage, hDC, cx, cy, True
            Else
                GetFileThumbnail3 = 1
                DebugAppend "GetFileThumbnail3->GdipLoadImageFromStream failed, hr=0x" & Hex$(hr), 11
            End If
        Else
            GetFileThumbnail3 = 3
        End If
    Else
        GetFileThumbnail3 = 2
        DebugAppend "GetFileThumbnail3->Failed to get IStream", 11
    End If
    
        
    End Function
    
    Private Function GetFileThumbnail4(siFile As IShellItem, cx As Long, cy As Long, objPB As Object) As LongPtr
        '<EhHeader>
        On Error GoTo tryalt
        '</EhHeader>
    Dim pTempFact As IThumbnailHandlerFactory
    Dim upi As IParentAndItem
    Dim pidlPar As LongPtr
    Dim psfTmp As IShellFolder
    Dim pidlRelZ As LongPtr
    Dim prpx As Long, prpy As Long
    Dim dbRatio As Double
    Dim si2 As IShellItem2
    Dim cxr As Long, lh As Long
    cxr = cx
    DebugAppend "InitCX=" & cx & "," & cy
    Set upi = siFile
    upi.GetParentAndItem pidlPar, psfTmp, pidlRelZ
    Set si2 = siFile
    si2.GetUInt32 PKEY_Image_HorizontalSize, prpx
    si2.GetUInt32 PKEY_Image_VerticalSize, prpy
    DebugAppend "Img=" & prpx & "," & prpy
    DebugAppend "fra=" & fraPreview.Height & ",pane=" & pbPreviewPane.Height / 15
    If cy > cx Then
        If prpy > prpx Then
            cxr = cx
            dbRatio = CDbl(prpy) / CDbl(prpx)
            lh = cxr
            cxr = lh * dbRatio
            If cxr > prpx Then cxr = prpx
        Else
            cxr = cx
        End If
    Else
        If prpy > prpx Then
            cxr = cy
        Else
            cxr = cy
            dbRatio = CDbl(prpx) / CDbl(prpy)
            lh = cxr
            cxr = lh * dbRatio
            If cxr > cx Then cxr = cx
        End If
    End If
        DebugAppend "RequestedWidth=" & cxr & ";Box=" & cx & "," & cy & ";Img=" & prpx & "," & prpy
    Dim pUnkTH As IUnknownUnrestricted
    Set pUnkTH = psfTmp
    Dim hrqi As Long
    hrqi = pUnkTH.QueryInterface(IID_IThumbnailHandlerFactory, pTempFact)
    
    If (pTempFact Is Nothing) = False Then
        DebugAppend "Trying IThumbnailHandlerFactory"
        Dim pTH As IThumbnailProvider
        pTempFact.GetThumbnailHandler pidlRelZ, 0&, IID_IThumbnailProvider, pTH
        pTH.GetThumbnail cxr, GetFileThumbnail4, WTSAT_ARGB
    Else
        DebugAppend "GetFileThumbnail4::IShellFolder does not support IThumbnailHandlerFactory"
    End If
    
    tryalt:
    On Error GoTo e0
    If GetFileThumbnail4 = 0 Then
        DebugAppend "THF failed, trying LocalThumbnailCache..."
        If ImgPrvLTC Is Nothing Then
            Set ImgPrvLTC = New LocalThumbnailCache
            DebugAppend "LocalThumbnailCache set"
            
        End If
        Dim pThumb As ISharedBitmap
        Dim tID As WTS_THUMBNAILID
        Dim tcFlags As WTS_CACHEFLAGS
        Dim hBmpRes As LongPtr
        If (siFile Is Nothing) Then
            DebugAppend "GFT0::siFile Is Nothing"
        End If
        DebugAppend "Trying LocalThumbnailCache..."
        ImgPrvLTC.GetThumbnail siFile, cxr, WTS_FORCEEXTRACTION Or WTS_SCALETOREQUESTEDSIZE, pThumb, tcFlags, tID
        If (pThumb Is Nothing) = False Then
            pThumb.GetSharedBitmap hBmpRes
            If hBmpRes Then
                'For unknown reasons, even if the HBITMAP var is module-level, the data it points to becomes inaccessible
                'so calling hBitmapToPictureBox back in ShowPreviewForFile will fail.
                hBitmapToPictureBox objPB, hBmpRes
                objPB.Refresh
                pThumb.Detach hBmpRes
                DeleteObject hBmpRes
                GetFileThumbnail4 = 1
            End If
        End If
    End If
    CoTaskMemFree pidlPar
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.GetFileThumbnail4->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    'Public Function dbg_zoom()
    'MsgBox cxyDispL & vbCrLf & mActualZoom & vbCrLf & m_ScaleX
    'End Function
    
    Private Sub hBitmapToPictureBox(picturebox As Object, hBitmap As LongPtr, Optional X As Long = 0&, Optional Y As Long = 0&)
    DebugAppend "hBitmapToPictureBox"
    'This or similar is always given as the example on how to do this
    'But it results in transparency being lost
    'So the below method seems a little ackward, but it works. It can
    'be done without the ImageList trick, but it's much more code
    Dim himlBmp As LongPtr
    Dim tBMP As BITMAP
    Dim cx As Long, cy As Long
    Call GetObject(hBitmap, LenB(tBMP), tBMP)
    cx = tBMP.BMWidth
    cy = tBMP.BMHeight
    If cx = 0 Then
        DebugAppend "no width"
        Exit Sub
    End If
    himlBmp = ImageList_Create(cx, cy, ILC_COLOR32, 1, 1)
    ImageList_Add himlBmp, hBitmap, 0&
    If (X = 0) And (Y = 0) Then
        'not manually specified, so center
        If cy < picturebox.ScaleHeight Then
            Y = ((picturebox.ScaleHeight - cy) / 2) '* Screen.TwipsPerPixelY
        End If
        If cx < picturebox.ScaleWidth Then
            X = ((picturebox.ScaleWidth - cx) / 2) '* Screen.TwipsPerPixelX
        End If
       DebugAppend "frame=" & fraPreview.Width & "," & fraPreview.Height & " pc4=" & pbPreviewPane.ScaleWidth & "(" & pbPreviewPane.Width / Screen.TwipsPerPixelX & ")," & pbPreviewPane.ScaleHeight & " cx=" & cx & " cy=" & cy & " x=" & X & " y=" & Y
    End If
    ImageList_Draw himlBmp, 0, picturebox.hDC, X, Y, ILD_NORMAL
    
    ImageList_Destroy himlBmp
    End Sub
    
    Private Function DoIcoPreview(sIcon As String, hDC As LongPtr, cxy As Long, Optional X As Long = 0&, Optional Y As Long = 0&) As Long
    'Deprecated. Left in just in case there's a problem with newer methods.
    
    Dim hIcon As LongPtr
    hIcon = LoadImageW(App.hInstance, StrPtr(sIcon), IMAGE_ICON, cxy, cxy, LR_LOADFROMFILE)
    
    If hIcon = 0 Then
        DebugAppend "DoIcoPreview.Failed to get hIcon", 2
        DoIcoPreview = -1
        Exit Function
    End If
    If (X = 0) And (Y = 0) Then
        'not manually specified, so center
        If cxy < pbPreviewPane.ScaleHeight Then
            X = ((pbPreviewPane.ScaleWidth - cxy) / 2) '* Screen.TwipsPerPixelX
            Y = ((pbPreviewPane.ScaleHeight - cxy) / 2) '* Screen.TwipsPerPixelY
        End If
    End If
    
    RenderIcon hDC, hIcon, cxy, X, Y
    
    End Function
    
    Private Sub RenderIcon(hDC As LongPtr, hIcon As LongPtr, cxy As Long, X As Long, Y As Long)
    Dim himlIcon As LongPtr
    himlIcon = ImageList_Create(cxy, cxy, ILC_COLOR32, 1, 1)
    ImageList_AddIcon himlIcon, hIcon
    ImageList_Draw himlIcon, 0, hDC, X, Y, ILD_TRANSPARENT
    Call DestroyIcon(hIcon)
    ImageList_Destroy himlIcon
    End Sub
    
    Private Function HBitmapFromHIcon(hIcon As LongPtr, cx As Long, cy As Long) As LongPtr
    Dim hDC As LongPtr
    Dim hBackDC As LongPtr
    Dim hBitmap As LongPtr
    Dim hBackSV As LongPtr
    
    hDC = GetDC(0)
    hBackDC = CreateCompatibleDC(hDC)
    hBitmap = Create32BitHBITMAP(hBackDC, cx, cy)
    
    hBackSV = SelectObject(hBackDC, hBitmap)
    
    DrawIconEx hBackDC, 0, 0, hIcon, cx, cy, 0, 0, DI_NORMAL
    
    Call SelectObject(hBackDC, hBackSV)
    Call ReleaseDC(0, hDC)
    Call DeleteDC(hBackDC)
    HBitmapFromHIcon = hBitmap
    End Function
    
    Private Function hBitmapFromFile(PicFile As String, Width As Long, Height As Long, Optional ByVal BackColor As Long = vbWhite, Optional RetainRatio As Boolean = False) As LongPtr
    Dim hDC     As LongPtr
    Dim hBitmap As LongPtr
    Dim Img     As LongPtr
        
    ' Load the image
    If GdipLoadImageFromFile(StrPtr(PicFile), Img) <> 0 Then
        DebugAppend "hBitmapFromFile::GdipLoadImageFromFile failed."
        Exit Function
    End If
    
    ' Calculate picture's width and height if not specified
    If Width = -1 Or Height = -1 Then
        GdipGetImageWidth Img, Width
        GdipGetImageHeight Img, Height
    End If
    
    ' Initialise the hDC
    InitDC hDC, hBitmap, BackColor, Width, Height
    
    ' Resize the picture
    'gdipResize Img, hDC, Width, Height, RetainRatio
    gdipDrawCentered Img, hDC, Width, Height, True
    GdipDisposeImage Img
    
    ' Get the bitmap back
    GetBitmap hDC, hBitmap
    
    hBitmapFromFile = hBitmap
    End Function
    
    Private Function BitmapHandleFromPicture(ByVal Picture As IPictureDisp, Optional ByVal BackColor As stdole.OLE_COLOR) As LongPtr
    'Function written by Krool.. thanks!
    If Picture Is Nothing Then Exit Function
    Dim hDCScreen As LongPtr, hBmp As LongPtr
    Dim hdc1 As LongPtr, hBmpOld1 As LongPtr
    Dim hDC2 As LongPtr, hBmpOld2 As LongPtr
    Dim bmp As BITMAP, hImage As LongPtr
    If Not Picture.Type = vbPicTypeIcon Then
        hImage = CLngPtr(Picture.Handle)
    Else
        Dim ICOI As ICONINFO
        GetIconInfo CLngPtr(Picture.Handle), ICOI
        hImage = ICOI.hBMColor
    End If
    If hImage <> 0 Then
        GetObject hImage, LenB(bmp), bmp
        hDCScreen = GetDC(0)
        If hDCScreen <> 0 Then
            If Not Picture.Type = vbPicTypeIcon Then
                hdc1 = CreateCompatibleDC(hDCScreen)
                If hdc1 <> 0 Then
                    hBmpOld1 = SelectObject(hdc1, hImage)
                    hDC2 = CreateCompatibleDC(hDCScreen)
                    If hDC2 <> 0 Then
                        hBmp = CreateCompatibleBitmap(hDCScreen, bmp.BMWidth, bmp.BMHeight)
                        If hBmp <> 0 Then
                            hBmpOld2 = SelectObject(hDC2, hBmp)
                            BitBlt hDC2, 0, 0, bmp.BMWidth, bmp.BMHeight, hdc1, 0, 0, vbSrcCopy
                            SelectObject hDC2, hBmpOld2
                            BitmapHandleFromPicture = hBmp
                        End If
                        DeleteDC hDC2
                    End If
                    SelectObject hdc1, hBmpOld1
                    DeleteDC hdc1
                End If
            Else
                hdc1 = CreateCompatibleDC(hDCScreen)
                If hdc1 <> 0 Then
                    hBmp = CreateCompatibleBitmap(hDCScreen, bmp.BMWidth, bmp.BMHeight)
                    If hBmp <> 0 Then
                        hBmpOld1 = SelectObject(hdc1, hBmp)
                        Dim Brush As LongPtr
                        Dim cr As Long
                        OleTranslateColor BackColor, 0&, cr
                        Brush = CreateSolidBrush(cr)
                        Const DI_NORMAL As Long = &H3
                        DrawIconEx hdc1, 0, 0, Picture.Handle, bmp.BMWidth, bmp.BMHeight, 0, Brush, DI_NORMAL
                        DeleteObject Brush
                        BitmapHandleFromPicture = hBmp
                    End If
                    SelectObject hdc1, hBmpOld1
                    DeleteDC hdc1
                End If
            End If
            ReleaseDC 0, hDCScreen
        End If
    End If
    End Function
    
    Private Function ResizeImageGDIP(hBitmapIn As LongPtr, ByVal BackColor As Long, Width As Long, Height As Long, RetainRatio As Boolean) As LongPtr
        Dim Img       As LongPtr
        Dim hDC       As LongPtr
        Dim hBitmap   As LongPtr
        
        ' Determine pictyre type
    
             GdipCreateBitmapFromHBITMAP hBitmapIn, ByVal 0&, Img
        
        ' Continue with resizing only if we have a valid image object
        If Img Then
            InitDC hDC, hBitmap, BackColor, Width, Height
            gdipResize Img, hDC, Width, Height, RetainRatio
            GdipDisposeImage Img
            GetBitmap hDC, hBitmap
            ResizeImageGDIP = hBitmap
        End If
    End Function
    
    ' Initialises the hDC to draw
    Private Sub InitDC(hDC As LongPtr, hBitmap As LongPtr, BackColor As Long, Width As Long, Height As Long)
        ' Create a memory DC and select a bitmap into it, fill it in with the backcolor
        hDC = CreateCompatibleDC(ByVal 0&)
        hBitmap = Create32BitHBITMAP(hDC, Width, Height)
        hBitmap = SelectObject(hDC, hBitmap)
        
    End Sub
    
    ' Resize the picture using GDI plus
    Private Sub gdipResize(Img As LongPtr, hDC As LongPtr, Width As Long, Height As Long, Optional RetainRatio As Boolean = False)
        Dim graphics   As LongPtr      ' Graphics Object Pointer
        Dim OrWidth    As Long      ' Original Image Width
        Dim OrHeight   As Long      ' Original Image Height
        Dim OrRatio    As Double    ' Original Image Ratio
        Dim DesRatio   As Double    ' Destination rect Ratio
        Dim DestX      As Long      ' Destination image X
        Dim DestY      As Long      ' Destination image Y
        Dim DestWidth  As Long      ' Destination image Width
        Dim DestHeight As Long      ' Destination image Height
        
        GdipCreateFromHDC hDC, graphics
        GdipSetInterpolationMode graphics, InterpolationModeHighQualityBicubic
        
        If RetainRatio Then
            GdipGetImageWidth Img, OrWidth
            GdipGetImageHeight Img, OrHeight
            
            OrRatio = OrWidth / OrHeight
            DesRatio = Width / Height
            
            ' Calculate destination coordinates
            DestWidth = IIf(DesRatio < OrRatio, Width, Height * OrRatio)
            DestHeight = IIf(DesRatio < OrRatio, Width / OrRatio, Height)
    '        DestX = (Width - DestWidth) / 2
    '        DestY = (Height - DestHeight) / 2
            If DestWidth > DestHeight Then
                DestY = (DestWidth - DestHeight) '/ 2
            ElseIf DestHeight > DestWidth Then
                DestX = (DestHeight - DestWidth) '/ 2
            End If
    '        DestX = 0
    '        DestY = 0
    
            GdipDrawImageRectRectI graphics, Img, DestX, DestY, DestWidth, DestHeight, 0, 0, OrWidth, OrHeight, UnitPixel, 0, 0, 0
        Else
            GdipDrawImageRectI graphics, Img, 0, 0, Width, Height
        End If
        GdipDeleteGraphics graphics
    End Sub
    
    Private Sub gdipResize2(Img As LongPtr, hDC As LongPtr, Width As Long, Height As Long, Optional RetainRatio As Boolean = False)
        Dim graphics   As LongPtr      ' Graphics Object Pointer
        Dim OrWidth    As Long      ' Original Image Width
        Dim OrHeight   As Long      ' Original Image Height
        Dim OrRatio    As Double    ' Original Image Ratio
        Dim DesRatio   As Double    ' Destination rect Ratio
        Dim DestX      As Long      ' Destination image X
        Dim DestY      As Long      ' Destination image Y
        Dim DestWidth  As Long      ' Destination image Width
        Dim DestHeight As Long      ' Destination image Height
        
        GdipCreateFromHDC hDC, graphics
        GdipSetInterpolationMode graphics, InterpolationModeHighQualityBicubic
        
        If RetainRatio Then
            GdipGetImageWidth Img, OrWidth
            GdipGetImageHeight Img, OrHeight
            If (OrWidth < Width) And (OrHeight < Height) Then
                DestWidth = OrWidth
                DestHeight = OrHeight
            Else
                OrRatio = OrWidth / OrHeight
                DesRatio = Width / Height
                
                ' Calculate destination coordinates
                DestWidth = IIf(DesRatio < OrRatio, Width, Height * OrRatio)
                DestHeight = IIf(DesRatio < OrRatio, Width / OrRatio, Height)
            End If
            DebugAppend "orHeight=" & OrHeight & ",DestHeight=" & Height & ",DestHeight=" & DestHeight, 11
            If Height > DestHeight Then
                DestY = (Height - DestHeight) / 2
            End If
            If Width > DestWidth Then
                DestX = (Width - DestWidth) / 2
            End If
    
            GdipDrawImageRectRectI graphics, Img, DestX, DestY, DestWidth, DestHeight, 0, 0, OrWidth, OrHeight, UnitPixel, 0, 0, 0
        Else
            GdipDrawImageRectI graphics, Img, 0, 0, Width, Height
        End If
        GdipDeleteGraphics graphics
    End Sub
    
    Private Sub gdipDrawCentered(Img As LongPtr, hDC As LongPtr, Width As Long, Height As Long, Optional bDrawBorder As Boolean = False)
    'draw a smaller image centered on a larger background
    DebugAppend "gdipDrawCentered", 9
        Dim graphics   As LongPtr      ' Graphics Object Pointer
        Dim OrWidth    As Long      ' Original Image Width
        Dim OrHeight   As Long      ' Original Image Height
        GdipGetImageWidth Img, OrWidth
        GdipGetImageHeight Img, OrHeight
        GdipCreateFromHDC hDC, graphics
        GdipSetInterpolationMode graphics, InterpolationModeHighQualityBicubic
    
        Dim DestX      As Long      ' Destination image X
        Dim DestY      As Long      ' Destination image Y
        Dim DestWidth  As Long      ' Destination image Width
        Dim DestHeight As Long      ' Destination image Height
        Dim maxCXY As Long
        Dim dRatio As Double
    If m_ThumbScaleCXY Then
        maxCXY = m_ThumbCXY '* m_ScaleX
        dRatio = OrWidth / OrHeight
        
        DestWidth = OrWidth * m_ScaleX
        DestHeight = OrHeight * m_ScaleY
        If DestWidth > maxCXY Then
            DestWidth = maxCXY
            DestHeight = DestWidth \ dRatio
        ElseIf DestHeight > maxCXY Then
            DestHeight = maxCXY
            DestWidth = DestHeight * dRatio
        End If
        DebugAppend "gdipDraw scaled " & OrWidth & "," & OrHeight & " to " & DestWidth & "x" & DestHeight, 22
        DestX = (Width - DestWidth) \ 2
        DestY = (Height - DestHeight) \ 2
    Else
        DestX = (Width - OrWidth) \ 2
        DestY = (Height - OrHeight) \ 2
    End If
    
    If bDrawBorder Then
        Dim hPen As LongPtr, lRet As Long
        'GdipCreatePen1 &HFFCFCFCF, 2, ByVal 2&, hPen '&HFFD6D6D6
        'Frame was hard to see on dark background; adjust for luminance
        Dim clr As Integer
        Dim cBlend As Long
        Dim col As Long
        OleTranslateColor clrBack, 0&, col
    '        DebugAppend "col=" & Hex$(col)
        Dim R As Integer
        Dim g As Integer
        Dim b As Integer
        R = &HFF& And col
        g = (&HFF00& And col) \ 256
        b = (&HFF0000 And col) \ 65536
        Dim lum As Long
        lum = CLng(Round((0.2126 * R + 0.7152 * g + 0.0722 * b), 0))
    '        DebugAppend "lum=" & lum
        clr = 200 - (240 - lum)
        If clr > 214 Then clr = 214
        If clr < 75 Then clr = 75
        cBlend = &HFF000000 + RGB(clr, clr, clr)
        GdipCreatePen1 cBlend, 2, ByVal 2&, hPen
        lRet = GdipDrawRectangleI(graphics, hPen, 0, 0, Width - 1, Height - 1)
        GdipDeletePen hPen
    End If
    
    If m_ThumbScaleCXY Then
        GdipDrawImageRectRectI graphics, Img, DestX, DestY, DestWidth, DestHeight, 0, 0, OrWidth, OrHeight, UnitPixel, 0, 0, 0
    Else
        GdipDrawImageRectI graphics, Img, DestX, DestY, OrWidth, OrHeight
    End If
    
    GdipDeleteGraphics graphics
    
    End Sub
    
    Private Sub gdipDrawCenteredNoScale(Img As LongPtr, hDC As LongPtr, Width As Long, Height As Long)
    'draw a smaller image centered on a larger background
    DebugAppend "gdipDrawCentered", 9
        Dim graphics   As LongPtr      ' Graphics Object Pointer
        Dim OrWidth    As Long      ' Original Image Width
        Dim OrHeight   As Long      ' Original Image Height
        GdipGetImageWidth Img, OrWidth
        GdipGetImageHeight Img, OrHeight
        GdipCreateFromHDC hDC, graphics
        GdipSetInterpolationMode graphics, InterpolationModeHighQualityBicubic
    
        Dim DestX      As Long      ' Destination image X
        Dim DestY      As Long      ' Destination image Y
        Dim DestWidth  As Long      ' Destination image Width
        Dim DestHeight As Long      ' Destination image Height
    
    'If m_ThumbScaleCXY Then
    '    DestWidth = OrWidth * m_ScaleX
    '    DestHeight = OrHeight * m_ScaleY
    '    DestX = (Width - DestWidth) \ 2
    '    DestY = (Height - OrHeight) \ 2
    'Else
        DestX = (Width - OrWidth) \ 2
        DestY = (Height - OrHeight) \ 2
    
        GdipDrawImageRectI graphics, Img, DestX, DestY, OrWidth, OrHeight
    
    GdipDeleteGraphics graphics
    
    End Sub
    
    
    ' Replaces the old bitmap of the hDC, Returns the bitmap and Deletes the hDC
    Private Sub GetBitmap(hDC As LongPtr, hBitmap As LongPtr)
        hBitmap = SelectObject(hDC, hBitmap)
        DeleteDC hDC
    End Sub
    
    Private Function Create32BitHBITMAP(hDC As LongPtr, cx As Long, cy As Long) As LongPtr
    Dim bmi As BITMAPINFO
        bmi.bmiHeader.biSize = LenB(bmi.bmiHeader)
        bmi.bmiHeader.biPlanes = 1
        bmi.bmiHeader.biCompression = 0
    
        bmi.bmiHeader.biWidth = cx
        bmi.bmiHeader.biHeight = cy
        bmi.bmiHeader.biBitCount = 32
        Create32BitHBITMAP = CreateDIBSection(hDC, bmi, DIB_RGB_COLORS, ByVal 0&, 0, 0)
        
    End Function
    
    Private Function GetOverlayExpanded(hIcon As LongPtr, cxy As Long) As LongPtr
    Dim hImage As LongPtr
    Dim hDC As LongPtr
    Dim cxo As Long, cyo As Long
    Dim dx As Long, dy As Long
    Dim hBmpNew As LongPtr
    
    GdipCreateBitmapFromHICON hIcon, hImage
        GdipGetImageWidth hImage, cxo
        GdipGetImageHeight hImage, cyo
    
    InitDC hDC, hBmpNew, &HFF000000, cxy, cxy
    Dim graphics   As LongPtr
        GdipCreateFromHDC hDC, graphics
        GdipSetInterpolationMode graphics, InterpolationModeHighQualityBicubic
    
    dx = 0
    dy = cxy - cyo
    
    GdipDrawImageRectI graphics, hImage, dx, dy, cxo, cyo
    GdipDeleteGraphics graphics
    
    GetBitmap hDC, hBmpNew
    GetOverlayExpanded = hBmpNew
    End Function
    Private Function AddToImageListEx(himl As LongPtr, hBmp As LongPtr, minX As Long, minY As Long) As Long
    'imagelist_add seems to fail if an image is smaller than the requested size
    'despite the fact that a valid hThumb is returned
    'this function will scale the image up, then try to add
    
    Dim lX As Long, lY As Long
    Dim hDC As LongPtr
    Dim hBmpNew As LongPtr
    Dim gimg As LongPtr
    On Error GoTo e0
    
    GdipCreateBitmapFromHBITMAP hBmp, ByVal 0&, gimg
    If gimg Then
        GdipGetImageWidth gimg, lX
        GdipGetImageHeight gimg, lY
        
    '    If (lX < minX) Or (lY < minY) Then
            DebugAppend "Addhimlex: resizing"
            InitDC hDC, hBmpNew, &HFF000000, minX, minY
            'gdipResize gimg, hDC, minX, minY, True
            If (lX > minX) Or (lY > minY) Then
                gdipResize gimg, hDC, minX, minY, True
                'gdipDrawCentered gimg, hDC, minX, minY, False
            ElseIf (lX = minX) Or (lY = minY) Then
                gdipDrawCenteredNoScale gimg, hDC, minX, minY
            Else
                gdipDrawCentered gimg, hDC, minX, minY, True
            End If
            GdipDisposeImage gimg
            GetBitmap hDC, hBmpNew
    '    Else
    '        DebugAppend "addhimlex: using original"
    '        hBmpNew = hBmp
    '    End If
    Else
        DebugAppend "addhimlex failed to generate gdip image"
        hBmpNew = hBmp
    End If
    If IsComCtl6 = False Then
        Dim clrMsk As Long
        OleTranslateColor clrFore, 0&, clrMsk
        AddToImageListEx = ImageList_AddMasked(himl, hBmpNew, clrMsk)
    Else
        AddToImageListEx = ImageList_Add(himl, hBmpNew, 0&)
    End If
    
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "ucShellBrowse.AddToImageListEx.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function QueryShowFile(sName As String, sPath As String) As Boolean
    Dim fsh As Long
    Dim sCmp As String
    If m_Filter = "" Then
        sCmp = "*"
    Else
        sCmp = m_Filter
    End If
    
    fsh = -1
    RaiseEvent FilterFile(sName, sPath, fsh)
    If fsh = 0 Then
        QueryShowFile = False
        Exit Function
    ElseIf fsh > 0& Then
        QueryShowFile = True
        Exit Function
    End If
    
    If PathMatchSpecW(StrPtr(sName), StrPtr(sCmp)) Then
        QueryShowFile = True
    Else
        QueryShowFile = False
    End If
    
    End Function
    
    Private Function QueryShowFolder(sName As String, sPath As String) As Boolean
    Dim fsh As Long
    Dim sCmp As String
    If m_FolderFilter = "" Then
        sCmp = "*"
    Else
        sCmp = m_FolderFilter
    End If
    fsh = -1
    RaiseEvent FilterFolder(sName, sPath, fsh)
    If fsh = 0 Then
        QueryShowFolder = False
        Exit Function
    ElseIf fsh > 0& Then
        QueryShowFolder = True
        Exit Function
    End If
    
    If PathMatchSpecW(StrPtr(sName), StrPtr(sCmp)) Then
        QueryShowFolder = True
    Else
        QueryShowFolder = False
    End If
    
    End Function
    
    Private Function AddBackslash(s As String) As String
    
       If Len(s) > 0 Then
          If Right$(s, 1) <> "\" Then
             AddBackslash = s & "\"
          Else
             AddBackslash = s
          End If
       Else
          AddBackslash = "\"
       End If
    
    End Function
    
    Private Function TrimBackslash(s As String) As String
    If (Len(s) = 3) And (Right$(s, 1) = "\") Then
        TrimBackslash = s
        Exit Function
    Else
        If (Right$(s, 1) = "\") Then
            TrimBackslash = Left$(s, Len(s) - 1)
        Else
            TrimBackslash = s
        End If
    End If
    End Function
            
    Private Function Attach(hWnd As LongPtr) As Long
    'after configuring settings, call this to attach to an hWnd
    If bRegDD = False Then
        m_hWnd = hWnd
        Attach = RegisterDragDrop(hWnd, Me)
        bRegDD = True
    End If
    End Function
    
    Private Function Detach() As Long
    'There's an appcrash if revoke is called on an unregistered window
    If bRegDD Then
        If RegisterDragDrop(m_hWnd, Me) = DRAGDROP_E_ALREADYREGISTERED Then
            Detach = RevokeDragDrop(m_hWnd)
            bRegDD = False
        End If
    End If
    End Function
    
    Private Sub SetTrackMouseLeave(hWnd As LongPtr)
    Dim tTME As TrackMouseEventStruct
    tTME.cbSize = LenB(tTME)
    tTME.dwFlags = TME_LEAVE
    tTME.hWndTrack = hWnd
    TrackMouseEvent tTME
    End Sub


    Private Sub chkColFilter_Click() Handles chkColFilter.Click
    Dim dwHdrStyle As ucsb_HeaderStyles
    dwHdrStyle = CLng(GetWindowLong(hLVCHdr, GWL_STYLE))
    If chkColFilter.Value = vbChecked Then
        dwHdrStyle = dwHdrStyle Or HDS_FILTERBAR
    Else
        dwHdrStyle = dwHdrStyle And Not HDS_FILTERBAR
        If bLVCGroup Then
            LVCFilterResetItems
        End If
    End If
    Dim rcx As RECT
    Dim cxT As Long, cyT As Long
    GetWindowRect hLVC, rcx
    cxT = rcx.Right - rcx.Left
    cyT = rcx.Bottom - rcx.Top
    SetWindowLong hLVCHdr, GWL_STYLE, dwHdrStyle
    SetWindowPos hLVC, 0&, 0&, 0&, cxT + 1, cyT, SWP_NOMOVE
    SetWindowPos hLVC, 0&, 0&, 0&, cxT, cyT, SWP_NOMOVE
    '...that's the only possible way, out of many I've tried, to get the ListView to correctly redraw the column header/filterbar
    If (chkColFilter.Value = vbChecked) And (mLVCFilt <> "") Then
        'Restore filter
        LVCApplyFilterbar 0&
    End If
    End Sub
    
    Private Sub chkDate_Click() Handles chkDate.Click
    hFocused = chkDate.hWnd
    
    If chkDate.Value = vbChecked Then
        cbDateType.Enabled = True
        cbDateCmp1.Enabled = True
        If hDTSearch1 Then EnableWindow hDTSearch1, 1
    Else
        cbDateType.Enabled = False
        cbDateCmp1.Enabled = False
        If hDTSearch1 Then EnableWindow hDTSearch1, 0
    End If
    End Sub
    
    Private Sub chkSrSz_Click() Handles chkSrSz.Click
    If chkSrSz.Value = vbChecked Then
        cbSrSize1.Enabled = True
    Else
        cbSrSize1.Enabled = False
    End If
    End Sub
    
    Private Sub cmdPropCancel_Click() Handles cmdPropCancel.Click
    Dim i As Long
    For i = 0 To UBound(tDispProps)
        tDispProps(i).bWrite = False
        If (tDispProps(i).dwDispType = PDDT_NUMBER) And (tDispProps(i).fReadOnly = S_OK) Then
            tDispProps(i).bUnformatNum = False 'Need to reset this or the formatted value appears if you edit again
        End If
        If tDispProps(i).hAlt Then
            DestroyWindow tDispProps(i).hAlt
            tDispProps(i).hAlt = 0&
            tDispProps(i).bEnumeratedUseNewIndex = False
            tDispProps(i).bUseNewST = False
            ShowWindow tDispProps(i).hEdit, SW_SHOW
        End If
    Next i
    For i = 0 To UBound(tDispProps)
        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sOrig)
    Next i
    cmdPropSave.Visible = False
    cmdPropCancel.Visible = False
    End Sub
    
    Private Sub cmdPropSave_Click() Handles cmdPropSave.Click
    WritePropertyChanges
    cmdPropSave.Visible = False
    cmdPropCancel.Visible = False
    End Sub
    
    Private Sub cmdColOK_Click() Handles cmdColOK.Click
    Dim i As Long, j As LongPtr
    Dim lIdx As Long, lCl As Long
    Dim lOrder() As LongPtr, nOd As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim cbItems(lIdx).lColSet(0)
    
    Dim lCnt As Long
    lCnt = CLng(SendMessage(hLVC, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    ReDim lOrder(0)
    For i = 0 To lCnt - 1
        j = GetLVItemlParam(hLVC, i)
        If ListView_GetCheckState(hLVC, i) Then
            ReDim Preserve cbItems(lIdx).lColSet(lCl)
            cbItems(lIdx).lColSet(lCl) = j
            lCl = lCl + 1
            uColData(j).bFlagRecent = True
            ReDim Preserve lOrder(nOd)
            lOrder(nOd) = j
            nOd = nOd + 1
        End If
    Next i
    DebugAppend "ColSet=" & dbg_sfromlarray(cbItems(lIdx).lColSet)
    DestroyWindow hLVC
    DestroyWindow hUpDown
    DestroyWindow hColCX
    'zUnThunk pbColumns.hWnd, SubclassThunk
    UnSubclass2 pbColumns.hWnd, AddressOf ColWndProc, pbColumns.hWnd
    
    pbColumns.Visible = False
    bColSelActive = False
    bLVCGroup = False
    bLVCFilterActive = False
    bLVCAdv = False
    UpdateColumns lIdx
    ReorderColumns lOrder
    End Sub
    
    Private Sub ReorderColumns(lByLP() As LongPtr)
    'Specify the desired order by lParam (uColData index)
    Dim lOrder() As Long
    Dim i As Long, j As Long, k As Long
    Dim lp As LongPtr
    Dim lColCnt As Long
    Dim lToSet() As Long
    For i = 0 To UBound(lByLP)
        DebugAppend "Desired(" & i & ")=" & uColData(lByLP(i)).szDisplayName
    Next i
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    ReDim lOrder(lColCnt - 1)
    ReDim lToSet(lColCnt - 1)
    SendMessage hLVSHdr, HDM_GETORDERARRAY, lColCnt, ByVal VarPtr(lOrder(0))
    
    For j = 0 To UBound(lByLP)
        For i = 0 To lColCnt - 1
            lp = GetHDItemlParam(hLVSHdr, lOrder(i))
    '        DebugAppend "Col " & i & ": " & uColData(lp).szDisplayName
            If lByLP(j) = lp Then
                lToSet(k) = lOrder(i)
                k = k + 1
    '            DebugAppend "SetDest(" & k & ")=" & uColData(lByLP(j)).szDisplayName
            End If
        Next i
    Next j
    
    SendMessage hLVSHdr, HDM_SETORDERARRAY, lColCnt, ByVal VarPtr(lToSet(0))
    
    RedrawList 'Column text won't be automatically redrawn, gotta do it manually
    End Sub
    Private Function RenameDevice(sDeviceID As String, sNewName As String) As Long
    'In Computer/ThisPC, lettered drives can be renamed with SetVolumeLabel and others, but
    'attached devices cannot be renamed like that. It seems the only way is a full-blown dive
    'into the Portable Devices COM interfaces.
    Dim sID As String
    sID = sDeviceID
    If Left$(sID, 4) <> "\\?\" Then
        sID = "\\?\" & sID 'The name requested when item added doesn't have this prefix, which is mandatory
    End If
    DebugAppend "RenameDevice id=" & sID & ",new=" & sNewName
     Dim pDevice As PortableDevice 'While PortableDeviceFTM is suggested for single-threaded apps, it is virtually
                                   'impossible to use from VB6.
  
     Dim pValues As IPortableDeviceValues, pResults As IPortableDeviceValues
     Dim pClient As IPortableDeviceValues
     Dim hr As Long, phr As Long
     Set pClient = New PortableDeviceValues
     
     DebugAppend "pClient CCI=0x" & Hex$(hr)
     If (pClient Is Nothing) = False Then
        'This app is the client; set its info
        hr = pClient.SetStringValue(WPD_CLIENT_NAME, StrPtr(mVersionApp))
        hr = pClient.SetUnsignedIntegerValue(WPD_CLIENT_MAJOR_VERSION, mVersionMjr)
        hr = pClient.SetUnsignedIntegerValue(WPD_CLIENT_MINOR_VERSION, mVersionMnr)
        hr = pClient.SetUnsignedIntegerValue(WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE, SECURITY_IMPERSONATION)
        Set pDevice = New PortableDevice
        hr = pDevice.Open(StrPtr(sID), pClient)
        
        DebugAppend "pDevice.Open=0x" & Hex$(hr)
        If hr = S_OK Then
            Dim pContent As IPortableDeviceContent
            Dim pProp As IPortableDeviceProperties
            hr = pDevice.Content(pContent)
            If (pContent Is Nothing) = False Then
                hr = pContent.Properties(pProp)
                If (pProp Is Nothing) = False Then
                    Set pValues = New PortableDeviceValues
                    If (pValues Is Nothing) = False Then
                        pValues.SetStringValue WPD_DEVICE_FRIENDLY_NAME, StrPtr(sNewName)
                        hr = pProp.SetValues(StrPtr(WPD_DEVICE_OBJECT_ID), pValues, pResults)
                        DebugAppend "RenameDevice->SetValues hr=0x" & Hex$(hr)
                        hr = pResults.GetErrorValue(WPD_DEVICE_FRIENDLY_NAME, phr)
                        DebugAppend "RenameDevice->SetFriendlyName result=0x" & Hex$(phr)
                        RenameDevice = phr
                    Else
                        DebugAppend "RenameDevice->Failed to create pValues, hr=0x" & Hex$(hr)
                        RenameDevice = -10
                    End If
                Else
                    DebugAppend "RenameDevice->Failed to create spProperties, hr=0x" & Hex$(hr)
                    RenameDevice = -11
                End If
            Else
                DebugAppend "RenameDevice->Failed to create spContent, hr=0x" & Hex$(hr)
                RenameDevice = -12
            End If
            hr = pDevice.Close()
        Else
            DebugAppend "RenameDevice->Failed to open device, hr=0x" & Hex$(hr)
            RenameDevice = -1
        End If
    Else
        DebugAppend "RenameDevice->Failed to create pClient, hr=0x" & Hex$(hr)
        RenameDevice = -13
    End If
    
    End Function
    
    Public Sub AddColumn(sSystemPropName As String)
    If bBlankLoaded = True Then
        UpdateStatus mStrBlankNoOp
        Exit Sub
    End If
    Dim nCol As Long
    Dim lIdx As Long
    Dim i As Long, j As Long
    
    nCol = -1
    For i = 0 To UBound(uColData)
        If uColData(i).szSystemName = sSystemPropName Then
            nCol = i
            Exit For
        End If
    Next i
    If nCol = -1 Then
        DebugAppend "AddColumn::" & sSystemPropName & " not found."
        Exit Sub
    End If
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    DebugAppend "idx=" & lIdx
    'For i = 0 To UBound(cbItems(lIdx).lColSet)
    '    If cbItems(lIdx).lColSet(i) = nCol Then Exit Sub 'column already added
    'Next i
    j = UBound(cbItems(lIdx).lColSet) + 1
    ReDim Preserve cbItems(lIdx).lColSet(j)
    cbItems(lIdx).lColSet(j) = nCol
    'uColData(nCol).bFlagRecent = True
    UpdateColumns lIdx
    
    End Sub
    
    Private Sub pvAddColumnByPKEY(pk As PROPERTYKEY)
    If bBlankLoaded = True Then
        UpdateStatus mStrBlankNoOp
        Exit Sub
    End If
    Dim nCol As Long
    Dim lIdx As Long
    Dim i As Long, j As Long
    
    nCol = -1
    For i = 0 To UBound(uColData)
        If IsEqualPKEY(uColData(i).pKey, pk) Then
            nCol = i
            Exit For
        End If
    Next i
    If nCol = -1 Then
        DebugAppend "pvAddColumnByPKEY::Key not found."
        Exit Sub
    End If
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    DebugAppend "idx=" & lIdx
    'For i = 0 To UBound(cbItems(lIdx).lColSet)
    '    If cbItems(lIdx).lColSet(i) = nCol Then Exit Sub 'column already added
    'Next i
    j = UBound(cbItems(lIdx).lColSet) + 1
    ReDim Preserve cbItems(lIdx).lColSet(j)
    cbItems(lIdx).lColSet(j) = nCol
    'uColData(nCol).bFlagRecent = True
    UpdateColumns lIdx
    
    End Sub
    
    Public Sub AddColumnByPKEY(pkey_varptr As Long)
    Dim pk As PROPERTYKEY
    
    If pkey_varptr Then
        CopyMemory ByVal VarPtr(pk), ByVal pkey_varptr, Len(pk)
    Else
        DebugAppend "AddColumnByPKEY::No pointer to PKEY"
        Exit Sub
    End If
    
    pvAddColumnByPKEY pk
    End Sub
    
    Private Sub cmdColCancel_Click() Handles cmdColCancel.Click
    pbColumns.Visible = False
    DestroyWindow hLVC
    DestroyWindow hUpDown
    DestroyWindow hColCX
    ' zUnThunk pbColumns.hWnd, SubclassThunk
    UnSubclass2 pbColumns.hWnd, AddressOf ColWndProc, pbColumns.hWnd
    bLVCGroup = False
    bLVCFilterActive = False
    bColSelActive = False
    bLVCAdv = False
    End Sub
    
    Private Sub cmdSrCl_Click() Handles cmdSrCl.Click
    SearchOptionsClose
    End Sub
    
    Private Sub cmdSrClr_Click() Handles cmdSrClr.Click
    cbShType.ListIndex = 0
    cbDateType.ListIndex = 0
    cbDateCmp1.ListIndex = 0
    cbSrSize1.ListIndex = 0
    txtSrSize1.Text = "0"
    chkSrSz.Value = vbUnchecked
    Dim stInitial As SYSTEMTIME
    stInitial = DateToSystemTime(Now)
    
    SendMessageW hDTSearch1, DTM_SETSYSTEMTIME, GDT_VALID, stInitial
    
    chkDate.Value = vbUnchecked
    chkShFldr.Value = vbUnchecked
    
    End Sub
    
    Private Sub cmdSrCn_Click() Handles cmdSrCn.Click
    bSrSetCancel = True
    End Sub
    
    Private Sub cmdStartSearch_Click() Handles cmdStartSearch.Click
    mFlagActiveSearch = True
    UpdateStatus mSearchCD & m_sCurPathDisp
    cmdStartSearch.Enabled = False
    cmdSrCn.Enabled = True
    bSearchExt = True 'Starting from pane so enable advanced options
    If m_sCurPath = sLibRoot2 Then
        Call ExecSearch(True)
    Else
        Call ExecSearch 'Will grab text in condition configure (GetCondition)
    End If
    If bSearchOptionsPersist = False Then
        SearchOptionsClose
    End If
    cmdStartSearch.Enabled = True
    cmdSrCn.Enabled = False
    UpdateStatus mSearchDone
    mFlagActiveSearch = False
    End Sub
    
    Private Sub SearchOptionsClose()
    DestroyWindow hDTSearch1
    DestroyWindow hDTSearch2
    hDTSearch1 = 0
    hDTSearch2 = 0
    DestroyWindow hSearchBoxAlt
    hSearchBoxAlt = 0&
    
    pbSearch.Visible = False
    
    End Sub
    
    Private Sub cbDateCmp1_GotFocus() Handles cbDateCmp1.GotFocus
    hFocused = cbDateCmp1.hWnd
    End Sub
    
    Private Sub cbDateType_GotFocus() Handles cbDateType.GotFocus
    hFocused = cbDateType.hWnd
    End Sub
    
    Private Sub cbShType_GotFocus() Handles cbShType.GotFocus
    hFocused = cbShType.hWnd
    End Sub
    
    Private Sub cbSrSize1_GotFocus() Handles cbSrSize1.GotFocus
    hFocused = cbSrSize1.hWnd
    End Sub
    
    Private Sub chkColFilter_GotFocus() Handles chkColFilter.GotFocus
    hFocused = chkColFilter.hWnd
    End Sub
    
    Private Sub chkDate_GotFocus() Handles chkDate.GotFocus
    hFocused = chkDate.hWnd
    End Sub
    
    Private Sub chkShFldr_Click() Handles chkShFldr.Click
    hFocused = chkShFldr.hWnd
    End Sub
    
    Private Sub chkShFldr_GotFocus() Handles chkShFldr.GotFocus
    hFocused = chkShFldr.hWnd
    End Sub
    
    Private Sub chkSrSz_GotFocus() Handles chkSrSz.GotFocus
    hFocused = chkSrSz.hWnd
    End Sub
    
    Private Sub cmdColCancel_GotFocus() Handles cmdColCancel.GotFocus
    hFocused = cmdColCancel.hWnd
    End Sub
    
    Private Sub cmdColOK_GotFocus() Handles cmdColOK.GotFocus
    hFocused = cmdColOK.hWnd
    End Sub
    
    Private Sub cmdPropCancel_GotFocus() Handles cmdPropCancel.GotFocus
    hFocused = cmdPropCancel.hWnd
    End Sub
    
    Private Sub cmdPropSave_GotFocus() Handles cmdPropSave.GotFocus
    hFocused = cmdPropSave.hWnd
    End Sub
    
    Private Sub cmdSrCl_GotFocus() Handles cmdSrCl.GotFocus
    hFocused = cmdSrCl.hWnd
    End Sub
    
    Private Sub cmdSrClr_GotFocus() Handles cmdSrClr.GotFocus
    hFocused = cmdSrClr.hWnd
    End Sub
    
    Private Sub cmdSrCn_GotFocus() Handles cmdSrCn.GotFocus
    hFocused = cmdSrCn.hWnd
    End Sub
    
    Private Sub cmdStartSearch_GotFocus() Handles cmdStartSearch.GotFocus
    hFocused = cmdStartSearch.hWnd
    End Sub
    
    Private Sub ShowBookmarkMenu()
    UserControl_Resize
    Dim hMenu As LongPtr, hSubMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
    Dim i As Long
    Dim nObj As Long
    Dim nPos As Long
    Dim siBkm As IShellItem
    Dim bCurIsBkmd As Boolean
    Dim arBkms() As String
    Dim hBmpRes() As LongPtr, nBM As Long
    ReDim hBmpRes(0)
    
    On Error GoTo e0
    
    DebugAppend "BkmStr=" & m_Bookmarks
    
    
    If InStr(m_Bookmarks, "|") Then
        arBkms = Split(m_Bookmarks, "|")
        For i = 0 To UBound(arBkms)
            If arBkms(i) = m_sCurPath Then
                bCurIsBkmd = True
                Exit For
            End If
        Next i
    Else
        If m_Bookmarks = m_sCurPath Then
            bCurIsBkmd = True
        End If
    End If
    
    If (m_Bookmarks <> "") And (m_Bookmarks <> "|") Then
        arBkms = Split(m_Bookmarks, "|")
        DebugAppend "BkmCt=" & (UBound(arBkms) + 1)
        nObj = (UBound(arBkms) + 1)
        For i = 0 To UBound(arBkms)
            DebugAppend "Bkm" & i & "=" & arBkms(i)
        Next i
    Else
        nObj = 0
        DebugAppend "No bookmarks in list"
    End If
    
    hMenu = CreatePopupMenu()
    If mSFinBKM Then hSubMenu = GenerateSpecialFolderMenu(hBmpRes)
    nBM = UBound(hBmpRes) + 1
    With mii
        .cbSize = LenB(mii)
        DebugAppend "construct bkm menuIf mSFinBKM Then "
    
        If bCurIsBkmd = False Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .wID = widBkmAdd
            .dwTypeData = StrPtr(mn_sBkmAdd)
            .cch = Len(mn_sBkmAdd)
            .fState = IIf(bCurIsBkmd, MFS_DISABLED, MFS_ENABLED)
            Call InsertMenuItemW(hMenu, nPos, True, mii)
            nPos = nPos + 1
        Else
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .wID = widBkmRem
            .dwTypeData = StrPtr(mn_sBkmRem)
            .cch = Len(mn_sBkmRem)
            .fState = IIf(bCurIsBkmd, MFS_ENABLED, MFS_DISABLED)
            Call InsertMenuItemW(hMenu, nPos, True, mii)
            nPos = nPos + 1
        End If
        
        'clear
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        .wID = widBkmClr
        .dwTypeData = StrPtr(mn_sBkmClr)
        .cch = Len(mn_sBkmClr)
        .fState = IIf(nObj > 0&, MFS_ENABLED, MFS_DISABLED)
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        
        If (nObj > 0&) Or (mSFinBKM = True) Then
            .fMask = MIIM_ID Or MIIM_TYPE
            .fType = MFT_SEPARATOR
            .wID = 0
            Call InsertMenuItemW(hMenu, nPos, True, mii)
            nPos = nPos + 1
        End If
        
        If mSFinBKM Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU
            .wID = widBkmLBase - 1
            .dwTypeData = StrPtr(mn_sBkmSpc)
            .cch = Len(mn_sBkmSpc)
            .hSubMenu = hSubMenu
            Call InsertMenuItemW(hMenu, nPos, True, mii)
            nPos = nPos + 1
        End If
        
        If nObj > 0 Then
            For i = 0 To UBound(arBkms)
                If arBkms(i) = "0" Then
                    SHGetKnownFolderItem FOLDERID_Desktop, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siBkm
                Else
                    SHCreateItemFromParsingName StrPtr(arBkms(i)), Nothing, IID_IShellItem, siBkm
                End If
                If (siBkm Is Nothing) Then
                    Dim pidlFQ As LongPtr
                    pidlFQ = ILCreateFromPathW(StrPtr(arBkms(i)))
                    If pidlFQ Then
                        SHCreateItemFromIDList pidlFQ, IID_IShellItem, siBkm
                        CoTaskMemFree pidlFQ
                    Else
                        DebugAppend "ShowBookmarkMenu::Alt creation failed."
                    
                    End If
                
                End If
                If (siBkm Is Nothing) = False Then
                    ReDim Preserve hBmpRes(nBM)
                    hBmpRes(nBM) = AddShellItemToMenu(hMenu, siBkm, widBkmLBase + i, nPos + i)
                    nBM = nBM + 1
                Else
                    If Left$(arBkms(i), 3) = "::{" Then
                        Dim sSh As String
                        sSh = "shell:" & arBkms(i)
                        SHCreateItemFromParsingName StrPtr(sSh), Nothing, IID_IShellItem, siBkm
                        If (siBkm Is Nothing) = False Then
                            ReDim Preserve hBmpRes(nBM)
                            hBmpRes(nBM) = AddShellItemToMenu(hMenu, siBkm, widBkmLBase + i, nPos + i)
                            nBM = nBM + 1
                        Else
                            DebugAppend "ShowBookmarkMenu::Last fallback failed."
                        End If
                    End If
                End If
            Next i
        End If
    
    End With
    
    PT.x = 0
    PT.y = cyCombo
    ClientToScreen hBkmButton, PT
    Dim hPar As LongPtr
    If hLVS = 0& Then
        hPar = UserControl.hWnd
    Else
        hPar = hLVS
    End If
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hPar, 0)
    If idCmd Then
        ProcessBookmarkMenuCmd idCmd, arBkms
    End If
    DestroyMenu hMenu
    For i = 0 To UBound(hBmpRes)
        If hBmpRes(i) Then DeleteObject hBmpRes(i)
    Next i
    
    Exit Sub
    
    e0:
        DebugAppend "ShowBookmarkMenu.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
        
    End Sub
    
    Private Sub ProcessBookmarkMenuCmd(idCmd As Long, arBkms() As String)
    Dim sTmp As String
    Dim i As Long, k As Long
        Dim arBook() As String
        Select Case idCmd
            Case widBkmAdd
                sTmp = m_Bookmarks
                If sTmp = m_sCurPath Then Exit Sub
                If sTmp = "" Then
                    m_Bookmarks = m_sCurPath
                    
                    SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
                    Exit Sub
                End If
                If InStr(sTmp, "|") = 0 Then 'only 1 entry, but it's not a dupe
                    m_Bookmarks = m_Bookmarks & "|" & m_sCurPath
                    SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
                    Exit Sub
                End If
                'multiple entries exist already, need to split
                arBook = Split(sTmp, "|")
                For i = 0 To UBound(arBook)
                    If arBook(i) = m_sCurPath Then 'dupe
                        Exit Sub
                    End If
                Next i
                ReDim Preserve arBook(UBound(arBook) + 1)
                arBook(UBound(arBook)) = m_sCurPath
                m_Bookmarks = Join(arBook, "|")
                SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
            Case widBkmRem
                If m_Bookmarks = "" Then Exit Sub
                sTmp = m_Bookmarks
                If sTmp = m_sCurPath Then
                    m_Bookmarks = ""
                    SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
                    Exit Sub
                End If
                If InStr(sTmp, "|") Then
                    arBook = Split(sTmp, "|")
                    m_Bookmarks = ""
                    For i = 0 To UBound(arBook)
                        If arBook(i) <> m_sCurPath Then
                            m_Bookmarks = m_Bookmarks & "|" & arBook(i)
                        End If
                    Next i
                    If Left$(m_Bookmarks, 1) = "|" Then
                        m_Bookmarks = Mid$(m_Bookmarks, 2)
                    End If
                End If
                SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
            Case widBkmClr
                m_Bookmarks = ""
                SaveSetting mRegDataName, "UserData", "Bookmarks", m_Bookmarks
            Case widBaseSF To (widBaseSF + 256)
                UpdateStatus mStrOpening
                Dim sfIdx As Long
                Dim tFID As UUID
                Dim siSF As IShellItem
                
                sfIdx = idCmd - widBaseSF
                
                GetSpecialFolderMenuItem sfIdx, tFID
                'Thanks to the added ability to open direct on an IShellItem, we don't even need to go mucking
                'around the the paths, and even worse identifying virtual folders and their pidls...
                SHGetKnownFolderItem tFID, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siSF
                
                BrowserOpenItem siSF
            
            Case widBkmLBase To (widBkmLBase + nMaxBookmarks)
                UpdateStatus mStrOpening
                k = idCmd - widBkmLBase
                DebugAppend "ShowBookmarkMenu GoTo(" & k & ")=" & arBkms(k)
                Dim li2 As Long
                Dim gii As Long
                gii = GetItemIndex(arBkms(k), li2)
                DebugAppend "ShowBookmarkMenu idx=" & gii & ",indt=" & li2
                If arBkms(k) = "0" Then 'desktop/root
                    bSuppress = True
                    Call SendMessage(hCombo, CB_SETCURSEL, 0&, ByVal 0&)
                    LVLoadFolder "0"
                    bSuppress = False
                    Exit Sub
                End If
                
                If gii = -1 Then
                    Dim li As Long
                    Dim idx As Long
                    Dim siItem As IShellItem
                '    Call SHCreateItemFromIDList(pidlt, IID_IShellItem, siItem)
                    Call SHCreateItemFromParsingName(StrPtr(arBkms(k)), Nothing, IID_IShellItem, siItem)
                    If siItem Is Nothing Then
                        If Left$(arBkms(k), 3) = "::{" Then
                            Dim sSh As String
                            sSh = "shell:" & arBkms(k)
                            SHCreateItemFromParsingName StrPtr(sSh), Nothing, IID_IShellItem, siItem
                        End If
                    End If
                    If m_Mode <> SBCTL_DrivesOnly Then
    
                        idx = AddStandardFSItem(siItem, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
                        DebugAppend "ShowBookmarkMenu::LVLoadFolder"
                        LVLoadFolder arBkms(k)
                    End If
                Else
                    bSuppress = True
                    Call SendMessage(hCombo, CB_SETCURSEL, gii, ByVal 0&)
                    LVLoadFolder arBkms(k)
                    bSuppress = False
                End If
             Case widSL1
                UpdateStatus mStrOpening
                SHCreateItemFromParsingName StrPtr("shell:::{26EE0668-A00A-44D7-9371-BEB064C98683}\8\::{7B81BE6A-CE2B-4676-A29E-EB907A5126C5}"), Nothing, IID_IShellItem, siItem
                If (siItem Is Nothing) = False Then
                    If m_Mode <> SBCTL_DrivesOnly Then
    
                        idx = AddStandardFSItem(siItem, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
                        
                        Set siDirect = siItem
                        LVLoadFolder "", True
                    End If
                End If
            Case widSL2
                UpdateStatus mStrOpening
                SHCreateItemFromParsingName StrPtr("shell:::{26EE0668-A00A-44D7-9371-BEB064C98683}\2\::{A8A91A66-3A7D-4424-8D24-04E180695C7A}"), Nothing, IID_IShellItem, siItem
                If (siItem Is Nothing) = False Then
                    If m_Mode <> SBCTL_DrivesOnly Then
    
                        idx = AddStandardFSItem(siItem, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
                        DebugAppend "ShowBookmarkMenu::LVLoadFolder"
                        
                        Set siDirect = siItem
                        LVLoadFolder "", True
                    End If
                End If
                
            Case widSL3
                UpdateStatus mStrOpening
                SHCreateItemFromParsingName StrPtr("shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"), Nothing, IID_IShellItem, siItem
                If (siItem Is Nothing) = False Then
                    If m_Mode <> SBCTL_DrivesOnly Then
    
                        idx = AddStandardFSItem(siItem, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
                        DebugAppend "ShowBookmarkMenu::LVLoadFolder"
                        
                        Set siDirect = siItem
                        LVLoadFolder "", True
                    End If
                End If
        End Select
    End Sub
    
    Private Sub GetSpecialFolderMenuItem(nIdx As Long, tID As UUID)
    'You can add or remove any folder id you want, just adjust nFC in GenerateSpecialFolderMenu
    Select Case nIdx
        Case 0: tID = FOLDERID_Profile
        Case 1: tID = FOLDERID_Downloads
        Case 2: tID = FOLDERID_Documents
        Case 3: tID = FOLDERID_Videos
        Case 4: tID = FOLDERID_Music
        Case 5: tID = FOLDERID_Pictures
        Case 6: tID = FOLDERID_Libraries
        Case 7: tID = FOLDERID_Favorites
        Case 8: tID = FOLDERID_Games
        Case 9: tID = FOLDERID_Recent
        Case 10: tID = FOLDERID_Fonts
        Case 11: tID = FOLDERID_PrintersFolder
        Case 12: tID = FOLDERID_ConnectionsFolder
        Case 13: tID = FOLDERID_RoamingAppData
        Case 14: tID = FOLDERID_Windows
        Case 15: tID = FOLDERID_Contacts
        Case 16: tID = FOLDERID_CommonAdminTools
        Case 17: tID = FOLDERID_AppsFolder 'Win8+ Only
        Case 18: tID = FOLDERID_SkyDrive   'Win8+ Only
    End Select
    End Sub
    
    Private Function GenerateSpecialFolderMenu(resHandles() As LongPtr) As LongPtr
    'it's the callers responsibility to call DestroyMenu()
    Dim mii As MENUITEMINFOW
    Dim j As Long, k As Long, n As Long
    Dim hIcon As LongPtr
    Dim pKFM As New KnownFolderManager
    Dim pKNF As IKnownFolder
    Dim tID As UUID
    Dim pUnk As IUnknown
    Dim isiif As IShellItemImageFactory
    Dim isi As IShellItem
    Dim hMenu As LongPtr
    Dim sCap As String
    Dim nFC As Long
    Dim nRH As Long
    nRH = UBound(resHandles) + 1
    hMenu = CreateMenu()
    'Set pKFM = New KnownFolderManager
    Dim lp1 As LongPtr
    
    'Begin folder blocks
    If bIsWin8OrGreater Then
        nFC = 18 'There's 2 extra Windows 8 and up folders I wanted to load.
    Else
        nFC = 16
    End If
    
    On Error GoTo e1
    For k = 0 To nFC 'number special folders in GetSpecialFolderMenuItem
        GetSpecialFolderMenuItem k, tID
        pKFM.GetFolder tID, pKNF
        pKNF.GetShellItem 0, IID_IShellItem, isi
        isi.GetDisplayName SIGDN_NORMALDISPLAY, lp1
        sCap = LPWSTRtoStr(lp1)
        Set isiif = isi
        Dim cxy As LongLong
        Dim sztmp As SIZE
        sztmp.cx = 16 * m_ScaleX: sztmp.cy = 16 * m_ScaleY
        CopyMemory cxy, sztmp, 8
        isiif.GetImage cxy, SIIGBF_ICONONLY, hIcon
        With mii
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_BITMAP Or MIIM_STATE
            .wID = (widBaseSF + n)
            .cch = Len(sCap)
            .dwTypeData = StrPtr(sCap)
            .hbmpItem = hIcon
            
            Call InsertMenuItemW(hMenu, j, True, mii)
            ReDim Preserve resHandles(nRH): resHandles(nRH) = hIcon: nRH = nRH + 1
            j = j + 1
        End With
    gsskp:
        n = n + 1
        Set isiif = Nothing
        Set isi = Nothing
        Set pKNF = Nothing
        Set pUnk = Nothing
    Next k
    On Error GoTo e2
    DebugAppend "GenerateSpecialFolderMenu::Cleared GPFMI loop", 3
    'Add special items Devices and Printers + Programs and Features, which can't be created with the above method
    SHCreateItemFromParsingName StrPtr("shell:::{26EE0668-A00A-44D7-9371-BEB064C98683}\8\::{7B81BE6A-CE2B-4676-A29E-EB907A5126C5}"), Nothing, IID_IShellItem, isi
    If (isi Is Nothing) = False Then
        ReDim Preserve resHandles(nRH)
        resHandles(nRH) = AddShellItemToMenu(hMenu, isi, widSL1, j)
        nRH = nRH + 1
        j = j + 1
        Set isi = Nothing
    End If
    SHCreateItemFromParsingName StrPtr("shell:::{26EE0668-A00A-44D7-9371-BEB064C98683}\2\::{A8A91A66-3A7D-4424-8D24-04E180695C7A}"), Nothing, IID_IShellItem, isi
    If (isi Is Nothing) = False Then
        ReDim Preserve resHandles(nRH)
        resHandles(nRH) = AddShellItemToMenu(hMenu, isi, widSL2, j)
        nRH = nRH + 1
        j = j + 1
        Set isi = Nothing
    End If
    'Also add 'Recent Places'. The FOLDERID_Recent entry is 'Recent Items' which has both folders and files; this has just folders.
    SHCreateItemFromParsingName StrPtr("shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"), Nothing, IID_IShellItem, isi
    If (isi Is Nothing) = False Then
        ReDim Preserve resHandles(nRH)
        resHandles(nRH) = AddShellItemToMenu(hMenu, isi, widSL3, j)
        j = j + 1
        Set isi = Nothing
    End If
    
    
    'end folder blocks
    
    GenerateSpecialFolderMenu = hMenu
    Exit Function
    e1:
        DebugAppend "GenerateSpecialFolderMenu - Loop error item " & n
    '    Err.Clear
        Resume gsskp
    
    e2:
        DebugAppend "GenerateSpecialFolderMenu - Error after loop."
    End Function
    
    Private Sub ShowHistoryMenu()
    
    Dim hMenu As LongPtr
    Dim PT As POINT
    Dim idCmd As Long
    Dim i As Long, j As Long, k As Long
    Dim siHst As IShellItem
    Dim siFB As IShellItem
    Dim nStart As Long, nEnd As Long, nOff As Long
    Dim hBmpRes() As LongPtr, nBM As Long
    ReDim hBmpRes(0)
    On Error GoTo e0
    
    If (UBound(sHistory) + 1) > mMaxHist Then
        nStart = nHistIdx - (mMaxHist / 2)
        nEnd = nHistIdx + (mMaxHist / 2)
        If nStart < 0 Then nStart = 0
        If nEnd > UBound(sHistory) Then nEnd = UBound(sHistory)
        If nEnd - nStart < mMaxHist Then
            nOff = mMaxHist - (nEnd - nStart)
            If nStart > 0 Then
                nStart = nStart - nOff
            ElseIf nEnd < UBound(sHistory) Then
                nEnd = nEnd + nOff
            End If
        End If
        If nStart < 0 Then nStart = 0
        If nEnd > UBound(sHistory) Then nEnd = UBound(sHistory)
    Else
        nStart = 0
        nEnd = UBound(sHistory)
    End If
    
    hMenu = CreatePopupMenu()
    
        If ((UBound(sHistory) > 0) Or ((UBound(sHistory) = 0) And (sHistory(0) <> ""))) Then
            For i = nStart To nEnd
                If sHistory(i) = "0" Then
                    SHGetKnownFolderItem FOLDERID_Desktop, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siHst
                Else
                    SHCreateItemFromParsingName StrPtr(sHistory(i)), Nothing, IID_IShellItem, siHst
                    If siHst Is Nothing Then
                        'try to scan pidl recs and create from that
                        For k = 0 To UBound(uPidlStore)
                            If uPidlStore(k).sPath = sHistory(i) Then
                                SHCreateItemFromIDList uPidlStore(k).pidlFQ, IID_IShellItem, siHst
                                Exit For
                            End If
                        Next k
                    End If
                End If
                If (siHst Is Nothing) = False Then
                    ReDim Preserve hBmpRes(nBM)
                    hBmpRes(nBM) = AddShellItemToMenu(hMenu, siHst, widHisMnBase + i, j, IIf(i = nHistIdx, MFS_DEFAULT, -1&))
                    nBM = nBM + 1
                    j = j + 1
                End If
            Next i
        End If
    
    
    
    Call GetCursorPos(PT)
    Dim hPar As LongPtr
    If hLVS = 0& Then
        hPar = UserControl.hWnd
    Else
        hPar = hLVS
    End If
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hPar, 0)
    If idCmd Then
        Dim lIdx As Long
        Dim lItem As Long, lInd As Long
        lIdx = idCmd - widHisMnBase
        If lIdx <> nHistIdx Then 'check to make sure it's different than current dir
            bSuppress = True
            nHistIdx = lIdx
            If nHistIdx = 0 Then
                EnableWindow hStdBackButton, 0&
                pvDrawBack NAV_BB_DISABLED
                bBackEnable = False
            End If
            If nHistIdx = UBound(sHistory) Then
                bEnableFwd = False
                EnableWindow hStdFwdButton, 0&
                pvDrawFwd NAV_FB_DISABLED
            End If
            lItem = GetItemIndex(sHistory(lIdx), lInd)
            Call SendMessage(hCombo, CB_SETCURSEL, lItem, ByVal 0&)
            bHistoryOp = True
            If Left$(sHistory(nHistIdx), 3) = "::{" Then
                'Virtual locations can be problematic on Win10, so create fallback from the pidl store
                For i = 0 To UBound(uPidlStore)
                    DebugAppend (uPidlStore(i).sPath)
                    If sHistory(nHistIdx) = uPidlStore(i).sPath Then
                        SHCreateItemFromIDList uPidlStore(i).pidlFQ, IID_IShellItem, siFB
                        LVLoadFolder sHistory(nHistIdx), , True, siFB
                        Exit For
                    End If
                Next i
                If siFB Is Nothing Then
                    DebugAppend "Failed to load virtual location pidl for history nav fallback."
                End If
            Else
                LVLoadFolder sHistory(nHistIdx)
            End If
            If (nHistIdx > 0) Then
                EnableWindow hStdBackButton, 1&
                pvDrawBack NAV_BB_NORMAL
                bBackEnable = True
            End If
            If ((nHistIdx < UBound(sHistory))) Then
                EnableWindow hStdFwdButton, 1&
                pvDrawFwd NAV_FB_NORMAL
                bEnableFwd = True
            End If
            bHistoryOp = False
            bSuppress = False
        End If
    End If
    
    DestroyMenu hMenu
    For i = 0 To UBound(hBmpRes)
        If hBmpRes(i) Then DeleteObject hBmpRes(i)
    Next i
    Exit Sub
    
    e0:
        DebugAppend "ShowHistoryMenu.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
        
    
    End Sub
    
    Private Sub FreeKnownFolderDefinitionFields(pKFD As KNOWNFOLDER_DEFINITION)
    Call CoTaskMemFree(pKFD.pszName)
    Call CoTaskMemFree(pKFD.pszDescription)
    Call CoTaskMemFree(pKFD.pszRelativePath)
    Call CoTaskMemFree(pKFD.pszParsingName)
    Call CoTaskMemFree(pKFD.pszTooltip)
    Call CoTaskMemFree(pKFD.pszLocalizedName)
    Call CoTaskMemFree(pKFD.pszIcon)
    Call CoTaskMemFree(pKFD.pszSecurity)
    End Sub
    
    Private Function AddShellItemToMenu(hMenu As LongPtr, psi As IShellItem, id As Long, nPos As Long, Optional dwState As ucsb_MF_State = -1&) As LongPtr
    Dim lpCap As LongPtr, sCap As String
    Dim mii As MENUITEMINFOW
    Dim hIcon As LongPtr
    Dim isiif As IShellItemImageFactory
    If (psi Is Nothing) Then Exit Function
    
    psi.GetDisplayName SIGDN_NORMALDISPLAY, lpCap
    If lpCap Then
        sCap = LPWSTRtoStr(lpCap)
        Set isiif = psi
        Dim cxy As LongLong
        Dim sztmp As SIZE
        sztmp.cx = 16 * m_ScaleX: sztmp.cy = 16 * m_FontScaleCXY
        CopyMemory cxy, sztmp, 8
        isiif.GetImage cxy, SIIGBF_ICONONLY, hIcon
        With mii
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_BITMAP
            .wID = id
            .cch = Len(sCap)
            .dwTypeData = StrPtr(sCap)
            .hbmpItem = hIcon
            If dwState > (-1&) Then
                .fMask = .fMask Or MIIM_STATE
                .fState = dwState
            End If
            Call InsertMenuItemW(hMenu, nPos, True, mii)
        End With
        Set isiif = Nothing
        AddShellItemToMenu = hIcon
    End If
    End Function
     
    Private Sub fraPreview_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles fraPreview.MouseUp
    If mPvPaneNoRS = False Then
        If Button = 2 Then
            PvLockMenu
        End If
    End If
    End Sub
    
    Private Sub PvLockMenu()
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
     
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        .wID = widLockPV
        .dwTypeData = StrPtr(mn_sLW)
        .cch = Len(mn_sLW)
        .fState = IIf(bPvLockCX, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 0, True, mii)
    End With
    Call GetCursorPos(PT)
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hLVS, 0)
    If idCmd Then
        Select Case idCmd
            Case widLockPV
                If bPvLockCX Then
                    bPvLockCX = False
                    pbPreviewSizer.Visible = True
                    pbPreviewSizer.Top = fraPreview.Top + 5
                    pbPreviewSizer.Height = fraPreview.Height - 10
                    pbPreviewSizer.Left = fraPreview.Left - 2
                    SetWindowPos pbPreviewSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
                Else
                    bPvLockCX = True
                    pbPreviewSizer.Visible = False
                End If
        End Select
    End If
    Call DestroyMenu(hMenu)
    End Sub
    
    Private Sub DtLockMenu()
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
    
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        .wID = widLockDT
        .dwTypeData = StrPtr(mn_sLH)
        .cch = Len(mn_sLH)
        .fState = IIf(bDtLockCY, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 0, True, mii)
    End With
    Call GetCursorPos(PT)
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hLVS, 0)
    If idCmd Then
        Select Case idCmd
            Case widLockDT
                If bDtLockCY Then
                    bDtLockCY = False
                    pbDetailSizer.Visible = True
                    pbDetailSizer.Top = pbDetailPane.Top
                    pbDetailSizer.Width = pbDetailPane.Width - 10
                    SetWindowPos pbDetailSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
                Else
                    bDtLockCY = True
                    pbDetailSizer.Visible = False
                End If
        End Select
    End If
    Call DestroyMenu(hMenu)
    End Sub
    
    Private Sub SetSrchFtrIcons()
    Dim pKFM As KnownFolderManager
    Dim pkf As IKnownFolder
    Set pKFM = New KnownFolderManager
    Dim psi As IShellItem
    Dim pIcon As IShellIcon
    Dim pidl As LongPtr
    Dim upi As IParentAndItem
    Dim pidl1 As LongPtr, pidl2 As LongPtr
    Dim psf As IShellFolder
    
    pKFM.GetFolder FOLDERID_Libraries, pkf
    If (pkf Is Nothing) = False Then
        pkf.GetIDList KF_FLAG_DEFAULT, pidl
        If pidl Then
            nSearchFtrIcon1 = GetFileIconIndexPIDL(pidl, SHGFI_SMALLICON)
        End If
    End If
    CoTaskMemFree pidl
    Set pkf = Nothing
    
    pKFM.GetFolder FOLDERID_ComputerFolder, pkf
    If (pkf Is Nothing) = False Then
        pkf.GetIDList KF_FLAG_DEFAULT, pidl
        If pidl Then
            nSearchFtrIcon2 = GetFileIconIndexPIDL(pidl, SHGFI_SMALLICON)
        End If
    End If
    CoTaskMemFree pidl
    Set pkf = Nothing
    
    pKFM.GetFolder FOLDERID_Downloads, pkf
    If (pkf Is Nothing) = False Then
        pkf.GetIDList KF_FLAG_DEFAULT, pidl
        If pidl Then
            nSearchFtrIcon3 = GetFileIconIndexPIDL(pidl, SHGFI_SMALLICON)
        End If
    End If
    CoTaskMemFree pidl
    Set pkf = Nothing
    
    pKFM.GetFolder FOLDERID_SavedSearches, pkf
    If (pkf Is Nothing) = False Then
        pkf.GetIDList KF_FLAG_DEFAULT, pidl
        If pidl Then
            nSearchFtrIcon5 = GetFileIconIndexPIDL(pidl, SHGFI_SMALLICON)
        End If
    End If
    CoTaskMemFree pidl
    Set pkf = Nothing
    
    SHCreateItemFromParsingName StrPtr("shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"), Nothing, IID_IShellItem, psi
    If (psi Is Nothing) = False Then
        Set upi = psi
        upi.GetParentAndItem pidl1, psf, pidl2
        pidl = ILCombine(pidl1, pidl2)
        If pidl Then
            nSearchFtrIcon4 = GetFileIconIndexPIDL(pidl, SHGFI_SMALLICON)
        End If
        CoTaskMemFree pidl
    End If
    End Sub
    
    Private Sub FooterAddSearchDone()
    Dim i As Long
    Dim nIcon As Long
    If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then Exit Sub 'Perhaps at some point, add a check and/or custom locations that are for sure in the root
                                                                         'But in the mean time, don't enable a way to circumvent root locks
    
    If (pLVF Is Nothing) = False Then
        pLVF.RemoveAllButtons
        Set pLVF = Nothing
    End If
    
    Call SendMessage(hLVS, LVM_SETIMAGELIST, LVSIL_FOOTER, ByVal ObjPtr(imlSys16))
    Call SendMessage(hLVS, LVM_QUERYINTERFACE, VarPtr(IID_IListViewFooter), pLVF)
    If (pLVF Is Nothing) = False Then
        SetSrchFtrIcons
        With pLVF
            .SetIntroText StrPtr(sSearchFtrHdr)
            .InsertButton 0&, StrPtr(sSearchFooter5), StrPtr(Left$(sSearchFooter5, 1&) & "..."), nSearchFtrIcon5, nSearchFooter5
            .InsertButton 0&, StrPtr(mRplDisp), StrPtr(Left$(mRplDisp, 1&) & "..."), nSearchFtrIcon4, nSearchFooter4
            .InsertButton 0&, StrPtr(mDlDisp), StrPtr(Left$(mDlDisp, 1&) & "..."), nSearchFtrIcon3, nSearchFooter3
            .InsertButton 0&, StrPtr(mCompRtDisp), StrPtr(Left$(mCompRtDisp, 1&) & "..."), nSearchFtrIcon2, nSearchFooter2
            .InsertButton 0&, StrPtr(mLibRootDisp), StrPtr(Left$(mLibRootDisp, 1&) & "..."), nSearchFtrIcon1, nSearchFooter1
            .Show Me
        End With
    End If
            
    End Sub
    
    Public Sub FooterCreate(ByVal sLabelText As String, hImageList As LongPtr, tButtonCaps() As String, tButtonIcons As Variant, tButtonLPs() As Long)
    Dim i As Long
    Dim nIcon As Long
    Dim hImg As LongPtr
    Dim ic() As Long
    
    If (pLVF Is Nothing) = False Then Exit Sub
    
    ftCache_LblText = sLabelText
    ftCache_himl = hImageList
    ftCache_BtnCaps = tButtonCaps
    ftCache_BtnIcon = tButtonIcons
    ftCache_BtnLp = tButtonLPs
    bFooterDoReload = True
    
    If hImageList Then
        SendMessage hLVS, LVM_SETIMAGELIST, LVSIL_FOOTER, ByVal hImageList
        
    Else
        'Create from resource ids
        If himlFooter Then ImageList_Destroy himlFooter
        himlFooter = ImageList_Create(16&, 16&, ILC_COLOR32, 1&, 1&)
        ReDim ic(UBound(tButtonCaps))
            For i = 0 To UBound(tButtonCaps)
                hImg = ResIconTohIcon(CStr(tButtonIcons(i)), 16, 16)
                
                ic(i) = ImageList_AddIcon(himlFooter, hImg)
            Next i
        SendMessage hLVS, LVM_SETIMAGELIST, LVSIL_FOOTER, ByVal himlFooter
    End If
    
    Call SendMessage(hLVS, LVM_QUERYINTERFACE, VarPtr(IID_IListViewFooter), pLVF)
    If (pLVF Is Nothing) = False Then
        With pLVF
            .SetIntroText StrPtr(sLabelText)
            For i = 0 To UBound(tButtonCaps)
    
                If himlFooter = 0& Then
                    nIcon = CLng(tButtonIcons(i))
                Else
                    nIcon = ic(i)
                  End If
                .InsertButton i, StrPtr(tButtonCaps(i)), StrPtr(Left$(tButtonCaps(i), 1&) & "..."), nIcon, tButtonLPs(i)
            Next i
            nFooterBtn = i
            .Show Me
        End With
    End If
    End Sub
    
    Public Sub FooterAddButton(sText As String, nIcon As Long, lParam As Long, Optional sAltText As String = "", Optional lInsertAt As Long = -1)
    If (pLVF Is Nothing) Then Exit Sub
    Dim sAlt As String
    Dim nPos As Long
    
    If sAltText = "" Then
        sAlt = Left$(sText, 1&) & "..."
    Else
        sAlt = sAltText
    End If
    nFooterBtn = nFooterBtn + 1
    If lInsertAt = -1 Then
        nPos = nFooterBtn
    Else
        nPos = lInsertAt
    End If
    pLVF.InsertButton nPos, StrPtr(sText), StrPtr(sAlt), nIcon, lParam
    ReDim Preserve ftCache_BtnCaps(UBound(ftCache_BtnCaps) + 1)
    ftCache_BtnCaps(UBound(ftCache_BtnCaps)) = sText
    ReDim Preserve ftCache_BtnLp(UBound(ftCache_BtnLp) + 1)
    ftCache_BtnLp(UBound(ftCache_BtnLp)) = lParam
    On Error GoTo e1
    ReDim Preserve ftCache_BtnIcon(UBound(ftCache_BtnIcon) + 1)
    ftCache_BtnIcon(UBound(ftCache_BtnIcon)) = nIcon
    e1:
    Exit Sub
    e0:
    DebugAppend "FooterAddButton.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Sub
    
    Public Sub FooterClearButtons()
    If (pLVF Is Nothing) Then Exit Sub
    pLVF.RemoveAllButtons
    End Sub
    
    Public Sub FooterRemove()
    If (pLVF Is Nothing) Then Exit Sub
    DebugAppend "RemoveFooter::Entry"
    pLVF.RemoveAllButtons
    DebugAppend "RemoveFooter::RemButtons"
    Set pLVF = Nothing
    ImageList_Destroy himlFooter
    SendMessage hLVS, LVM_SETIMAGELIST, LVSIL_FOOTER, ByVal 0&
    DebugAppend "RemoveFooter::SetToNothing"
    
    End Sub
    
    Private Function GetSearchLabelForArray(psia As IShellItemArray, Optional nMaxMembers As Long = 3&) As String
    'Instead of just 'Custom...' for all repeat in custom location searches, generate something more unique
    On Error GoTo e0
    Dim i As Long
    Dim lCt As Long
    Dim idx As Long
    Dim nTo As Long
    Dim siChild As IShellItem
    Dim lpn As LongPtr, szn As String
    Dim sOut As String
    nTo = nMaxMembers - 1
    
    psia.GetCount lCt
    If lCt < nMaxMembers Then nTo = lCt - 1
    
    For i = 0 To nTo
        psia.GetItemAt i, siChild
        If (siChild Is Nothing) = False Then
            siChild.GetDisplayName SIGDN_NORMALDISPLAY, lpn
            szn = LPWSTRtoStr(lpn)
            If (szn <> "") And (szn <> vbNullChar) Then
                sOut = sOut & szn & ", "
            End If
            Set siChild = Nothing
            lpn = 0: szn = ""
        End If
    Next i
    If lCt > nMaxMembers Then
        sOut = sOut & "..."
    Else
        sOut = Left$(sOut, Len(sOut) - 2) 'Trim trailing comma
    End If
    GetSearchLabelForArray = sOut
    
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.GetSearchLabelForArray->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function

    Private Sub SetWaitCursor()
    m_hCurBusy = LoadCursor(0&, IDC_APPSTARTING)
    m_hCurPrev = SetCursor(m_hCurBusy)
    End Sub
    Private Sub ClearWaitCursor()
    SetCursor m_hCurPrev
    End Sub
    
    Private Sub LVDT_QueryDragOverData(in_ItemIndex As LongPtr, in_fIsGroup As Boolean, out_FullPath As String, out_Invalid As Boolean)
    If in_fIsGroup Then
        out_FullPath = m_sCurPath 'GroupGetPathForFolder(in_ItemIndex)
    Else
        Dim lp As LongPtr
    '    If gOwnerData Then
    '        lp = in_ItemIndex
    '    Else
            lp = GetLVItemlParam(hLVS, CLng(in_ItemIndex))
    '    End If
        out_FullPath = LVEntries(lp).sFullPath
    End If
    End Sub
    
    Private Sub LVDT_QueryDragOverItem(in_ptX As Long, in_ptY As Long, in_PrevIndex As LongPtr, out_NewIndex As LongPtr, out_fGroup As Boolean)
    Dim PT As POINT
    PT.x = in_ptX
    PT.y = in_ptY
    out_NewIndex = LVDragOverFolder(hLVS, PT, in_PrevIndex, out_fGroup)
    If in_PrevIndex <> out_NewIndex Then DebugAppend "LVDT_QDOI change::prev=" & in_PrevIndex & ",cur=" & out_NewIndex
    End Sub
    
    Private Sub LVDT_QueryDragOverTip(in_ItemIndex As Long, in_fIsGroup As Boolean, in_CurFolder As String, inout_CurEffect As DROPEFFECTS, out_DoDefault As Boolean, out_DropTipMsg As String, out_DropTipInsert As String, out_DropTipImage As DROPIMAGETYPE)
    'If LVDT.IsFormatAvailable(CFSTR_FILECONTENTS) Then
    '    If in_CurFolder <> "" Then
    '        Debug.Print "set tip " & in_CurFolder
    '        out_DropTipMsg = "Save to %1"
    '        out_DropTipInsert = "$CD"
    '        out_DropTipImage = DROPIMAGE_LABEL
    '    Else
    '        out_DoDefault = True
    '    End If
    'Else
        out_DoDefault = True
    'End If
    End Sub
    
    Private Function LVDragOverFolder(hWnd As LongPtr, ppt As POINT, lPrevItem As LongPtr, IndexIsGroup As Boolean) As LongPtr
    'called in response to the DragOver event, checks if it's a folder being dragged
    'over, and if so selects it and returns the full path
    
    'CSBmk <LVDragOverFolderEx_Bkm>
    Dim lpOld As LongPtr
    Dim LVHTI As LVHITTESTINFO
    Dim lvst As LVHITTESTINFO
    Dim lp As LongPtr
    
    Call ScreenToClient(hWnd, ppt)
    lvst.PT.x = ppt.x
    lvst.PT.y = ppt.y
    LVHTI.PT.x = ppt.x
    LVHTI.PT.y = ppt.y
    
    ListView_HitTestEx hWnd, LVHTI
    ListView_SubItemHitTest hWnd, lvst
    ''Debug.Print "htflags/" & ppt.X & "=" & LVHTI.Flags
            lp = GetLVItemlParam(hWnd, LVHTI.iItem)
    '    DebugAppend "dragover " & LVEntries(lp).sName & ",sub=" & lvst.iSubitem
    If (LVHTI.Flags And LVHT_ONITEM) Then
    '    If gOwnerData Then
    '        lp = LVHTI.iItem
    '    Else
    '    End If
        If LVHTI.iItem <> lPrevItem Then
            If SupportsDropByIdx(lp) = 1& Then
              If (ListView_GetItemState(hWnd, LVHTI.iItem, LVIS_FOCUSED) = 0) Then
                  ListView_SetItemState hWnd, LVHTI.iItem, LVIS_FOCUSED Or LVIS_DROPHILITED, LVIS_FOCUSED Or LVIS_DROPHILITED
              End If
              LVDragOverFolder = LVHTI.iItem
              lvDragOverIdx = LVHTI.iItem
              lvDragOverLP = lp
            Else
                LVDragOverFolder = -1&
                lvDragOverIdx = -1&
                lvDragOverLP = -1&
            End If
            If (lPrevItem <> -1&) And (lPrevItem <> LVHTI.iItem) Then
                If ListView_GetItemState(hWnd, CLng(lPrevItem), LVIS_DROPHILITED) Then
                    lpOld = GetLVItemlParam(hWnd, CLng(lPrevItem))
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_FOCUSED
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_DROPHILITED
                End If
    '            LVDragOverFolder = lPrevItem
            End If
        Else
            'is on folder item that is not previous folder item; deselect old item if not null
            LVDragOverFolder = LVHTI.iItem
        End If
    ElseIf (LVHTI.Flags And LVHT_EX_GROUP) Then
            IndexIsGroup = False
            LVDragOverFolder = -1&
        If (lPrevItem <> -1&) Then
                If ListView_GetItemState(hWnd, CLng(lPrevItem), LVIS_DROPHILITED) Then
                    lpOld = GetLVItemlParam(hWnd, CLng(lPrevItem))
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_FOCUSED
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_DROPHILITED
                End If
        End If
        lvDragOverIdx = -1& 'cleared
        lvDragOverLP = -1&
    Else
        'not on item; if there was a previous one, clear it
        If (lPrevItem <> -1&) Then
                If ListView_GetItemState(hWnd, CLng(lPrevItem), LVIS_DROPHILITED) Then
                    lpOld = GetLVItemlParam(hWnd, CLng(lPrevItem))
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_FOCUSED
                    ListView_SetItemState hWnd, CLng(lPrevItem), 0&, LVIS_DROPHILITED
                End If
        End If
        LVDragOverFolder = -1&
        lvDragOverIdx = -1& 'cleared
        lvDragOverLP = -1&
    End If
            
    End Function
    
    Private Function PathGetDisp(ByVal sPath As String) As String
    If Right$(sPath, 1) = "\" Then
        sPath = Left$(sPath, Len(sPath) - 1)
    End If
    Dim psi As IShellItem
    Dim lp As LongPtr
    Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, psi)
    
    If (psi Is Nothing) = False Then
        psi.GetDisplayName SIGDN_NORMALDISPLAY, lp
        PathGetDisp = LPWSTRtoStr(lp)
    End If
    End Function
    
    Private Function DataObjSupportsFormat(pIDO As IDataObject, lFmt As Long, Optional ty As TYMED = TYMED_HGLOBAL, Optional lIndex As Long = -1, Optional dva As DVASPECT = DVASPECT_CONTENT, Optional lDev As LongPtr = 0) As Boolean
    Dim tFMT As FORMATETC
    With tFMT
        .cfFormat = lFmt
        .TYMED = ty
        .dwAspect = dva
        .lIndex = lIndex
        .pDVTARGETDEVICE = lDev
    End With
   
    If pIDO.QueryGetData(tFMT) = S_OK Then
        DataObjSupportsFormat = True
    End If
    End Function
    
    Private Sub SetPreferredEffect(ido As IDataObject, nVal As Long)
    Dim fmt As FORMATETC
    Dim sTg As STGMEDIUM
    Dim tDD As DROPDESCRIPTION
    Dim hGlobal As LongPtr, lpGlobal As LongPtr
    Dim i As Long
    DebugAppend "adddil.enter"
    
    hGlobal = GlobalAlloc(GHND, LenB(nVal))
    If hGlobal Then
        lpGlobal = GlobalLock(hGlobal)
        Call CopyMemory(ByVal lpGlobal, nVal, LenB(nVal))
        DebugAppend "adddil.copymem"
        Call GlobalUnlock(hGlobal)
        sTg.TYMED = TYMED_HGLOBAL
        sTg.data = lpGlobal
        fmt.cfFormat = CF_PREFERREDDROPEFFECT
        fmt.dwAspect = DVASPECT_CONTENT
        fmt.lIndex = -1
        fmt.TYMED = TYMED_HGLOBAL
        ido.SetData fmt, sTg, 1
    Else
        DebugAppend "failed to get hglobal"
    End If
    End Sub
    
    Private Function AddDropDescription(ido As IDataObject, nType As DROPIMAGETYPE, sMsg As String, sIns As String) As Boolean
    'If bFlagBlockDD Then Exit Function
    If (ido Is Nothing) Then
        DebugAppend "AddDropDescription::No data object, aborting"
        Exit Function
    End If
    Dim fmt As FORMATETC
    Dim sTg As STGMEDIUM
    Dim tDD As DROPDESCRIPTION
    Dim iTmp1() As Integer
    Dim iTmp2() As Integer
    Dim hGlobal As LongPtr, lpGlobal As LongPtr
    Dim i As Long
    On Error GoTo e0
    AddDropDescription = True
    DebugAppend "cDropTarget.AddDropDescription.Entry" ', 9
    Str2WCHAR sMsg, iTmp1
    Str2WCHAR sIns, iTmp2
    
    For i = 0 To UBound(iTmp1)
        tDD.szMessage(i) = iTmp1(i)
    Next i
    
    For i = 0 To UBound(iTmp2)
        tDD.szInsert(i) = iTmp2(i)
    Next i
    tDD.type = nType
    
    hGlobal = GlobalAlloc(GHND, LenB(tDD))
    If hGlobal Then
        lpGlobal = GlobalLock(hGlobal)
        Call CopyMemory(ByVal lpGlobal, tDD, LenB(tDD))
        Call GlobalUnlock(hGlobal)
        
        sTg.TYMED = TYMED_HGLOBAL
        sTg.data = lpGlobal
         
        
        fmt.cfFormat = CF_DROPDESCRIPTION
        fmt.dwAspect = DVASPECT_CONTENT
        fmt.lIndex = -1
        fmt.TYMED = TYMED_HGLOBAL
            
        ido.SetData fmt, sTg, 1
    End If
    Exit Function
    e0:
        DebugAppend "AddDropDescription->" & Err.Description & " (" & Err.Number & ")"
        AddDropDescription = False
    End Function
    
    Private Sub Str2WCHAR(sz As String, iOut() As Integer)
    Dim i As Long
    ReDim iOut(255)
    For i = 1 To Len(sz)
        iOut(i - 1) = AscW(Mid$(sz, i, 1))
    Next i
    
    End Sub
    
    Private Function WCHARtoSTR(aCh() As Integer) As String
    Dim i As Long
    Dim sz As String
    For i = LBound(aCh) To UBound(aCh)
        If aCh(i) <> 0 Then
            sz = sz & ChrW$(CLng(aCh(i)))
        End If
    Next
    WCHARtoSTR = sz
    End Function
    Private Function WCHARbtarToSTR(aCh() As Byte) As String
    Dim i As Long
    Dim sz As String
    For i = LBound(aCh) To UBound(aCh)
        If aCh(i) <> 0 Then
            sz = sz & ChrW$(CLng(aCh(i)))
        End If
    Next
    WCHARbtarToSTR = sz
    End Function
    
    Public Function FilePathFromPos(lPos As Long) As String
    Dim lp As LongPtr
    lp = GetLVItemlParam(hLVS, lPos)
    FilePathFromPos = LVEntries(lp).sFullPath
    End Function
    
    Public Function FilesChecked() As String()
    'Returns a list of checked files
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = False Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    ReDim Preserve sOut(nOut)
                    sOut(nOut) = LVEntries(i).sName
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FilesChecked = sOut
    End Function
    
    Public Function FilesCheckedCount() As Long
    Dim i As Long
    Dim nOut As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = False Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FilesCheckedCount = nOut
    
    End Function
    Public Function FilesCheckedFull() As String()
    'Returns a list of checked files
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = False Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    ReDim Preserve sOut(nOut)
                    sOut(nOut) = LVEntries(i).sFullPath
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FilesCheckedFull = sOut
    End Function
    
    Public Function FilesSelected() As String()
    FilesSelected = sSelectedFilesOnly
    End Function
    Public Function FilesSelectedFull() As String()
    FilesSelectedFull = sSelectedFilesOnlyFull
    End Function
    Public Function FilesSelectedCount() As Long
    If UBound(sSelectedFilesOnly) = 0 Then
        If sSelectedFilesOnly(0) = "" Then
            FilesSelectedCount = 0
        Else
            FilesSelectedCount = 1
        End If
    Else
        FilesSelectedCount = UBound(sSelectedFilesOnly)
    End If
    End Function
    Public Function FoldersSelected() As String()
    FoldersSelected = sSelectedFoldersOnly
    End Function
    Public Function FoldersSelectedFull() As String()
    FoldersSelectedFull = sSelectedFoldersOnlyFull
    End Function
    Public Function FoldersSelectedCount() As Long
    If UBound(sSelectedFoldersOnly) = 0 Then
        If sSelectedFoldersOnly(0) = "" Then
            FoldersSelectedCount = 0
        Else
            FoldersSelectedCount = 1
        End If
    Else
        FoldersSelectedCount = UBound(sSelectedFoldersOnly)
    End If
    End Function
    
    Public Function FoldersChecked() As String()
    'Returns a list of checked folders
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = True Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    ReDim Preserve sOut(nOut)
                    sOut(nOut) = LVEntries(i).sName
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FoldersChecked = sOut
    End Function
    
    Public Function FoldersCheckedFull() As String()
    'Returns a list of checked folders
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = True Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    ReDim Preserve sOut(nOut)
                    sOut(nOut) = LVEntries(i).sFullPath
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FoldersCheckedFull = sOut
    End Function
    
    Public Function FoldersCheckedCount() As Long
    Dim i As Long
    Dim nOut As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = True Then
            If LVEntries(i).bDeleted = False Then
                If LVEntries(i).fChecked Then
                    nOut = nOut + 1
                End If
            End If
        End If
    Next i
    FoldersCheckedCount = nOut
    End Function
    
    Public Function FileSetCheck(ByVal sName As String, ByVal fCheck As Long) As Long
    Dim i As Long
    'Dim cnt As Long
    'Dim lp As Long
    Dim idx As Long
    'cnt = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    
    For i = 0 To UBound(LVEntries) '(cnt - 1)
    '    lp = GetLVItemlParam(hLVS, i)
        If LVEntries(i).bDeleted = False Then
            If LCase$(LVEntries(i).sName) = LCase$(sName) Then
                If LVEntries(i).fChecked <> fCheck Then
                    idx = CLng(SendMessage(hLVS, LVM_MAPIDTOINDEX, LVEntries(i).dwID, ByVal 0&))
                    ListView_SetCheckState hLVS, idx, fCheck
                End If
                FileSetCheck = S_OK
                Exit Function
            End If
        End If
    Next i
    FileSetCheck = -1
            
    End Function
    
    Public Function FileGetCheck(ByVal sName As String) As Long
    Dim i As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).sName = sName Then
                FileGetCheck = LVEntries(i).fChecked
                Exit Function
            End If
        End If
    Next i
    End Function
    
    Public Function FileItemFromPos(lPos As Long) As IShellItem
    Dim llp As LongPtr
    Dim isi As IShellItem
    Dim pidlFQItem As LongPtr
    
    llp = GetLVItemlParam(hLVS, lPos)
    SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem, isi
    If (isi Is Nothing) Then
        DebugAppend "FileItemFromPos->Failed to get isi"
        pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
        SHCreateItemFromIDList pidlFQItem, IID_IShellItem, isi
        If (isi Is Nothing) Then
            DebugAppend "FileItemFromPos->Alternate isi creation failed"
        End If
        If pidlFQItem Then CoTaskMemFree pidlFQItem
    End If
    If (isi Is Nothing) = False Then
        Set FileItemFromPos = isi
    End If
    End Function
    
    Public Function FileCount() As Long
    FileCount = nCurFiles
    End Function
    Public Function FolderCount() As Long
    FolderCount = nCurFolders
    End Function
    
    Public Function Files(Optional sFilter As String = "*", Optional bAbsolute As Boolean = False) As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = False Then
            If InStr(sFilter, ";") Then
                lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
            Else
                lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
            End If
            If lPMS Then
                ReDim Preserve sOut(j)
                If bAbsolute Then
                    sOut(j) = LVEntries(i).sNameFull 'Absolute name; like .lnk on links, GUIDs for non-file shell objects
                Else
                    sOut(j) = LVEntries(i).sName
                End If
                j = j + 1
            End If
        End If
    Next i
    Files = sOut
                
    End Function
    
    Public Function ItemCount() As Long
    ItemCount = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    End Function
    
    Public Function Items(Optional sFilter As String = "*", Optional bAbsolute As Boolean = False) As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If InStr(sFilter, ";") Then
            lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
        Else
            lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
        End If
        If lPMS Then
            ReDim Preserve sOut(j)
            If bAbsolute Then
                sOut(j) = LVEntries(i).sNameFull 'Absolute name; like .lnk on links, GUIDs for non-file shell objects
            Else
                sOut(j) = LVEntries(i).sName
            End If
            j = j + 1
        End If
    Next i
    Items = sOut
                
    End Function
    
    Public Function ItemsFullParsing(Optional sFilter As String = "*") As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If InStr(sFilter, ";") Then
            lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
        Else
            lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
        End If
        If lPMS Then
            ReDim Preserve sOut(j)
            sOut(j) = LVEntries(i).sFullPath 'Absolute name; like .lnk on links, GUIDs for non-file shell objects
            j = j + 1
        End If
    Next i
    ItemsFullParsing = sOut
                
    End Function
    
    Public Function ItemsSelected(Optional bAbsolute As Boolean = False) As String()
    If bAbsolute Then
        ItemsSelected = sSelectedFileNamesF
    Else
        ItemsSelected = sSelectedFileNames
    End If
    End Function
    
    Public Function ItemsSelectedFull() As String()
    ItemsSelectedFull = sSelectedFiles
    End Function
    
    Public Function ItemsSelectedCount() As Long
    If UBound(sSelectedFiles) = 0 Then
        If sSelectedFiles(0) = "" Then
            ItemsSelectedCount = 0
        Else
            ItemsSelectedCount = 1
        End If
    Else
        ItemsSelectedCount = UBound(sSelectedFiles)
    End If
    End Function
    
    Public Function ItemsChecked(Optional bAbsolute As Boolean = False) As String()
    'Returns a list of checked files
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).fChecked Then
                ReDim Preserve sOut(nOut)
                If bAbsolute Then
                    sOut(nOut) = LVEntries(i).sNameFull
                Else
                    sOut(nOut) = LVEntries(i).sName
                End If
                nOut = nOut + 1
            End If
        End If
    Next i
    ItemsChecked = sOut
    End Function
    
    Public Function ItemsCheckedFull() As String()
    'Returns a list of checked files
    Dim i As Long
    Dim sOut() As String, nOut As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).fChecked Then
                ReDim Preserve sOut(nOut)
                sOut(nOut) = LVEntries(i).sFullPath
                nOut = nOut + 1
            End If
        End If
    Next i
    ItemsCheckedFull = sOut
    End Function
    
    Public Function ItemsCheckedCount() As Long
    Dim i As Long
    Dim nOut As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).fChecked Then
                nOut = nOut + 1
            End If
        End If
    Next i
    ItemsCheckedCount = nOut
    End Function
    
    Public Function FilesFullParsing(Optional sFilter As String = "*") As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder = False Then
            If InStr(sFilter, ";") Then
                lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
            Else
                lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
            End If
            If lPMS Then
                ReDim Preserve sOut(j)
                sOut(j) = LVEntries(i).sFullPath
                j = j + 1
            End If
        End If
    Next i
    FilesFullParsing = sOut
                
    End Function
    
    Public Function FileGetProperty(sFile As String, sPropName As String) As String
    'Specify file name or full parsing path and canonical property name
    On Error GoTo e0
    Dim sFull As String
    Dim pkProp As PROPERTYKEY
    Dim pps As IPropertyStore
    Dim lpsz As LongPtr
    Dim ppd As IPropertyDescription
    
    If InStr(sFile, "\") Then
        sFull = sFile
    Else
        Dim i As Long
        For i = 0 To UBound(LVEntries)
            If LVEntries(i).sName = sFile Then
                sFull = LVEntries(i).sFullPath
                Exit For
            End If
        Next i
    End If
    
    PSGetPropertyKeyFromName StrPtr(sPropName), pkProp
    SHGetPropertyStoreFromParsingName StrPtr(sFull), ByVal 0&, GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
    PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
    If ((pps Is Nothing) = False) And ((ppd Is Nothing) = False) Then
        PSFormatPropertyValue ObjPtr(pps), ObjPtr(ppd), PDFF_DEFAULT, lpsz
        SysReAllocString VarPtr(FileGetProperty), lpsz
        CoTaskMemFree lpsz
    End If
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.FileGetProperty->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Public Function FileGetPropertyByPKEY(sFile As String, pkey_varptr As LongPtr) As String
    'Specify file name or full parsing path and canonical property name
    On Error GoTo e0
    Dim sFull As String
    Dim pkProp As PROPERTYKEY
    Dim pps As IPropertyStore
    Dim lpsz As LongPtr
    Dim ppd As IPropertyDescription
    
    If InStr(sFile, "\") Then
        sFull = sFile
    Else
        Dim i As Long
        For i = 0 To UBound(LVEntries)
            If LVEntries(i).sName = sFile Then
                sFull = LVEntries(i).sFullPath
                Exit For
            End If
        Next i
    End If
    
    If pkey_varptr Then
        CopyMemory ByVal VarPtr(pkProp), ByVal pkey_varptr, LenB(pkProp)
    Else
        DebugAppend "FileGetPropertyByPKEY->No pointer for pkey"
        Exit Function
    End If
    
    
    SHGetPropertyStoreFromParsingName StrPtr(sFull), ByVal 0&, GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
    PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
    If ((pps Is Nothing) = False) And ((ppd Is Nothing) = False) Then
        PSFormatPropertyValue ObjPtr(pps), ObjPtr(ppd), PDFF_DEFAULT, lpsz
        SysReAllocString VarPtr(FileGetPropertyByPKEY), lpsz
        CoTaskMemFree lpsz
    End If
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.FileGetPropertyByPKEY->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Public Function Folders(Optional sFilter As String = "*", Optional bAbsolute As Boolean = False) As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder Then
            If InStr(sFilter, ";") Then
                lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
            Else
                lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
            End If
            If lPMS Then
                ReDim Preserve sOut(j)
                If bAbsolute Then
                    sOut(j) = LVEntries(i).sNameFull 'Absolute name; like GUIDs for non-file shell objects
                Else
                    sOut(j) = LVEntries(i).sName
                End If
                j = j + 1
            End If
        End If
    Next i
    Folders = sOut
    End Function
    
    Public Function FoldersFullParsing(Optional sFilter As String = "*") As String()
    Dim sOut() As String
    Dim i As Long
    Dim j As Long
    Dim lPMS As Long
    ReDim sOut(0)
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bFolder Then
            If InStr(sFilter, ";") Then
                lPMS = PathMatchSpecExW(StrPtr(LVEntries(i).sName), StrPtr(sFilter), PMSF_MULTIPLE)
            Else
                lPMS = PathMatchSpecW(StrPtr(LVEntries(i).sName), StrPtr(sFilter))
            End If
            If lPMS Then
                ReDim Preserve sOut(j)
                sOut(j) = LVEntries(i).sFullPath
                j = j + 1
            End If
        End If
    Next i
    FoldersFullParsing = sOut
                
    End Function
    
    Public Sub StartRename()
    If m_AllowRename Then
        Dim iItem As Long
        iItem = ListView_GetSelectedItem(hLVS)
        If iItem <> LVI_NOITEM Then
            SendMessage hLVS, LVM_EDITLABELW, iItem, ByVal 0&
        End If
    End If
    End Sub
    Public Sub SelectedFileSet(sName As String, bSelected As Boolean, Optional bDeselectOthers As Boolean = False, Optional bFocused As Boolean = True, Optional bEnsureVisible As Boolean = True)
    Dim i As Long
    Dim nItm As Long
    nItm = -1
    Dim lp As Long
    Dim lCnt As Long
    
    'lCnt = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    'ListView_SetItemState hLVS, -1, 0&, LVIS_FOCUSED Or LVIS_SELECTED
    
    For i = 0 To UBound(LVEntries) '(lCnt - 1)
    '    lp = GetLVItemlParam(hLVS, i)
        If LVEntries(i).bDeleted = False Then
            If LCase$(LVEntries(i).sName) = LCase$(sName) Then
                nItm = CLng(SendMessage(hLVS, LVM_MAPIDTOINDEX, LVEntries(i).dwID, ByVal 0&))
                Exit For
            End If
        End If
    Next i
    If nItm = -1 Then Exit Sub
    
    If bDeselectOthers Then ListView_SelectNone hLVS
    
    Dim lvi As Long
    If bSelected Then
        lvi = LVIS_SELECTED
        If bFocused Then
            lvi = lvi Or LVIS_FOCUSED
        End If
        ListView_SetItemState hLVS, nItm, lvi, lvi
    Else
        ListView_SetItemState hLVS, nItm, 0&, LVIS_SELECTED
    End If
    
    If bEnsureVisible Then
        SendMessage hLVS, LVM_ENSUREVISIBLE, nItm, ByVal 1&
    End If
    
    End Sub
    Private Sub ShowBalloonTipEx(hWnd As LongPtr, sTitle As String, sText As String, btIcon As ucsb_BalloonTipIconConstants)
    Dim lr As LongPtr
    Dim tEBT As EDITBALLOONTIP
    tEBT.cbStruct = LenB(tEBT)
    tEBT.pszText = StrPtr(sText)
    tEBT.pszTitle = StrPtr(sTitle)
    tEBT.ttiIcon = btIcon
    lr = SendMessageW(hWnd, EM_SHOWBALLOONTIP, 0, tEBT)
    'DebugAppend "ShowBalloonTipEx=" & lR
    End Sub
    
    Private Function IsClipboardValidFileName() As Integer
    Dim sz As String
    sz = GetClipboardTextW()
    'dbg_stringbytes sz
    IsClipboardValidFileName = 1
    
    If sz = vbNullString Then
        DebugAppend "Clip is null"
        IsClipboardValidFileName = -1
    End If
    If Len(sz) > MAX_PATH Then IsClipboardValidFileName = -2
    
    If InStr(sz, "*") Or InStr(sz, "<") Or InStr(sz, ">") Or InStr(sz, "|") Or InStr(sz, Chr$(34)) Or InStr(sz, Chr(&H3F)) Then
        IsClipboardValidFileName = -1
    End If
    
    DebugAppend "ClipCheck=" & IsClipboardValidFileName & "," & InStr(sz, "?")
    
    End Function
    
    Private Function GetClipboardTextW() As String
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim pdo As IDataObject
    Dim tSTG As STGMEDIUM
    Dim tFMT As FORMATETC
    Dim lpText As LongPtr
    
    OleGetClipboard pdo
    If (pdo Is Nothing) Then Exit Function
    
    If DataObjSupportsFormat(pdo, CF_UNICODETEXT) Then
        'This should return True and successfully retrieve the text even if technically
        'the clipboard object actually only contains CF_TEXT.
        DebugAppend "DataObj Get CF_UNICODETEXT"
        
        tFMT.cfFormat = CF_UNICODETEXT
        tFMT.dwAspect = DVASPECT_CONTENT
        tFMT.lIndex = -1
        tFMT.TYMED = TYMED_HGLOBAL
    
        pdo.GetData tFMT, tSTG
        lpText = GlobalLock(tSTG.data)
        GetClipboardTextW = LPWSTRtoStr(lpText, False)
        Call GlobalUnlock(tSTG.data)
        ReleaseStgMedium tSTG
    ElseIf DataObjSupportsFormat(pdo, CF_TEXT) Then 'if there's no unicode chars there might be this only
        tFMT.cfFormat = CF_TEXT
        tFMT.dwAspect = DVASPECT_CONTENT
        tFMT.lIndex = -1
        tFMT.TYMED = TYMED_HGLOBAL
    
        pdo.GetData tFMT, tSTG
        lpText = GlobalLock(tSTG.data)
        GetClipboardTextW = GetStrFromPtrA(lpText)
        DebugAppend "GetClipboardText ANSI fallback=" & GetClipboardTextW
    End If
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.GetClipboardTextW->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function SimpleDialog(sMessage As String, Optional dwBtn As ucsb_TDBUTTONS = TDCBF_OK_BUTTON, Optional sTitle As String, Optional sMainText As String, Optional dwIco As ucsb_TDICONS, Optional hWndOwner As LongPtr, Optional hInst As LongPtr) As ucsb_TDBUTTONS
    Dim dwIcon As Long
    Dim pnButton As Long
        
    Dim pszTitle As LongPtr
    Dim pszMain As LongPtr
    Dim pszContent As LongPtr
    
    If sTitle = "" Then
        sTitle = App.Title
    End If
    pszTitle = StrPtr(sTitle)
    If sMainText <> "" Then pszMain = StrPtr(sMainText)
    If sMessage <> "" Then pszContent = StrPtr(sMessage)
    
    If dwIco Then
       dwIcon = MAKEINTRESOURCE(dwIco)
    End If
    
    Call TaskDialog(hWndOwner, hInst, pszTitle, pszMain, pszContent, dwBtn, dwIcon, pnButton)
        
    SimpleDialog = pnButton
    End Function
    
    Private Function GetStrFromPtrA(lpszA As LongPtr) As String
      Dim sRtn As String
      sRtn = String$(lstrlenA(ByVal lpszA), 0)
      Call lstrcpyA(ByVal sRtn, ByVal lpszA)
      GetStrFromPtrA = sRtn
    End Function
    
    Private Function MAKEINTRESOURCE(ByVal dwVal As Long) As Long
       MAKEINTRESOURCE = &HFFFF& And dwVal
    End Function
    
    Private Function TrimNullW(sData As String) As String
        TrimNullW = Left$(sData, lstrlenW(ByVal StrPtr(sData)))
    End Function
    
    Private Sub lblSrch_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles lblSrch.MouseDown
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbSearch.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    
    Private Sub pbSearch_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbSearch.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbSearch.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    
    Private Sub lblColCap_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles lblColCap.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbColumns.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    
    Private Sub pbColumns_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbColumns.MouseMove
    If Button = 1 Then
        Call ReleaseCapture
        Call SendMessage(pbColumns.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
    End If
    End Sub
    
    Private Function QueryMenuTip(id As Long) As String
    'English-language strings have been relocated to just below User Consts section of this control so everything is in one place
    Select Case id
        Case widViewFirst To widViewLast: QueryMenuTip = sQMT01
        Case widGrpNone: QueryMenuTip = sQMT02
        Case widBaseGrp: QueryMenuTip = sQMT03
        Case widBaseG To (widBaseG + 999): QueryMenuTip = sQMT04
        Case widBaseSort: QueryMenuTip = sQMT05
        Case widBaseS To (widBaseS + 999): QueryMenuTip = sQMT06
        Case widSortAsc: QueryMenuTip = sQMT07
        Case widSortDsc: QueryMenuTip = sQMT08
        Case widNewFldr: QueryMenuTip = sQMT09
        Case widProps: QueryMenuTip = sQMT10
        Case widRefresh: QueryMenuTip = sQMT11
        Case widShowSB: QueryMenuTip = sQMT12
        Case widShowPV: QueryMenuTip = sQMT13
        Case widShowDT: QueryMenuTip = sQMT14
        Case idName To idAcc: QueryMenuTip = sQMT15
        Case idMore: QueryMenuTip = sQMT16
        Case idLockCol: QueryMenuTip = sQMT17
        Case widLockDT: QueryMenuTip = sQMT18
        Case widLockPV: QueryMenuTip = sQMT19
        Case wIDSel: QueryMenuTip = sQMT20
        Case widBkmAdd: QueryMenuTip = sQMT21
        Case widBkmRem: QueryMenuTip = sQMT22
        Case widBkmClr: QueryMenuTip = sQMT23
        Case widBkmLBase To (widBkmLBase + nMaxBookmarks): QueryMenuTip = GetBookmarkTip(id - widBkmLBase)
        Case widBaseSF To (widBaseSF + 99): QueryMenuTip = sQMT24
        Case widSL1, widSL2: QueryMenuTip = sQMT25
        Case widSelAll: QueryMenuTip = sQMT26
        Case widSelInv: QueryMenuTip = sQMT27
        Case widLay: QueryMenuTip = sQMT28
        Case widCtlB: QueryMenuTip = sQMT29
        Case widShowSX, widShowSXA: QueryMenuTip = sQMT30
        Case widNavTree: QueryMenuTip = sQMT31
        Case widCopyPath: QueryMenuTip = sQMT32
        Case widBkPaste: QueryMenuTip = sQMT33
    End Select
    End Function
    
    Private Function GetBookmarkTip(id As Long) As String
    Dim arBook() As String
    Dim sPath As String
    If InStr(m_Bookmarks, "|") Then
        arBook = Split(m_Bookmarks, "|")
        sPath = arBook(id)
    Else
        sPath = m_Bookmarks
    End If
    If sPath = "0" Then
        sPath = mNavToDsk
    End If
    GetBookmarkTip = mNavToStr & sPath
        
    End Function
    
    Private Function ShowShellContextMenu() As Long
    DebugAppend "ShowShellContextMenu.Entry::bBlockLoad=" & bBlockLoad
    If bBlockLoad Then
        If mPlaySnd Then
            If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
        End If
        Exit Function
    End If
    Dim cnt As Long
    cnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    If cnt = 0 Then
        SetFocusAPI UserControl.ContainerHwnd
        SetFocusAPI hLVS
        ShowViewMenu True
        Exit Function
    End If
    If m_EnableShellMenu = False Then Exit Function
    
    'SetFocusAPI UserControl.ContainerHwnd
    'SetFocusAPI hLVS
    
    Dim i As Long
    Dim nFocused As Long, lpFocused As LongPtr
    Dim lp As LongPtr
    Dim apidl() As LongPtr
    Dim cpidl As Long
    Dim cmi As CMINVOKECOMMANDINFO
    Dim PT As POINT
    Dim idCmd As Long
    Dim hMenu As LongPtr
    Dim uFlag As QueryContextMenuFlags
    Dim mii As MENUITEMINFOW
    Dim pidlFQ As LongPtr, pidlPar As LongPtr, sip As IShellItem, upi As IParentAndItem, psfCust As IShellFolder, pidlc As LongPtr
    ReDim apidl(0)
    
    Set pcm = Nothing
    
    nFocused = ListView_GetSelectedItem(hLVS)
    lpFocused = GetLVItemlParam(hLVS, nFocused)
    
    If LVEntries(lpFocused).bIsADS Then
        If mPlaySnd Then
            If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
        End If
        UpdateStatus mStrNoADS
        Exit Function
    End If
    
    If m_sCurPath = "*CUSTOM" Then
        i = nFocused: lp = lpFocused
        pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(lp).sFullPath))
        SHCreateItemFromIDList pidlFQ, IID_IShellItem, sip
        Set upi = sip
        upi.GetParentAndItem pidlPar, psfCust, pidlc
        apidl(0) = pidlc
        cpidl = 1
        psfCust.GetUIObjectOf 0&, cpidl, apidl(0), IID_IContextMenu, 0&, pcm
        Call CoTaskMemFree(pidlFQ)
        Call CoTaskMemFree(pidlPar)
    Else
    
        i = LVI_NOITEM
        Do
            i = CLng(SendMessage(hLVS, LVM_GETNEXTITEM, i, ByVal LVNI_SELECTED))
            If (i <> LVI_NOITEM) Then
                lp = GetLVItemlParam(hLVS, i)
                ReDim Preserve apidl(cpidl)
                apidl(cpidl) = LVEntries(lp).pidlRel
                cpidl = cpidl + 1
                DebugAppend "ContextMenuAddItem " & LVEntries(lp).sName
            End If
        Loop Until (i = LVI_NOITEM)
    End If
        DebugAppend "CPM cpidl=" & cpidl & ",ub=" & UBound(apidl)
    
    If False Then
        'You can replace the ShowViewMenu block above with the shell background menu if you want:
        'WARNING: This currently works very, very poorly. Enable at your own risk.
        Dim psv As IShellView
        psfCur.CreateViewObject hLVS, IID_IShellView, psv
        If (psv Is Nothing) = False Then
            DebugAppend "Got shell view", 20
            psv.SelectItem apidl(0), SVSI_SELECT Or SVSI_FOCUSED
            psv.GetItemObject SVGIO_BACKGROUND, IID_IContextMenu, pcm
            uFlag = CMF_NODEFAULT Or CMF_ITEMMENU
        Else
            DebugAppend "No shell view :("
        End If
    Else
        If (pcm Is Nothing) Then
            psfCur.GetUIObjectOf 0&, cpidl, apidl(0), IID_IContextMenu, 0&, pcm
        End If
    
        uFlag = CMF_NODEFAULT Or CMF_EXPLORE 'Or CMF_OPTIMIZEFORINVOKE Or CMF_INCLUDESTATIC '  Or CMF_EXTENDEDVERBS ' Or CMF_NORMAL Or CMF_ITEMMENU    'Or CMF_DISABLEDVERBSOr CMF_ASYNCVERBSTATE
        If m_AllowRename Then uFlag = uFlag Or CMF_CANRENAME
        
        If mAlwaysShowExtVerbs Then
            uFlag = uFlag Or CMF_EXTENDEDVERBS
        Else
            If (GetKeyState(VK_SHIFT) And &H80) = &H80 Then
                uFlag = uFlag Or CMF_EXTENDEDVERBS
            End If
        End If
    
    End If
    
    If (pcm Is Nothing) = False Then
        Dim pUnk As IUnknownUnrestricted
        hMenu = CreatePopupMenu()
        Set pUnk = pcm
        pUnk.QueryInterface IID_IContextMenu3, ICtxMenu3
        pUnk.QueryInterface IID_IContextMenu2, ICtxMenu2
        If (ICtxMenu3 Is Nothing) = False Then
            DebugAppend "Using IContextMenu3", 20
            ICtxMenu3.QueryContextMenu hMenu, 0&, 1&, &H7FFF, uFlag
        Else
            If (ICtxMenu2 Is Nothing) = False Then
                DebugAppend "Using IContextMenu2", 20
                ICtxMenu2.QueryContextMenu hMenu, 0&, 1&, &H7FFF, uFlag
            Else
                DebugAppend "Using IContextMenu", 20
                pcm.QueryContextMenu hMenu, 0&, 1&, &H7FFF, uFlag
            End If
        End If
    '    dbg_EnumVerbs pcm
        mii.cbSize = LenB(mii)
        mii.fMask = MIIM_TYPE
        mii.fType = MFT_SEPARATOR
        InsertMenuItemW hMenu, 0&, True, mii
        
        mii.fMask = MIIM_STRING Or MIIM_ID
        mii.wID = widCpyPaths
        mii.cch = IIf(cnt > 1, Len(mn_CopyFPs), Len(mn_CopyFP))
        mii.dwTypeData = IIf(cnt > 1, StrPtr(mn_CopyFPs), StrPtr(mn_CopyFP))
        InsertMenuItemW hMenu, 0&, True, mii
        
        mii.fMask = MIIM_STRING Or MIIM_ID
        mii.wID = widCpyNames
        mii.cch = IIf(cnt > 1, Len(mn_CopyFNs), Len(mn_CopyFN))
        mii.dwTypeData = IIf(cnt > 1, StrPtr(mn_CopyFNs), StrPtr(mn_CopyFN))
        InsertMenuItemW hMenu, 0&, True, mii

        
        If (m_LockNav = False) Then
            mii.fMask = MIIM_STRING Or MIIM_ID Or MIIM_STATE
            mii.wID = widBrowse
            mii.cch = Len(mn_Browse)
            mii.dwTypeData = StrPtr(mn_Browse)
            If (cnt = 1) And (LVEntries(lpFocused).bFolder = True) Then
                mii.fState = MFS_ENABLED
            Else
                mii.fState = MFS_DISABLED
            End If
            InsertMenuItemW hMenu, 0&, True, mii
        End If
        
        
        mii.fMask = MIIM_STRING Or MIIM_ID Or MIIM_STATE
        mii.wID = wIDSel
        mii.fState = MFS_DEFAULT
        mii.cch = Len(mn_sSel)
        mii.dwTypeData = StrPtr(mn_sSel)
        InsertMenuItemW hMenu, 0&, True, mii
    
        Call GetCursorPos(PT)
        DebugAppend "PopupShellMenu@" & PT.x & "," & PT.y
    
        idCmd = TrackPopupMenuEx(hMenu, TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD Or TPM_NOANIMATION, PT.x, PT.y, hLVS, ByVal 0&)
        
        If idCmd Then
            If idCmd = wIDSel Then
                RaiseEvent FileExecute(sSelectedFile, siFocus)
            ElseIf idCmd = widBrowse Then
                LVDoubleClick nFocused
            ElseIf idCmd = widCpyNames Then
                 If cnt = 1 Then
                    ClipboardSetText tSelectedFile.sName
                Else
                    ClipboardSetText Join(sSelectedFileNames, vbCrLf)
                End If
            ElseIf idCmd = widCpyPaths Then
                 If cnt = 1 Then
                    ClipboardSetText tSelectedFile.sFullPath
                Else
                    ClipboardSetText Join(sSelectedFiles, vbCrLf)
                End If
            Else
                Dim sVerb As String
                sVerb = String$(MAX_PATH, 0&)
                On Error Resume Next
                pcm.GetCommandString idCmd - 1, GCS_VERBW, 0&, StrPtr(sVerb), Len(sVerb)
                
                sVerb = LCase$(TrimNullW(sVerb))
                DebugAppend "ShellContextMenu->Verb=" & sVerb, 20
                On Error GoTo e0
                
                If sVerb = "rename" Then
                    DebugAppend "ShellContextMenu->Rename"
                    Dim lIdx As Long
                    lIdx = ListView_GetSelectedItem(hLVS)
                    Call SendMessage(hLVS, LVM_EDITLABELW, lIdx, ByVal 0&)
                Else
                    With cmi
                        .cbSize = LenB(cmi)
                        .hwnd = hLVS
                        .lpVerb = idCmd - 1 ' MAKEINTRESOURCE(idCmd-1);
                        .nShow = SW_SHOWNORMAL
                    End With
                    If (ICtxMenu3 Is Nothing) = False Then
                        ICtxMenu3.InvokeCommand VarPtr(cmi)
                    Else
                        If (ICtxMenu2 Is Nothing) = False Then
                            ICtxMenu2.InvokeCommand VarPtr(cmi)
                        Else
                            pcm.InvokeCommand VarPtr(cmi)
                        End If
                    End If
                    If sVerb = "cut" Then LVCutSelected
                End If
            End If
        End If
    Else
        DebugAppend "ShowShellContextMenu->Failed to get IContextMenu"
    End If
    DestroyMenu hMenu
    Set ICtxMenu2 = Nothing
    Set ICtxMenu3 = Nothing
    Set pcm = Nothing
    Exit Function
    e0:
    DebugAppend "ShowShellContextMenu->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function FileTimeToDate(ft As FILETIME) As Date
    Dim ST As SYSTEMTIME
    Dim FTL As FILETIME
    Call FileTimeToLocalFileTime(ft, FTL)
    Call FileTimeToSystemTime(FTL, ST)
    
    FileTimeToDate = SystemTimeToDate(ST)
    End Function
    
    Private Sub OpenParent()
    If bBlockLoad = True Then Exit Sub
    If bUpEnable = False Then Exit Sub
    On Error GoTo e0
    If m_Mode = SBCTL_DrivesOnly Then Exit Sub 'Only drives are shown and we don't want to open Computer or Desktop
    bSuppress = True
    Dim i As Long
    Dim li As Long
    Dim lpName As LongPtr, sName As String
    Dim siCur As IShellItem, siPar As IShellItem
    'Call SHCreateItemFromParsingName(StrPtr(m_sCurPath), Nothing, IID_IShellItem, siCur)
    If (siCurPath Is Nothing) = False Then
        On Error Resume Next
        siCurPath.GetParent siPar
        On Error GoTo e0
        i = GetItemIndex(m_sCurPath, li)
        If li = 1 Then 'indent=1 == parent=desktop
            bSuppress = True
            Call SendMessage(hCombo, CB_SETCURSEL, 0&, ByVal 0&)
            LVLoadFolder "0"
            bSuppress = False
        Else
            If (siPar Is Nothing) = False Then
                i = AddStandardFSItem(siPar, li, True)
                Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
                siPar.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpName
                sName = LPWSTRtoStr(lpName)
                If (Left$(sName, 3) = "::{") Or (sName = "") Then
                    LVLoadFolder sName, , True, siPar
                Else
                    LVLoadFolder sName
                End If
            End If
        End If
    End If
    
    bSuppress = False
    Exit Sub
    e0:
    DebugAppend "OpenParent->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub SetButtonIcons()
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
        
        
    '    If iidxBack = -1 Then
    '        hIconBack = pbStdBkBtnIco.Picture.Handle
    '    Else
    ''        imlMisc.GetIcon iidxBack, ILD_TRANSPARENT, hIconBack
            If m_ScaleX = 1 Then
                hIconBack = PBEncodedIconTohIcon(pbidx_ICO_MNBACK, 24, 24)
                hIconFwd = PBEncodedIconTohIcon(pbidx_ICO_MNFWD, 24, 24)
                ButtonIconAssign hStdBackButton, hIconBack, 24, 24, 0&, 2&, 2&, 0&
                ButtonIconAssign hStdFwdButton, hIconFwd, 24, 24, 0&, 2&, 2&, 0&
            Else
                hIconBack = PBEncodedIconTohIcon(pbidx_ICO_MNBACK, 32, 32)
                hIconFwd = PBEncodedIconTohIcon(pbidx_ICO_MNFWD, 32, 32)
                ButtonIconAssign hStdBackButton, hIconBack, 32&, 32&, 0&, 2&, 2&, 0&
                ButtonIconAssign hStdFwdButton, hIconFwd, 32&, 32&, 0&, 2&, 2&, 0&
            End If

        
        If iidxUp = -1 Then
            Dim siSys As IShellItem
            SHGetKnownFolderItem FOLDERID_SystemX86, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siSys
            If (siSys Is Nothing) Then
                SHGetKnownFolderItem FOLDERID_System, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siSys 'if 32bit Windows, will there be a sysx86???
            End If
            If (siSys Is Nothing) = False Then
                Dim lpPath As LongPtr, sPath As String
                siSys.GetDisplayName SIGDN_FILESYSPATH, lpPath
                sPath = LPWSTRtoStr(lpPath)
                sPath = sPath & "\shell32.dll"
                Call ExtractIconExW(StrPtr(sPath), 45&, ByVal 0&, hIconUp, 1)
            End If
            If m_ScaleX = 1 Then
                ButtonIconAssign hUpButton, hIconUp, 24, 24, 0&, 2&, 2&, 0&
            Else
                ButtonIconAssign hUpButton, hIconUp, 32&, 32&, 0&, 2&, 2&, 0&
            End If
        Else
            If m_ScaleX = 1 Then
                hIconUp = PBEncodedIconTohIcon(pbidx_ICO_UP, 24, 24)
                ButtonIconAssign hUpButton, hIconUp, 24, 24, 0&, 2&, 2&, 0&
            Else
                hIconUp = PBEncodedIconTohIcon(pbidx_ICO_UP, 32, 32)
                ButtonIconAssign hUpButton, hIconUp, 32&, 32&, 0&, 2&, 2&, 0&
            End If
        End If
        
        If iidxView = -1 Then
            hIconView = Picture6.Picture.Handle
            ButtonIconAssign hViewButton, hIconView, 24, 24, 0&, 2&, 2&, 0&
        Else
            If m_ScaleX = 1 Then
                hIconView = PBEncodedIconTohIcon(pbidx_ICO_VIEW, 24, 24)
                ButtonIconAssign hViewButton, hIconView, 24, 24, 0&, 2&, 2&, 0&
            Else
                hIconView = PBEncodedIconTohIcon(pbidx_ICO_VIEW, 32, 32)
                ButtonIconAssign hViewButton, hIconView, 32, 32, 0&, 2&, 2&, 0&
            End If
        End If
        If iidxBkm = -1 Then
            hIconBkm = Picture5.Picture.Handle
            ButtonIconAssign hBkmButton, hIconBkm, 24, 24, 0&, 0&, 2&, 0&
        Else
            If m_ScaleX = 1 Then
                hIconBkm = PBEncodedIconTohIcon(pbidx_ICO_NEWBKM, 24, 24)
                ButtonIconAssign hBkmButton, hIconBkm, 24, 24, 0&, 0&, 2&, 0&
            Else
                hIconBkm = PBEncodedIconTohIcon(pbidx_ICO_NEWBKM, 32, 32)
                ButtonIconAssign hBkmButton, hIconBkm, 32, 32, 0&, 0&, 2&, 0&
            End If
        End If
    
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.SetButtonIcons->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    Private Sub ButtonIconAssign(hWnd As LongPtr, hIcon As LongPtr, cx As Long, cy As Long, margLeft As Long, margRight As Long, margTop As Long, margBottom As Long)
    
    On Error GoTo e0
    Dim bi4 As BUTTON_IMAGELIST
    bi4.himl = ImageList_Create(cx, cy, ILC_COLOR32 Or ILC_MASK, 1, 1)
    If bi4.himl Then
        bi4.margin.Left = margLeft
        bi4.margin.Right = margRight
        bi4.margin.Top = margTop
        bi4.margin.Bottom = margBottom
        ImageList_ReplaceIcon bi4.himl, -1, hIcon
        Call SendMessage(hWnd, BCM_SETIMAGELIST, 0&, bi4)
    End If
    
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "mButtonDefs.ButtonIconAssign.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Sub
    
    Private Sub pbDetailPane_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbDetailPane.MouseUp
    If mDtPaneNoRS = False Then
        If Button = 2 Then DtLockMenu
    End If
    DebugAppend "SizerTop=" & pbDetailSizer.Top
    End Sub
    
    ' Private Sub pbDetailPane_OLEDragOver(data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
    ' DebugAppend "pbDetailPane_OLEDragOver"
    ' End Sub
    
    Private Sub pbDetailPane_Resize() Handles pbDetailPane.Resize
    On Error Resume Next
    'DebugAppend "pbDetailPane_Resize"
    If cmdPropSave.Visible = True Then
        cmdPropSave.Top = pbDetailPane.Height - cmdPropSave.Height - (4 * m_ScaleY)
        cmdPropSave.Left = pbDetailPane.Width - cmdPropCancel.Width - cmdPropSave.Width - (6 * m_ScaleX)
        cmdPropCancel.Top = pbDetailPane.Height - cmdPropCancel.Height - (4 * m_ScaleY)
        cmdPropCancel.Left = pbDetailPane.Width - cmdPropCancel.Width - (4 * m_ScaleX)
    End If
    End Sub
    
    Private Sub ShowDtSave()
    cmdPropSave.Visible = True
    cmdPropCancel.Visible = True
    'cmdPropSave.Top = pbDetailPane.Height - cmdPropSave.Height - 1
    'cmdPropSave.Left = pbDetailPane.Width - cmdPropCancel.Width - cmdPropSave.Width - 6
    'cmdPropCancel.Top = pbDetailPane.Height - cmdPropCancel.Height - 1
    'cmdPropCancel.Left = pbDetailPane.Width - cmdPropCancel.Width - 2
        cmdPropSave.Top = pbDetailPane.Height - cmdPropSave.Height - (4 * m_ScaleY)
        cmdPropSave.Left = pbDetailPane.Width - cmdPropCancel.Width - cmdPropSave.Width - (6 * m_ScaleX)
        cmdPropCancel.Top = pbDetailPane.Height - cmdPropCancel.Height - (4 * m_ScaleY)
        cmdPropCancel.Left = pbDetailPane.Width - cmdPropCancel.Width - (4 * m_ScaleX)
    pbDetailPane_Resize
    End Sub
    
    Private Sub pbDetailSizer_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbDetailSizer.MouseDown
    If Button = 1 Then
    bSMove = True
    SetWindowPos pbDetailSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    Dim PT As POINT
    PT.x = mDTOffsetX
    ClientToScreen UserControl.hWnd, PT
    mDTSLeft = PT.x
    mDTSRight = PT.x + (pbDetailSizer.Width) + 4
    
    If Ambient.UserMode Then
    ' If ssc_Subclass(pbDetailSizer.hWnd, , 23) Then
    '      Call ssc_AddMsg(pbDetailSizer.hWnd, MSG_BEFORE, WM_MOVING)
    ' End If
        Subclass2 pbDetailSizer.hWnd, AddressOf DTSWndProc, pbDetailSizer.hWnd
    End If
    
    DebugAppend "MouseDown y=" & Y & ",cx=" & pbDetailSizer.Width & ",InitTop=" & pbDetailSizer.Top
    End If
    End Sub
    
    Private Sub pbDetailSizer_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbDetailSizer.MouseMove
    'DebugAppend "pbDetailSizer_MouseMove"
    
    If bSMove Then
        If Button = 1 Then
            Dim cxOrig As Long
            bSMove = True
            cxOrig = pbDetailSizer.Width
    '        pbDetailSizer.Width = cxOrig * 4
    '        pbDetailSizer.Left = (-1) * cxOrig
            'DebugAppend "PreReleaseCapture Top=" & pbDetailSizer.Top

            ReleaseCapture
            SendMessage pbDetailSizer.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, ByVal 0&
            FastDoEvents
            ' ssc_DelMsg pbDetailSizer.hWnd, MSG_BEFORE, WM_MOVING
            ' ssc_UnSubclass pbDetailSizer.hWnd
            ' UnSubclass2 pbDetailSizer.hWnd, AddressOf DTSWndProc, pbDetailSizer.hWnd
            pbDetailSizer.Refresh
    '        If pbDetailSizer.Top < (cyMinListView + cyCombo + 6) Then
    '            pbDetailSizer.Top = (cyMinListView + cyCombo + 6)
    '        End If
            pbDetailSizer.Width = cxOrig
            pbDetailSizer.Left = pbDetailPane.Left + 5
            'DebugAppend "PostReleaseCapture Top=" & pbDetailSizer.Top
            UserControl_Resize
            RedrawLastDetailPane
            If m_PvPane Then RefreshPreview
            bSMove = False
            DebugAppend "pbDetailSizer bSMove=False (MM/BTN1)"
        Else
            bSMove = False
            DebugAppend "pbDetailSizer bSMove=False (MM/BTN2)"
        End If
    End If
    End Sub
    Private Sub pbDetailSizer_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbDetailSizer.MouseUp
    bSMove = False
    DebugAppend "pbDetailSizer bSMove=False (MU)"
    End Sub
    
    Private Sub pbPreviewSizer_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbPreviewSizer.MouseDown
    If Button = 1 Then
    mPrevBarHeight = pbPreviewSizer.Height
    mPrevBarTop = pbPreviewSizer.Top
    pbPreviewSizer.Height = UserControl.Height * 4
    pbPreviewSizer.Top = (-1) * mPrevBarHeight
    bPMove = True
    SetWindowPos pbPreviewSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
    End If
    End Sub
    
    Private Sub pbPreviewSizer_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbPreviewSizer.MouseMove
    If bPMove Then
        If Button = 1 Then
            ReleaseCapture
            SendMessage pbPreviewSizer.hWnd, WM_NCLBUTTONDOWN, HTCAPTION, ByVal 0&
            DebugAppend "left=" & pbPreviewSizer.Left & ",sw=" & UserControl.ScaleWidth
            If pbPreviewSizer.Left > (UserControl.ScaleWidth - 38) Then
                pbPreviewSizer.Left = (UserControl.ScaleWidth - 38)
            End If
            If pbPreviewSizer.Left < m_cxMinLV Then pbPreviewSizer.Left = 45
            UserControl_Resize
            RefreshPreview
        Else
            bPMove = False
        End If
    End If
    End Sub
    
    Private Sub pbPreviewSizer_MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single) Handles pbPreviewSizer.MouseUp
    bPMove = False
    pbPreviewSizer.Height = mPrevBarHeight
    pbPreviewSizer.Top = mPrevBarTop
    End Sub
    
    Public Sub RefreshPreview()
    Dim rc As RECT
    rc.Top = 2
    rc.Bottom = (pbPreviewPane.Height / Screen.TwipsPerPixelY) - 2
    rc.Left = 2
    rc.Right = (pbPreviewPane.Width / Screen.TwipsPerPixelX) - 2
    If (ipv Is Nothing) = False Then
        ipv.SetRect rc
    Else
        If (siFocus Is Nothing) = False Then
            ShowPreviewForFile siFocus, pbPreviewPane.hWnd, rc, pbPreviewPane
        End If
    End If
    End Sub
    
    Private Sub PropFontDt_FontChanged(ByVal PropertyName As String) Handles PropFontDt.FontChanged
        Set pbDetailPane.Font = PropFontDt
        Set mIFTmp = PropFontDt
        Dim lftmp As LOGFONTW
        GetObjectW CLngPtr(mIFTmp.hFont), LenB(lftmp), lftmp
        
        m_hFontDtAlt = CreateFontIndirectW(lftmp)
        Set Temp2Font = CloneOLEFont(PropFontDt)
        Temp2Font.Size = Temp2Font.Size + 1
        Dim lfdt As LOGFONTW
        Set mIFTmp2 = Temp2Font
        GetObjectW CLngPtr(mIFTmp2.hFont), LenB(lfdt), lfdt
        m_hFontDtHdrAlt = CreateFontIndirectW(lfdt)
        cyDtName = PropFontDt.Size * 2
        m_cyFontDtTxt = PropFontDt.Size
        If m_FontScaleCXY Then
            m_cyFontDtTxt = TextHeightW(pbDetailPane.hDC, "|1T") 'pbDetailPane.TextHeight("|1T")
    '        m_cyFontDtTxt = m_cyFontDtTxt + (4 * m_ScaleY)
    '    Else
    '        m_cyFontDtTxt = m_cyFontDtTxt + 4
        End If
        DebugAppend "PropFontDtChange DtFont=" & m_hFontDtAlt, 444
    End Sub
    
    Private Sub PropFontLV_FontChanged(ByVal PropertyName As String) Handles PropFontLV.FontChanged
    Set mIFMain = PropFontLV
    Dim old1 As LongPtr, old2 As LongPtr, old3 As LongPtr
    old1 = hFontLVMain
    old2 = hFontDropdown
    old3 = hFontLVHdrMain
    
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(mIFLV.hFont), LenB(lftmp), lftmp
    hFontLVMain = CreateFontIndirectW(lftmp)
    hFontDropdown = hFontLVMain
    hFontLVHdrMain = hFontLVMain
    
    If hLVS <> 0 Then SendMessage hLVS, WM_SETFONT, hFontLVMain, ByVal 1&
    If hCombo Then SendMessage hCombo, WM_SETFONT, hFontLVMain, ByVal 1&
    If hLVSHdr <> 0 Then SendMessageW hLVSHdr, WM_SETFONT, hFontLVMain, ByVal 1&
    If old1 Then DeleteObject old1
    If old2 Then DeleteObject old2
    If old3 Then DeleteObject old3
    End Sub

    Private Function OLEFontIsEqual(ByVal Font As StdFont, ByVal FontOther As StdFont) As Boolean
    If Font Is Nothing Then
        If FontOther Is Nothing Then OLEFontIsEqual = True
    ElseIf FontOther Is Nothing Then
        If Font Is Nothing Then OLEFontIsEqual = True
    Else
        If Font.Name = FontOther.Name And Font.Size = FontOther.Size And Font.Charset = FontOther.Charset And Font.Weight = FontOther.Weight And _
        Font.Underline = FontOther.Underline And Font.Italic = FontOther.Italic And Font.Strikethrough = FontOther.Strikethrough Then
            OLEFontIsEqual = True
        End If
    End If
    End Function
    
    Private Sub tmrChangeQueue_Timer() Handles tmrChangeQueue.Timer
    'tcHoldTime1 is set every time LVN_ITEMCHANGED is sent
    'So to queue the call and wait until those messages stop firing, we wait until 20ms has elapsed
    'This speed catches all multi-file selection changes in one update
    tcHoldTime2 = GetTickCount()
    If (tcHoldTime2 - tcHoldTime1) > 20 Then
        bChangeQueued = False
        LVProcItemChange nmiclv
        tmrChangeQueue.Enabled = False
        DebugAppend "Executed queued LVProcItemChange"
    End If
    End Sub
    
    Private Sub tmrChangeSet_Timer() Handles tmrChangeSet.Timer
    If bICFlag Then
        tct1 = tct1 + 10
        If tct1 > nSelUpdateMillisecs Then
            Dim nmlv As NMLISTVIEW
            DebugAppend "Timer hit"
            nmlv.uOldState = LVIS_SELECTED
            LVProcItemChange nmlv
            bICFlag = False
            tct1 = 0
            If (GetKeyState(VK_LBUTTON) = 0&) And (GetKeyState(VK_RBUTTON) = 0&) Then
                tmrChangeSet.Enabled = False
                bTmrFlag = False
            End If
        End If
    End If
    End Sub
    
    Private Sub tmrResize_Timer() Handles tmrResize.Timer
    rzHoldTime2 = GetTickCount()
    If (rzHoldTime2 - rzHoldTime1) > 500 Then
        bResizeQueued = False
        If m_DtPane Then
            RedrawLastDetailPane
        End If
        If m_PvPane Then
            RefreshPreview
        End If
        tmrResize.Enabled = False
        DebugAppend "Refreshed details/preview on timer"
    End If
    End Sub
    
    Private Sub txtColCX_Click() Handles txtColCX.Click
    hFocused = txtColCX.hWnd
    End Sub
    
    Private Sub txtColCX_GotFocus() Handles txtColCX.GotFocus
    hFocused = txtColCX.hWnd
    'pvSetIPAO
    End Sub
    
    Private Sub txtSrSize1_GotFocus() Handles txtSrSize1.GotFocus
    hFocused = txtSrSize1.hWnd
    End Sub
    
    Private Sub pbBackBtn_GotFocus() Handles pbBackBtn.GotFocus
    hFocused = pbBackBtn.hWnd
    End Sub
    
    Private Sub pbFwdBtn_GotFocus() Handles pbFwdBtn.GotFocus
    hFocused = pbFwdBtn.hWnd
    End Sub
    
    Private Function GetCheckedCount() As Long
    Dim i As Long
    Dim n As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).fChecked Then
            If LVEntries(i).bDeleted = False Then n = n + 1
        End If
    Next i
    GetCheckedCount = n
    
    End Function
    
    Private Function LVProcItemChange(nmlv As NMLISTVIEW) As Long
    If (nmlv.uOldState = LVIS_SELECTED) Or (nmlv.uNewState = LVIS_SELECTED) Or _
       (nmlv.uOldState = LVIS_FOCUSED) Or (nmlv.uNewState = LVIS_FOCUSED) Or _
       (nmlv.uOldState = (LVIS_SELECTED Or LVIS_FOCUSED)) Or (nmlv.uNewState = (LVIS_SELECTED Or LVIS_FOCUSED)) Then
        
        'Selection state of an item has changed
        LVSetSelection
    
        If m_PvPane Then
            If (siFocusNS Is Nothing) = False Then
                Dim rc As RECT
                rc.Top = 2
                rc.Bottom = (pbPreviewPane.Height / Screen.TwipsPerPixelY) - 2
                rc.Left = 2
                rc.Right = (pbPreviewPane.Width / Screen.TwipsPerPixelX) - 2
                
                ShowPreviewForFile siFocusNS, pbPreviewPane.hWnd, rc, pbPreviewPane
            End If
        End If
        If m_DtPane Then
            Dim lSelK As LongPtr
            lSelK = SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&)
            DebugAppend "ProcItemChg k=" & lSelK
            If lSelK = 1 Then
                pvCreateItemDetailPane
            ElseIf lSelK = 0 Then
                pvCreateDetailPaneBkg
            Else '>1
                pvCreateMultiItemDetailPane
            End If
        End If
    End If
    
    End Function
    
    Private Function LVSetSelection() As Long
    'CHECK IF SELECTION IS VALID:
    'If this function returns 0, no item is selected and the
    'selection variables *are not valid*
    'Selection is valid only when this function returns a positive
    'number, which represents the number of selected items, which
    'is always 1 for single sel
    'TO CONTROL MULTISEL OR SINGLESEL:
    'Adjust ListView style in InitLV
    'If multiselect, the single select variables will contain
    'the focused item, and the arrays will contain that and the rest
    On Error GoTo e0
    Dim lSelCnt As Long
    Dim i As Long
    Dim nSel As Long
    Dim nCtFi As Long, nCtFl As Long
    Dim lp As LongPtr
    Dim idx As Long
    'If bHoldSS Then Exit Function
    
    lSelCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    If lSelCnt = 1& Then
        mLastSelStr = "1 " & mFileSelStr
    ElseIf lSelCnt = 0& Then
        mLastSelStr = mNoFilesSelStr
    Else
        mLastSelStr = lSelCnt & " " & mFilesSelStr
    End If
    UpdateStatus mLastSelStr
    Set siFocusNS = Nothing
    idx = ListView_GetSelectedItem(hLVS)
    If idx <> LVI_NOITEM Then
        
        lp = GetLVItemlParam(hLVS, idx)
        SHCreateItemFromParsingName StrPtr(LVEntries(lp).sFullPath), Nothing, IID_IShellItem, siFocusNS
    End If
    If lSelCnt = 0& Then
        DebugAppend "LVSetSelect->Ct=0,ClearSel"
        ReDim sSelectedFiles(0)
        ReDim tSelectedFiles(0)
        ReDim sSelectedFileNames(0)
        ReDim sSelectedFilesOnly(0)
        ReDim sSelectedFilesOnlyFull(0)
        ReDim sSelectedFoldersOnly(0)
        ReDim sSelectedFoldersOnlyFull(0)
        sSelectedFile = ""
        tSelectedFile.sFullPath = ""
        tSelectedFile.sName = ""
        tSelectedFile.sNameFull = ""
        Set siFocus = Nothing
        RaiseEvent SelectionCleared
        RaiseEvent SelectionChanged(sSelectedFiles, "", Nothing)
        Exit Function
    End If
    ReDim tSelectedFiles(0)
    ReDim sSelectedFiles(0)
    ReDim sSelectedFileNames(0)
    ReDim sSelectedFileNamesF(0)
    ReDim sSelectedFilesOnly(0)
    ReDim sSelectedFilesOnlyFull(0)
    ReDim sSelectedFoldersOnly(0)
    ReDim sSelectedFoldersOnlyFull(0)
    SelectedFileIndex = -1
    lp = -1
    
                
    idx = ListView_GetSelectedItem(hLVS)
    '    DebugAppend "LVGSI=" & idx
    lp = GetLVItemlParam(hLVS, idx)
    sSelectedFile = LVEntries(lp).sFullPath
    tSelectedFile = LVEntries(lp)
    SelectedFileIndex = CLng(lp)
    'DebugAppend "LVSetSelect->Focused=" & sSelectedFile
    i = LVI_NOITEM
    Do
        i = CLng(SendMessage(hLVS, LVM_GETNEXTITEM, i, ByVal LVNI_SELECTED))
        If (i <> LVI_NOITEM) Then
            lp = GetLVItemlParam(hLVS, i)
            ReDim Preserve tSelectedFiles(nSel)
            tSelectedFiles(nSel) = LVEntries(lp)
            ReDim Preserve sSelectedFiles(nSel)
            sSelectedFiles(nSel) = LVEntries(lp).sFullPath
            ReDim Preserve sSelectedFileNames(nSel)
            sSelectedFileNames(nSel) = LVEntries(lp).sName
            ReDim Preserve sSelectedFileNamesF(nSel)
            sSelectedFileNamesF(nSel) = LVEntries(lp).sNameFull
            nSel = nSel + 1
            If LVEntries(lp).bFolder = False Then
                ReDim Preserve sSelectedFilesOnly(nCtFi)
                ReDim Preserve sSelectedFilesOnlyFull(nCtFi)
                sSelectedFilesOnly(nCtFi) = LVEntries(lp).sName
                sSelectedFilesOnlyFull(nCtFi) = LVEntries(lp).sFullPath
                nCtFi = nCtFi + 1
            Else
                ReDim Preserve sSelectedFoldersOnly(nCtFl)
                ReDim Preserve sSelectedFoldersOnlyFull(nCtFl)
                sSelectedFoldersOnly(nCtFl) = LVEntries(lp).sName
                sSelectedFoldersOnlyFull(nCtFl) = LVEntries(lp).sFullPath
                nCtFl = nCtFl + 1
            End If
        End If
    Loop Until (i = LVI_NOITEM)
    If (idx = -1) And (nSel > 0) Then 'selected but no focus; returns an invalid item
        sSelectedFile = sSelectedFiles(0)
        tSelectedFile = tSelectedFiles(0)
    End If
    LVSetSelection = nSel
    Set siFocus = Nothing
    SHCreateItemFromParsingName StrPtr(sSelectedFile), Nothing, IID_IShellItem, siFocus
    If (siFocus Is Nothing) And (lp > (-1)) Then
        'Attempt alt method
        Dim pidl As LongPtr
        pidl = ILCombine(pidlFQCur, LVEntries(lp).pidlRel)
        SHCreateItemFromIDList pidl, IID_IShellItem, siFocus
        If pidl Then CoTaskMemFree pidl
    End If
    Dim uAtr As SFGAO_Flags
    siFocus.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK Or SFGAO_SYSTEM, uAtr
    DebugAppend "Attrib=" & dbg_sfgao_tostring(uAtr)
    DebugAppend "LVSetSelection file=" & LVEntries(lp).sName & ",sType=" & LVEntries(lp).sType & ",bFolder=" & LVEntries(lp).bFolder
    'DebugAppend "LVSetSelection full path=" & GetShellItemFileName(siFocus, SIGDN_DESKTOPABSOLUTEPARSING)
    'DebugAppend "LVSetSelection ParFull=" & LVEntries(lp).sParentFull ' & ",bIsZip=" & LVEntries(lp).bZip & ",bFolder=" & LVEntries(lp).bFolder
    'DebugAppend "LVSetSelection ParRelParse=" & GetShellItemFileName(siFocus, SIGDN_PARENTRELATIVEPARSING)
    '
    'SupportsDropByIdx SelectedFileIndex
    
    'Dim si2f As IShellItem2
    'Set si2f = siFocus
    'Dim lps As Long
    'si2f.GetString PKEY_SFGAOFlags, lps
    'DebugAppend "LVSetSel prop=" & dbg_sfgao_tostring(LPWSTRtoStr(lps))
    RaiseEvent SelectionChanged(sSelectedFiles, sSelectedFile, siFocus)
    Exit Function
    e0:
    DebugAppend "LVSetSelection->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    
    Public Function GetHistoryData(sEntries() As String, piIndex As Long, piMaxDisplayed As Long) As Long
    sEntries = sHistory
    piIndex = nHistIdx
    piMaxDisplayed = mMaxHist
    GetHistoryData = UBound(sHistory) + 1
    End Function
    
    Public Function GetPidlStoreEntry(sPath As String) As LongPtr
    'Caller must not free the pidl; copy it if needed
    Dim i As Long
    For i = 0 To UBound(uPidlStore)
        If LCase$(uPidlStore(i).sPath) = LCase$(sPath) Then
            GetPidlStoreEntry = uPidlStore(i).pidlFQ
            Exit Function
        End If
    Next i
    End Function
    
    Public Function GetCurrentColumnCount() As Long
    GetCurrentColumnCount = Header_GetItemCount(hLVSHdr)
    End Function
    
    Public Function GetCurrentColumns(ptr_pk_ar As Long, sDispNames() As String) As Long
    Dim pk() As PROPERTYKEY
    Dim lColCnt As Long
    lColCnt = Header_GetItemCount(hLVSHdr)
    ReDim pk(lColCnt - 1)
    Dim i As Long
    Dim lp As LongPtr
    For i = 0 To (lColCnt - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
        pk(i) = uColData(lp).pKey
        sDispNames(i) = uColData(lp).szDisplayName
    Next i
    CopyMemory ByVal ptr_pk_ar, pk(0), LenB(pk(0)) * lColCnt
    GetCurrentColumns = lColCnt
    End Function
    
    Public Function GetGroupColumn() As Long
    If bGV Then
        GetGroupColumn = lGrpCol
    Else
        'Group mode disabled
        GetGroupColumn = -1
    End If
    End Function
    Public Sub InvokeGroupByColumn(lCol As Long)
    'Pass -1 for 'None'
    If lCol = -1 Then
        SetGroupMode SBGB_None
        lGrpCol = -1
        bCatGrpActive = False
        Exit Sub
    End If
    Dim lp As LongPtr
    lp = GetHDItemlParam(hLVSHdr, lCol)
    If lp <> lGrpCol Then
        lGrpCol = CLng(lp)
        Select Case lp
            Case lDefColIdx(0): SetGroupMode SBGB_Name
            Case lDefColIdx(1): SetGroupMode SBGB_Size
            Case lDefColIdx(2): SetGroupMode SBGB_Type
            Case lDefColIdx(3): SetGroupMode SBGB_DateModified
            Case lDefColIdx(4): SetGroupMode SBGB_DateCreated
            Case lDefColIdx(5): SetGroupMode SBGB_DateAccessed
            
            Case Else: SetGroupMode SBGB_Extended
        End Select
        bCatGrpActive = False
    End If
    End Sub
    Public Sub InvokeGroupByPKEY(ptr_pkey As LongPtr)
    Dim pk As PROPERTYKEY
    
    If ptr_pkey Then
        CopyMemory ByVal VarPtr(pk), ByVal ptr_pkey, LenB(pk)
    Else
        DebugAppend "InvokeSortByPKEY::No pointer to PKEY"
        Exit Sub
    End If
    
    Dim lColCnt As Long
    lColCnt = Header_GetItemCount(hLVSHdr)
    
    Dim i As Long
    Dim lp As LongPtr
    For i = 0 To (lColCnt - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
        If IsEqualPKEY(pk, uColData(lp).pKey) Then
            lGrpCol = CLng(lp)
            Select Case lp
                Case lDefColIdx(0): SetGroupMode SBGB_Name
                Case lDefColIdx(1): SetGroupMode SBGB_Size
                Case lDefColIdx(2): SetGroupMode SBGB_Type
                Case lDefColIdx(3): SetGroupMode SBGB_DateModified
                Case lDefColIdx(4): SetGroupMode SBGB_DateCreated
                Case lDefColIdx(5): SetGroupMode SBGB_DateAccessed
                
                Case Else: SetGroupMode SBGB_Extended
            End Select
            bCatGrpActive = False
            Exit Sub
         End If
    Next i
    End Sub
    
    Public Sub InvokeSortByColumn(iCol As Long)
    LVColumnClick iCol
    End Sub
    
    
    Public Sub InvokeSortAscending()
    If lSortD = 0 Then
        LVColumnClick lSortK
        lSortD = 1
    End If
    End Sub
    Public Sub InvokeSortDescending()
    If lSortD = 1 Then
        LVColumnClick lSortK
        lSortD = 0
    End If
    End Sub
    
    Public Function GetSortDirection() As Integer
    '0=Descending, 1=Ascending
    If lSortD <> 0 Then
        GetSortDirection = 1
    End If
    End Function
    Public Function GetSortColumn() As Long
    GetSortColumn = lSortK
    End Function
    
    Public Sub InvokeSortByPKEY(ptr_pkey As LongPtr)
    Dim pk As PROPERTYKEY
    
    If ptr_pkey Then
        CopyMemory ByVal VarPtr(pk), ByVal ptr_pkey, LenB(pk)
    Else
        DebugAppend "InvokeSortByPKEY::No pointer to PKEY"
        Exit Sub
    End If
    
    Dim lColCnt As Long
    lColCnt = Header_GetItemCount(hLVSHdr)
    Dim i As Long
    Dim lp As LongPtr
    For i = 0 To (lColCnt - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
        If IsEqualPKEY(pk, uColData(lp).pKey) Then
            LVColumnClick i
            Exit Sub
        End If
    Next i
    End Sub
    Public Sub InvokeColumnSelection()
    LoadColumnSelect
    End Sub
    
    Public Sub InvokeNewFolder()
    DoNewFolder
    End Sub
    
    Public Sub InvokeSelectAll()
    SetFocusOnFiles
    LVSelectAll
    End Sub
    
    Public Sub InvokeInvertSelection()
    SetFocusOnFiles
    LVInvertSel
    End Sub
    
    Public Sub InvokeKeyPress(vKey As VirtualKeyCodes, Optional bShift As Boolean = False, Optional bControl As Boolean = False, Optional bAlt As Boolean = False, Optional bRaiseEvent As Boolean = True)
    If vKey = VK_RETURN Then
       If bAlt Then
            ShowSelFileProps
        Else
            LVDoubleClick ListView_GetSelectedItem(hLVS)
        End If
    Else
        If bRaiseEvent Then
            Dim bCn As Boolean
            RaiseEvent ListKeyDown(vKey, bShift, bControl, bAlt, bCn)
            DebugAppend "ListKeyDown " & vKey
            If bCn = True Then Exit Sub
        End If
        LVHandleKeypress hLVS, vKey, bAlt, bShift, bControl
    End If
        
    End Sub
    
    Private Sub LVHandleKeypress(lng_hWnd As LongPtr, wVKey As VirtualKeyCodes, blvkdA As Boolean, blvkdS As Boolean, blvkdC As Boolean)
    
    On Error GoTo LVHandleKeypress_Err
    DebugAppend "ListKeyDown " & wVKey
     
    If bDisableAllKeyboardShortcuts = True Then Exit Sub
    
    Dim pCTM As IContextMenu
    Dim i As Long
    Dim lCnt As Long
    
    Select Case wVKey
        Case vbKeyTab
            If lng_hWnd = hLVS Then
                DebugAppend "LVN_KEY tab from hlvs", 2
                'SetFocusAPI hLVSHdr
            ElseIf lng_hWnd = hLVSHdr Then
                DebugAppend "LVN_KEY tab from hdr", 2
            Else
                DebugAppend "LVN_KEY tab other hwnd", 2
                SetFocusAPI hLVSHdr
            End If
            
        Case VK_CONTEXTKEY
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                ShowShellContextMenu
            End If
            
        Case vbKeyF2
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                i = ListView_GetSelectedItem(hLVS)
                If i <> LVI_NOITEM Then
                    Call SendMessage(hLVS, LVM_EDITLABELW, i, ByVal 0&)
                End If
            End If
            
        Case vbKeyF5
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                RefreshView
            End If
            
        Case vbKeyBack
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                If m_LockNav Then Exit Sub
                OpenParent
            End If
        
        Case vbKeyUp
            If (blvkdA = True) And (blvkdS = False) And (blvkdC = False) Then
                If m_LockNav Then Exit Sub
                OpenParent
            End If
        Case vbKeyLeft
            If (blvkdA = True) And (blvkdS = False) And (blvkdC = False) Then
                If m_LockNav Then Exit Sub
                DoBack
            End If
        Case vbKeyRight
            If (blvkdA = True) And (blvkdS = False) And (blvkdC = False) Then
                If m_LockNav Then Exit Sub
                DoForward
            End If
            
        Case vbKeyEscape
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                If bInLVLFLoop Then
                    bLVEscaped = True
                Else
                    ListView_SelectNone hLVS
                End If
            End If
            
        Case vbKeyDelete
            'You could manually delete, but we're mimicking Explorer, so this way
            'we'll get the nice confirmation prompts, shell notifications, move to
            'recycle or permanent according to Explorer pref, all automatically,
            'by going through a 'Delete' shell context menu selection by code
    '                        If GetAsyncKeyState(vbKeyShift) Then
            If (blvkdA = False) And (blvkdS = True) And (blvkdC = False) Then
                lCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
                If lCnt = 1 Then
                    Dim sL() As String
                    ReDim sL(0)
                    sL(0) = sSelectedFile
                    Call DeleteFile(sL)
                ElseIf lCnt > 1 Then
                    Call DeleteFile(sSelectedFiles)
                End If
            ElseIf (blvkdA = False) And (blvkdS = False) And (blvkdC = False) Then
                lCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
                If lCnt > 0& Then
                    
                    SetSelectedItemArray
                    siaSelected.BindToHandler 0&, BHID_SFUIObject, IID_IContextMenu, pCTM
                    If (pCTM Is Nothing) = False Then
                        InvokeVerb pCTM, "delete"
                        Exit Sub
                    End If
                End If
            End If
            
        Case vbKeyA
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                LVSelectAll
            End If
            
        Case vbKeyC
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                lCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
                If lCnt > 0& Then
                    SetSelectedItemArray
                    siaSelected.BindToHandler 0&, BHID_SFUIObject, IID_IContextMenu, pCTM
                    If (pCTM Is Nothing) = False Then
                        InvokeVerb pCTM, "copy"
                        Exit Sub
                    End If
                End If
            End If
            
        Case vbKeyD
            If (blvkdA = True) And (blvkdS = False) And (blvkdC = False) Then
                SetFocusOnDropdown
            End If
            
        Case vbKeyF
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                If hSearchBox Then
                    SetFocusAPI hSearchBox
                End If
            End If
            
        Case vbKeyN
            If (blvkdA = False) And (blvkdS = True) And (blvkdC = True) Then
                If mEnableNewFolder Then DoNewFolder
            End If
            
        Case vbKeyX
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                lCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
                If lCnt > 0& Then
                    SetSelectedItemArray
                    siaSelected.BindToHandler 0&, BHID_SFUIObject, IID_IContextMenu, pCTM
                    If (pCTM Is Nothing) = False Then
                        InvokeVerb pCTM, "cut"
                        LVCutSelected
                        Exit Sub
                    End If
                End If
            End If
            
        Case vbKeyV
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                LVDoPaste
                Exit Sub
            End If
            
        Case vbKeyP
            If (blvkdA = True) And (blvkdS = False) And (blvkdC = False) Then
                If m_EnablePreview Then
                    If m_PvPane Then
                        m_PvPane = False
                        fraPreview.Visible = False
                        pbPreviewSizer.Visible = False
                    Else
                        m_PvPane = True
                        pbPreviewSizer.Visible = True
                        SetPVInitPos
                        SetLVInitPos
                    End If
                    RaiseEvent PreviewPaneWidthChanged
                    UserControl_Resize
                End If
            End If
        
            If (blvkdA = False) And (blvkdS = True) And (blvkdC = True) Then
                ShowAboutDialog
            End If
            
        Case vbKeyY, vbKeyZ
            If (blvkdA = False) And (blvkdS = False) And (blvkdC = True) Then
                Dim pcmBk As IContextMenu
                Dim psvBk As IShellView
                Dim siDesk As IShellItem
                
                Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siDesk)
                If (siDesk Is Nothing) = False Then
                
                    siDesk.BindToHandler 0&, BHID_SFViewObject, IID_IShellView, psvBk
    
                    If (psvBk Is Nothing) = False Then
                        psvBk.GetItemObject SVGIO_BACKGROUND, IID_IContextMenu, pcmBk
                        If (pcmBk Is Nothing) = False Then
                            If wVKey = vbKeyY Then
                                InvokeVerb pcmBk, m_sVerbRedo
                            ElseIf wVKey = vbKeyZ Then
                                InvokeVerb pcmBk, m_sVerbUndo
                            End If
                        End If
                        Set psvBk = Nothing
                    End If
                    Set siDesk = Nothing
                End If
            End If
    End Select
    
    Exit Sub
    
    LVHandleKeypress_Err:
        DebugAppend "LVHandleKeypress.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Function GenerateInfoTip(iItem As Long) As String
    Dim si As IShellItem
    Dim sTip As String
    On Error GoTo e0
    'DebugAppend "GenerateInfoTip::Entry", 11
    SHCreateItemFromParsingName StrPtr(LVEntries(iItem).sFullPath), Nothing, IID_IShellItem, si
    If si Is Nothing Then
        Dim pidl As LongPtr
        pidl = ILCombine(pidlFQCur, LVEntries(iItem).pidlRel)
        SHCreateItemFromIDList pidl, IID_IShellItem, si
    End If
    If (si Is Nothing = False) Then
        
        Dim pqi As IQueryInfo
        si.BindToHandler 0&, BHID_SFUIObject, IID_IQueryInfo, pqi
        If (pqi Is Nothing) Then
    '        DebugAppend "GenerateInfoTip::Try alternate..."
            If (psfCur Is Nothing) = False Then
                psfCur.GetUIObjectOf hLVS, 1&, LVEntries(iItem).pidlRel, IID_IQueryInfo, 0&, pqi
            End If
        End If
        If (pqi Is Nothing) = False Then
            Dim lpTip As LongPtr, sQITip As String
            Dim dwFlags As QITipFlags
            If (mHighPerfMode = True) And (mInfoTipLimitHPF = True) Then
                dwFlags = QITIPF_LINKNOTARGET
            Else
                dwFlags = QITIPF_LINKUSETARGET Or QITIPF_USESLOWTIP
            End If
            pqi.GetInfoTip dwFlags, lpTip
            sQITip = LPWSTRtoStr(lpTip)
    '        DebugAppend "QITIPF_USESLOWTIPGenerateInfoTip::Exit->UseSlowTip=" & sQITip, 11
            GenerateInfoTip = sQITip
            Exit Function
        Else
            DebugAppend "Failed to get IQueryInfo"
            If mHighPerfMode Then Exit Function
        End If
        
        Dim lpp As Long
        Dim si2p As IShellItem2
        Dim pl As IPropertyDescriptionList
        Dim pd As IPropertyDescription
        Dim lpn As LongPtr, sPN As String
        
        Set si2p = si
        Dim pst As IPropertyStore
        si2p.GetPropertyDescriptionList PKEY_PropList_InfoTip, IID_IPropertyDescriptionList, pl
        If (pl Is Nothing) = False Then
            pl.GetCount lpp
    '        DebugAppend "InfoTip Cnt=" & lpp
            If lpp Then
                Dim stt As String
                si2p.GetPropertyStore GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pst
                If (pst Is Nothing) = False Then
    '                DebugAppend "PropsList=" & GetPropertyKeyDisplayString(pst, PKEY_PropList_InfoTip)
                    'We could just parse that; but going through IPropertyDescriptionList automatically skips
                    'fields where there's no data (an error is raised, hence the e1/resume next)GPS_DEFAULT Or
                    On Error GoTo e1
                    Dim i As Long
                    For i = 0 To (lpp - 1)
                        pl.GetAt i, IID_IPropertyDescription, pd
                        If (pd Is Nothing) = False Then
                            stt = GetPropertyDisplayString(pst, pd, PKEY_NULL)
                            If stt <> "" Then
                                pd.GetDisplayName lpn
                                sPN = LPWSTRtoStr(lpn)
                                stt = sPN & ": " & stt
                                If sTip = "" Then
                                    sTip = stt
                                Else
                                    sTip = sTip & vbCrLf & stt
                                End If
    '                            DebugAppend "Prop=" & stt
                                stt = ""
                            Else
                                DebugAppend "Prop=(empty)"
                            End If
                            Set pd = Nothing
                        Else
                            DebugAppend "Prop=(missing)"
                        End If
                    Next i
                    Set pst = Nothing
                End If
            Else
                DebugAppend "lpp=" & lpp
            End If
        Else
            DebugAppend "No proplist"
        End If
    Else
        DebugAppend "No IShellItem"
    End If
    'DebugAppend "GenerateInfoTip::Exit->Regular=" & sTip, 11
    GenerateInfoTip = sTip
    Exit Function
    e0:
    DebugAppend "GenerateInfoTip->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    Exit Function
    e1:
    DebugAppend "GenerateInfoTip->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    Resume Next
    End Function
    
    Private Function GetShellItemFileName(siItem As IShellItem, dwType As SIGDN) As String
    'A more robust alternative to IShellItem.GetDisplayName, which fails with at least fonts, if not more
    Dim lpPath As LongPtr
    Dim uAtr As SFGAO_Flags
    siItem.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK, uAtr
    If (((uAtr And SFGAO_FILESYSTEM) = SFGAO_FILESYSTEM) Or ((uAtr And SFGAO_STREAM) = SFGAO_STREAM) Or ((uAtr And SFGAO_FOLDER) = SFGAO_FOLDER)) Or (dwType = SIGDN_NORMALDISPLAY) Then 'Normal file or type, no issues
        siItem.GetDisplayName dwType, lpPath
        GetShellItemFileName = LPWSTRtoStr(lpPath)
    '    DebugAppend "GetShellItemFileName::std method return=" & GetShellItemFileName
        Exit Function
    End If
    Dim si2 As IShellItem2
    Select Case dwType
        Case SIGDN_PARENTRELATIVE, SIGDN_PARENTRELATIVEEDITING, SIGDN_PARENTRELATIVEFORADDRESSBAR, SIGDN_PARENTRELATIVEFORUI, SIGDN_PARENTRELATIVEPARSING
            Set si2 = siItem
            si2.GetString PKEY_ParsingName, lpPath
    '        Dim vnm As Variant, vbnm As Variant
    '        si2.GetProperty PKEY_FileName, vnm
    '        PropVariantToVariant vnm, vbnm
    '        GetShellItemFileName = CStr(vbnm)
            GetShellItemFileName = LPWSTRtoStr(lpPath)
    '         Dim pstr As IPropertyStore
    '         si2.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pstr
    '         If (pstr Is Nothing) = False Then
    '            GetShellItemFileName = GetPropertyKeyDisplayString(pstr, PKEY_ParsingName)
    '         Else
    '            DebugAppend "GetShellItemFileName->Failed to open property store"
    '        End If
        Case SIGDN_FILESYSPATH, SIGDN_DESKTOPABSOLUTEPARSING, SIGDN_DESKTOPABSOLUTEEDITING
            Dim pdo As IDataObject
            siItem.BindToHandler 0&, BHID_DataObject, IID_IDataObject, pdo
            Dim tSTG As STGMEDIUM, tFMT As FORMATETC
            tFMT.cfFormat = CF_HDROP
            tFMT.TYMED = TYMED_HGLOBAL
            tFMT.dwAspect = DVASPECT_CONTENT
            tFMT.lIndex = -1
            
            If pdo.QueryGetData(tFMT) = S_OK Then
                DebugAppend "GSIFN::QGD Ok"
                Dim sBuffer As String
                Dim nFiles As Long
                pdo.GetData tFMT, tSTG
                nFiles = DragQueryFileW(tSTG.data, &HFFFFFFFF, 0, 0)
                If nFiles > 1 Then DebugAppend "WARNING: Multiple names returned on item, only providing first"
                SysReAllocStringLen VarPtr(sBuffer), , DragQueryFileW(tSTG.data, 0&)
                DragQueryFileW tSTG.data, 0&, StrPtr(sBuffer), Len(sBuffer) + 1&
                GetShellItemFileName = sBuffer
                ReleaseStgMedium tSTG
            End If
    End Select
    DebugAppend "GetShellItemFileName::alt methods return=" & GetShellItemFileName
    End Function
    
    Private Function ThumbIDisNull(tID As WTS_THUMBNAILID) As Boolean
    Dim i As Long
    ThumbIDisNull = True
    For i = 0 To 15
        If tID.rgbKey(i) Then
            ThumbIDisNull = False
            Exit Function
        End If
    Next i
    End Function
    
    Private Function IndexItemCategory(id As Long, sName As String) As Long
    Dim i As Long
    For i = 0 To UBound(sItemCats)
        If sItemCats(i).lid = id Then
            IndexItemCategory = i
            Exit Function
        End If
    Next i
    Dim k As Long
    If (UBound(sItemCats) = 0) And (sItemCats(0).sName = "") Then
        sItemCats(0).lid = id
        sItemCats(0).sName = sName
    Else
        k = UBound(sItemCats)
        k = k + 1
        ReDim Preserve sItemCats(k)
        sItemCats(k).lid = id
        sItemCats(k).sName = sName
    End If
    IndexItemCategory = k
    End Function
    
    Public Sub HighlightColumnByProperty(sSysName As String, clrBack As Long)
    Dim i As Long
    Dim lp As LongPtr
    Dim cm As Long
    
    cm = Header_GetItemCount(hLVSHdr)
    For i = 0 To (cm - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
        If uColData(lp).szSystemName = sSysName Then
            ColumnSetBk i, clrBack
            Exit Sub
        End If
    Next i
    
    End Sub
    
    Public Sub HighlightColumn(nColumn As Long, clrBack As Long)
    If nColumn = -1 Then
        SendMessage hLVS, LVM_SETSELECTEDCOLUMN, -1&, ByVal 0&
        Exit Sub
    End If
    ColumnSetBk nColumn, clrBack
    End Sub
    
    Private Sub ColumnSetBk(nCol As Long, clr As Long)
    Dim pVis As IVisualProperties
    SendMessage hLVS, LVM_QUERYINTERFACE, VarPtr(IID_IVisualProperties), pVis
    If (pVis Is Nothing) Then
        DebugAppend "HighlightColumn::Failed to get IVisualProperties"
        Exit Sub
    End If
    pVis.SetColor VPCF_SORTCOLUMN, clr
    
    SendMessage hLVS, LVM_SETSELECTEDCOLUMN, nCol, ByVal 0&
    End Sub
    
    Private Sub ColumnSetSelColor(clr As Long)
    Dim pVis As IVisualProperties
    SendMessage hLVS, LVM_QUERYINTERFACE, VarPtr(IID_IVisualProperties), pVis
    If (pVis Is Nothing) Then
        DebugAppend "ColumnSetSelColor::Failed to get IVisualProperties"
        Exit Sub
    End If
    pVis.SetColor VPCF_SORTCOLUMN, clr
    
    Dim lCurCol As Long
    lCurCol = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOLUMN, 0&, ByVal 0&))
    If lCurCol >= 0& Then
        SendMessage hLVS, LVM_SETSELECTEDCOLUMN, lCurCol, ByVal 0&
    End If
    End Sub
    
    Private Sub LVSetInsertMark(hLiVw As LongPtr, nItem As Long)
    Dim lvim As LVINSERTMARK
    lvim.cbSize = LenB(lvim)
    lvim.iItem = nItem
    'lvim.dwFlags = LVIM_AFTER
    SendMessage hLiVw, LVM_SETINSERTMARK, 0&, lvim
    End Sub
    
    Private Function IsInArray(sFind As String, sAr As Variant) As Boolean
    Dim i As Long
    For i = LBound(sAr) To UBound(sAr)
        If LCase$(sAr(i)) = LCase$(sFind) Then
            IsInArray = True
            Exit Function
        End If
    Next i
    End Function
    
    Public Sub ClearSelection()
    ListView_SelectNone hLVS
    End Sub
    Private Sub SetSelectedItemArray()
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    
    'If pidlFQCur Then
    '    SetSelectedItemArrayEx
    '    Exit Sub
    'End If
    Dim apidl() As LongPtr
    Dim cpidl As Long
    Dim i As Long
    
    If m_sCurPath = "*CUSTOM" Then
        Dim pidlFQ As LongPtr, pidlPar As LongPtr, sip As IShellItem, upi As IParentAndItem, psfCust As IShellFolder, pidlc As LongPtr
        Dim nFocused As Long, lpFocused As LongPtr, lp As LongPtr
        nFocused = ListView_GetSelectedItem(hLVS)
        lpFocused = GetLVItemlParam(hLVS, nFocused)
        i = nFocused: lp = lpFocused
        pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(lp).sFullPath))
        SHCreateItemFromIDList pidlFQ, IID_IShellItem, sip
        Set upi = sip
        upi.GetParentAndItem pidlPar, psfCust, pidlc
        apidl(0) = pidlc
        cpidl = 1
        psfCust.GetUIObjectOf 0&, cpidl, apidl(0), IID_IContextMenu, 0&, pcm
        Call CoTaskMemFree(pidlFQ)
        Call CoTaskMemFree(pidlPar)
    Else
    
        i = LVI_NOITEM
        Do
            i = CLng(SendMessage(hLVS, LVM_GETNEXTITEM, i, ByVal LVNI_SELECTED))
            If (i <> LVI_NOITEM) Then
                lp = GetLVItemlParam(hLVS, i)
                ReDim Preserve apidl(cpidl)
                apidl(cpidl) = LVEntries(lp).pidlRel
                cpidl = cpidl + 1
            End If
        Loop Until (i = LVI_NOITEM)
    End If
    If cpidl Then
        Dim pdo As IDataObject
        psfCur.GetUIObjectOf 0&, cpidl, apidl(0), IID_IDataObject, 0&, pdo
        If (pdo Is Nothing) = False Then
            SHCreateShellItemArrayFromDataObject pdo, IID_IShellItemArray, siaSelected
        End If
    End If
    'ReDim apidl(0)
    'For i = 0 To UBound(sSelectedFiles)
    '    ReDim Preserve apidl(cpidl)
    '    DebugAppend "SetSelectedItemArray->Add " & sSelectedFiles(i)
    '    apidl(cpidl) = ILCreateFromPathW(StrPtr(sSelectedFiles(i)))
    '    If apidl(cpidl) = 0& Then 'try another way to get pidl
    '      apidl(cpidl) = ILCombine(pidlFQCur, tSelectedFiles(i).pidlRel)
    '    End If
    '    cpidl = cpidl + 1
    'Next
    'Set siaSelected = Nothing
    'SHCreateShellItemArrayFromIDLists cpidl, VarPtr(apidl(0)), siaSelected
    'For i = 0 To UBound(apidl)
    '    CoTaskMemFree apidl(i)
    'Next i
    
    
    '<EhFooter>
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.SetSelectedItemArray->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Sub SetSelectedItemArrayEx()
    Dim i As Long
    Dim lp As LongPtr
    Dim apidl() As LongPtr
    Dim cpidl As Long
    Dim j As Long
    
    i = LVI_NOITEM
    ReDim apidl(0)
    Do
        i = CLng(SendMessage(hLVS, LVM_GETNEXTITEM, i, ByVal LVNI_SELECTED))
        If (i <> LVI_NOITEM) Then
            lp = GetLVItemlParam(hLVS, i)
            ReDim Preserve apidl(cpidl)
            apidl(j) = ILCombine(pidlFQCur, LVEntries(lp).pidlRel)
            cpidl = cpidl + 1
        End If
    Loop Until (i = LVI_NOITEM)
    
    Set siaSelected = Nothing
    SHCreateShellItemArrayFromIDLists cpidl, VarPtr(apidl(0)), siaSelected
    For i = 0 To UBound(apidl)
        CoTaskMemFree apidl(i)
    Next i
    
    End Sub
    
    Public Function SetSelectedItemsEx(sName As String, Optional bDeselectPrev As Boolean = True, Optional nMaxMatches As Long = 0&, Optional iSelectType As SB_ITEMSEL_MODE = SBIM_FilesOnly, Optional bEnsureVisible As Boolean = True, Optional bCaseSensitive As Boolean = False, Optional bZipIsFile As Integer = 0) As Long
    'bDeselectPrev - Clears any existing selection.
    'nMaxMatches - If sName contains wildcards, specifies maximum matches. 0 = unlimited. Does not override Multiselect; so if Multiselect is False, any value larger than 1 is invalid.
    'iSelectType - Match sName against Files only, Folders only, or both.
    'bEnsureVisible - Scrolls the selected item into view. If multiple selections made, applied to the first match.
    'bCaseSensitive - Applies both with and without wildcards.
    'bZipIsFile - 0: Follow BrowseZip setting, 1: Always folder, 2: Always file
    'Returns files selected.
    'Note: First match receives focus.
    Dim i As Long
    Dim lp As LongPtr
    Dim lCnt As Long
    Dim sCp1 As String, sCp2 As String
    Dim nMt As Long
    Dim nEV As Long
    
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    If bDeselectPrev Then
        ListView_SetItemState hLVS, -1, 0&, LVIS_FOCUSED Or LVIS_SELECTED
    End If
    
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        If (bZipIsFile = 0) Or (LVEntries(lp).bZip = False) Or (iSelectType = SBIM_FilesAndFolders) Then
            If (iSelectType = SBIM_FilesOnly) And (LVEntries(lp).bFolder = True) Then GoTo nxt
            If (iSelectType = SBIM_FoldersOnly) And (LVEntries(lp).bFolder = False) Then GoTo nxt
        ElseIf bZipIsFile = 1 Then
            If iSelectType = SBIM_FilesOnly Then GoTo nxt
        ElseIf bZipIsFile = 2 Then
            If iSelectType = SBIM_FoldersOnly Then GoTo nxt
        End If
        If bCaseSensitive Then
            sCp1 = LVEntries(lp).sName: sCp2 = sName
        Else
            sCp1 = LCase$(sCp1): sCp2 = LCase$(sCp2)
        End If
        If PathMatchSpecW(StrPtr(sCp1), StrPtr(sCp2)) Then
            nMt = nMt + 1
            If nMt = 1 Then
                ListView_SetItemState hLVS, i, LVIS_FOCUSED Or LVIS_SELECTED, LVIS_FOCUSED Or LVIS_SELECTED
                nEV = i
            Else
                ListView_SetItemState hLVS, i, LVIS_SELECTED, LVIS_SELECTED
            End If
            If ((nMaxMatches > 0&) And (nMt = nMaxMatches)) Or (m_MultiSelect = False) Then Exit For
        End If
    nxt:
    Next i
    LVSetSelection
    If nMt Then SendMessage hLVS, LVM_ENSUREVISIBLE, nEV, ByVal 1&
    SetSelectedItemsEx = nMt
    End Function
    
    Private Function LVDoubleClick(lIndex As Long) As LongPtr
    DebugAppend "LVDoubleClick.Entry::idx=" & lIndex & ",bBlockLoad=" & bBlockLoad
    If lIndex = -1 Then Exit Function
    Dim i As Long
    Dim li As Long
    Dim lp As LongPtr
    Dim siItem As IShellItem
    Dim sPath As String
    
    On Error GoTo e0
    
    lIndex = ListView_GetSelectedItem(hLVS)
    lp = GetLVItemlParam(hLVS, lIndex)
    LVDoubleClick = lp
    
    If lIndex < 0& Then Exit Function
    
    If m_NoDblClkNav Then
        LVSetSelection
        RaiseEvent FileExecute(tSelectedFile.sFullPath, siFocus)
        Exit Function
    End If
    
    DebugAppend "LVDoubleClick idx=" & lIndex & ",lp=" & lp & ",file=" & LVEntries(lp).sName & " in " & LVEntries(lp).sParentFull
    Call SHCreateItemFromParsingName(StrPtr(LVEntries(lp).sFullPath), Nothing, IID_IShellItem, siItem)
    If (siItem Is Nothing) Then
        DebugAppend "Failed to get siItem"
        Dim pidlFQItem As LongPtr
        pidlFQItem = ILCombine(pidlFQCur, LVEntries(lp).pidlRel)
        SHCreateItemFromIDList pidlFQItem, IID_IShellItem, siItem
        If (siItem Is Nothing) Then
            DebugAppend "Alternate siItem creation failed"
        End If
        If pidlFQItem Then CoTaskMemFree pidlFQItem
    End If
    If (siItem Is Nothing) = False Then
        If LVEntries(lp).bFolder Then
            If bBlockLoad Then Exit Function
            If (m_LockNav = False) And (m_NoDblClkNav = False) Then
                DebugAppend "LVDoubleClick.OpenFolder"
                bSuppress = True
                i = AddStandardFSItem(siItem, li, True)
                Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
                bSuppress = False
    '            sPath = LVEntries(lp).sFullPath
    '            LVLoadFolder sPath, , True, siItem
                Set siDirect = siItem
                LVLoadFolder "", True
            Else
                LVSetSelection
                RaiseEvent FileExecute(tSelectedFile.sFullPath, siFocus)
            
            End If
        ElseIf ((LVEntries(lp).dwAttrib And SFGAO_LINK) = SFGAO_LINK) And (m_FollowLinks = True) Then
            If bBlockLoad Then Exit Function
            Dim siLink As IShellItem, sLink As String, pidl As LongPtr
            pidl = GetLinkTargetPIDL(siItem)
            If pidl Then
                SHCreateItemFromIDList pidl, IID_IShellItem, siLink
            Else
                sLink = GetLinkTargetPP(siItem)
                If sLink = "" Then
                    DebugAppend "LVDoubleClick::Unable to resolve link."
                    Exit Function
                Else
                    SHCreateItemFromParsingName StrPtr(sLink), Nothing, IID_IShellItem, siLink
                End If
                
            End If
            Dim dwAtr As SFGAO_Flags
            If (siLink Is Nothing) = False Then
                siLink.GetAttributes SFGAO_FOLDER Or SFGAO_STREAM, dwAtr
                If (((dwAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And (m_BrowseZip = True)) Or (((dwAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((dwAtr And SFGAO_STREAM) = 0) And (m_BrowseZip = False)) Then
                    If (m_LockNav = False) And (m_NoDblClkNav = False) Then
                        DebugAppend "LVDoubleClick.OpenFolderFromLink"
            
                        bSuppress = True
                        i = AddStandardFSItem(siLink, li, True)
                        Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
                        bSuppress = False
                        If sPath = "" Then
                            BrowserOpenItem siLink
                        Else
                            LVLoadFolder sLink, , True, siLink
                        End If
                    Else
                        LVSetSelection
                        RaiseEvent FileExecute(tSelectedFile.sFullPath, siFocus)
                        
                    End If
                Else
                    LVSetSelection
                    RaiseEvent FileExecute(tSelectedFile.sFullPath, siFocus)
                End If
            Else
                DebugAppend "LVDoubleClick::Unable to create link item."
            End If
            If pidl Then CoTaskMemFree pidl
        Else
                LVSetSelection
                DebugAppend "TileInfo=" & GetShellItemPropString(siFocus, PKEY_PropList_TileInfo)
                RaiseEvent FileExecute(tSelectedFile.sFullPath, siFocus)
    
        End If
    Else
        DebugAppend "LVDoubleClick->Failed to get IShellItem from parsing name"
    End If
    Exit Function
    e0:
    DebugAppend "LVDoubleClick->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function GetLinkTarget(siLink As IShellItem) As String
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim isl As IShellLinkW
    Dim sTmp As String
    Dim wfd As WIN32_FIND_DATAW
    siLink.BindToHandler 0&, BHID_SFUIObject, IID_IShellLinkW, isl
    If (isl Is Nothing) = False Then
        sTmp = String$(MAX_PATH, 0)
        isl.GetPath sTmp, MAX_PATH, wfd, 0&
        sTmp = TrimNullW(sTmp)
        GetLinkTarget = sTmp
    End If
     
    Exit Function
    e0:
        DebugAppend "ucShellTree.GetLinkTarget->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function GetLinkTargetPP(siLink As IShellItem) As String
    Dim si2 As IShellItem2
    Dim lp As LongPtr
    Set si2 = siLink
    si2.GetString PKEY_Link_TargetParsingPath, lp
    GetLinkTargetPP = LPWSTRtoStr(lp)
    DebugAppend "GetLinkTargetPP=" & GetLinkTargetPP, 2
    If GetLinkTargetPP = "" Then
        'Try the old way as a fallback
        GetLinkTargetPP = GetLinkTarget(siLink)
    End If
    End Function
    
    Private Function GetLinkTargetPIDL(siLink As IShellItem) As LongPtr
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    
    Dim isl As IShellLinkW
    siLink.BindToHandler 0&, BHID_SFUIObject, IID_IShellLinkW, isl
    If (isl Is Nothing) = False Then
        GetLinkTargetPIDL = isl.GetIDList()
    '    dbg_linkinfo isl
    End If
     
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellTree.GetLinkTargetPIDL->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function GetLinkAttribsByPath(sLink As String) As Long
    Dim cSL As ShellLinkW
    Dim ipf As IPersistFile
    
    Set cSL = New ShellLinkW

    Set ipf = cSL
    ipf.Load sLink, STGM_READ
    cSL.Resolve hLVS, 0&
    
    Dim pidl As LongPtr
    pidl = cSL.GetIDList()
    If pidl Then
        GetLinkAttribsByPath = GetFileAtrDirPidl(pidl)
    End If
    Set ipf = Nothing
    End Function
    
    Private Function ExpandEnvVars(sIn As String) As String
    'Expand environment variables
    Dim sTmp As String
    Dim chs As Long
    
    sTmp = String$(MAX_PATH, 0)
    chs = ExpandEnvironmentStringsW(StrPtr(sIn), StrPtr(sTmp), MAX_PATH)
    If chs > 1& Then
        ExpandEnvVars = Left$(sTmp, chs - 1&) 'It includes a null terminator
    Else
        ExpandEnvVars = sIn
    End If
    
    End Function
    Private Function LVItemClick(lIndex As Long) As Long
    'Single click, update selection
    DebugAppend "LVItemClick " & lIndex
    'UserControl.SetFocus
    'SetFocus hLVS
    End Function
    
    Private Function LVItemGetDispColor(nItem As Long) As Long
    'Compressed = blue, encrypted = green
    If ((m_NameColors = SBCP_UseExplorer) And (m_NCExVal = SBCP_ForceOff)) Or (m_NameColors = SBCP_ForceOff) Then
        LVItemGetDispColor = clrFore 'm_SysClrText
        Exit Function
    End If
    Dim lp As LongPtr
    lp = GetLVItemlParam(hLVS, nItem)
    'Debug.Print "QueryColor " & LVEntries(lp).sName
    
    If (LVEntries(lp).dwAttrib And SFGAO_COMPRESSED) = SFGAO_COMPRESSED Then
        LVItemGetDispColor = vbBlue
    '    DebugAppend "BLUEITEM: " & LVEntries(lp).sName
        Exit Function
    End If
    If (LVEntries(lp).dwAttrib And SFGAO_ENCRYPTED) = SFGAO_ENCRYPTED Then
        LVItemGetDispColor = &HD9213
        Exit Function
    End If
    OleTranslateColor clrFore, 0&, LVItemGetDispColor
    End Function
    
    Public Function ItemIsFolder(Optional lPos As Long = -1, Optional sName As String = "", Optional sFullPath As String = "") As Boolean
    'Only one of these arguments needs to be given
    If lPos >= 0 Then
        Dim lp As LongPtr
        lp = GetLVItemlParam(hLVS, lPos)
        ItemIsFolder = LVEntries(lp).bFolder
        Exit Function
    End If
    Dim i As Long
    If sName <> "" Then
        For i = 0 To UBound(LVEntries)
            If (LVEntries(i).sName = sName) And (LVEntries(i).bDeleted = False) Then
                ItemIsFolder = LVEntries(i).bFolder
                Exit Function
            End If
        Next i
    End If
    If sFullPath <> "" Then
        For i = 0 To UBound(LVEntries)
            If (LVEntries(i).sFullPath = sFullPath) And (LVEntries(i).bDeleted = False) Then
                ItemIsFolder = LVEntries(i).bFolder
                Exit Function
            End If
        Next i
    End If
    End Function
    
    Private Function GetLVItemIndexByName(sTg As String) As Long
    Dim i As Long
    
    GetLVItemIndexByName = -1&
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).sName = sTg Then
                GetLVItemIndexByName = i
                Exit Function
            End If
        End If
    Next
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).sNameParsing = sTg Then
                GetLVItemIndexByName = i
                Exit Function
            End If
        End If
    Next
    
    End Function
    
    Private Function GetPathFromPIDLW(pidl As LongPtr) As String
      Dim pszPath As String
      pszPath = String(MAX_PATH, 0)
      If SHGetPathFromIDListW(pidl, StrPtr(pszPath)) Then
        If InStr(pszPath, vbNullChar) Then
            GetPathFromPIDLW = Left$(pszPath, InStr(pszPath, vbNullChar) - 1)
        End If
      End If
    End Function
    
    Private Function GetDefaultDropEffect(pDataObj As IDataObject) As DROPEFFECTS
    'Calculate the most likely left-button drop effect based on whether the dropped files have the same root as the current path
    GetDefaultDropEffect = DROPEFFECT_COPY
    On Error GoTo e0
    Dim sCP As String, lpCP As LongPtr
    If m_sCurPath = "" Then
        sCP = GetPathFromPIDLW(pidlFQCur)
        If sCP = "" Then
            If (siDirect Is Nothing) = False Then
                siDirect.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpCP
                sCP = LPWSTRtoStr(lpCP)
            End If
        End If
    Else
        sCP = m_sCurPath
    End If
    If (InStr(sCP, ".zip\")) Or (InStr(sCP, ".cab\")) Then
        'Inside a zip; default action is copy
        GetDefaultDropEffect = DROPEFFECT_COPY
        Exit Function
    End If
    If lvDragOverIdx >= 0& Then
        Dim lpi As LongPtr
        lpi = GetLVItemlParam(hLVS, lvDragOverIdx)
        If lpi >= 0& Then
            If LVEntries(lpi).lDropTarget = 3 Then 'Supports drop but is not a zip or folder
                GetDefaultDropEffect = DROPEFFECT_COPY
                Exit Function
            End If
        End If
    End If
    
    sCP = GetPathRoot(sCP)
    If sCP = "" Then 'something went wrong, let's just go with copy
        GetDefaultDropEffect = DROPEFFECT_COPY
        Exit Function
    End If
    
    If bGotDropPathList = False Then
        Dim psia As IShellItemArray
        SHCreateShellItemArrayFromDataObject pDataObj, IID_IShellItemArray, psia
        If (psia Is Nothing) = False Then
            Dim pEnum As IEnumShellItems
            Dim sia As IShellItem
            Dim lpc As LongPtr, szc As String
            Dim pcl As Long
            Dim k As Long
            ReDim mDropPathList(0)
            psia.EnumItems pEnum
            If (pEnum Is Nothing) = False Then
               
                Do While pEnum.Next(1&, sia, pcl) = S_OK
                    sia.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpc
                    ReDim Preserve mDropPathList(k)
                    mDropPathList(k) = LPWSTRtoStr(lpc)
                    k = k + 1
                Loop
            End If
            bGotDropPathList = True
        End If
    End If
    Dim i As Long
    For i = 0 To UBound(mDropPathList)
        If GetPathRoot(mDropPathList(i)) <> sCP Then
            DebugAppend "GetDefaultDropEffect root mismatch " & GetPathRoot(mDropPathList(i)) & "|" & sCP
            GetDefaultDropEffect = DROPEFFECT_COPY
            Exit Function
        End If
    Next i
    GetDefaultDropEffect = DROPEFFECT_MOVE
    Exit Function
    e0:
    DebugAppend "GetDefaultDropEffect.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    
    Private Function LVHandleDropEx(pDataObj As IDataObject, PT As POINT, pdwEffect As DROPEFFECTS, dwKeys As Long) As Long
    On Error GoTo e0
    Dim pDT As IDropTarget
    Dim pidlCur As LongPtr
    Dim lButton As Long
    Dim lIdx As Long
    Dim sTmp As String
    Dim lpdoi As LongPtr
    Dim i As Long
    Dim psfDesk As IShellFolder
    Call SHGetDesktopFolder(psfDesk)
    If ddRightButton Then
        lButton = MK_RBUTTON
    Else
        lButton = MK_LBUTTON
    End If
    If sFolder <> "" Then
    DebugAppend "LVHandleDropEx sFolder[" & sFolder & "]"
    '        pidlCur = ILCreateFromPathW(StrPtr(sFolder))
            If pidlCur = 0& Then
                If sFolder = m_sCurPath Then
                    pidlCur = pidlFQCur
                ElseIf m_sCurPath = sLibRoot2 Then
                    Dim sDef As String, lpDef As LongPtr
                    Dim sLib As String
                    Dim pidlLib As LongPtr
                    Dim siLibDrop As IShellItem
                    Dim pSL As ShellLibrary
                    lIdx = GetLVItemIndexByName(Right$(sFolder, Len(sFolder) - InStrRev(sFolder, "\")))
                    pidlLib = ILCombine(pidlFQCur, LVEntries(lIdx).pidlRel)
                    
                    SHCreateItemFromIDList pidlLib, IID_IShellItem, siLibDrop
                    If (siLibDrop Is Nothing) = False Then
                        Dim siLibDef As IShellItem
                        
                        Set pSL = New ShellLibrary
                        pSL.LoadLibraryFromItem siLibDrop, STGM_READ
                        pSL.GetDefaultSaveFolder DSFT_DETECT, IID_IShellItem, siLibDef
                        If (siLibDef Is Nothing) = False Then
                            siLibDef.GetDisplayName SIGDN_FILESYSPATH, lpDef
                            sDef = LPWSTRtoStr(lpDef)
                            pidlCur = ILCreateFromPathW(StrPtr(sDef))
                        End If
                    End If
    '                sLib = sLibRoot & Right$(sFolder, Len(sFolder) - InStrRev(sFolder, "\"))
    '                sDef = LibGetDefLoc2(sLib)
    '                pidlCur = ILCreateFromPathW(StrPtr(sDef))
                ElseIf Left$(m_sCurPath, Len(sFolder)) = sFolder Then 'dropped on folder within current path
                    sTmp = sFolder
                    If (Right$(sTmp, 1) = "\") And (Len(sTmp) > 3) Then
                        sTmp = Left$(sTmp, Len(sTmp) - 1)
                        sTmp = Right$(sTmp, Len(sTmp) - InStrRev(sTmp, "\"))
                    End If
                    lIdx = GetLVItemIndexByName(sTmp)
                    If lIdx > -1& Then
                        DebugAppend "DropOnItem Got idx=" & lIdx & ", name=" & LVEntries(lIdx).sName
                        pidlCur = ILCombine(pidlFQCur, LVEntries(lIdx).pidlRel)
                    End If
                End If
            End If
                    
                    
            DebugAppend "OnFolderDrop will clear " & lvDragOverIdx
            If lvDragOverIdx <> -1 Then
                'LVIS_DROPHILITED doesn't automatically clear when the selection changes or is clicked, must clear manually
                ListView_SetItemState hWnd, lvDragOverIdx, 0&, LVIS_DROPHILITED Or LVIS_FOCUSED Or LVIS_SELECTED
                ListView_SetItemState hLVS, lvDragOverIdx, 0&, LVIS_DROPHILITED
                'DebugAppend   "State(5)=" & ListView_GetItemState(hLVS, 5, LVIS_DROPHILITED)
                ListView_SetItemState hLVS, lvDragOverIdx, LVIS_SELECTED, LVIS_SELECTED
            End If
    
    Else
        If m_sAltDrop <> "" Then
            DebugAppend "LVHandleDropEx m_sAltDrop[" & m_sAltDrop & "]"
            pidlCur = ILCreateFromPathW(StrPtr(m_sAltDrop)) 'drop to a library's default save folder
            If pidlCur = 0& Then
                If sFolder = m_sAltDrop Then
                    pidlCur = pidlFQCur
                ElseIf Left$(m_sCurPath, Len(m_sAltDrop)) = m_sAltDrop Then 'dropped on folder within current path
                    sTmp = m_sAltDrop
                    If (Right$(sTmp, 1) = "\") And (Len(sTmp) > 3) Then
                        sTmp = Left$(sTmp, Len(sTmp) - 1)
                        sTmp = Right$(sTmp, Len(sTmp) - InStrRev(sTmp, "\"))
                    End If
                    lIdx = GetLVItemIndexByName(sTmp)
                    If lIdx > -1& Then
                        pidlCur = ILCombine(pidlFQCur, LVEntries(lIdx).pidlRel)
                    End If
                End If
            End If
        Else
            DebugAppend "LVHandleDropEx m_sCurPath[" & m_sCurPath & "],pidlFQCur=" & pidlFQCur
            pidlCur = pidlFQCur
        End If
    End If
    If pidlCur = 0& Then
        If lvDragOverIdx >= 0& Then
            lpdoi = GetLVItemlParam(hLVS, lvDragOverIdx)
            DebugAppend "DOI(" & lvDragOverIdx & ") " & LVEntries(lpdoi).sName
            DebugAppend sFolder
            pidlCur = ILCreateFromPathW(StrPtr(sFolder))
            If pidlCur Then
                psfDesk.GetUIObjectOf 0&, 1&, pidlCur, IID_IDropTarget, 0&, pDT
            End If
            If (pDT Is Nothing) Then
                CoTaskMemFree pidlCur
                pidlCur = ILCombine(pidlFQCur, LVEntries(lpdoi).pidlRel)
                psfDesk.GetUIObjectOf 0&, 1&, pidlCur, IID_IDropTarget, 0&, pDT
            End If
            If (pDT Is Nothing) Then
                CoTaskMemFree pidlCur
                psfCur.GetUIObjectOf 0&, 1&, LVEntries(lpdoi).pidlRel, IID_IDropTarget, 0&, pDT
            End If
        Else
            pidlCur = pidlFQCur
        End If
    Else
    
        psfDesk.GetUIObjectOf 0&, 1&, pidlCur, IID_IDropTarget, 0&, pDT
        
        If (pDT Is Nothing) Then
            If (sFolder <> "") And (sFolder <> m_sCurPath) And (lvDragOverIdx >= 0&) Then
                lpdoi = GetLVItemlParam(hLVS, lvDragOverIdx)
                psfCur.GetUIObjectOf 0&, 1&, LVEntries(lpdoi).pidlRel, IID_IDropTarget, 0&, pDT
            ElseIf (lvDragOverIdx = -1&) Then
                If (siCurPath Is Nothing) = False Then
                    siCurPath.BindToHandler 0&, BHID_SFUIObject, IID_IDropTarget, pDT
                End If
                If (pDT Is Nothing) Then
                    If m_sCurPath <> "" Then
                        Dim pidlTryAgain As LongPtr
                        pidlTryAgain = ILCreateFromPathW(StrPtr(m_sCurPath))
                        psfDesk.GetUIObjectOf 0&, 1&, pidlTryAgain, IID_IDropTarget, 0&, pDT
                        CoTaskMemFree pidlTryAgain
                    End If
                End If
            End If
        End If
    End If
    If (pDT Is Nothing) = False Then
        DebugAppend "Got drop target, dropping..."
        Dim ptt As LongLong
        CopyMemory ptt, PT, LenB(PT)
        pDT.DragEnter pDataObj, lButton, ptt, pdwEffect
        pDT.Drop pDataObj, lButton, ptt, DROPEFFECT_MOVE Or DROPEFFECT_COPY Or DROPEFFECT_LINK
        LVHandleDropEx = pdwEffect
        
        Dim siTarget As IShellItem
        Dim lpTar As LongPtr, sTar As String
        Dim sFilesOut() As String
        Dim nFilesOut As Long
        ReDim sFilesOut(0)
        
        Dim psia As IShellItemArray
        SHCreateShellItemArrayFromDataObject pDataObj, IID_IShellItemArray, psia
        If (psia Is Nothing) = False Then
            Dim pEnum As IEnumShellItems
            Dim sia As IShellItem
            Dim lpc As LongPtr, szc As String
            Dim pcl As Long
            psia.EnumItems pEnum
            If (pEnum Is Nothing) = False Then
                Do While pEnum.Next(1&, sia, pcl) = S_OK
                    sia.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpc
                    ReDim Preserve sFilesOut(nFilesOut)
                    sFilesOut(nFilesOut) = LPWSTRtoStr(lpc)
                    nFilesOut = nFilesOut + 1
                Loop
            End If
        End If
        SHCreateItemFromIDList pidlCur, IID_IShellItem, siTarget
        If (siTarget Is Nothing) = False Then
            siTarget.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpTar
            sTar = LPWSTRtoStr(lpTar)
        End If
        RaiseEvent DropFiles(sFilesOut, psia, pDataObj, sTar, siTarget, pdwEffect, dwKeys, PT.x, PT.y)
        UpdateStatus m_str_FilesDropped
    Else
        DebugAppend "No Drop Target"
        LVHandleDropEx = -1
    End If
    
    CoTaskMemFree pidlCur
    Exit Function
    e0:
    LVHandleDropEx = -1
    DebugAppend "LVHandleDropEx->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function GetFileNamesFromDataObject(pDataObj As IDataObject) As String()
        Dim sf() As String
        ReDim sf(0)
        Dim psia As IShellItemArray
        Dim piesi As IEnumShellItems
        Dim pItem As IShellItem
        Dim lpFile As LongPtr
        Dim pcl As Long
        Dim nF As Long
        Call SHCreateShellItemArrayFromDataObject(pDataObj, IID_IShellItemArray, psia)
        If (psia Is Nothing) = False Then
            psia.EnumItems piesi
            Do While (piesi.Next(1, pItem, pcl) = NOERROR)
                pItem.GetDisplayName SIGDN_FILESYSPATH, lpFile
                ReDim Preserve sf(nF)
                sf(nF) = LPWSTRtoStr(lpFile)
                DebugAppend "Drop::" & sf(nF)
                nF = nF + 1
            Loop
        End If
    GetFileNamesFromDataObject = sf
    End Function
    '
    'The following function is deprecated, but may be of interest if you're having issues with Drag Drop, or want
    'a custom menu for dropping with the right button, so it's included but commented out as it needs some work
    'in order to run.
    'Private Function LVHandleDrop(sFiles() As String) As Long
    'Dim bCopyDef As Boolean
    'Dim idCmd As Long
    'Dim fx As DROPEFFECTS
    'Dim i As Long
    'On Error GoTo e0
    ''If on same drive, Move is default; otherwise Copy is default
    'If Left$(sFiles(0), 3) = Left$(m_sCurPath, 3) Then
    '    bCopyDef = False
    'Else
    '    bCopyDef = True
    'End If
    ''If GetAsyncKeyState(VK_RBUTTON) Then
    'If (GetKeyState(VK_RBUTTON) And &H80) = &H80 Then
    '    Dim hMenu As LongPtr
    '    Dim mii As MENUITEMINFOW
    '    Dim PT As POINT
    '    Const sCopy As String = "&Copy here"
    '    Const sMove As String = "&Move here"
    '    Const sLink As String = "Create &shortcuts here"
    '    Const sCan As String = "Ca&ncel"
    '
    '
    '
    '    hMenu = CreatePopupMenu()
    '
    '    With mii
    '        .cbSize = LenB(mii)
    '        .fMask = MIIM_ID Or MIIM_STRING
    '        .wID = 100
    '        .cch = Len(sCopy)
    '        .dwTypeData = StrPtr(sCopy)
    '        If bCopyDef Then
    '            .fMask = .fMask Or MIIM_STATE
    '            .fState = MFS_DEFAULT
    '        End If
    '
    '        InsertMenuItemW hMenu, 0&, True, mii
    '
    '        .fMask = MIIM_ID Or MIIM_STRING
    '        .wID = 101
    '        .cch = Len(sMove)
    '        .dwTypeData = StrPtr(sMove)
    '        If bCopyDef = False Then
    '            .fMask = .fMask Or MIIM_STATE
    '            .fState = MFS_DEFAULT
    '        End If
    '
    '        InsertMenuItemW hMenu, 1&, True, mii
    '
    '        .fMask = MIIM_ID Or MIIM_STRING
    '        .wID = 102
    '        .cch = Len(sLink)
    '        .dwTypeData = StrPtr(sLink)
    '
    '        InsertMenuItemW hMenu, 2&, True, mii
    '
    '        .fMask = MIIM_TYPE
    '        .fType = MFT_SEPARATOR
    '
    '        InsertMenuItemW hMenu, 3&, True, mii
    '
    '        .fMask = MIIM_ID Or MIIM_STRING
    '        .wID = 104
    '        .cch = Len(sCan)
    '        .dwTypeData = StrPtr(sCan)
    '
    '        InsertMenuItemW hMenu, 4&, True, mii
    '    End With
    '
    '    Call GetCursorPos(PT)
    '
    '    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.X, PT.Y, 0&, hLVS, 0&)
    '    Select Case idCmd
    '
    '        Case 100: fx = DROPEFFECT_COPY
    '        Case 101: fx = DROPEFFECT_MOVE
    '        Case 102: fx = DROPEFFECT_LINK
    '        Case 104: fx = DROPEFFECT_NONE
    '
    '    End Select
    'Else
    '    If bCopyDef Then
    '        fx = DROPEFFECT_COPY
    '    Else
    '        fx = DROPEFFECT_MOVE
    '    End If
    'End If
    'If fx = DROPEFFECT_NONE Then
    '    LVHandleDrop = DROPEFFECT_NONE
    '    Exit Function
    'End If
    'Dim pFO As FileOperation
    'Set pFO = New FileOperation
    '
    'Dim siDest As IShellItem
    'SHCreateItemFromParsingName StrPtr(m_sCurPath), Nothing, IID_IShellItem, siDest
    '
    'Dim siItems As IShellItemArray
    'Dim apidl() As LongPtr
    'Dim cpidl As Long
    '
    'ReDim apidl(UBound(sFiles))
    '
    'For i = 0 To UBound(apidl)
    '    apidl(i) = ILCreateFromPathW(StrPtr(sFiles(i)))
    'Next
    'cpidl = UBound(apidl) + 1
    'SHCreateShellItemArrayFromIDLists cpidl, VarPtr(apidl(0)), siItems
    'If (siItems Is Nothing) Or (siDest Is Nothing) Then
    '    LVHandleDrop = DROPEFFECT_NONE
    '    Exit Function
    'End If
    '
    '
    'Select Case fx
    '    Case DROPEFFECT_COPY
    '
    '        pFO.CopyItems siItems, siDest
    '
    '
    '    Case DROPEFFECT_MOVE
    '        pFO.MoveItems siItems, siDest
    '    Case DROPEFFECT_LINK
    '        For i = 0 To UBound(sFiles)
    '            SaveNewLink sFiles(i) & ".lnk", m_sCurPath
    '        Next i
    'End Select
    'pFO.SetOwnerWindow hLVS
    'pFO.SetOperationFlags IFO_ALLOWUNDO
    'pFO.PerformOperations
    '
    'bSuppress = True
    'LVLoadFolder m_sCurPath 'refresh
    'bSuppress = False
    '
    'LVHandleDrop = fx
    'RaiseEvent DropFiles(sFiles, fx)
    '
    'Exit Function
    'e0:
    'DebugAppend "LVHandleDrop->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '
    'End Function
    
    Private Function pvCreateColListView() As Long
    Dim dwStyle As ucsb_LVStyles
    Dim dwStyleEx As ucsb_LVStylesEx
    Dim prc As RECT
    
    dwStyle = LVS_AUTOARRANGE Or LVS_SHOWSELALWAYS Or LVS_ALIGNTOP Or LVS_REPORT Or _
                    WS_VISIBLE Or WS_CHILD Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN
    
    dwStyleEx = LVS_EX_CHECKBOXES Or LVS_EX_AUTOSIZECOLUMNS
    
    Call GetClientRect(pbColumns.hWnd, prc)
    
     
    hLVC = CreateWindowExW(0&, StrPtr(WC_LISTVIEW), 0&, dwStyle, 0&, 16 * m_ScaleY, prc.Right - (0 * m_ScaleX), prc.Bottom - (40 * m_ScaleY), pbColumns.hWnd, 0&, App.hInstance, ByVal 0&)
    
    DebugAppend "hLVC=" & hLVC & ",right=" & prc.Right & ",btm=" & prc.Bottom, 9
    Dim swt1 As String
    swt1 = "explorer"
    Call SetWindowTheme(hLVC, StrPtr(swt1), 0&)
    
    ListView_SetExtendedStyle hLVC, dwStyleEx
    
    hLVCHdr = SendMessage(hLVC, LVM_GETHEADER, 0&, ByVal 0&)
    
    'Dim dwHdrStyle As ucsb_HeaderStyles
    'dwHdrStyle = GetWindowLong(hLVCHdr, GWL_STYLE)
    'dwHdrStyle = dwHdrStyle Or HDS_FILTERBAR
    'Call SetWindowLong(hLVCHdr, GWL_STYLE, dwHdrStyle)
    If bColLVInheritFont Then
        SendMessage hLVC, WM_SETFONT, hFontLVMain, ByVal 1&
        If hFontLVHdrMain Then
            SendMessageW hLVCHdr, WM_SETFONT, hFontLVHdrMain, ByVal 1&
        Else
            SendMessageW hLVCHdr, WM_SETFONT, m_hFontMain, ByVal 1&
        End If
    End If
    
    If Ambient.UserMode Then
        ' If ssc_Subclass(hLVC, , 19, , , True, True) Then
        '     Call ssc_AddMsg(hLVC, MSG_BEFORE, ALL_MESSAGES)
        '     Call ssc_AddMsg(hLVC, MSG_AFTER, WM_NCMOUSELEAVE, WM_PAINT, WM_VSCROLL, WM_LBUTTONUP, WM_MOUSEMOVE)
        ' End If
        Subclass2 hLVC, AddressOf LVCWndProc, hLVC
    End If
    
    Dim lvcol As LVCOLUMNW
    
    lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
    lvcol.CX = prc.Right - 20
    lvcol.cchTextMax = Len(scc_PropCol) + 1
    lvcol.pszText = StrPtr(scc_PropCol)
    Call SendMessage(hLVC, LVM_INSERTCOLUMNW, 0&, lvcol)
    
    If bEnableColumnAdvancedMode Then
        Dim HDI As HDITEMW
        HDI.Mask = HDI_FORMAT Or HDI_LPARAM 'Or HDI_TEXT Or HDI_STATE
        HDI.fmt = HDF_SPLITBUTTON Or HDF_STRING
        HDI.lParam = 0&
        'HDI.cchTextMax = Len(scc_PropCol)
        'HDI.pszText = StrPtr(scc_PropCol & vbNullChar)
        Call SendMessage(hLVCHdr, HDM_SETITEMW, 0, HDI)
    End If
    
    End Function
    
    Private Sub pvCreateUpDownForCol(Optional bArrows As Boolean = False)
    Dim rcLV As RECT, rcWin As RECT
    GetClientRect hLVC, rcLV
    DebugAppend "hUpDown=" & hUpDown & ",rct=" & rcLV.Top & ",rcb=" & rcLV.Bottom & ",rcr=" & rcLV.Right
    GetWindowRect hLVC, rcWin
    DebugAppend "Window=" & (rcWin.Bottom - rcWin.Top)
    'rcLV.Right + 1rcLV.Bottom /rcLV.Bottom \ 2
    Dim dwStyle As Long
    dwStyle = UDS_ALIGNRIGHT Or WS_VISIBLE Or WS_CHILD Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN
    If bArrows Then
        dwStyle = dwStyle Or UDS_ARROWKEYS
    End If
    hUpDown = CreateWindowExW(0&, StrPtr(UPDOWN_CLASS), StrPtr("Up Down"), dwStyle, 0, 0, 20 * m_ScaleX, 40 * m_ScaleY, pbColumns.hWnd, 0&, App.hInstance, ByVal 0&)
    SendMessage hUpDown, UDM_SETBUDDY, hLVC, ByVal 0&
    Dim lCnt As LongPtr
    lCnt = SendMessage(hLVC, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    SendMessage hUpDown, UDM_SETRANGE, 0&, ByVal lCnt
    'SetWindowPos hUpDown, hLVC, rcLV.Right + 10, 120, 0&, 0&, SWP_NOSIZE
    End Sub
    Private Function LVCColMenu() As Long
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
    Dim k As Long
    
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_STRING Or MIIM_ID
        .wID = widLVCTop
        .dwTypeData = StrPtr(mn_ColTop)
        .cch = Len(mn_ColTop)
        Call InsertMenuItemW(hMenu, 0, True, mii)
         
        .fMask = MIIM_ID Or MIIM_TYPE
        .fType = MFT_SEPARATOR
        .wID = 0
        Call InsertMenuItemW(hMenu, 1, True, mii)
    
        .fMask = MIIM_STRING Or MIIM_ID Or MIIM_STATE
        .wID = widLVCCol
        .dwTypeData = StrPtr(mn_ColAdv)
        .cch = Len(mn_ColAdv)
        .fState = IIf(bLVCAdv, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 2, True, mii)
    
    End With
    
    Call GetCursorPos(PT)
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_RIGHTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD Or TPM_VERNEGANIMATION, PT.x, PT.y, 0, hLVC, 0)
    
    If idCmd Then
        Select Case idCmd
            Case widLVCCol
                If bLVCAdv Then
                    bLVCAdv = False
                    LVCSetAdvancedMode 0&
                Else
                    bLVCAdv = True
                    LVCSetAdvancedMode 1&
                End If
            Case widLVCTop
                    Dim lSel As Long
                    lSel = ListView_GetSelectedItem(hLVC)
                    If lSel <> LVI_NOITEM Then
                        LVMoveItem hLVC, lSel, 0&
                    End If
            
        End Select
    End If
    LVCColMenu = idCmd
    End Function
    
    Private Sub LVCSetAdvancedMode(fEnable As Long)
    Dim i As Long
    Dim lPos As Long
    'todo: double and halve size
    Call SendMessage(hLVC, LVM_DELETEALLITEMS, 0&, ByVal 0&)
    FastDoEvents
    If fEnable = 0& Then
        Call SendMessage(hLVC, LVM_DELETECOLUMN, 1&, ByVal 0&)
        LVCSortArrowsClear
        If UserControl.Width > 2500 Then
            pbColumns.Width = 2500
        End If
    Else
        Dim lvcol As LVCOLUMNW
    
        lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvcol.CX = 160 * m_ScaleX
        lvcol.cchTextMax = Len(scc_AdvCol) + 1
        lvcol.pszText = StrPtr(scc_AdvCol)
        Call SendMessage(hLVC, LVM_INSERTCOLUMNW, 1&, lvcol)
        Dim HDI As HDITEMW
        HDI.Mask = HDI_LPARAM
        HDI.lParam = 1&
        Call SendMessage(hLVCHdr, HDM_SETITEMW, 1&, HDI)
        If UserControl.Width > 5000 Then
            pbColumns.Width = 5000
        End If
    End If
    
    bLVCFlagLoad = True
    DebugAppend "Add ColHead;proceed w/ ub=" & UBound(uColData) & ",dciub=" & UBound(lDefColIdx) & ",1=" & lDefColIdx(1)
    For i = 0 To UBound(uColData)
        If (i <> lDefColIdx(0)) And (i <> lDefColIdx(1)) And (i <> lDefColIdx(2)) And (i <> lDefColIdx(3)) And (i <> lDefColIdx(4)) And (i <> lDefColIdx(5)) Then
            If (uColData(i).ColVis = False) Then
                If ((fEnable = 0&) And (uColData(i).NoList = False)) Or (fEnable > 0&) Then
                    If (uColData(i).bFlagCustom = True) Then
                        If m_sCurPath <> uColData(i).szCustomFor Then GoTo rcnxt
                    End If
        '            dbg_chkdupes uColData(i).szDisplayName, i
                    If InStr(uColData(i).szDisplayName, "Folder name") Then
                        DebugAppend "LVCSetAdc " & i & "=" & uColData(i).szDisplayName & "->" & uColData(i).szSystemName
                    End If
                    lPos = InsertLVColItem(uColData(i).szDisplayName, i, , uColData(i).szSystemName)
                    If uColData(i).Visible = True Then
                         ListView_SetCheckState hLVC, lPos, 1
                    Else
                        ListView_SetCheckState hLVC, lPos, 0
                    End If
                End If
            End If
        Else
            DebugAppend "SkipCol " & uColData(i).szDisplayName
        End If
    rcnxt:
    
    Next i
    If m_ColSortCallback = 0& Then m_ColSortCallback = AddressOf LVColSortProc' scb_SetCallbackAddr(3&, 7&)
    Call SendMessage(hLVC, LVM_SORTITEMS, 0&, ByVal m_ColSortCallback)
    
    DebugAppend "LoadColumnSelect->First sort"
    
    For i = 0 To UBound(uColData)
        If (uColData(i).IsDefProp = False) And (uColData(i).ColVis = True) Then 'Used to check NoList--but should be here if loaded
            
            DebugAppend "VisExtColAdd " & uColData(i).szSystemName & ",wasNoList=" & uColData(i).NoList
            lPos = InsertLVColItem(uColData(i).szDisplayName, i, , uColData(i).szSystemName)
            If uColData(i).Visible = True Then
                ListView_SetCheckState hLVC, lPos, 1
            Else
                ListView_SetCheckState hLVC, lPos, 0
            End If
        End If
    Next i
    DebugAppend "LoadColumnSelect->Added vis cols"
    'add default columns last; don't want them mixed in with others(uColData(lDefColIdx(i)).ColVis = True) Or
    For i = 5 To 0 Step -1
        If (uColData(lDefColIdx(i)).NoList = False) Then
    '        DebugAppend "ColAdd2 " & uColData(lDefColIdx(i)).szDisplayName
            lPos = InsertLVColItem(uColData(lDefColIdx(i)).szDisplayName, lDefColIdx(i), IIf(i = 0, 1, 0), uColData(lDefColIdx(i)).szSystemName)
            If uColData(lDefColIdx(i)).Visible = True Then
                ListView_SetCheckState hLVC, lPos, 1
            Else
                ListView_SetCheckState hLVC, lPos, 0
            End If
           
        End If
    Next i
    
    bLVCFlagLoad = False
    
    End Sub
    Private Function InsertLVColItem(sText As String, ByVal lParam As LongPtr, Optional fGhost As Long = 0, Optional sSysName As String = "", Optional lPos As Long = -1&) As Long
    Dim lvi As LVITEM
    lvi.Mask = LVIF_TEXT Or LVIF_PARAM
    lvi.cchTextMax = Len(sText) + 1
    lvi.pszText = StrPtr(sText)
    lvi.lParam = lParam
    If lPos <> -1& Then lvi.iItem = lPos
    If fGhost Then
        lvi.Mask = lvi.Mask Or LVIF_STATE
        lvi.StateMask = LVIS_CUT
        lvi.State = LVIS_CUT
    End If
    InsertLVColItem = CLng(SendMessageW(hLVC, LVM_INSERTITEMW, 0&, lvi))
    If bLVCAdv Then
        lvi.Mask = LVIF_TEXT
        lvi.iSubItem = 1
        lvi.cchTextMax = Len(sSysName) + 1
        lvi.pszText = StrPtr(sSysName)
        Call SendMessageW(hLVC, LVM_SETITEMW, 0&, lvi)
    End If
    'Debug.Print "InsertLVColItem " & sText & "->" & sSysName
    End Function
    
    Public Function zz_ExportSelectedItemFullData(ByRef pData As LongPtr, ByRef nLinkCol As Long, ByRef nExtColData As Long) As Long
    'Provides an advanced method to retrieve the full UCSBFile structure.
    'Step 1: Copy type definitions for UCSBFile, UCSBF_ColLink, and ColumnCache to the calling form/module.
    'Step 2: Declare a USCBFile variable, and 3 Long's to be passed as arguments above.
    'Step 3: Redim UCSBFile.LinkCols(nLinkCol) and UCSBFile.ExtColData(nExtColData)
    'Step 4: CopyMemory to UCSBFile from ByVal pData (only if this function returns non-zero!)
    
    'Returns the full size of the structure.
    Dim iItem As Long
    Dim lp As LongPtr
    iItem = ListView_GetSelectedItem(hLVS)
    If iItem <> LVI_NOITEM Then
        lp = GetLVItemlParam(hLVS, iItem)
        pData = VarPtr(LVEntries(lp))
        nLinkCol = UBound(LVEntries(lp).LinkCols)
        nExtColData = UBound(LVEntries(lp).ExtColData)
        zz_ExportSelectedItemFullData = LenB(LVEntries(lp))
    End If
    End Function
    Public Function zz_ExportItemFullDataByPos(ByVal lPos As Long, ByRef pData As LongPtr, ByRef nLinkCol As Long, ByRef nExtColData As Long) As Long
    'Provides an advanced method to retrieve the full UCSBFile structure.
    'Usage is same as above. This function provides data based on item position in the ListView.
    
    Dim iItems As Long
    Dim lp As LongPtr
    iItems = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lPos < iItems Then
        lp = GetLVItemlParam(hLVS, lPos)
        pData = VarPtr(LVEntries(lp))
        nLinkCol = UBound(LVEntries(lp).LinkCols)
        nExtColData = UBound(LVEntries(lp).ExtColData)
        zz_ExportItemFullDataByPos = LenB(LVEntries(lp))
    End If
    End Function
    
    
    Public Function SetCustomComboImageList(himl As LongPtr) As LongPtr
    SetCustomComboImageList = SendMessageW(hCombo, CBEM_SETIMAGELIST, 0, ByVal himl)
    End Function
    
    Public Function SetCustomListViewImageLists(himlSmall As LongPtr, LVhimlLarge As LongPtr, himlJumbo As LongPtr, himlGroupHeader As LongPtr, Optional himlState As LongPtr = -1) As Long
    If himlSmall <> -1& Then
        Set imlSys16 = Nothing
        If himlSmall Then
            HIMAGELIST_QueryInterface himlSmall, IID_IImageList, imlSys16
        End If
    End If
    If LVhimlLarge <> -1& Then
        Set imlSys32 = Nothing
        If LVhimlLarge Then
            HIMAGELIST_QueryInterface LVhimlLarge, IID_IImageList, imlSys32
        End If
        imlSys32.GetIconSize cxLVIcon, cyLVIcon
    End If
    If himlJumbo <> -1& Then
        Set imlSysJM = Nothing
        If himlJumbo Then
            HIMAGELIST_QueryInterface himlJumbo, IID_IImageList, imlSysJM
        End If
    End If
    If m_HideIcons = False Then
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys32), LVSIL_NORMAL)
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_SMALL)
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_GROUPHEADER)
    End If
    If himlState <> -1& Then
        Call ListView_SetImageList(hLVS, himlState, LVSIL_STATE)
    End If
    If (imlSys16 Is Nothing) And (himlSmall <> 0) Then
        SetCustomListViewImageLists = &H2
    End If
    If (imlSys32 Is Nothing) And (LVhimlLarge <> 0) Then
        SetCustomListViewImageLists = (SetCustomListViewImageLists Or &H4)
    End If
    If (imlSysJM Is Nothing) And (himlJumbo <> 0) Then
        SetCustomListViewImageLists = (SetCustomListViewImageLists Or &H8)
    End If
    End Function
    
    Private Function pvCreateListView(hwndParent As LongPtr, _
                                                      iid As Long, _
                                                      dwStyle As Long, _
                                                      dwExStyle As Long) As LongPtr
      Dim rc As RECT
      Dim hWndLV As LongPtr
      ' Get the client area of the parent.
      Call GetClientRect(hwndParent, rc)
      hWndLV = CreateWindowExW(dwExStyle, StrPtr(WC_LISTVIEW), 0&, _
                                                    dwStyle, mLVOffX, 25, rc.Right - 20 - mLVOffX, rc.Bottom - 10, _
                                                    hwndParent, iid, App.hInstance, 0)
    
    
    '    Call SendMessageW(hwndLV, WM_SETFONT, m_hFontDtHdr, ByVal 1&)
    cxLV = rc.Right - 20
    If Ambient.UserMode Then
        Set Me.Font = PropFont
        DebugAppend "Subclass LV, h=" & hWndLV
        ' If ssc_Subclass(hWndLV, , , , , True, True) Then
        '  Call ssc_AddMsg(hWndLV, MSG_BEFORE, ALL_MESSAGES)
        '  Call ssc_AddMsg(hWndLV, MSG_AFTER, WM_NCMOUSELEAVE, WM_PAINT, WM_VSCROLL, WM_LBUTTONUP, WM_MOUSEMOVE)
        ' End If
        Subclass2 hWndLV, AddressOf ucWndProc, hWndLV
     End If
     
    
    '  Dim dwCallback As ucsb_LVITEM_state
    '   If bUseChecks Then
    '     dwCallback = LVIS_STATEIMAGEMASK
    '   End If
    '   If bUseOverlays Then
    '     dwCallback = dwCallback Or LVIS_OVERLAYMASK
    '   End If
       
    '   If dwCallback Then Call SendMessage(hLVS, LVM_SETCALLBACKMASK, dwMask, ByVal 0&)
          pvCreateListView = hWndLV
    End Function
    
    Private Sub InitLV()
    Dim dwStyle As ucsb_LVStyles, dwExWinStyle As WindowStylesEx
    Dim i As Long
    DebugAppend "InitLV Viewmode=" & m_ViewMode
    dwStyle = LVS_SHAREIMAGELISTS
    If m_AllowRename Then dwStyle = dwStyle Or LVS_EDITLABELS
    If m_MultiSelect = False Then dwStyle = dwStyle Or LVS_SINGLESEL
    If m_HideColumnHeader Then dwStyle = dwStyle Or LVS_NOCOLUMNHEADER
    If mNoLblWrap Then dwStyle = dwStyle Or LVS_NOLABELWRAP
    If mShowSelAlw Then dwStyle = dwStyle Or LVS_SHOWSELALWAYS
    If mAutoArr Then dwStyle = dwStyle Or LVS_AUTOARRANGE
    If mAlignTop Then
        dwStyle = dwStyle Or LVS_ALIGNTOP
    Else
        dwStyle = dwStyle Or LVS_ALIGNLEFT
    End If
    Select Case m_Border
        Case SBBS_Standard
            dwStyle = dwStyle Or WS_BORDER
        Case SBBS_Thick
            dwStyle = dwStyle Or WS_BORDER
            dwExWinStyle = WS_EX_CLIENTEDGE
        Case SBBS_Thicker
            dwStyle = dwStyle Or WS_BORDER Or WS_THICKFRAME
            dwExWinStyle = WS_EX_CLIENTEDGE
    End Select
    
    If IsComCtl6 = False Then
        If (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS) Then
            m_ViewMode = SB_VIEW_ICON
        End If
    End If
    
    Select Case m_ViewMode
        Case SB_VIEW_ICON: dwStyle = dwStyle Or LVS_ICON
        Case SB_VIEW_SMALLICON: dwStyle = dwStyle Or LVS_SMALLICON
        Case SB_VIEW_LIST: dwStyle = dwStyle Or LVS_LIST
        Case SB_VIEW_DETAILS: dwStyle = dwStyle Or LVS_REPORT
    '    Case SB_VIEW_THUMBNAIL: dwStyle = dwStyle Or LVS_ICON
    End Select
    
    If dwStyle Or LVS_ICON Then
        DebugAppend "InitLV set view LVS_ICON", 4
    End If
    If m_HdrMinCX < 0& Then m_HdrMinCX = 0
    hLVS = pvCreateListView(UserControl.hWnd, IDD_LISTVIEW, _
                        dwStyle Or _
                        WS_VISIBLE Or WS_CHILD Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN, dwExWinStyle)
    
    
    If hLVS <> 0 Then SendMessage hLVS, WM_SETFONT, hFontLVMain, ByVal 1&
    
    SendMessage hLVS, LVM_SETVIEW, LV_VIEW_DETAILS, ByVal 0&
    
    SetLVInitPos
    
    If m_HideIcons = False Then
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys32), LVSIL_NORMAL)
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_SMALL)
        Call ListView_SetImageList(hLVS, ObjPtr(imlSys16), LVSIL_GROUPHEADER)
    End If
    
    Dim dwStyleEx As ucsb_LVStylesEx
    dwStyleEx = LVS_EX_AUTOAUTOARRANGE Or LVS_EX_JUSTIFYCOLUMNS Or LVS_EX_DOUBLEBUFFER Or LVS_EX_TRANSPARENTSHADOWTEXT
    If m_FullRowSel Then dwStyleEx = dwStyleEx Or LVS_EX_FULLROWSELECT
    If m_SnapToGrid Then dwStyleEx = dwStyleEx Or LVS_EX_SNAPTOGRID
    If m_AutoSzCol Then dwStyleEx = dwStyleEx Or LVS_EX_AUTOSIZECOLUMNS
    If m_Checkboxes Then dwStyleEx = dwStyleEx Or LVS_EX_CHECKBOXES
    If m_GridLines Then dwStyleEx = dwStyleEx Or LVS_EX_GRIDLINES
    If m_HideLabels Then dwStyleEx = dwStyleEx Or LVS_EX_HIDELABELS
    If m_HdrDD Then dwStyleEx = dwStyleEx Or LVS_EX_HEADERDRAGDROP
    If m_HeaderInAll Then dwStyleEx = dwStyleEx Or LVS_EX_HEADERINALLVIEWS
    If m_TrackSel Then dwStyleEx = dwStyleEx Or LVS_EX_TRACKSELECT
    If m_OneClickAct Then dwStyleEx = dwStyleEx Or LVS_EX_ONECLICKACTIVATE
    If m_TwoClickAct Then dwStyleEx = dwStyleEx Or LVS_EX_TWOCLICKACTIVATE
    If m_ULHot Then dwStyleEx = dwStyleEx Or LVS_EX_UNDERLINEHOT
    If m_ULCold Then dwStyleEx = dwStyleEx Or LVS_EX_UNDERLINECOLD
    If m_CheckSel Then dwStyleEx = dwStyleEx Or LVS_EX_AUTOCHECKSELECT
    If mSimpSel Then dwStyleEx = dwStyleEx Or LVS_EX_SIMPLESELECT
    Select Case mInfoTipMode
         Case SBITM_LabelTipOnly: dwStyleEx = dwStyleEx Or LVS_EX_LABELTIP
         Case SBITM_Extended, SBITM_Custom: dwStyleEx = dwStyleEx Or LVS_EX_INFOTIP Or LVS_EX_LABELTIP
    End Select
    Call SendMessage(hLVS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0&, ByVal dwStyleEx)
    
    Me.BackColor = clrBack
    Me.ForeColor = clrFore
    
    
    
    If mExplorerStyle Then
        Dim swt1 As String
        swt1 = "explorer"
        Call SetWindowTheme(hLVS, StrPtr(swt1), 0&)
        If mExplSel Then
            LVSetExplSel True
        End If
    End If
    
    
    Dim sUserCols() As String
    Dim sColShow As String
    Dim cct As Long
    If (m_DefCol = "") Or (m_DefCol = " ") Or (m_DefCol = vbNullChar) Then
        sColShow = "0"
        ReDim sUserCols(0)
        sUserCols(0) = "0"
    Else
        sColShow = "0," & m_DefCol
        sUserCols = Split(sColShow, ",")
    End If
    Dim lvcol As LVCOLUMNW
    Dim k As Long
    Dim HDI As HDITEMW
    hLVSHdr = SendMessage(hLVS, LVM_GETHEADER, 0&, ByVal 0&)
    If hLVSHdr <> 0 Then SendMessage hLVSHdr, WM_SETFONT, hFontLVMain, ByVal 1&
    
    DebugAppend "InitLV->hLVSHdr=" & hLVSHdr
    If hLVSHdr Then
        If Ambient.UserMode Then
        ' If ssc_Subclass(hLVSHdr, , 21, , , True, True) Then
        '  Call ssc_AddMsg(hLVSHdr, MSG_BEFORE, ALL_MESSAGES)
        ' End If
            Subclass2 hLVSHdr, AddressOf HdrWndProc, hLVSHdr
        End If
        Dim dwHdrStyle As ucsb_HeaderStyles
        dwHdrStyle = CLng(GetWindowLong(hLVSHdr, GWL_STYLE))
        dwHdrStyle = dwHdrStyle Or HDS_DRAGDROP
        If m_HdrOverflow Then dwHdrStyle = dwHdrStyle Or HDS_OVERFLOW
        If m_AllowSorting Then dwHdrStyle = dwHdrStyle Or HDS_BUTTONS
        If m_Checkboxes = True Then dwHdrStyle = dwHdrStyle Or HDS_CHECKBOXES
        If m_NoHdrSize = True Then dwHdrStyle = dwHdrStyle Or HDS_NOSIZING
        If m_HdrHotTrack = True Then dwHdrStyle = dwHdrStyle Or HDS_HOTTRACK
        If m_FilterBar = True Then dwHdrStyle = dwHdrStyle Or HDS_FILTERBAR
        
        Call SetWindowLong(hLVSHdr, GWL_STYLE, dwHdrStyle)
        
        If nFilterChangeInterval <> -1 Then
            SendMessage hLVSHdr, HDM_SETFILTERCHANGETIMEOUT, 0&, ByVal nFilterChangeInterval
        End If
    End If
    ''So I like a little icon in the file name column header... if so desired,
    ''you can set it too by uncommenting the following
    
    'If himlHdrMV Then
    '    Call ImageList_Destroy(himlHdrMV)
    'End If
    '
    'himlHdrMV = ImageList_Create(16, 16, ILC_MASK Or ILC_COLOR32, 5, 0)
    '
    'Dim hIcon As Long
    'hIcon = Picture7.Picture.Handle
    'ImageList_Add himlHdrMV, hIcon, &HCECECE
    'Call SendMessage(hLVSHdr, HDM_SETIMAGELIST, HDSIL_NORMAL, ByVal himlHdrMV)
     
    ReDim sColText(5)
    sColText(0) = uColData(lDefColIdx(0)).szDisplayName '"Name" These were switched out like this because that .szDisplayName string will already be localized to whatever language the Windows install is in
    sColText(1) = uColData(lDefColIdx(1)).szDisplayName '"Size"
    sColText(2) = uColData(lDefColIdx(2)).szDisplayName '"File Type"
    sColText(3) = uColData(lDefColIdx(3)).szDisplayName '"Date Modified"
    sColText(4) = uColData(lDefColIdx(4)).szDisplayName '"Date Created"
    sColText(5) = uColData(lDefColIdx(5)).szDisplayName '"Date Accessed"
    
    lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH Or LVCF_MINWIDTH
    lvcol.cchTextMax = Len(sColText(0)) + 1
    lvcol.pszText = StrPtr(sColText(0))
    If uColData(lDefColIdx(0)).DefWidth > 80 Then
        lvcol.CX = uColData(lDefColIdx(0)).DefWidth * m_ScaleX
    Else
        lvcol.CX = 190 * m_ScaleX
    End If
    lvcol.cxMin = m_HdrMinCX
    '    DebugAppend "ubcol=" & UBound(sUserCols) & ",sz=" & sColShow & ",1=" & sUserCols(1)
    If UBound(sUserCols) = 0 Then
        Dim rclv As RECT
        GetClientRect hLVS, rclv
        DebugAppend "SetSingleColCX=" & (cxLV - 2), 1111
        lvcol.CX = rclv.Right - (20 * m_ScaleX)
    End If
    Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 1, lvcol)
    HDI.Mask = HDI_LPARAM Or HDI_FORMAT
    If himlHdrMV Then
        HDI.Mask = HDI.Mask Or HDI_IMAGE
        HDI.fmt = HDI.fmt Or HDF_IMAGE
        HDI.iImage = i
    End If
    If m_Checkboxes Then
        HDI.fmt = HDF_CHECKBOX
    End If
    HDI.lParam = lDefColIdx(0)
    HDI.fmt = HDI.fmt Or HDF_STRING
    Call SendMessage(hLVSHdr, HDM_SETITEMW, 0, HDI)
    bColStates(0) = True
    
    If strarr_Search(sUserCols, "1") >= 0& Then
        lvcol.cchTextMax = Len(sColText(1)) + 1
        lvcol.pszText = StrPtr(sColText(1))
        lvcol.CX = uColData(lDefColIdx(1)).DefWidth * m_ScaleX
        lvcol.cxMin = m_HdrMinCX
        Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 2, lvcol)
        cct = cct + 1
        HDI.Mask = HDI_LPARAM
        HDI.lParam = lDefColIdx(1)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, cct, HDI)
        bColStates(1) = True
    End If
    
    If strarr_Search(sUserCols, "2") >= 0& Then
        lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvcol.cchTextMax = Len(sColText(2)) + 1
        lvcol.pszText = StrPtr(sColText(2))
        lvcol.CX = uColData(lDefColIdx(2)).DefWidth * m_ScaleX
        lvcol.cxMin = m_HdrMinCX
        Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 3, lvcol)
        cct = cct + 1
        HDI.Mask = HDI_LPARAM
        HDI.lParam = lDefColIdx(2)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, cct, HDI)
        bColStates(2) = True
    End If
    
    
    If strarr_Search(sUserCols, "3") >= 0& Then
        lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvcol.cchTextMax = Len(sColText(3)) + 1
        lvcol.pszText = StrPtr(sColText(3))
        lvcol.CX = uColData(lDefColIdx(3)).DefWidth * m_ScaleX
        lvcol.cxMin = m_HdrMinCX
        Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 4, lvcol)
        cct = cct + 1
        HDI.Mask = HDI_LPARAM
        HDI.lParam = lDefColIdx(3)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, cct, HDI)
        bColStates(3) = True
    End If
    
    If strarr_Search(sUserCols, "4") >= 0& Then
        lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvcol.cchTextMax = Len(sColText(4)) + 1
        lvcol.pszText = StrPtr(sColText(4))
        lvcol.CX = uColData(lDefColIdx(4)).DefWidth * m_ScaleX
        lvcol.cxMin = m_HdrMinCX
        Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 5, lvcol)
        cct = cct + 1
        HDI.Mask = HDI_LPARAM
        HDI.lParam = lDefColIdx(4)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, cct, HDI)
        bColStates(4) = True
    End If
    
    If strarr_Search(sUserCols, "5") >= 0& Then
        lvcol.Mask = LVCF_TEXT Or LVCF_WIDTH
        lvcol.cchTextMax = Len(sColText(5)) + 1
        lvcol.pszText = StrPtr(sColText(5))
        lvcol.CX = uColData(lDefColIdx(5)).DefWidth * m_ScaleX
        lvcol.cxMin = m_HdrMinCX
        Call SendMessage(hLVS, LVM_INSERTCOLUMNW, 6, lvcol)
        cct = cct + 1
        HDI.Mask = HDI_LPARAM
        HDI.lParam = lDefColIdx(5)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, cct, HDI)
        bColStates(5) = True
    End If
        
    DebugAppend "InitLV->cnt=" & Header_GetItemCount(hLVSHdr)
       
    
    'set fallback columns to user defaults
    'Note the user selected columns generally shouldn't be seen
    'They're only used when we fail to get the default column
    'set from Explorer.
    ReDim lFBCol(0)
    lFBCol(0) = lDefColIdx(0)
    k = 1
    If bColStates(1) Then
        ReDim Preserve lFBCol(k)
        lFBCol(k) = lDefColIdx(1)
        k = k + 1
    End If
    If bColStates(2) Then
        ReDim Preserve lFBCol(k)
        lFBCol(k) = lDefColIdx(2)
        k = k + 1
    End If
    If bColStates(3) Then
        ReDim Preserve lFBCol(k)
        lFBCol(k) = lDefColIdx(3)
        k = k + 1
    End If
    If bColStates(4) Then
        ReDim Preserve lFBCol(k)
        lFBCol(k) = lDefColIdx(4)
        k = k + 1
    End If
    If bColStates(5) Then
        ReDim Preserve lFBCol(k)
        lFBCol(k) = lDefColIdx(5)
    End If
        
    lColKey(0) = lDefColIdx(0)
    lColKey(1) = lDefColIdx(1)
    lColKey(2) = lDefColIdx(2)
    lColKey(3) = lDefColIdx(3)
    lColKey(4) = lDefColIdx(4)
    
    'If m_ViewMode = SB_VIEW_TILE Then
    '    SetTileView hLVS
    'ElseIf m_ViewMode = SB_VIEW_CONTENTS Then
    '    SetTileViewEx hLVS
    'ElseIf (m_ViewMode = SB_VIEW_ICON) Or (m_ViewMode = SB_VIEW_LIST) Or (m_ViewMode = SB_VIEW_SMALLICON) Then
    '    SendMessage hLVS, LVM_SETVIEW, m_ViewMode, ByVal 0&
    'End If
    
    Me.PictureAlignment = PropPictureAlignment
    
    If Ambient.UserMode = False Then
        ReDim LVEntries(1)
        With LVEntries(0)
            .sName = mVersionStr
            .cSize = 123
            .sSize = mSamS1
            .sType = mSamS2
            .sDateM = mSamS3
        End With
        InsertListItem LVEntries(0), , , True
    End If
    'If m_HideColumnHeader Then
    '    Me.HideColumnHeader = True
    'End If
    
    'TODO: SAVE/LOAD EXTENDED COLUMNS TO DISPLAY BY DEFAULT
    End Sub
    
    Private Function GetFilterText(iCol As Long) As String
    If sManualFilter <> "" Then
        GetFilterText = sManualFilter
        sManualFilter = "" 'or else a future typed filter would get overridden
        Exit Function
    End If
    
    GetFilterText = HeaderReadFilterText(hLVSHdr, iCol)
    
    End Function
    
    Private Function HeaderReadFilterText(hHdr As LongPtr, iCol As Long) As String
    Dim uHDI   As HDITEM
    Dim uValue As HD_TEXTFILTERW
    Dim sText As String
    Dim hr As LongPtr
    
    sText = String$(255, 0)
    
    uValue.cchTextMax = 255
    uValue.pszText = StrPtr(sText)
    
    uHDI.Mask = HDI_FILTER
    uHDI.pvFilter = VarPtr(uValue)
    
    hr = SendMessageW(hHdr, HDM_GETITEMW, iCol, uHDI)
    
    HeaderReadFilterText = TrimNullW(sText)
    
    End Function
    
    Private Sub FilterResetItems()
    'Restore original group numbers or remove groups after filterbar is cleared
    If bFilterActive = True Then 'if no filtering has been done, don't bother
        bFilterActive = False
    Else
        Exit Sub
    End If
    
    Dim i As Long
    Dim tLI As LVITEM
    Dim lCt As Long
    Dim lNewGrp As Long
    Dim sTmp As String
    Dim lp As LongPtr
    
    lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCt = 0& Then Exit Sub
    
    If m_GroupMode = SBGB_None Then
        SendMessage hLVS, LVM_ENABLEGROUPVIEW, 0&, ByVal 0&
        SendMessage hLVS, LVM_REMOVEALLGROUPS, 0&, ByVal 0&
        Exit Sub
    End If
    For i = 0 To (lCt - 1)
        lp = GetLVItemlParam(hLVS, i)
        Select Case m_GroupMode
            Case SBGB_Name: lNewGrp = GroupGetIDForAlpha(LVEntries(lp).sName)
            Case SBGB_Size: lNewGrp = GroupGetIDForSize(LVEntries(lp).cSize)
            Case SBGB_Type: lNewGrp = GroupGetIDForType(LVEntries(lp).sType)
            Case SBGB_DateModified: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateM), 0)
            Case SBGB_DateCreated: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateC), 1)
            Case SBGB_DateAccessed: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateA), 2)
            Case SBGB_Extended
                sTmp = GetSubitemTextW(i, lGrpCol)
                lNewGrp = GetTextGroupId(sTmp)
        End Select
        With tLI
            .Mask = LVIF_GROUPID
            .iItem = i
            .iGroupId = lNewGrp
        End With
        SendMessage hLVS, LVM_SETITEMW, i, tLI
    Next i
    
    End Sub
    
    Private Sub LVCFilterResetItems()
    'Remove the filter
    If bLVCFilterActive = True Then 'if no filtering has been done, don't bother
        bLVCFilterActive = False
    Else
        Exit Sub
    End If
    
    SendMessage hLVC, LVM_ENABLEGROUPVIEW, 0&, ByVal 0&
    SendMessage hLVC, LVM_REMOVEALLGROUPS, 0&, ByVal 0&
    bLVCGroup = False
    
    End Sub
    
    Public Sub FilterBarApplyManually(sFilter As String, iColumn As Long)
    sManualFilter = sFilter
    LVApplyFilterbar iColumn
    End Sub
    
    Private Sub LVApplyFilterbar(iCol As Long)
    Dim sFilter As String
    Dim sCol As String
    Dim i As Long
    Dim lp As LongPtr
    Dim lRes As Long
    Dim bShow As Boolean
    Dim lCt As Long
    Dim tLI As LVITEM
    Dim sCmp As String
    Dim lNewGrp As Long
    Dim sTmp As String
    Dim lShCt As Long
    
    lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCt = 0 Then Exit Sub
    
    sFilter = GetFilterText(iCol)
    
    DebugAppend "LVApplyFilterBar::Col=" & CStr(iCol) & ",Filter=" & sFilter & ",CaseSens=" & CStr(m_FilterCase)
    
    If sFilter = "" Then
        FilterResetItems
        Exit Sub
    Else
        bFilterActive = True
    End If
    
    If m_GroupMode = SBGB_None Then
        InsertGroupForFilter
    End If
    If m_FilterCase = False Then
        sFilter = LCase$(sFilter)
    End If
    
    For i = 0 To (lCt - 1)
        lNewGrp = 0
        sCol = GetSubitemTextW(i, iCol)
        If m_FilterCase = False Then
            sCmp = LCase$(sCol)
        Else
            sCmp = sCol
        End If
        If InStr(sFilter, "*") Then
            If sCmp Like sFilter Then
                bShow = True
            Else
                bShow = False
            End If
        Else
            If Len(sFilter) > Len(sCmp) Then
                sCmp = Left$(sCmp, Len(sFilter))
            End If
            If Left$(sCmp, Len(sFilter)) = sFilter Then
                bShow = True
            Else
                bShow = False
            End If
        End If
        lRes = -1
        lp = GetLVItemlParam(hLVS, i)
        RaiseEvent FilterBarOverride(sFilter, sCol, m_FilterCase, LVEntries(lp).sFullPath, lRes)
        If lRes = 0 Then
            bShow = False
        ElseIf lRes > 0 Then
            bShow = True
        End If
        If bShow Then
            Select Case m_GroupMode
                Case SBGB_None: lNewGrp = 1
                Case SBGB_Name: lNewGrp = GroupGetIDForAlpha(LVEntries(lp).sName)
                Case SBGB_Size: lNewGrp = GroupGetIDForSize(LVEntries(lp).cSize)
                Case SBGB_Type: lNewGrp = GroupGetIDForType(LVEntries(lp).sType)
                Case SBGB_DateModified: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateM), 0)
                Case SBGB_DateCreated: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateC), 1)
                Case SBGB_DateAccessed: lNewGrp = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateA), 2)
                Case SBGB_Extended
                    sTmp = GetSubitemTextW(i, lGrpCol)
                    lNewGrp = GetTextGroupId(sTmp)
            End Select
            lShCt = lShCt + 1
        Else
            lNewGrp = 0&
        End If
        With tLI
            .Mask = LVIF_GROUPID
            .iItem = i
            .iGroupId = lNewGrp
        End With
        SendMessage hLVS, LVM_SETITEMW, i, tLI
    Next i
    
    If m_GroupMode = SBGB_None Then
        SendMessage hLVS, LVM_ENABLEGROUPVIEW, 1&, ByVal 0&
        Dim sFoot As String
        If lShCt = 1 Then
            sFoot = "1 " & mItemStr & "."
        Else
            sFoot = CStr(lShCt) & " " & mItemsStr & "."
        End If
        GroupUpdateFooter hLVS, 1&, sFoot
    Else
        GroupUpdateAllFooters hLVS
    End If
    
    End Sub
    
    Private Sub LVCApplyFilterbar(iCol As Long)
    Dim sFilter As String
    Dim sCol As String
    Dim i As Long
    Dim lRes As Long
    Dim bShow As Boolean
    Dim lCt As Long
    Dim tLI As LVITEM
    Dim sCmp As String
    Dim lNewGrp As Long
    
    lCt = CLng(SendMessage(hLVC, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCt = 0 Then Exit Sub
    
    sFilter = HeaderReadFilterText(hLVCHdr, iCol)
    mLVCFilt = sFilter
    
    DebugAppend "LVCApplyFilterBar::Col=" & CStr(iCol) & ",Filter=" & sFilter
    
    If sFilter = "" Then
        LVCFilterResetItems
        Exit Sub
    Else
        bLVCFilterActive = True
    End If
    
    If bLVCGroup = False Then
        LVCInsertFilterGroup
    End If
    
    sFilter = LCase$(sFilter)
    
    
    For i = 0 To (lCt - 1)
        lNewGrp = 0
        sCol = GetLVItemTextW(hLVC, i, iCol)
        sCmp = LCase$(sCol)
        If InStr(sFilter, "*") Then
            If sCmp Like sFilter Then
                bShow = True
            Else
                bShow = False
            End If
        Else
            If Len(sFilter) > Len(sCmp) Then
                sCmp = Left$(sCmp, Len(sFilter))
            End If
            If Left$(sCmp, Len(sFilter)) = sFilter Then
                bShow = True
            Else
                bShow = False
            End If
        End If
        lRes = -1
        If bShow Then
            lNewGrp = 1&
        Else
            lNewGrp = 0&
        End If
        With tLI
            .Mask = LVIF_GROUPID
            .iItem = i
            .iGroupId = lNewGrp
        End With
        SendMessage hLVC, LVM_SETITEMW, i, tLI
    Next i
    
    If bLVCGroup = False Then
        SendMessage hLVC, LVM_ENABLEGROUPVIEW, 1&, ByVal 0&
        bLVCGroup = True
    End If
    End Sub
    
    Private Sub LVCInsertFilterGroup()
    Dim lvg As LVGROUP
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER
        .iGroupId = 1
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .cchHeader = Len(m_str_Cols) + 1
        .pszHeader = StrPtr(m_str_Cols)
    End With
    Call SendMessageW(hLVC, LVM_INSERTGROUP, -1&, ByVal VarPtr(lvg))
    End Sub
    
    Private Sub InsertGroupForFilter()
    Dim lvg As LVGROUP
    Dim sCap As String
    Dim sDefFoot As String
    sDefFoot = "0" & " " & mFilesStr & "."
    sCap = m_str_Matches
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 1
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
    
        .cchHeader = Len(sCap) + 1
        .pszHeader = StrPtr(sCap)
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    
    End Sub
    
    Private Function StrGetPath(ByVal sFull As String) As String
    'Gets a file path
    Dim sOut As String
    sOut = sFull
    If InStrRev(sOut, "\") = 1 Then
        sFull = Left$(sOut, Len(sOut) - 1)
    End If
    If InStr(sFull, "\") = 0 Then
        StrGetPath = sFull 'usually happens for C:\ top level
        Exit Function
    End If
    StrGetPath = Left$(sOut, InStrRev(sOut, "\") - 1)
    If Right$(StrGetPath, 1) = ":" Then
        StrGetPath = StrGetPath & "\" 'write C:\ instead of C:
    End If
    End Function
    
    Private Sub SetUnsupportedHPfLocs()
    'Set locations that are not virtual paths, but do something funky that makes them incompatible with the high-performance loader
    'So far, only Fonts are known to have this issue.
    
    Dim pKFM As IKnownFolderManager, pkf As IKnownFolder
    Dim lpPath As LongPtr, sPath As String
    Dim i As Long, j As Long
    
    ReDim sUnsupportedHPF(0)
    
    'Be sure to use LCase; the IDE and compiled versions returned different cases on Win10
    sUnsupportedHPF(0) = LCase$(SpecialFolderPath(FOLDERID_Fonts))
    
    End Sub
    
    Private Function CheckDirForHPf(sPath As String) As Boolean
    On Error GoTo e0
    Dim i As Long
    For i = 0 To UBound(sUnsupportedHPF)
        If Len(sPath) >= Len(sUnsupportedHPF(i)) Then
            If LCase$(Left$(sPath, Len(sUnsupportedHPF(i)))) = sUnsupportedHPF(i) Then
                CheckDirForHPf = True
                Exit Function
            End If
        End If
    Next i
    
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.CheckDirForHPf->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Sub dbg_analyzeustr(tUS As UNICODE_STRING)
    DebugAppend "tUS.uLength=" & tUS.uLength, 22
    DebugAppend "tUS.uMaximumLength=" & tUS.uMaximumLength, 22
    Dim pBuf() As Byte
    ReDim pBuf(tUS.uLength - 1)
    CopyMemory ByVal VarPtr(pBuf(0)), ByVal tUS.pBuffer, tUS.uLength
    dbg_printbytes pBuf
    End Sub
    Private Function FindFirstFileNt(ByVal strDirectory As String, bytBuffer() As Byte) As LongPtr
    On Error GoTo e0
        Dim strFolder As String
        Dim obAttr As OBJECT_ATTRIBUTES
        Dim objIoStatus As IO_STATUS_BLOCK
        Dim NTSTATUS As Long
        Dim hFind As LongPtr
        Dim strUnicode As UNICODE_STRING
        Dim fp As Long, rn As Long
        Dim hr As Long
        strFolder = "\??\"
        strFolder = strFolder & strDirectory
    '    RtlDosPathNameToNtPathName_U StrPtr(strFolder), strUnicode, fp, rn
        RtlInitUnicodeString strUnicode, StrPtr(strFolder)
         dbg_analyzeustr strUnicode
        obAttr.Length = LenB(obAttr)
        obAttr.Attributes = OBJ_CASE_INSENSITIVE
        obAttr.ObjectName = VarPtr(strUnicode)
        obAttr.RootDirectory = 0
        obAttr.SecurityDescriptor = 0
        obAttr.SecurityQualityOfService = 0
        DebugAppend "Calling NtCreateFile...", 22
        NTSTATUS = NtCreateFile(hFind, FILE_LIST_DIRECTORY Or SYNCHRONIZE Or FILE_READ_ACCESS, _
                                obAttr, objIoStatus, ByVal 0&, 0&, FILE_SHARE_READ, FILE_OPEN, _
                                FILE_DIRECTORY_FILE Or FILE_SYNCHRONOUS_IO_NONALERT, ByVal 0&, 0&)
    '    NTSTATUS = NtOpenFile(hFind, _
    '                        FILE_LIST_DIRECTORY Or SYNCHRONIZE Or FILE_READ_ACCESS, _
    '                        obAttr, _
    '                        objIoStatus, _
    '                        3, _
    '                        FILE_DIRECTORY_FILE Or FILE_SYNCHRONOUS_IO_NONALERT) ' Or FILE_OPEN_FOR_BACKUP_INTENT)
        DebugAppend "hFind=" & hFind & ",ntStatus=0x" & Hex$(NTSTATUS), 22 '& " " & GetNTStatusStr(NTSTATUS)
    '        Debug.Print "iostatus=0x" & Hex$(objIoStatus.IoStatus) & ",iobytes=" & objIoStatus.Information
        If NTSTATUS = 0 And hFind <> -1 Then
            NTSTATUS = NtQueryDirectoryFile(hFind, _
                                         0, _
                                         0, _
                                         0, _
                                         objIoStatus, _
                                         bytBuffer(0), _
                                         UBound(bytBuffer) + 1, _
                                         FileDirectoryInformation, _
                                         1, _
                                         ByVal 0&, _
                                         0)
            If NTSTATUS = 0 Then
                DebugAppend "NtQDF success", 22
                FindFirstFileNt = hFind
            Else
                DebugAppend "Error2, ntStatus=0x" & Hex$(NTSTATUS) '& " " & GetNTStatusStr(NTSTATUS)
                bFlagHPfErr = True
                NtClose hFind
            End If
        Else
            bFlagHPfErr = True
            DebugAppend "Error, ntStatus=0x" & Hex$(NTSTATUS) '& " " & GetNTStatusStr(NTSTATUS)
    
        End If
    Exit Function
    e0:
        bFlagHPfErr = True
        DebugAppend "FindFirstFileNt.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    '*1
    Private Function FindNextFileNt(ByVal hFind As LongPtr, bytBuffer() As Byte) As Boolean
        Dim NTSTATUS As Long
        Dim objIoStatus As IO_STATUS_BLOCK
        NTSTATUS = NtQueryDirectoryFile(hFind, _
                                     0, _
                                     0, _
                                     0, _
                                     objIoStatus, _
                                     bytBuffer(0), _
                                     UBound(bytBuffer) + 1, _
                                     FileDirectoryInformation, _
                                     0, _
                                     ByVal 0&, _
                                     0)
        If NTSTATUS = 0 Then
            FindNextFileNt = True
        Else
    '        Debug.Print "FindNextFile hFind=" & hFind & ",err=0x" & Hex$(NTSTATUS) & " " & GetNTStatusStr(NTSTATUS)
    '        Debug.Print "iostatus=0x" & Hex$(objIoStatus.Status) & ",iobytes=" & objIoStatus.uInformation
            FindNextFileNt = False
        End If
    End Function
    
    
    Private Sub LVLoadFolderEx(ByVal sPath As String, Optional bLoadFID As Boolean = False, Optional bFallbackPresent As Boolean = False, Optional siFallback As IShellItem, Optional IsRefresh As Boolean = False, Optional lAssignSearchIdx As Long = -1&)
    'Sync any changes with LVAddEntry
    If Ambient.UserMode = False Then Exit Sub
    
    'To time folder loading, uncomment the following two lines
    'Then uncomment the other timing/results call for lvlftt2 at the end of this sub
    Dim lvlftt1 As Long, lvlftt2 As Long, lvlftt3 As Long
    lvlftt1 = GetTickCount()
    bSupDisp = True
    Dim fNavCan As Long
    Dim sRslv As String
    If sRslv = "0" Then
        If m_CompAsRoot Then
            sRslv = sComp
        Else
            sRslv = m_sDesktopPath
        End If
    End If
    RaiseEvent PreDirectoryChange(sRslv, fNavCan)
    If bUseSearchMarkup = True Then
        bUseSearchMarkup = False
        SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
    End If
    
    FastDoEvents 'DoEvents
    If fNavCan <> S_OK Then Exit Sub
    UpdateStatus mStrOpening
    'If m_DisableWhileLoading Then EnableWindow hLVS, 0&
    Dim i As Long, j As Long
    Dim siParent As IShellItem
    Dim lAtr As SFGAO_Flags, lAtrP As SFGAO_Flags
    Dim nCur As Long, nCurFol As Long, nCurFil As Long
    Dim bIsFldr As Boolean, bIsZip As Boolean
    Dim sName As String, snlc As String
    Dim sNameFull As String
    Dim sNameParse As String
    Dim sFull As String
    Dim sParFull As String
    Dim dwLinkAtr As SFGAO_Flags
    Dim bLnkFldr As Boolean, bLnkGen As Boolean
    Dim lpDisp As LongPtr, sDisp As String
    Dim sExt As String
    Dim crSize As LongLong
    Dim lpIcon As Long
    Dim lpCPath As LongPtr
    Dim sPP As String
    Dim sParPN As String
    Dim lpPath As LongPtr
    Dim sOldPath As String
    Dim bFlagFixCh As Boolean
    Dim li As Long
    
    nAdjustOrder = 0
    sOldPath = m_sCurPath
    On Error GoTo e0
    
    'Clear any old preview
    Set pbPreviewPane.Picture = Nothing
    If (ipv Is Nothing) = False Then
        Set pPvhVis = Nothing
        ipv.Unload
    End If
    
    Set mIShIcon = Nothing
    
    ReDim bOvrAdded(0)
    bUseDrvRemForEM = False
    SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
    
    DebugAppend UserControl.Name & ".LVLoadFolderEx " & sPath & ",m_sCurPath=" & m_sCurPath & ",sPrevPath=" & sPrevPath & ",GrpMode=" & m_GroupMode, 22
    If sPath = "*CUSTOM" Then
        PopulateCustomSet
        Exit Sub
    Else
        bCustActive = False
    End If
    
    'EnableWindow hLVS, 0&
    Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&)
    
    EnableWindow hUpButton, 1&
    bUpEnable = True
    
    If bLoadFID = False Then
        If sPath = "0" Then 'desktop
            If mCustomRoot <> "" Then
                SHCreateItemFromParsingName StrPtr(mCustomRoot), Nothing, IID_IShellItem, siParent
            Else
                
                If m_CompAsRoot Or (m_Mode = SBCTL_DrivesOnly) Then
                    SHGetKnownFolderItem FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siParent
                Else
                    Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siParent)
                End If
            End If
            EnableWindow hUpButton, 0&
            bUpEnable = False
        Else
            SHCreateItemFromParsingName StrPtr(sPath), Nothing, IID_IShellItem, siParent
            If siParent Is Nothing Then
                'Try shell: fallback for ::{GUID} items not resolving normally
                If Left$(sPath, 3) = "::{" Then
                    Dim sSh As String
                    sSh = "shell:" & sPath
                    SHCreateItemFromParsingName StrPtr(sSh), Nothing, IID_IShellItem, siParent
                End If
            End If
            If (sPath = mCustomRoot) And (mCustomRootEnforce = True) Then
                EnableWindow hUpButton, 0&
                bUpEnable = False
            End If
        End If
    Else
        'load from direct Folder ID
    '    SHGetKnownFolderItem LFFID, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siParent
        If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
            If IsRootChild(, siDirect) = False Then
                UpdateStatus mStrForbidden
                Exit Sub
            End If
        End If
        Set siParent = siDirect
        'Add item to combo here to avoid querying for the shell item twice
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
        sPath = LPWSTRtoStr(lpPath)
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpCPath
    
        m_sCurPath = LPWSTRtoStr(lpCPath)
        bSuppress = True
        i = AddStandardFSItem(siParent, li, True, lAssignSearchIdx)
        Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
        bSuppress = False
        If i = 0 Then
            EnableWindow hUpButton, 0&
            bUpEnable = False
        End If
    End If
    
    If (siParent Is Nothing) Then
        If bFallbackPresent Then
            Set siParent = siFallback
        End If
    End If
    
    If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
        If IsRootChild(, siParent) = False Then
            UpdateStatus mStrForbidden
            Exit Sub
        End If
    End If
    'Set history
    
    If (siParent Is Nothing) = False Then
        If (sPath <> sOldPath) And (sPath <> "") Then 'if equal it's a refresh, so don't duplicate in history
            
            sPrevPath = m_sCurPath
            m_sCurPath = sPath
          If bHistoryOp = False Then
            If nHistIdx = -1 Then
                sHistory(0) = m_sCurPath
                nHistIdx = 0
            Else
                If nHistIdx <> UBound(sHistory) Then
                    Dim sht() As String
                    ReDim sht(nHistIdx + 1)
                    For i = 0 To nHistIdx
                        sht(i) = sHistory(i)
                    Next i
                    nHistIdx = nHistIdx + 1
                    sht(nHistIdx) = sPath
                    sHistory = sht
                End If
                If sHistory(nHistIdx) <> sPath Then
                    nHistIdx = nHistIdx + 1
                    ReDim Preserve sHistory(nHistIdx)
                    sHistory(nHistIdx) = sPath
                    EnableWindow hStdBackButton, 1&
                    pvDrawBack NAV_BB_NORMAL
                    bBackEnable = True
                End If
            End If
          End If
        End If
    End If
    
    'If hLVS = 0 Then GoTo loaddone
    
    If (siParent Is Nothing) = False Then
        'first clear selection
        If (bCatGrpActive = True) Then
            DebugAppend "LVLoadFolderEx::SetPrevGrp " & mPrevGrpMode
            SetGroupMode mPrevGrpMode
            lGrpCol = mPrevGrpMode
        End If
        If bGV Then
           
            If m_GroupMode = SBGB_Type Then ClearGroupData 'remove groups for dynamic categories only
            If m_GroupMode = SBGB_Extended Then ClearGroupData ' SendMessage hLVS, LVM_REMOVEALLGROUPS, 0&, ByVal 0& 'they're rebuilt as items are added
            If m_GroupMode = SBGB_Categorizer Then ClearGroupData
        End If
    
        Call SendMessage(hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&)
        If bThumbsActive Then
            ImageList_Remove himl_Thumb, -1
        End If
        
        If m_ViewMode = SB_VIEW_ICON Then
    '        SwitchView LV_VIEW_DETAILS
    '        SwitchView m_ViewModeEx
        
            ImageList_Remove himlLarge, -1
    '        nCthimlL = 0
    '        LVSwitchToLgIcon
        End If
        
        nCurFolders = 0
        nCurFiles = 0
    
        ReDim LVEntries(0)
        mOvrMax = 0
        sSelectedFile = ""
        tSelectedFile.sName = ""
        tSelectedFile.sFullPath = ""
        ReDim sSelectedFiles(0)
        ReDim tSelectedFiles(0)
        ReDim sSelectedFileNames(0)
        ReDim sSelectedFileNamesF(0)
        ReDim sSelectedFilesOnly(0)
        ReDim sSelectedFilesOnlyFull(0)
        ReDim sSelectedFoldersOnly(0)
        ReDim sSelectedFoldersOnlyFull(0)
        Set siFocus = Nothing
        If pidlFQCur Then CoTaskMemFree pidlFQCur
        Set psfCur = Nothing
        
        m_CurSize = 0
        If IsRefresh = False Then m_SubItemProgress = 0&
        ResetSpecialCols
        If nLinks > 0 Then
            For i = 0 To UBound(hLinks)
                DestroyWindow hLinks(i)
            Next i
        End If
        ReDim hLinks(0): nLinks = 0
        ReDim SysImgCache(0)
        nSysImgCache = 0
        'Finish up then enumerate contents
    
        Set siCurPath = Nothing
        siParent.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK, lAtrP
        DebugAppend "PathAttrib=" & dbg_sfgao_tostring(lAtrP)
        siParent.GetDisplayName SIGDN_NORMALDISPLAY, lpDisp
        sDisp = LPWSTRtoStr(lpDisp)
        m_sCurPathDisp = sDisp
        Dim pCatG As ICategorizer
        bFolderHasCat = False
        ReDim gidCat(0)
        ReDim sItemCats(0)
    '    If (sPath = sComp) Then
            DebugAppend "In Computer, trying catprovider"
            Dim psf2 As IShellFolder2
            siParent.BindToHandler 0&, BHID_SFObject, IID_IShellFolder2, psf2
            If (psf2 Is Nothing) Then
                DebugAppend "Failed to get IShellFolder2", 22
            Else
                DebugAppend "Got IShellFolder2", 22
            End If
            If (psf2 Is Nothing) = False Then
                Dim scid As SHCOLUMNID
    '            psf2.MapColumnToSCID 1&, scid
                
                Dim pCatProvider As ICategoryProvider
                siParent.BindToHandler 0&, BHID_SFViewObject, IID_ICategoryProvider, pCatProvider
                If (pCatProvider Is Nothing) = False Then
                    DebugAppend "Got category provider", 22
                    
                    Dim tIDTmp As UUID
                    Dim tSCGUID As UUID
                    pCatProvider.GetDefaultCategory tIDTmp, scid
                    
    '                Dim pkn As PROPERTYKEY
    '                pkn = PKEY_ItemNameDisplay
    '                CopyMemory ByVal VarPtr(scid.fmtid.Data1), ByVal VarPtr(pkn), LenB(pkn)
    '                DebugAppend "0x" & Hex$(scid.fmtid.Data1) & "...0x" & Hex$(scid.fmtid.Data4(7)) & "," & scid.pid
                    pCatProvider.GetCategoryForSCID scid, tSCGUID
                    DebugAppend "guid=" & dbg_GUIDToString(tSCGUID)
                    
                    If IsEqualIID(tSCGUID, UUID_NULL) = 0& Then
                        Dim ppv As LongPtr
                        pCatProvider.CreateCategory tSCGUID, IID_ICategorizer, pCatG 'ppv '
                        ' If ppv Then
                        '     vbaObjSetAddRef pCatG, ppv
                        ' Else
                        '     DebugAppend "no catg ptr"
                        ' End If
                            
                        If (pCatG Is Nothing) = False Then
                            DebugAppend "Got categorizer", 22
                            bFolderHasCat = True
                        Else
                            DebugAppend "Failed to get categorizer", 22
                        End If
                    Else
                        DebugAppend "LVLoadFolderEx::No category support (SCID=NULL)"
                    End If
                Else
                    DebugAppend "LVLoadFolderEx::No category provider found.", 22
                End If
            End If
    '    End If
               
        lpCPath = 0
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpCPath
        
        sPP = LPWSTRtoStr(lpCPath)
        Dim si2Par As IShellItem2
        Set si2Par = siParent
        Dim lp5 As LongPtr
        si2Par.GetString PKEY_ParsingName, lp5
        sParPN = LPWSTRtoStr(lp5)
        
        
        Dim ieidl As IEnumIDList
        Dim upiNew As IParentAndItem
        Dim psfNew As IShellFolder, psf2New As IShellFolder2
        Dim pidlNew1 As LongPtr, pidlRelNew1 As LongPtr
        Dim pidlRelM As LongPtr, pclNew As Long
        
        siParent.BindToHandler 0&, BHID_SFObject, IID_IShellFolder, psfNew
        SHGetIDListFromObject psfNew, pidlFQCur
        If pidlFQCur = 0 Then
            DebugAppend "LVLoadFolderEx->WARNING: pidlFQCur=0", 22
        End If
        If (psfNew Is Nothing) = False Then
            Set psfCur = psfNew 'psf
        Else
            Set psfCur = Nothing
            DebugAppend "LVLoadFolderEx->WARNING: Could not get IShellFolder for current location.", 22
        End If
        
    '    siParent.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
        
    '    Set upiNew = siParent
    '    upiNew.GetParentAndItem pidlNew1, psfNew, pidlRelNew1
    '    psfNew.EnumObjects hLVS, SHCONTF_FOLDERS, ieidl
        
        Set psf2New = psfNew
        
    '    If (pEnum Is Nothing) = False Then
    '        DebugAppend "LVLoadFolder::pEnum succeeded"
    '    End If
        Set pThumbFact = Nothing
        bBlockLoad = True
        nBlocks = nBlocks + 1
        DebugAppend "LVLoadFolderEx::Start nBlocks=" & nBlocks, 2000
            Dim nclp As LongPtr
            nclp = -1
        If hCombo Then
            Dim nccb As Long
            nccb = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
            nclp = GetCBXItemlParam(hCombo, nccb)
            EnableWindow hCombo, 0&
            pbControlBox.Enabled = False
            nIcoForMq = cbItems(nclp).nIcon
            If mEditMarq Then StartLoadingMarquee m_sCurPathDisp
        End If
        If sPP <> "" Then
        Dim lCacheID As Long
        
        lCacheID = DoCacheEntry(sPP)
        If nclp >= 0 Then
            cbItems(nclp).lCacheIdx = lCacheID
        End If
           
        If (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS) Then
            If (sPP <> sComp) And (InStr(sPP, "\\?\usb#") = 0) Then
                'Only those folders can display progress, but the m_SubitemProgress item can't be cleared
                'for sure until after column processing, which is after enum and adding items. So we'll
                'clear it hear presumptively to avoid a bug with tile lines.
                m_SubItemProgress = 0
            End If
        End If
           
    '    If (MainCache(lCacheID).bSet = True) And (MainCache(lCacheID).bInvalidate = False) Then
    '        'Restore from Cache
    '        'exit sub
    '    End If
        End If
    
        Set siCurPath = siParent
    
        If (pLVF Is Nothing) = False Then
            If bFooterDoReload Then
                FooterRemove
            Else
                pLVF.RemoveAllButtons
            End If
            Set pLVF = Nothing
        End If
            
        lCurMaxInd = 0
        If ((bShowParentItemsInAllViews = True) Or ((m_ViewMode = SB_VIEW_DETAILS) And (bGV = False))) Then
            
            If (mDispParAndIndt = True) And (bFlagNoIndent = False) Then
                AddParentsToLVItms siParent
                nCur = UBound(LVEntries) + 1
                lCurMaxInd = LVComputeIndent(sPP) + 1
                     If (m_CompAsRoot = True) And (sPP = sComp) Then lCurMaxInd = 0&
        
            End If
        End If
        DebugAppend "LVLoadFolderEx::Start main loop...    ", 22
            If (Left$(sPP, 3) = "::{") And (Left$(sPP, Len(sLibRoot)) <> sLibRoot) Then ' And (InStr(sPP, "\\?\usb#") = 0) Then
    '        bColPreload = True
            bFlagNoPL = True
        Else
    '        bColPreload = mExtColPreload
            bFlagNoPL = False
        End If
    
        bInLVLFLoop = True
        bLVEscaped = False
    '    Do While (pEnum.Next(1&, siChild, pc) = S_OK)
        '*********************************************************
        
        
        Dim pDir As FILE_DIRECTORY_INFORMATION
        Dim hFind As LongPtr
        Dim bytBuffer() As Byte
        Dim bytName() As Byte
        Dim strPath As String
        Dim strFileName As String * 520
        Dim dwFileNameOffset As LongPtr
        Dim dwDirOffset As Long
        Dim sTrimmed As String
        strPath = sPP
        
        ReDim bytBuffer(LenB(pDir) + 260 * 2 - 3)
        
            
        If Right$(strPath, 1) <> "\" Then strPath = strPath & "\"
        hFind = FindFirstFileNt(strPath, bytBuffer)
        If (hFind = -1) Or (hFind = 0) Then
            DebugAppend "hFind=-1, exiting", 22
            GoTo enumdone
        End If
        DebugAppend "UBound(bytBuffer)=" & UBound(bytBuffer), 22
        CopyMemory pDir, bytBuffer(0), LenB(pDir)
        ReDim bytName(pDir.FileNameLength - 1)
        dwFileNameOffset = VarPtr(bytBuffer(&H40))
        CopyMemory bytName(0), ByVal dwFileNameOffset, pDir.FileNameLength
        strFileName = strPath & CStr(bytName)
        
        Erase bytBuffer
        ReDim bytBuffer((LenB(pDir) + CLng(260 * 2 - 3)) * CLng(&H10000))
        
        
        If FindNextFileNt(hFind, bytBuffer) Then
            dwDirOffset = 0
            Do While 1
                ZeroMemory pDir, LenB(pDir)
                CopyMemory pDir, ByVal VarPtr(bytBuffer(dwDirOffset)), LenB(pDir)
                Erase bytName
                ReDim bytName(pDir.FileNameLength - 1)
                dwFileNameOffset = dwDirOffset + &H40
                dwFileNameOffset = VarPtr(bytBuffer(dwFileNameOffset))
                CopyMemory bytName(0), ByVal dwFileNameOffset, pDir.FileNameLength
                strFileName = strPath & CStr(bytName)
                    sTrimmed = CStr(bytName) ' Left$(strFileName, Len(strPath) + (pDir.FileNameLength / 2))
    '                sTrimmed = CStr(bytName) 'CStr(FileTimeToDate(pDir.CreationTime)) & " " &
                    If (sTrimmed <> (".")) And (sTrimmed <> ("..")) Then
    '                    i = i + 1
    '                    Debug.Print "cb=" & pDir.FileNameLength & ",attrib=" & pDir.FileAttributes & ",id=" & Dec2Hex(Replace(CStr(LargeIntToLongLong(pDir.FileId)), ".", "")) & ",file=" & sTrimmed
    '                    nFiles = nFiles + 1
                        lAtr = FileAttribsToSFGAO(pDir.FileAttributes)
                        If (m_HiddenPref = SBHP_UseExplorer) Then
                            If (mHPInExp = False) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
                        Else
                            If (m_HiddenPref = SBHP_AlwaysHide) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
                        End If
                        If (m_SuperHiddenPref = SBSHP_UseExplorer) Then
                            If (mSHPInExp = False) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
                        Else
                            If (m_SuperHiddenPref = SBSHP_AlwaysHide) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
                        End If
                        
                        If bLVEscaped = True Then 'cancel load
                            GoTo enumdone
                        End If
                        
                        If bSrSetCancel = True Then
                            'Enumerating a search folder is conducting the search; stop enum aborts
                            bSrSetCancel = False
                            GoTo enumdone
                        End If
    
                        sName = "": sFull = "": sNameFull = "": sNameParse = "": sExt = "": crSize = 0: bIsZip = False: bIsFldr = False: dwLinkAtr = 0&: bLnkFldr = False: bLnkGen = False ': lpName = 0&: lpFull = 0&: lpIcon = 0&: lpIconOvr = -1&
                
                        sName = sTrimmed
                        sNameFull = sName
                        sFull = AddBackslash(sPP) & sName
                        snlc = LCase$(sName)
                        If (pDir.FileAttributes And FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY Then
                            bIsFldr = True
                            If mFilesOnly Then GoTo nxt
                        End If
                        bIsZip = (Right$(snlc, 4) = ".zip")
                        If (bIsFldr = True) Or ((bIsZip = True) And (m_BrowseZip = True)) Then
                            If (m_FolderFilter <> "") And (m_FolderFilter <> "*") Then
                                If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                            End If
                        Else
    
    
                            If (m_FollowLinks = True) Then
                                If mIncludeFldrLnkInFldrOnlyHPF = True Then
                                    If Len(sName) > 4 Then
                                        If Right$(snlc, 4) = ".lnk" Then
                                            dwLinkAtr = GetLinkAttribsByPath(sFull)
                                            If (((dwLinkAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And (m_BrowseZip = True)) Or (((dwLinkAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((dwLinkAtr And SFGAO_STREAM) = 0) And (m_BrowseZip = False)) Then
                                                bLnkFldr = True
                                            End If
                                        End If
                                    End If
                                End If
                            End If
    
    
                            If (mFoldersOnly = True) Then
                                If m_BrowseZip Then
                                    If (bIsZip = False) And (bLnkFldr = False) Then GoTo nxt
                                Else
                                    If (bLnkFldr = False) Then GoTo nxt
                                End If
                            End If
                            If (m_Filter <> "") And (m_Filter <> "*") And (m_Filter <> "*.*") Then
                                If QueryShowFile(sName, m_sCurPath) = False Then GoTo nxt
                            End If
                        End If
                                       
                        sExt = Right$(sNameFull, Len(sNameFull) - (InStrRev(sNameFull, ".") - 1))
                        
                        sParFull = sPP
                                                
                        lpIcon = I_IMAGECALLBACK
                        
                        If Len(sName) > 4 Then
                            If Right$(snlc, 4) = ".lnk" Then
                                bLnkGen = True
                                sName = Replace09(sName, ".lnk", "", Len(sName) - 4, 1, vbTextCompare)
                            End If
                        End If
                        ReDim Preserve LVEntries(nCur)
                        With LVEntries(nCur)
                            .pidlRel = pidlRelM
                            .sName = sName
                            .sNameExt = sName
                            .sNameFull = sNameFull
                            .sNameParsing = sNameFull 'sNameParse
                            .sExt = sExt
                            .dwAttrib = lAtr
                '            DebugAppend "InsertFull " & sNameFull & ",ext=" & sExt
                            .sFullPath = sFull
                            .sParentFull = sParFull
                            .ftDateA = pDir.LastAccessTime
                            .ftDateC = pDir.CreationTime
                            .ftDateM = pDir.LastWriteTime
                            .bFolder = bIsFldr
                            .bZip = bIsZip
                            If .bZip Then .bFolder = True
    '                        DebugAppend "LVLFEx " & sName & "->IsZip=" & .bZip
                            If bIsFldr Then
                                nCurFol = nCurFol + 1
                            Else
                '                DebugAppend "AddFile::" & sName
                                nCurFil = nCurFil + 1
                            End If
                            If bLnkGen Then
                                .bLink = True
                                If bLnkFldr Then
                                    .bLinkToFolder = True
                                End If
                            End If
    '                        If (bIsFldr = True) Or (bIsZip = True) Then
    '                            .lDropTarget = 2
    '                        End If
                '            .sSize = CStr(vpv)
                            '.cSize = crSize '* 10000 'No longer need to multiply since switch from IShellItem2.GetUI64 to IPropertyStore.GetValue
                            CopyMemory .cSize, pDir.AllocationSize, 8
                            m_CurSize = m_CurSize + .cSize
                            If bGV Then
                                .iGrp = I_GROUPIDCALLBACK
                            End If
                            .nIcon = I_IMAGECALLBACK
                            .nFileIcon = I_IMAGECALLBACK
                            If bLnkGen Then
                                .nFileOverlay = 2
                                .nOverlay = 2
                            End If
                            .lParam = nCur
                        End With
                        ReDim LVEntries(nCur).LinkCols(0)
                        ReDim LVEntries(nCur).ExtColData(0)
                        LVEntries(nCur).ExtColData(0).cdid = lDefColIdx(0)
                        If sParPN = sComp Then
                            LVEntries(nCur).ExtColData(0).sDisp = sNameFull
                            LVEntries(nCur).ExtColData(0).vRaw = sNameFull
                        Else
                            LVEntries(nCur).ExtColData(0).sDisp = sName
                            LVEntries(nCur).ExtColData(0).vRaw = sName
                        End If
                        
                        If hLVS Then
                            If InsertListItem(LVEntries(nCur)) = -1 Then
                                DebugAppend "LVLoadFolderEx->Error: LVM_INSERTITEMW failed"
                            End If
            
                            If mShowDataStreams Then
                                nCur = nCur + AddDataStreams(nCur)
                            End If
                        End If
                        
                        
    ''In a future version I'm going to time this out and apply it to see if the difference is minor enough
    ''to include, but for now if you want to use this feature you'll need to disable High Performance Mode.
    '            If bAllowExpandChildrenInHPF Then
    '                Dim bAddToDD As Boolean
    '                Select Case nExpandSelectedFolderInDropdown
    '                    Case 0
    '                        If ((m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls)) And (bIsFldr = True) Then
    '                            bAddToDD = True
    '                        Else
    '                            bAddToDD = False
    '                        End If
    '                    Case 1
    '                        If (bIsFldr = True) Then
    '                            bAddToDD = True
    '                        Else
    '                            bAddToDD = False
    '                        End If
    '                    Case 2
    '                        bAddToDD = False
    '                End Select
    '                If bAddToDD Then
    '                    If (siChild Is Nothing) = False Then
    '                        bSuppress = True
    '                        DebugAppend "LVLoadFolder::Insert " & sName
    '                        bAdjustOrder = True
    '                        nAdjustOrder = nAdjustOrder + 1
    '                        Call AddStandardFSItem(siChild, li, False)
    '                        bAdjustOrder = False
    '                        bSuppress = False
    '                        bFlagFixCh = True
    '                    End If
    '                End If
    '            End If
                        
                        
                        
                        nCur = nCur + 1
                        
    nxt:
                        If nCur = 30 Then
                            UpdateStatus mStrListing
                        End If
                        If nCur Mod lFolderLoadFileUpdateCount = 0 Then
                            UpdateStatus mStrListing & " " & nCur
                        End If
    
                    End If
                
                If pDir.NextEntryOffset = 0 Then Exit Do
                dwDirOffset = dwDirOffset + pDir.NextEntryOffset
                
            Loop
        End If
        NtClose hFind
    enumdone:
    lvlftt2 = GetTickCount()
    DebugAppend "LVLoadFolderEx loop time=" & (lvlftt2 - lvlftt1) & "ms" ', 11
    
        nAdjustOrder = 0
        bInLVLFLoop = False
    '    Set psfCur = psfNew
    '    pidlFQCur = pidlNew1
        If bBlankLoaded Then
            bBlankLoaded = False
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
        End If
        lKeepColIdx = nCurrentCBItemIndex
        lKeepColSet = cbItems(lKeepColIdx).lColSet
        If hLVS Then
    '        LVAdjustLabelWidth
            ProcessColumns siParent
            DebugAppend "LVLoadFolderEx returned from ProcessColumns", 2
            bSupDisp = False
            lSortK = 0
            lSortD = 1
            ecdKey = 0
            If m_cbSort = 0& Then
                If mUseAdvancedSort Then
                    m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
                Else
                    m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
                End If
            End If
            mLastSortInfo = eSortName
            Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
            Call SetSortArrowAPI(hLVS, -1, -1)
            Call SendMessage(hLVS, LVM_SETSELECTEDCOLUMN, -1&, ByVal 0&)
            If m_GroupMode <> SBGB_None Then GroupUpdateAllFooters hLVS
            If (m_ViewMode = SB_VIEW_TILE) And (m_SubItemProgress > 0) Then
                'Since the subitem gets cleared after navigating to a new folder, we need to reset the tiles
                DebugAppend "LVLoadFolderEx (m_ViewMode = SB_VIEW_TILE) And (m_SubItemProgress > 0)", 3
                TileViewProgressEnsureCols
                Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
                SetTileInfo hLVS
                SendMessage hLVS, LVM_REDRAWITEMS, 0, ByVal nCur
                UpdateWindow hLVS
            End If
        End If
    
    lvlftt3 = GetTickCount()
    DebugAppend "LVLoadFolderEx interval=" & (lvlftt3 - lvlftt2) & "ms" ', 11
    
    loaddone:
    
        If bFooterDoReload Then
            If bWillLoadSearchFt = False Then
                FooterCreate ftCache_LblText, ftCache_himl, ftCache_BtnCaps, ftCache_BtnIcon, ftCache_BtnLp
            End If
        End If
        If bWillLoadSearchFt = True Then
            bWillLoadSearchFt = False
        End If
        
        If hLVS Then MapCurrentColumns
        Dim lColCnt As Long
        lColCnt = Header_GetItemCount(hLVSHdr)
        'next, delete unused columns
        ReDim MainCache(lCacheID).ColSet(lColCnt)
        Dim lp As LongPtr
        For i = 0 To lColCnt - 1
            lp = GetHDItemlParam(hLVSHdr, i)
            MainCache(lCacheID).ColSet(i) = lp
        Next i
        MainCache(lCacheID).FileData = LVEntries
        MainCache(lCacheID).bSet = True
        DebugAppend "LVLoadFolderEx::Created cache entry", 2
        
        If bFlagFixCh Then
            DebugAppend "LVLoadFolderEx::Rearrange children for dropdown, par->" & m_sCurPath
            FixChildren m_sCurPath
        End If
        
        StopLoadingMarquee
        Dim sRpt As String
        sRpt = sPath
        If sRpt = "0" Then 'we don't want to report "0" externally,; it's our internal reference point
            Dim lpx As LongPtr
            siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpx
            sRpt = LPWSTRtoStr(lpx)
        End If
        Set siCurPath = siParent
        
        nBlocks = nBlocks - 1
        DebugAppend "LVLoadFolderEx::Out nBlocks=" & nBlocks, 2000
        If nBlocks = 0 Then
            bBlockLoad = False
            If hCombo Then EnableWindow hCombo, 1&
            pbControlBox.Enabled = True
        End If
        Dim idxCB As Long
        idxCB = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
        nCurrentCBItemIndex = GetCBXItemlParam(hCombo, idxCB)
        DebugAppend "idxCB=" & idxCB & ",lp=" & nCurrentCBItemIndex
    
        SetSearchBoxCue
        
        If m_DtPane Then pvCreateDetailPaneBkg
        nCurFolders = nCurFol
        nCurFiles = nCurFil
        DebugAppend "Loaded " & nCurFiles & " files and " & nCurFolders & " folders"
        Dim sFN As String
        If nCurFolders = 1 Then
            sFN = " " & mFolderStr & ", "
        Else
            sFN = " " & mFoldersStr & ", "
        End If
        Dim sfn2 As String
        If nCurFiles = 1 Then
            sfn2 = " " & mFileStr & " ("
        Else
            sfn2 = " " & mFilesStr & " ("
        End If
        UpdateStatus mReadyStr
        If (nCurFiles + nCurFolders) = 0 Then
            UpdateStatus mNoItemsStr, idxSizePanel
        Else
            UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2 & _
                                                        FormatFileSizeCurExB(m_CurSize, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                       False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb) & ")", idxSizePanel
        End If
        StartNotifyOnCurPath
        Dim upip As IParentAndItem
        Set upip = siParent
        Dim pp1 As LongPtr, pp2 As LongPtr
        Dim psfx As IShellFolder
        upip.GetParentAndItem pp1, psfx, pp2
        
        If AppendPidlRecByItem(m_sCurPath, siParent) = False Then
            AppendPidlRec m_sCurPath, pp1, pp2 'store the pidl in case there's trouble loading virtual locations
        End If
    '    For i = 0 To UBound(sHistory)
    '        If i = nHistIdx Then
    '            DebugAppend sHistory(i) & "<---nHistIdx (Verify?=" & VerifyHistIdx(m_sCurPath) & ")"
    '        Else
    '            DebugAppend sHistory(i)
    '        End If
    '    Next i
        
        If nHistIdx = UBound(sHistory) Then
            DebugAppend "SET DISABLE FORWARD"
            bEnableFwd = False
            EnableWindow hStdFwdButton, 0&
            pvDrawFwd NAV_FB_DISABLED
        End If
    '    For i = 0 To UBound(uPidlStore)
    '        DebugAppend "updl(" & i & ")=" & uPidlStore(i).sPath
    '    Next i
        If hLVS Then
            If (bFolderHasCat = True) And (bAutoGroupCategories = True) Then
                Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
                GroupByCatInsertGroups
                GroupByCatSetItems
                GroupUpdateAllFooters hLVS
                bCatGrpActive = True
                If mPrevGrpMode <> SBGB_Categorizer Then
                    mPrevGrpMode = m_GroupMode
                End If
                m_GroupMode = SBGB_Categorizer
            End If
        End If
        DebugAppend "LVLoadFolderEx Exiting. ParentParsing=" & sParPN & ", m_GroupMode=" & m_GroupMode & ", IsEnabled=" & CStr(SendMessage(hLVS, LVM_ISGROUPVIEWENABLED, 0&, ByVal 0&)) & ", GroupCount=" & CStr(SendMessage(hLVS, LVM_GETGROUPCOUNT, 0&, ByVal 0&))
    Else
        DebugAppend "LVLoadFolderEx->Failed to get siParent"
        If IsComCtl6 Then
            SimpleDialog mLoadFail & sPath, TDCBF_OK_BUTTON, App.Title
        Else
            MsgBox mLoadFail & sPath, vbOKOnly, App.Title
        End If
        
        UpdateStatus mLoadFail & sPath
        If CBItemExists(m_sCurPath) And (m_sCurPath <> "") Then
            i = GetItemIndex(m_sCurPath, j)
            SendMessage hCombo, CB_SETCURSEL, i, ByVal 0&
        End If
    End If
    
    'We wouldn't be *in* a Search Folder, but we might be exiting one.
    'Check if we need to revert to the prior Group state.
    If bSearchAutogrouped Then 'Previous folder autogrouped
        If lPriorGroupCol = -1& Then
            SetGroupMode SBGB_None
            lGrpCol = -1
        Else
            lGrpCol = lPriorGroupCol
            SetGroupModeByCol lGrpCol
        End If
    End If
    bSearchAutogrouped = False
    
    'Don't even get me fucking started on the bug that this addresses:
    If (bFlagRootReset = True) Or ((InStr(sTrackPrevLoc, "\\?\usb#") = 0) And (InStr(m_sCurPath, "\\?\usb#") > 0)) Then
        bFlagRootReset = False
        If ((m_ViewModeEx = SB_VIEW_MDICON) Or (m_ViewModeEx = SB_VIEW_ICON) Or (m_ViewModeEx = SB_VIEW_XLICON)) Then
            LVResetIconCallbacks
        End If
        DebugAppend "LVLoadFolderEx::Did refresh", 3
    End If
    If Left$(sParPN, 8) = "\\?\usb#" Then
        bFlagRootReset = True
    End If
    'End fucked up bug fix
    'LockWindowUpdate 0&
    'EnableWindow hLVS, 1&
    'Dim tcsr As Long, tcsr2 As Long
    SendMessage hLVS, LVM_REDRAWITEMS, 0, ByVal nCur
    'tcsr = GetTickCount()
    Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
    'tcsr2 = GetTickCount()
    'Debug.Print "WM_SETREDRAW time=" & (tcsr2 - tcsr) & "ms"
    'If m_DisableWhileLoading Then EnableWindow hLVS, 1&
    'If IsRefresh Then Exit Sub
    sTrackPrevLoc = m_sCurPath
    
    If bLVEscaped Then
        UpdateStatus m_str_CancelLoad
        If mPlaySnd Then
            If bSoundCritical Then DoSound SND_CRITICAL
        End If
        bLVEscaped = False
    Else
        If mPlaySnd Then
            If bSoundNavigate Then DoSound SND_NAVIGATESTART
        End If
    End If
    
    If mDispSecZn Then
        Dim zn As URLZONE
        zn = GetFileEffectiveZone(m_sCurPath)
        UpdateZonePanel zn
        DebugAppend "Zone=" & zn
    End If
    
    RaiseEvent DirectoryChanged(sRpt, siParent, pidlFQCur)
    Dim lvlftt4 As Long
    lvlftt4 = GetTickCount()
    DebugAppend "LVLoadFolderEx total time=" & (lvlftt4 - lvlftt1) & "ms, post-loop=" & (lvlftt4 - lvlftt3) & "ms", 11
    If bShowLoadTimeAsStatus Then
        UpdateStatus "Load Time (HighPerf): Total time=" & (lvlftt4 - lvlftt1) & "ms, post-loop=" & (lvlftt4 - lvlftt3) & "ms"
    End If
    Exit Sub
    e0:
    DebugAppend "LVLoadFolderEx->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 2
    Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
    End Sub
    
    '*2
    
    Private Sub LVLoadFolder(ByVal sPath As String, Optional bLoadFID As Boolean = False, Optional bFallbackPresent As Boolean = False, Optional siFallback As IShellItem, Optional IsRefresh As Boolean = False, Optional lAssignSearchIdx As Long = -1&)
    'Sync any changes with LVAddEntry.
    If Ambient.UserMode = False Then Exit Sub
    bUsedHPFforCD = False
    Dim bSearchFld As Boolean
    If (lAssignSearchIdx >= 0&) Or (bWillLoadSearchFt = True) Or (Left$(sPath, Len(mFldrSrch)) = mFldrSrch) Then
        bSearchFld = True 'Search Results folder
        If bUseSearchMarkup = False Then
            bUseSearchMarkup = True
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
        End If
        If hSearchBox Then
            bFlagSearchDisable = True
            EnableWindow hSearchBox, 0&
        End If
    Else
        If bUseSearchMarkup = True Then
            bUseSearchMarkup = False
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
        End If
        If hSearchBox Then
            bFlagSearchDisable = False
            EnableWindow hSearchBox, 1&
        End If
    End If
    
    If (mHighPerfMode = True) And (mExtColPreload = False) Then
        '*********************************
        'HIGH PERFORMANCE ROUTINE
        'Only supports standard hard drive locations; can't redirect for virtual locations
        Dim bAllowAlt As Boolean
        bAllowAlt = True
        Dim lpDct As LongPtr, sDct As String
        If (sPath <> "") And (sPath <> "0") And (sPath <> "1") Then
            sDct = sPath
        Else
            If (siDirect Is Nothing) = False Then
                siDirect.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpDct
                sDct = LPWSTRtoStr(lpDct)
            End If
        End If
        
        If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then bAllowAlt = False: GoTo gohpf
        If (nExpandSelectedFolderInDropdown = SBEDM_AllModes) Then bAllowAlt = False: GoTo gohpf
        If sDct = "" Then bAllowAlt = False: GoTo gohpf
        If Left$(sDct, 3) = "::{" Then bAllowAlt = False: GoTo gohpf 'Virtual locations are unsupported
        If Left$(sDct, 8) = "\\?\usb#" Then bAllowAlt = False: GoTo gohpf
        If CheckDirForHPf(sDct) = True Then bAllowAlt = False: GoTo gohpf 'Right now just fonts; but any other incompatible folders may be added later
        If bSearchFld = True Then bAllowAlt = False: GoTo gohpf 'Doesn't work with Search Results folders
        If mDispParAndIndt = True Then bAllowAlt = False: GoTo gohpf
        If Len(sDct) > 3 Then
            If (LCase$(Right$(sDct, 4)) = ".zip") Or (LCase$(Right$(sDct, 4)) = ".cab") Then 'Doesn't work inside Zip files.
                bAllowAlt = False: GoTo gohpf
            End If
            If (InStr(LCase$(sDct), ".zip\")) Or (InStr(LCase$(sDct), ".cab\")) Then
                bAllowAlt = False: GoTo gohpf
            End If
        End If
        If Len(sDct) >= 3 Then
            If PathIsNetworkPath(StrPtr(sDct)) Then bAllowAlt = False
        End If
    gohpf:
        If bAllowAlt = True Then
            bFlagHPfErr = False
            DebugAppend "LVLoadFolder->Using high performance loader for " & sDct, 23
            LVLoadFolderEx sPath, bLoadFID, bFallbackPresent, siFallback, IsRefresh, lAssignSearchIdx
            If bFlagHPfErr = False Then
                bUsedHPFforCD = True
                Exit Sub
            Else
                DebugAppend "WARNING: Error in high-perf loader; falling back to standard. Dir=" & sDct, 10
                bFlagHPfErr = False 'An error occured with the new routines; fall back to the regular one
            End If
        Else
            DebugAppend "LVLoadFolder->Using standard loader for " & sDct, 23
        End If
        '*********************************
    End If
    
    
    
    'To time folder loading, uncomment the following two lines
    'Then uncomment the other timing/results call for lvlftt2 at the end of this sub
    Dim lvlftt1 As Long, lvlftt2 As Long
    lvlftt1 = GetTickCount()
    bSupDisp = True
    Dim fNavCan As Long
    Dim sRslv As String
    If sRslv = "0" Then
        If m_CompAsRoot Then
            sRslv = sComp
        Else
            sRslv = m_sDesktopPath
        End If
    End If
    RaiseEvent PreDirectoryChange(sRslv, fNavCan)
    FastDoEvents 'DoEvents
    If fNavCan <> S_OK Then Exit Sub
    UpdateStatus mStrOpening
    If m_DisableWhileLoading Then EnableWindow hLVS, 0&
    Dim i As Long, j As Long
    Dim pEnum As IEnumShellItems
    Dim siChild As IShellItem
    Dim siParent As IShellItem
    Dim pc As Long
    Dim bLnkFldr As Boolean
    Dim siLink As IShellItem, sLink As String, pidlLink As Long
    Dim dwLnkAtr As SFGAO_Flags
    Dim lAtr As SFGAO_Flags, lAtrP As SFGAO_Flags
    Dim nCur As Long, nCurFol As Long, nCurFil As Long
    Dim psf As IShellFolder
    Dim bIsFldr As Boolean, bIsZip As Boolean
    Dim lGM As Long
    Dim hr As Long
    Dim nOvr As Long
    Dim nPos As Long
    Dim lpName As LongPtr, sName As String
    Dim sNameExt As String
    Dim sNameFull As String
    Dim sNameParse As String
    Dim lpFull As LongPtr, sFull As String
    Dim sParFull As String
    Dim lpDisp As LongPtr, sDisp As String
    Dim sExt As String, lpExt As Long
    Dim crSize As Currency
    Dim lpr As Long, szr As String
    Dim tFTC As FILETIME, tFTM As FILETIME, tFTA As FILETIME
    Dim pIcon As IShellIcon
    Dim pIconOvr As IShellIconOverlay
    Dim si2Child As IShellItem2
    Dim vpv As Variant, vbv As Variant
    Dim pStore As IPropertyStore 'Limited Property Store. MSDN says GetPropertyStoreForKeys is faster than a full store.
    Dim pkSet() As PROPERTYKEY, npkSet As Long
    Dim pdSet() As IPropertyDescription 'Also avoid looking up the Property Description every time
    Dim pidlPar As LongPtr, pidlRel As LongPtr, pidlcb As LongPtr
    Dim lpIcon As Long, lpIconOvr As Long, lpOvrN As Long
    Dim hIcon As LongPtr
    Dim pUnk As IUnknownUnrestricted
    Dim upi As IParentAndItem
    Dim lpCPath As LongPtr
    Dim sPP As String
    Dim sParPN As String
    Dim st1 As SYSTEMTIME
    Dim rtSup As Boolean, rtVal As Long
    Dim lpPath As LongPtr
    Dim sOldPath As String
    Dim bModeForcedFO As Boolean
    Dim bFlagFixCh As Boolean
    Dim pidxDC As Long, pidxDM As Long, pidxDA As Long, pidxTY As Long, pidxRT As Long, pidxPL As Long, pidxGP As Long, pidxSZ As Long
    Dim npidx As Long
    Dim bColPreload As Boolean
    Dim li As Long
    Dim pcppv As LongPtr
    
    
    
    nAdjustOrder = 0
    sOldPath = m_sCurPath
    On Error GoTo e0
    
    'Clear any old preview
    Set pbPreviewPane.Picture = Nothing
    If (ipv Is Nothing) = False Then
        Set pPvhVis = Nothing
        ipv.Unload
    End If
    
    
    Set mIShIcon = Nothing
    
    ReDim bOvrAdded(0)
    bUseDrvRemForEM = False
    SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
    
    DebugAppend UserControl.Name & ".LVLoadFolder " & sPath & ",m_sCurPath=" & m_sCurPath & ",sPrevPath=" & sPrevPath & ",GrpMode=" & m_GroupMode, 2
    If sPath = "*CUSTOM" Then
        PopulateCustomSet
        Exit Sub
    Else
        bCustActive = False
    End If
     
    Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&)
    
    EnableWindow hUpButton, 1&
    bUpEnable = True
    If bLoadFID = False Then
        If sPath = "0" Then 'desktop
            If mCustomRoot <> "" Then
                SHCreateItemFromParsingName StrPtr(mCustomRoot), Nothing, IID_IShellItem, siParent
            Else
                
                If m_CompAsRoot Or (m_Mode = SBCTL_DrivesOnly) Then
                    SHGetKnownFolderItem FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siParent
                Else
                    Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siParent)
                End If
            End If
            EnableWindow hUpButton, 0&
            bUpEnable = False
        Else
            SHCreateItemFromParsingName StrPtr(sPath), Nothing, IID_IShellItem, siParent
            If siParent Is Nothing Then
                'Try shell: fallback for ::{GUID} items not resolving normally
                If Left$(sPath, 3) = "::{" Then
                    Dim sSh As String
                    sSh = "shell:" & sPath
                    SHCreateItemFromParsingName StrPtr(sSh), Nothing, IID_IShellItem, siParent
                End If
            End If
            If (sPath = mCustomRoot) And (mCustomRootEnforce = True) Then
                EnableWindow hUpButton, 0&
                bUpEnable = False
            End If
        End If
    Else
        'load from direct Folder ID
    '    SHGetKnownFolderItem LFFID, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siParent
        If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
            If IsRootChild(, siDirect) = False Then
                UpdateStatus mStrForbidden
                Exit Sub
            End If
        End If
        Set siParent = siDirect
        'Add item to combo here to avoid querying for the shell item twice
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
        sPath = LPWSTRtoStr(lpPath)
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpCPath
    
        m_sCurPath = LPWSTRtoStr(lpCPath)
        bSuppress = True
        i = AddStandardFSItem(siParent, li, True, lAssignSearchIdx)
        Call SendMessage(hCombo, CB_SETCURSEL, i, ByVal 0&)
        bSuppress = False
        If i = 0 Then
            EnableWindow hUpButton, 0&
            bUpEnable = False
        End If
    End If
    
    If (siParent Is Nothing) Then
        If bFallbackPresent Then
            Set siParent = siFallback
        End If
    End If
    
    If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
        If IsRootChild(, siParent) = False Then
            UpdateStatus mStrForbidden
            Exit Sub
        End If
    End If
    
    'Set history
    If (siParent Is Nothing) = False Then
        If (sPath <> sOldPath) And (sPath <> "") Then 'if equal it's a refresh, so don't duplicate in history
            
            sPrevPath = m_sCurPath
            m_sCurPath = sPath
          If bHistoryOp = False Then
            If nHistIdx = -1 Then
                sHistory(0) = m_sCurPath
                nHistIdx = 0
            Else
                If nHistIdx <> UBound(sHistory) Then
                    Dim sht() As String
                    ReDim sht(nHistIdx + 1)
                    For i = 0 To nHistIdx
                        sht(i) = sHistory(i)
                    Next i
                    nHistIdx = nHistIdx + 1
                    sht(nHistIdx) = sPath
                    sHistory = sht
                End If
                If sHistory(nHistIdx) <> sPath Then
                    nHistIdx = nHistIdx + 1
                    ReDim Preserve sHistory(nHistIdx)
                    sHistory(nHistIdx) = sPath
                    EnableWindow hStdBackButton, 1&
                    pvDrawBack NAV_BB_NORMAL
                    bBackEnable = True
                End If
            End If
          End If
        End If
    End If
    
    'If hLVS = 0 Then GoTo loaddone
    
    If (siParent Is Nothing) = False Then
        'first clear selection
        If (bCatGrpActive = True) Then
            DebugAppend "LVLoadFolder::SetPrevGrp " & mPrevGrpMode
            SetGroupMode mPrevGrpMode
            lGrpCol = mPrevGrpMode
        End If
        If bGV Then
           
            If m_GroupMode = SBGB_Type Then ClearGroupData 'remove groups for dynamic categories only
            If m_GroupMode = SBGB_Extended Then ClearGroupData ' SendMessage hLVS, LVM_REMOVEALLGROUPS, 0&, ByVal 0& 'they're rebuilt as items are added
            If m_GroupMode = SBGB_Categorizer Then ClearGroupData
        End If
    
        Call SendMessage(hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&)
        If bThumbsActive Then
            ImageList_Remove himl_Thumb, -1
        End If
        
        If m_ViewMode = SB_VIEW_ICON Then
    '        SwitchView LV_VIEW_DETAILS
    '        SwitchView m_ViewModeEx
        
            ImageList_Remove himlLarge, -1
    '        nCthimlL = 0
    '        LVSwitchToLgIcon
        End If
        
        nCurFolders = 0
        nCurFiles = 0
    
        ReDim LVEntries(0)
        mOvrMax = 0
        sSelectedFile = ""
        tSelectedFile.sName = ""
        tSelectedFile.sFullPath = ""
        ReDim sSelectedFiles(0)
        ReDim tSelectedFiles(0)
        ReDim sSelectedFileNames(0)
        ReDim sSelectedFileNamesF(0)
        ReDim sSelectedFilesOnly(0)
        ReDim sSelectedFilesOnlyFull(0)
        ReDim sSelectedFoldersOnly(0)
        ReDim sSelectedFoldersOnlyFull(0)
        Set siFocus = Nothing
        If pidlFQCur Then CoTaskMemFree pidlFQCur
        Set psfCur = Nothing
        
        m_CurSize = 0
        If IsRefresh = False Then m_SubItemProgress = 0&
        ResetSpecialCols
        
        If nLinks > 0 Then
            For i = 0 To UBound(hLinks)
                DestroyWindow hLinks(i)
            Next i
        End If
        ReDim hLinks(0): nLinks = 0
        ReDim SysImgCache(0)
        nSysImgCache = 0
        'Finish up then enumerate contents
    
        Set siCurPath = Nothing
        siParent.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK, lAtrP
        DebugAppend "PathAttrib=" & dbg_sfgao_tostring(lAtrP)
        siParent.GetDisplayName SIGDN_NORMALDISPLAY, lpDisp
        sDisp = LPWSTRtoStr(lpDisp)
        m_sCurPathDisp = sDisp
        Dim pCatG As ICategorizer, pUnkCG As IUnknown 'Unrestricted
        Dim nCategory As Long, kCat As Long
        bFolderHasCat = False
        ReDim gidCat(0)
        ReDim sItemCats(0)
    '    If (sPath = sComp) Then
            DebugAppend "In Computer, trying catprovider"
            Dim psf2 As IShellFolder2
            siParent.BindToHandler 0&, BHID_SFObject, IID_IShellFolder2, psf2
            If (psf2 Is Nothing) Then
                DebugAppend "Failed to get IShellFolder2"
            Else
                DebugAppend "Got IShellFolder2"
            End If
            If (psf2 Is Nothing) = False Then
                Dim scid As SHCOLUMNID
    '            psf2.MapColumnToSCID 1&, scid
                
                Dim pCatProvider As ICategoryProvider
                siParent.BindToHandler 0&, BHID_SFViewObject, IID_ICategoryProvider, pCatProvider
                If (pCatProvider Is Nothing) = False Then
                    DebugAppend "Got category provider"
                    
                    Dim tIDTmp As UUID
                    Dim tSCGUID As UUID
                    pCatProvider.GetDefaultCategory tIDTmp, scid
                    
    '                Dim pkn As PROPERTYKEY
    '                pkn = PKEY_ItemNameDisplay
    '                CopyMemory ByVal VarPtr(scid.fmtid.Data1), ByVal VarPtr(pkn), LenB(pkn)
    '                DebugAppend "pk 0x" & Hex$(scid.fmtid.Data1) & "...0x" & Hex$(scid.fmtid.Data4(7)) & "," & scid.pid
                    pCatProvider.GetCategoryForSCID scid, tSCGUID
                    DebugAppend "guid=" & dbg_GUIDToString(tSCGUID)
                    
                    If IsEqualIID(tSCGUID, UUID_NULL) = 0& Then
                        pCatProvider.CreateCategory tSCGUID, IID_IUnknown, pcppv 'pUnkCG 'pCatG '
                        If pcppv Then
                            vbaObjSetAddRef pCatG, pcppv
                        Else
                            DebugAppend "no catg ptr"
                        End If
                            
                        If (pCatG Is Nothing) = False Then
                            DebugAppend "Got categorizer"
                            bFolderHasCat = True
                        Else
                            DebugAppend "Failed to get categorizer"
                        End If
                    Else
                        DebugAppend "LVLoadFolder::No category support (SCID=NULL)"
                    End If
                Else
                    DebugAppend "LVLoadFolder::No category provider found."
                End If
            End If
    '    End If
               
        lpCPath = 0
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpCPath
        
        sPP = LPWSTRtoStr(lpCPath)
        Dim si2Par As IShellItem2
        Set si2Par = siParent
        Dim lp5 As LongPtr
        si2Par.GetString PKEY_ParsingName, lp5
        sParPN = LPWSTRtoStr(lp5)
        
        
        Dim psfNew As IShellFolder, psf2New As IShellFolder2
        Dim pidlNew1 As LongPtr, pidlRelNew1 As LongPtr
        Dim pidlRelM As LongPtr, pclNew As Long
        
        siParent.BindToHandler 0&, BHID_SFObject, IID_IShellFolder, psfNew
        SHGetIDListFromObject psfNew, pidlFQCur
        If pidlFQCur = 0 Then
            DebugAppend "WARNING: pidlFQCur=0"
        End If
        If (psfNew Is Nothing) = False Then
            Set psfCur = psfNew 'psf
        Else
            Set psfCur = Nothing
            DebugAppend "LVLoadFolder->WARNING: Could not get IShellFolder for current location."
        End If
            
    
        siParent.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
    
        If (pEnum Is Nothing) = False Then
            DebugAppend "LVLoadFolder::pEnum succeeded"
        End If
        Set pThumbFact = Nothing
        bBlockLoad = True
        nBlocks = nBlocks + 1
        DebugAppend "LVLoadFolder::Start nBlocks=" & nBlocks, 2000
        Dim nclp As LongPtr
        nclp = -1
        If hCombo Then
            Dim nccb As Long
            nccb = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
            nclp = GetCBXItemlParam(hCombo, nccb)
            EnableWindow hCombo, 0&
            pbControlBox.Enabled = False
            nIcoForMq = cbItems(nclp).nIcon
            If mEditMarq Then StartLoadingMarquee m_sCurPathDisp
        End If
        If sPP <> "" Then
        Dim lCacheID As Long
        
        lCacheID = DoCacheEntry(sPP)
        If nclp >= 0 Then
            cbItems(nclp).lCacheIdx = lCacheID
        End If
        
        If (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS) Then
            If (sPP <> sComp) And (InStr(sPP, "\\?\usb#") = 0) Then
                'Only those folders can display progress, but the m_SubitemProgress item can't be cleared
                'for sure until after column processing, which is after enum and adding items. So we'll
                'clear it hear presumptively to avoid a bug with tile lines.
                m_SubItemProgress = 0
            End If
        End If
        
    '    If (MainCache(lCacheID).bSet = True) And (MainCache(lCacheID).bInvalidate = False) Then
    '        'Restore from Cache
    '        'exit sub
    '    End If
        End If
        
        If (Left$(sPP, 3) = "::{") And (Left$(sPP, Len(sLibRoot)) <> sLibRoot) Then ' And (InStr(sPP, "\\?\usb#") = 0) Then
            bColPreload = True
            bFlagNoPL = True
        Else
            bColPreload = mExtColPreload
            bFlagNoPL = False
        End If
    DebugAppend "LVLoadFolder::Begin PKEY Setup..."
        ReDim pkSet(4)
        ReDim pdSet(4)
        pkSet(0) = PKEY_ParsingName: PSGetPropertyDescription pkSet(0), IID_IPropertyDescription, pdSet(0)
        pkSet(1) = PKEY_FileExtension: PSGetPropertyDescription pkSet(1), IID_IPropertyDescription, pdSet(1)
        pkSet(2) = PKEY_ParsingPath: PSGetPropertyDescription pkSet(2), IID_IPropertyDescription, pdSet(2)
        pkSet(3) = PKEY_ItemNameDisplay: PSGetPropertyDescription pkSet(3), IID_IPropertyDescription, pdSet(3)
        pkSet(4) = PKEY_SFGAOFlags: PSGetPropertyDescription pkSet(4), IID_IPropertyDescription, pdSet(4)
        npidx = 5
        If bColPreload Then
            ReDim Preserve pkSet(9)
            ReDim Preserve pdSet(9)
            pkSet(5) = PKEY_Size: PSGetPropertyDescription pkSet(5), IID_IPropertyDescription, pdSet(5): pidxSZ = 5
            pkSet(6) = PKEY_DateCreated: PSGetPropertyDescription pkSet(6), IID_IPropertyDescription, pdSet(6): pidxDC = 6
            pkSet(7) = PKEY_DateModified: PSGetPropertyDescription pkSet(7), IID_IPropertyDescription, pdSet(7): pidxDM = 7
            pkSet(8) = PKEY_DateAccessed: PSGetPropertyDescription pkSet(8), IID_IPropertyDescription, pdSet(8): pidxDA = 8
            pkSet(9) = PKEY_ItemTypeText: PSGetPropertyDescription pkSet(9), IID_IPropertyDescription, pdSet(9): pidxTY = 9
            npidx = 9
        End If
        If lvrCol > 0 Then
            ReDim Preserve pkSet(npidx + 2)
            ReDim Preserve pdSet(npidx + 2)
            pkSet(npidx + 1) = PKEY_Rating: PSGetPropertyDescription pkSet(npidx + 1), IID_IPropertyDescription, pdSet(npidx + 1): pidxRT = npidx + 1
            pkSet(npidx + 2) = PKEY_PropList_PreviewDetails: PSGetPropertyDescription pkSet(npidx + 2), IID_IPropertyDescription, pdSet(npidx + 2): pidxPL = npidx + 2
            npidx = npidx + 2
        End If
        npkSet = UBound(pkSet) + 1
        If bGV Then 'If you add anymore, you need to keep this block last, or change the usage of UBound(pdSet)
            DebugAppend "LVLoadFolder::bGV enabled post PKEY setup, lGrpCol=" & lGrpCol
            ReDim Preserve pkSet(npkSet)
            ReDim Preserve pdSet(npkSet)
            pkSet(npkSet) = uColData(lGrpCol).pKey: PSGetPropertyDescription pkSet(npkSet), IID_IPropertyDescription, pdSet(npkSet)
            npkSet = npkSet + 1
        End If
        
        Set siCurPath = siParent
    
        If (pLVF Is Nothing) = False Then
            If bFooterDoReload Then
                FooterRemove
            Else
                pLVF.RemoveAllButtons
            End If
            Set pLVF = Nothing
        End If
            
        lCurMaxInd = 0
        If ((bShowParentItemsInAllViews = True) Or ((m_ViewMode = SB_VIEW_DETAILS) And (bGV = False))) Then
            
            If (mDispParAndIndt = True) And (bFlagNoIndent = False) Then
                AddParentsToLVItms siParent
                nCur = UBound(LVEntries) + 1
                lCurMaxInd = LVComputeIndent(sPP) + 1
                     If (m_CompAsRoot = True) And (sPP = sComp) Then lCurMaxInd = 0&
        
            End If
        End If
        DebugAppend "LVLoadFolder::Start file enum loop...", 2000
        
        bInLVLFLoop = True
        bLVEscaped = False
        If (pEnum Is Nothing) Then
            DebugAppend "No enum object.", 2000
            GoTo loaddone
        End If
    '*********************************************************
    'START FILE ENUMERATION
    '   
        
        Do While (pEnum.Next(1&, siChild, pc) = S_OK)
            FastDoEvents
            Dim lppn As LongPtr
            Dim szppn As String
            siChild.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lppn
            szppn = LPWSTRtoStr(lppn)
            DebugAppend szppn
            
            If bLVEscaped = True Then 'cancel load
                GoTo enumdone
            End If
            
            If bSrSetCancel = True Then
                'Enumerating a search folder is conducting the search; stop enum aborts
                bSrSetCancel = False
                GoTo enumdone
            End If
            If pidlPar Then CoTaskMemFree pidlPar
            PropVariantClear vpv
            pidlPar = 0&: pidlcb = 0&: vbv = 0: lpr = 0: szr = "": bLnkFldr = False: sLink = "": dwLnkAtr = 0&: pidlLink = 0&
            sName = "": sFull = "": sNameFull = "": sNameParse = "": sExt = "": lpName = 0&: lpFull = 0&: lpIcon = 0&: lpIconOvr = -1&: crSize = 0: bIsZip = False
            If (siChild Is Nothing) Then
                DebugAppend "LVLF Enum child is nothing", 9
            End If
            Set si2Child = siChild
            Dim pshr As Long
            DebugAppend "Preparing to load pstore..."
            pshr = si2Child.GetPropertyStoreForKeys(pkSet(0), npkSet, GPS_OPENSLOWITEM Or GPS_BESTEFFORT Or GPS_DEFAULT, IID_IPropertyStore, pStore)
            pStore.GetValue PKEY_SFGAOFlags, vpv
            PropVariantToVariant vpv, vbv
            lAtr = CLng(vbv)
            If (m_HiddenPref = SBHP_UseExplorer) Then
                If (mHPInExp = False) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
            Else
                If (m_HiddenPref = SBHP_AlwaysHide) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
            End If
            If (m_SuperHiddenPref = SBSHP_UseExplorer) Then
                If (mSHPInExp = False) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
            Else
                If (m_SuperHiddenPref = SBSHP_AlwaysHide) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
            End If
            sFull = GetPropertyDisplayString(pStore, pdSet(2), pkSet(2)) 'PKEY_ParsingPath
            Dim ssPKP As String
            ssPKP = sFull
            If InStr(sFull, "\") Then
                sName = Right$(sFull, Len(sFull) - InStrRev(sFull, "\"))
                sNameFull = szppn
            Else
                sName = GetPropertyDisplayString(pStore, pdSet(3), pkSet(3)) 'PKEY_ItemNameDisplay
                sNameFull = sName & sExt
            End If
            If (pStore Is Nothing) = False Then
                sExt = GetPropertyDisplayString(pStore, pdSet(1), pkSet(1)) 'PKEY_FileExtension
    '            sNameParse = GetPropertyDisplayString(pStore, pdSet(1), pkSet(1)) 'PKEY_ParsingName
                If InStr(sName, "lnk") Then
                    DebugAppend "PKEY_ItemNameDisplay=" & sName
                    DebugAppend "PKEY_ParsingPath=" & sFull
                    DebugAppend "SIGDN_DeskAbsPar=" & szppn
                End If
                If InStr(szppn, "\") Then
                    sNameParse = Right$(szppn, Len(szppn) - InStrRev(szppn, "\"))
                    If sNameParse = "" Then
                        sNameParse = szppn
                    End If
                Else
                    sNameParse = szppn
                End If
            Else
                If sExt = "" Then
                    If InStr(sNameParse, ".") Then
                        sExt = Right$(sNameParse, Len(sNameParse) - (InStrRev(sNameParse, ".") - 1))
                    End If
    '            Else
    '                Dim sNFTmp As String, lpNFTmp As Long
    '                siChild.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpNFTmp
    '                sNFTmp = LPWSTRtoStr(lpNFTmp)
    '                If InStr(sNFTmp, ".") Then
    '                    sExt = Right$(sNFTmp, Len(sNFTmp) - (InStrRev(sNFTmp, ".") - 1))
    '                End If
                End If
                sNameParse = sNameFull
            End If
                
            If m_FollowLinks Then
                If ((lAtr And SFGAO_LINK) = SFGAO_LINK) Then
                    If mIncludeFldrLnkInFldrOnly = True Then 'Analyze link to see if it's a folder
                        On Error Resume Next
                        si2Child.GetUInt32 PKEY_Link_TargetSFGAOFlags, dwLnkAtr
                        Err.Clear
                        On Error GoTo e0
                        If (((dwLnkAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And (m_BrowseZip = True)) Or (((dwLnkAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((dwLnkAtr And SFGAO_STREAM) = 0) And (m_BrowseZip = False)) Then
                            bLnkFldr = True
                        End If
                    End If
                End If
            End If
            
            If m_BrowseZip Then
                If (((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER)) Or (bLnkFldr = True) Then 'And ((lAtr And SFGAO_STREAM) = 0) Then '
                    'true folder; always show
    '                    DebugAppend "AddFolder::" & sName
                        bIsFldr = True
                        If (m_FolderFilter <> "") And (m_FolderFilter <> "*") Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                Else
                    bIsFldr = False
                    If (mFoldersOnly = True) And (bLnkFldr = False) Then GoTo nxt
                    If (m_Filter <> "") And (m_Filter <> "*") And (m_Filter <> "*.*") Then
                            If QueryShowFile(sName, m_sCurPath) = False Then GoTo nxt
                    End If
                End If
            Else
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0) Then 'Then '
                    'true folder; always show
    '                    DebugAppend "AddFolder::" & sName
                        bIsFldr = True
                        If (m_FolderFilter <> "") And (m_FolderFilter <> "*") Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                Else
                    If sExt = ".library-ms" Then
                        bIsFldr = True
                        If (m_FolderFilter <> "") And (m_FolderFilter <> "*") Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                    Else
                        bIsFldr = False
                        If (mFoldersOnly = True) And (bLnkFldr = False) Then GoTo nxt
                        If (m_Filter <> "") And (m_Filter <> "*") And (m_Filter <> "*.*") Then
                            If QueryShowFile(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                    End If
    
                End If
            End If
            If (bIsFldr = True) And (mFilesOnly = True) Then GoTo nxt
            If (lAtr And SFGAO_FOLDER) = SFGAO_FOLDER Then
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = SFGAO_STREAM) Then
                    If sExt <> ".library-ms" Then
                        If ((lAtr And SFGAO_LINK) = 0&) Then
                            bIsZip = True
                        End If
                    End If
                End If
            End If
            DebugAppend "LVLoadFolder::Add sName=" & sName, 2
            sNameExt = sName
            siChild.GetDisplayName SIGDN_NORMALDISPLAY, lpName
            sName = LPWSTRtoStr(lpName)
    '        DebugAppend "sName=" & sName, 2
    
            sParFull = StrGetPath(sFull)
    '        If (pStore Is Nothing) = False Then
    '            sExt = GetPropertyDisplayString(pStore, pdSet(2), pkSet(2)) 'PKEY_FileExtension
    '            sNameParse = GetPropertyDisplayString(pStore, pdSet(1), pkSet(1)) 'PKEY_ParsingName
    '        Else
    '            If InStr(sNameFull, ".") Then
    '                sExt = Right$(sNameFull, Len(sNameFull) - (InStrRev(sNameFull, ".") - 1))
    '            End If
    '            sNameParse = sNameFull
    '        End If
            If InStr(sFull, "\") Then
                sNameFull = Right$(sFull, Len(sFull) - InStrRev(sFull, "\"))
            Else
                sNameFull = sName & sExt
            End If
            If (sNameFull = "") And (Len(sFull) = 3) Then
                'Drive in Computer
                sNameFull = sFull
            End If
            If m_ForceExt = SBEP_AlwaysShow Then
                If sPath <> sComp Then 'Names given to USB devices is a god damn mess
                    If (Left$(sNameFull, 3) <> "::{") And (Left$(sNameFull, 5) <> "uuid:") And ((InStr(sNameFull, "\?\usb#")) = 0) And (Left$(sNameFull, 7) <> "usb#vid") Then
                        sName = sNameFull
                    End If
                End If
            End If
    
    
            Set upi = siChild
            upi.GetParentAndItem pidlPar, psf, pidlRel
            If bColPreload = True Then
            On Error Resume Next
            If (psf Is Nothing) = False Then
    '            DebugAppend "psf is valid, set pIcon with pidlRel=" & pidlRel & ",pidl=" & pidlPar
    '            Set pIcon = psf
                Set pUnk = psf
                hr = pUnk.QueryInterface(IID_IShellIcon, pIcon)
    '           DebugAppend "QueryInterface=0x" & Hex$(hr)
                If hr = S_OK Then
                    pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
                Else
    
                  pidlcb = ILCombine(pidlPar, pidlRel)
    '              DebugAppend "pidlcb=" & pidlcb
                  lpIcon = GetFileIconIndexPIDL(pidlcb, SHGFI_SMALLICON)
    '              DebugAppend "lpIcon via pidlcb=" & lpIcon
                  If lpIcon = -1 Then lpIcon = 0
                  If lpIcon = 0 Then
                    'Fonts folder requires custom handling here; let me know if anywhere else needs it
                    Dim cFn As Long
                    cFn = Len(mFontFolder)
                    If True Then 'Left$(sParFull, cFn) = mFontFolder Then
                        Dim psfPar As IShellFolder
                        Dim pidlt1 As LongPtr, pidlrelt1 As LongPtr
                        Dim upipar As IParentAndItem
                        Set upipar = siParent
                        upipar.GetParentAndItem pidlt1, psfPar, pidlrelt1
                        If (psfPar Is Nothing) = False Then
    '                        DebugAppend "Got psfPar"
                            Dim punk2 As IUnknownUnrestricted
                            Set punk2 = psfPar
                            hr = 0&
                            hr = punk2.QueryInterface(IID_IShellIcon, pIcon)
    '                        DebugAppend "SI->icn=0x" & Hex$(hr)
                            If hr = S_OK Then
                                pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
    '                            DebugAppend "psfPar::lpIcon=" & lpIcon
                            End If
                        End If
                        'PASTE
                    End If
                  End If
                End If
    '            If lpIcon = 0 Then
    '                DebugAppend "No icon retrieved, using parent..."
    '                If pidlPar Then
    '                    lpIcon = GetFileIconIndexPIDL(pidlPar, SHGFI_SMALLICON)
    '                Else
    '                    lpIcon = GetFileIconIndex(sParFull, SHGFI_SMALLICON)
    '                End If
    '            End If
    '            DebugAppend "lpIcon=" & lpIcon
                If lpIcon = -1 Then lpIcon = 0
            Else
                DebugAppend "psf NOT valid"
            End If
            Else
                lpIcon = I_IMAGECALLBACK
            End If
            If bColPreload = True Then
                If m_DisableOvr = False Then
        
                    If mExtOverlay Then
                         
                        Set pIconOvr = psf
                        pIconOvr.GetOverlayIndex pidlRel, VarPtr(lpIconOvr)
                        pIconOvr.GetOverlayIconIndex pidlRel, VarPtr(lpOvrN)
                    End If
                    On Error GoTo e0
            '        DebugAppend sName & " ovr=" & lpIconOvr & ", ovrn=" & lpOvrN
                    If (lpIconOvr > 15) Or (lpIconOvr < 0) Then
                        'Overlay icons are a mess. On Win7 there's a bunch in root that return 16, which is invalid
                        'and will cause a crash later on, and doesn't show anything. Shares never get shown so I'm
                        'going to manually set those
                        If (lAtr And SFGAO_SHARE) = SFGAO_SHARE Then
                            lpIconOvr = 1
                        End If
                        If (lAtr And SFGAO_LINK) = SFGAO_LINK Then
                            lpIconOvr = 2
                        End If
                    End If
                End If
            Else
                If (lAtr And SFGAO_SHARE) = SFGAO_SHARE Then
                    lpIconOvr = 1
                End If
                If (lAtr And SFGAO_LINK) = SFGAO_LINK Then
                    lpIconOvr = 2
                End If
            End If
    
            ReDim Preserve LVEntries(nCur)
            With LVEntries(nCur)
                .pidlRel = pidlRel
                .sName = sName
                .sNameExt = sNameExt
                .sNameFull = sNameFull
                .sNameParsing = sNameParse
                .sFullPKParse = ssPKP
                .sFullDAPRaw = szppn
                .sExt = sExt
    '            DebugAppend "InsertFull " & sNameFull & ",ext=" & sExt
     
                .sFullPath = sFull
                If (.sExt = ".lnk") And (Right$(.sFullPath, 3) <> "lnk") Then
                    .sFullPath = .sFullPath & ".lnk"
                End If
                If (.sExt = ".url") And (Right$(.sFullPath, 3) <> "url") Then
                    .sFullPath = .sFullPath & ".url"
                End If
                .sParentFull = sParFull
                .dwAttrib = lAtr
                .bFolder = bIsFldr
                .bZip = bIsZip
                If bIsFldr Then
                    nCurFol = nCurFol + 1
                Else
    '                DebugAppend "AddFile::" & sName
                    nCurFil = nCurFil + 1
                End If
                If (lAtr And SFGAO_LINK) = SFGAO_LINK Then
                    .bLink = True
                    If bLnkFldr Then
                        .bLinkToFolder = True
                    End If
                End If
                If m_ViewMode = SB_VIEW_ICON Then
                    .nIcon = I_IMAGECALLBACK
                Else
                    .nIcon = lpIcon
                End If
                .nFileIcon = lpIcon
                .nOverlay = lpIconOvr
                .nFileOverlay = lpIconOvr
                If lpIconOvr > mOvrMax Then mOvrMax = lpIconOvr
                If bColPreload Then
                    pStore.GetValue PKEY_Size, vpv
                    PropVariantToVariant vpv, vbv
                    crSize = CCur(vbv)
            '
                    pStore.GetValue PKEY_DateCreated, vpv
                    PropVariantToVariant vpv, vbv
                    
                    st1 = DateToSystemTime(CDate(vbv))
                    SystemTimeToFileTime st1, tFTC
            
                    pStore.GetValue PKEY_DateAccessed, vpv
                    PropVariantToVariant vpv, vbv
                    st1 = DateToSystemTime(CDate(vbv))
                    SystemTimeToFileTime st1, tFTA
            
                    pStore.GetValue PKEY_DateModified, vpv
                    PropVariantToVariant vpv, vbv
                    st1 = DateToSystemTime(CDate(vbv))
                    SystemTimeToFileTime st1, tFTM
                    .ftDateC = tFTC
                    .ftDateM = tFTM
                    .ftDateA = tFTA
                    .sType = GetPropertyDisplayString(pStore, pdSet(pidxTY), pkSet(pidxTY)) 'PKEY_ItemTypeText
                    .sDateC = GetPropertyDisplayString(pStore, pdSet(pidxDC), pkSet(pidxDC)) 'PKEY_DateCreated
                    .sDateM = GetPropertyDisplayString(pStore, pdSet(pidxDM), pkSet(pidxDM)) 'PKEY_DateModified
                    .sDateA = GetPropertyDisplayString(pStore, pdSet(pidxDA), pkSet(pidxDA)) 'PKEY_DateAccessed
                    .sSize = GetPropertyDisplayString(pStore, pdSet(pidxSZ), pkSet(pidxSZ)) 'PKEY_Size
    '                DebugAppend "ColPreload.SetSize=" & .sSize
                    .cSize = crSize '* 10000 'No longer need to multiply since switch from IShellItem2.GetUI64 to IPropertyStore.GetValue
                    m_CurSize = m_CurSize + .cSize
                End If
    
                If lvrCol > 0 Then
                    pStore.GetValue PKEY_Rating, vpv
                    PropVariantToVariant vpv, vbv
                    lpr = CLng(vbv)
                    Select Case lpr
                        Case 1 To 12: .lRating = 1& 'sys default=1
                        Case 13 To 37: .lRating = 2& 'default=25
                        Case 38 To 62: .lRating = 3& 'default=50
                        Case 63 To 87: .lRating = 4& 'default=75
                        Case 88 To 99: .lRating = 5& 'default=99
                        Case Else: .lRating = 0&
                    End Select
                    szr = GetPropertyDisplayString(pStore, pdSet(pidxPL), pkSet(pidxPL)) 'PKEY_PropList_PreviewDetails
                    If InStr(szr, "System.Rating") Then
                        .bRatingSupport = True
                    End If
            '        Debug.Print .sName & " rating=" & .lRating
                End If
                .lParam = nCur
                End With
                ReDim LVEntries(nCur).LinkCols(0)
        If hLVS Then
            With LVEntries(nCur)
             If bColPreload Then
                If bGV Then
                    Dim lResGrp As Long
    '                .lTypeID = GroupGetIDForType(.sType, .sName)
                    Select Case m_GroupMode
                        Case 0
                            .iGrp = 0
                        Case 1
                            lResGrp = GroupGetIDForAlpha(.sName)
                            .iGrp = lResGrp
                        Case 2
                            lResGrp = GroupGetIDForSize(.cSize)
                            .iGrp = lResGrp
                        Case 3
                            lResGrp = GroupGetIDForType(.sType, nCur)
                            .iGrp = lResGrp
                        Case 4
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateM), 0)
                            .iGrp = lResGrp
                        Case 5
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateC), 1)
                            .iGrp = lResGrp
                        Case 6
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateA), 2)
                            .iGrp = lResGrp
                        Case 7
                            If (lGrpCol >= 0&) And (lGrpCol <= UBound(uColData)) Then
                                lResGrp = GetTextGroupId(GetPropertyDisplayString(pStore, pdSet(UBound(pdSet)), pkSet(UBound(pkSet))))
                                .iGrp = lResGrp
                            End If
                     End Select
                End If
                If bFolderHasCat Then
                    If LVEntries(nCur).pidlRel = 0& Then
                        psfCur.ParseDisplayName hLVS, 0&, StrPtr(LVEntries(nCur).sName), 0&, LVEntries(nCur).pidlRel, 0&
                    End If
                    DebugAppend "FolderHasCat " & LVEntries(nCur).sName & ",pidlRel=" & LVEntries(nCur).pidlRel
                    pCatG.GetCategory 1&, LVEntries(nCur).pidlRel, nCategory
                    DebugAppend "Got nCategory=" & nCategory
                    Dim ci As CATEGORY_INFO
                    Dim sCgName As String
                    pCatG.GetCategoryInfo nCategory, ci
                    DebugAppend "Got catinfo"
                    sCgName = String$(MAX_PATH, 0)
                    CopyMemory ByVal StrPtr(sCgName), ByVal VarPtr(ci.wszName(0)), MAX_PATH
                    sCgName = TrimNullW(sCgName)
                    DebugAppend "sCgName=" & sCgName
                    .lCatID = IndexItemCategory(nCategory, sCgName)
                    .iGrp = GetCatGroupId(sCgName)
                Else
                    If m_GroupMode = SBGB_Extended Then GroupByTextInsertGroup (.iGrp)
                End If
    
    
                If m_GroupMode = SBGB_Type Then InsertGroupForType .sType
            
             Else
                .iGrp = I_GROUPIDCALLBACK
             End If
            End With
            If bThumbsActive Then
                'Generate thumbnails as added so we don't have to deactivate/reactive through ShowThumbsAPI
    
            '    DebugAppend "Starting AddThumbView for " & LVEntries(nCur).sNameFull
                If m_ThumbPreload Then
    
                    If pidlcb = 0& Then pidlcb = ILCombine(pidlPar, pidlRel)
                    If pidlcb = 0& Then pidlcb = ILCreateFromPathW(StrPtr(LVEntries(nCur).sFullPath))
                     If mUsingCustomIcons Then
                        Dim hImg As LongPtr, hCIco As LongPtr, bFree As Boolean
                        hImg = -1: hCIco = -1
                        RaiseEvent QueryCustomIcon(LVEntries(nCur).sNameFull, LVEntries(nCur).sParentFull, LVEntries(nCur).sFullPath, LVEntries(nCur).bFolder, pidlcb, mcxyCustom * m_ScaleX, hImg, hCIco, bFree)
                        If hCIco > 0& Then
                            hr = AddThumbCustom(himl_Thumb, hCIco, True, bFree)
                        ElseIf hImg > 0& Then
                            hr = AddThumbCustom(himl_Thumb, hImg, False, bFree)
                        End If
                        If hr < 0& Then GoTo atv
                    Else
    atv:
                        hr = AddThumbView2(himl_Thumb, m_ThumbCXY, m_ThumbCXY, pidlcb, LVEntries(nCur).pidlRel, LVEntries(nCur).sFullPath, LVEntries(nCur).bFolder, nCur)
                    End If
                Else
                    hr = I_IMAGECALLBACK
                End If
    
                ReDim Preserve bOvrAdded(mOvrMax + 1)
    
                LVEntries(nCur).nIcon = hr
                If m_DisableOvr = False Then
                    If (LVEntries(nCur).nOverlay) > 0 Then
                '                DebugAppend "Will set overlay " & LVEntries(nCur).nOverlay
                        If bOvrAdded(LVEntries(nCur).nOverlay) = False Then
                            'If this file has an overlay image, make sure we've copied it from
                            'the system imagelist to our thumbnail imagelist.
                            'DebugAppend "Request overlay=" & LVEntries(nCur).nOverlay & ", last N=" & lpOvrN
                            If mUsingCustomIcons Then
                                Dim hBmpO As LongPtr, hIcoO As LongPtr, bRls As Boolean
                                hBmpO = -1&: hIcoO = -1&
                                RaiseEvent QueryCustomIconOverlay(LVEntries(nCur).nOverlay, mcxyCustom * m_ScaleX, hBmpO, hIcoO, bRls)
                                If hIcoO <> -1& Then
                                    nPos = ImageList_AddIcon(himl_Thumb, hIcoO)
                                    If bRls Then DestroyIcon hIcoO
                                ElseIf hBmpO <> -1& Then
                                    nPos = AddThumbCustom(himl_Thumb, hBmpO, False, bRls)
                                Else
                                    GoTo getsysovr
                                End If
                                ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                                bOvrAdded(LVEntries(nCur).nOverlay) = True
                            Else
    getsysovr:
                                nOvr = -1
                                On Error Resume Next
                                If (LVEntries(nCur).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                                    If himlCxActual = 0& Then
                                        ImageList_GetIconSize himl_Thumb, himlCxActual, himlCyActual
                                    End If
                                    If LoadShortcutOverlay(himlCxActual) Then
                                        Dim hBmpOvr As LongPtr
                                        hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                                        nPos = ImageList_Add(himl_Thumb, hBmpOvr, 0&)
                                        DeleteObject hBmpOvr
                                        If nPos <> -1& Then
                                            ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                                            bOvrAdded(LVEntries(nCur).nOverlay) = True
                                            GoTo skipovr
                                        Else
                                            GoTo sysimlovr
                                        End If
                                    End If
                                End If
    sysimlovr:
                                imlSysJM.GetOverlayImage LVEntries(nCur).nOverlay, nOvr
                                If nOvr = -1 Then
                                imlSysJM.GetIcon lpOvrN, ILD_TRANSPARENT, hIcon
                                Else
                                imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                                End If
                                nPos = ImageList_AddIcon(himl_Thumb, hIcon)
                                Call DestroyIcon(hIcon)
                                ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                                DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(nCur).nOverlay, 11
                                bOvrAdded(LVEntries(nCur).nOverlay) = True
                                On Error GoTo e0
                            End If
                        End If
    skipovr:
                    End If
                End If
            End If
    
            If (((m_ViewMode = SB_VIEW_ICON) Or (m_ViewMode = SB_VIEW_MDICON) Or (m_ViewMode = SB_VIEW_XLICON)) And (bThumbsActive = False)) Then
                If m_IconPreload Then
                    hr = LVGetThumbIdxLarge(nCur, cxyDispL)
                Else
                    hr = I_IMAGECALLBACK
                End If
    
                ReDim Preserve bOvrAdded(mOvrMax + 1)
    
                LVEntries(nCur).nIcon = hr
                If m_DisableOvr = False Then
                    If (LVEntries(nCur).nOverlay) > 0 Then
                '                DebugAppend "Will set overlay " & LVEntries(nCur).nOverlay
                        If bOvrAdded(LVEntries(nCur).nOverlay) = False Then
                            'If this file has an overlay image, make sure we've copied it from
                            'the system imagelist to our thumbnail imagelist.
    '                        DebugAppend "Request overlay=" & LVEntries(nCur).nOverlay & ", last N=" & lpOvrN
                            nOvr = -1
                            On Error Resume Next
                            If (LVEntries(nCur).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                                If himlCxActual = 0& Then
                                    ImageList_GetIconSize himlLarge, himlCxActual, himlCyActual
                                End If
                                If LoadShortcutOverlay(himlCxActual) Then
                                    Dim hBmpOvr2 As LongPtr
                                    hBmpOvr2 = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                                    nPos = ImageList_Add(himlLarge, hBmpOvr2, 0&)
                                    DeleteObject hBmpOvr2
                                    If nPos <> -1& Then
                                        ImageList_SetOverlayImage himlLarge, nPos, LVEntries(nCur).nOverlay
                                        bOvrAdded(LVEntries(nCur).nOverlay) = True
                                        GoTo skipovr2
                                    Else
                                        GoTo sysimlovr2
                                    End If
                                End If
                            End If
    sysimlovr2:
                            imlSysJM.GetOverlayImage LVEntries(nCur).nOverlay, nOvr
                            If nOvr = -1 Then
                                imlSysJM.GetIcon lpOvrN, ILD_TRANSPARENT, hIcon
                            Else
                                imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                            End If
                            nPos = ImageList_AddIcon(himlLarge, hIcon)
                            Call DestroyIcon(hIcon)
                            ImageList_SetOverlayImage himlLarge, nPos, LVEntries(nCur).nOverlay
                            bOvrAdded(LVEntries(nCur).nOverlay) = True
                            On Error GoTo e0
                        End If
    skipovr2:
                    End If
                End If
            End If
        End If
            'DebugAppend "Setting ExtColData defaults..."
            ReDim LVEntries(nCur).ExtColData(0)
            LVEntries(nCur).ExtColData(0).cdid = lDefColIdx(0)
            If sParPN = sComp Then
                LVEntries(nCur).ExtColData(0).sDisp = sNameParse
                LVEntries(nCur).ExtColData(0).vRaw = sNameParse
            Else
                LVEntries(nCur).ExtColData(0).sDisp = sName
                LVEntries(nCur).ExtColData(0).vRaw = sName
            End If
            
            If (mDispParAndIndt = True) And (bFlagNoIndent = False) Then
                LVEntries(nCur).lIndent = lCurMaxInd ' LVComputeIndent(LVEntries(nCur).sFullPath)
    '            lCurMaxInd = LVEntries(nCur).lIndent
            End If
            
            
            
            
            If hLVS Then
                'DebugAppend "Calling InsertListItem..."
                If InsertListItem(LVEntries(nCur)) = -1 Then
                    DebugAppend "LVLoadFolder->Error: LVM_INSERTITEMW failed"
                End If
            
                If mShowDataStreams Then
                    nCur = nCur + AddDataStreams(nCur)
                End If
            
            End If
            
            
            Dim bAddToDD As Boolean
            Select Case nExpandSelectedFolderInDropdown
                Case 0
                    If ((m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls)) And (bIsFldr = True) Then
                        bAddToDD = True
                    Else
                        bAddToDD = False
                    End If
                Case 1
                    If (bIsFldr = True) Then
                        bAddToDD = True
                    Else
                        bAddToDD = False
                    End If
                Case 2
                    bAddToDD = False
            End Select
            If bAddToDD Then
                If (siChild Is Nothing) = False Then
                    bSuppress = True
    '                DebugAppend "LVLoadFolder::Insert " & sName
                    bAdjustOrder = True
                    nAdjustOrder = nAdjustOrder + 1
                    Call AddStandardFSItem(siChild, li, False)
                    bAdjustOrder = False
                    bSuppress = False
                    bFlagFixCh = True
                End If
            End If
            
            
            
            Set pStore = Nothing
            Set upi = Nothing
            Set si2Child = Nothing
            Set siChild = Nothing
    '        Set psf = Nothing
            nCur = nCur + 1
    nxt:
            If pidlcb Then CoTaskMemFree pidlcb
            If nCur = 30 Then
                If mFlagActiveSearch Then
                    UpdateStatus mEnumSRes
                Else
                    UpdateStatus mStrListing
                End If
                bSupDisp = False
                bFlag30 = True
                Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
                RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
                UpdateWindow hLVS
                FastDoEvents
                Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&)
                bSupDisp = True
                bFlag30 = False
            End If
            If nCur Mod lFolderLoadFileUpdateCount = 0 Then
                If mFlagActiveSearch Then
                    UpdateStatus mEnumSRes & nCur
                Else
                    UpdateStatus mStrListing & " " & nCur
                End If
            End If
        Loop
        DebugAppend "LVLoadFolder::Finished enum loop", 2000
    enumdone:
        nAdjustOrder = 0
        bInLVLFLoop = False
    ''    Set psfCur = psfNew 'psf
    '    pidlFQCur = pidlNew1 ' pidlPar
        If bBlankLoaded Then
            bBlankLoaded = False
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
        End If
        
        DebugAppend "LVLoadFolder::UBound(cbItems)=" & UBound(cbItems) & ",nCurrentCBItemIndex=" & nCurrentCBItemIndex, 2000
        lKeepColIdx = nCurrentCBItemIndex
        lKeepColSet = cbItems(lKeepColIdx).lColSet
        If hLVS Then
            LVAdjustLabelWidth
            DebugAppend "LVLoadFolder::ProcessColumns", 2000
            ProcessColumns siParent
            DebugAppend "LVLoadFolder returned from ProcessColumns", 2000
            bSupDisp = False
            lSortK = 0
            lSortD = 1
            ecdKey = 0
            If m_cbSort = 0& Then
                If mUseAdvancedSort Then
                    m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
                Else
                    m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
                End If
            End If
            mLastSortInfo = eSortName
            Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
            Call SetSortArrowAPI(hLVS, -1, -1)
            Call SendMessage(hLVS, LVM_SETSELECTEDCOLUMN, -1&, ByVal 0&)
            If m_GroupMode <> SBGB_None Then GroupUpdateAllFooters hLVS
            If (m_ViewMode = SB_VIEW_TILE) And (m_SubItemProgress > 0) Then
                'Since the subitem gets cleared after navigating to a new folder, we need to reset the tiles
                DebugAppend "LVLoadFolder (m_ViewMode = SB_VIEW_TILE) And (m_SubItemProgress > 0)", 3
                TileViewProgressEnsureCols
                Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
                SetTileInfo hLVS
                SendMessage hLVS, LVM_REDRAWITEMS, 0, ByVal nCur
                UpdateWindow hLVS
            End If
        End If
    loaddone:
        
        Set pCatG = Nothing 'Set with vbaObjSetAddref-- will VB know to destroy?
        Set pCatProvider = Nothing
    '    If pcppv Then GlobalFree pcppv
        
        If bFooterDoReload Then
            If bWillLoadSearchFt = False Then
                FooterCreate ftCache_LblText, ftCache_himl, ftCache_BtnCaps, ftCache_BtnIcon, ftCache_BtnLp
            End If
        End If
        If bWillLoadSearchFt = True Then
            bWillLoadSearchFt = False
        End If
        
        If hLVS Then MapCurrentColumns
        Dim lColCnt As Long
        lColCnt = Header_GetItemCount(hLVSHdr)
        'next, delete unused columns
        ReDim MainCache(lCacheID).ColSet(lColCnt)
        Dim lp As LongPtr
        For i = 0 To lColCnt - 1
            lp = GetHDItemlParam(hLVSHdr, i)
            MainCache(lCacheID).ColSet(i) = lp
        Next i
        MainCache(lCacheID).FileData = LVEntries
        MainCache(lCacheID).bSet = True
        DebugAppend "LVLoadFolder::Created cache entry", 2000
        
        If bFlagFixCh Then
            DebugAppend "LVLoadFolder::Rearrange children for dropdown, par->" & m_sCurPath
            FixChildren m_sCurPath
        End If
        
        StopLoadingMarquee
        Dim sRpt As String
        sRpt = sPath
        If sRpt = "0" Then 'we don't want to report "0" externally,; it's our internal reference point
            Dim lpx As LongPtr
            siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpx
            sRpt = LPWSTRtoStr(lpx)
        End If
        Set siCurPath = siParent
        
        nBlocks = nBlocks - 1
        DebugAppend "LVLoadFolder::Out nBlocks=" & nBlocks, 2000
        If nBlocks = 0 Then
            bBlockLoad = False
            If hCombo Then EnableWindow hCombo, 1&
            pbControlBox.Enabled = True
        End If
        Dim idxCB As Long
        idxCB = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
        nCurrentCBItemIndex = GetCBXItemlParam(hCombo, idxCB)
        DebugAppend "idxCB=" & idxCB & ",lp=" & nCurrentCBItemIndex, 4
    
        SetSearchBoxCue
        DebugAppend "Returned from SetSearchBoxCue"
        If m_DtPane Then pvCreateDetailPaneBkg
        DebugAppend "Returned from pvCreateDetailPaneBkg"
        nCurFolders = nCurFol
        nCurFiles = nCurFil
        DebugAppend "Loaded " & nCurFiles & " files and " & nCurFolders & " folders"
        Dim sFN As String
        If nCurFolders = 1 Then
            sFN = " " & mFolderStr & ", "
        Else
            sFN = " " & mFoldersStr & ", "
        End If
        Dim sfn2 As String
        UpdateStatus mReadyStr
        If (nCurFiles + nCurFolders) = 0 Then
            UpdateStatus mNoItemsStr, 2
        Else
            Dim sStatSz As String
            If bColPreload Then
                If nCurFiles = 1 Then
                    sfn2 = " " & mFileStr & " ("
                Else
                    sfn2 = " " & mFilesStr & " ("
                End If
                sStatSz = FormatFileSizeCurExB(m_CurSize, False, sSizeFmt_byte, False, sSizeFmt_kb, False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb)
                UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2 & sStatSz & ")", idxSizePanel
            Else
                If nCurFiles = 1 Then
                    sfn2 = " " & mFileStr
                Else
                    sfn2 = " " & mFilesStr
                End If
                UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2, idxSizePanel
            End If
        End If
        StartNotifyOnCurPath
        Dim upip As IParentAndItem
        Set upip = siParent
        Dim pp1 As LongPtr, pp2 As LongPtr
        Dim psfx As IShellFolder
        upip.GetParentAndItem pp1, psfx, pp2
        
        If AppendPidlRecByItem(m_sCurPath, siParent) = False Then
            AppendPidlRec m_sCurPath, pp1, pp2 'store the pidl in case there's trouble loading virtual locations
        End If
    '    For i = 0 To UBound(sHistory)
    '        If i = nHistIdx Then
    '            DebugAppend sHistory(i) & "<---nHistIdx (Verify?=" & VerifyHistIdx(m_sCurPath) & ")"
    '        Else
    '            DebugAppend sHistory(i)
    '        End If
    '    Next i
        
        If nHistIdx = UBound(sHistory) Then
            DebugAppend "SET DISABLE FORWARD"
            bEnableFwd = False
            EnableWindow hStdFwdButton, 0&
            pvDrawFwd NAV_FB_DISABLED
        End If
    '    For i = 0 To UBound(uPidlStore)
    '        DebugAppend "updl(" & i & ")=" & uPidlStore(i).sPath
    '    Next i
        If hLVS Then
            If (bFolderHasCat = True) And (bAutoGroupCategories = True) Then
                Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
                GroupByCatInsertGroups
                GroupByCatSetItems
                GroupUpdateAllFooters hLVS
                bCatGrpActive = True
                If mPrevGrpMode <> SBGB_Categorizer Then
                    mPrevGrpMode = m_GroupMode
                End If
                m_GroupMode = SBGB_Categorizer
            End If
        End If
        DebugAppend "LVLoadFolder Exiting. ParentParsing=" & sParPN & ", m_GroupMode=" & m_GroupMode & ", IsEnabled=" & CStr(SendMessage(hLVS, LVM_ISGROUPVIEWENABLED, 0&, ByVal 0&)) & ", GroupCount=" & CStr(SendMessage(hLVS, LVM_GETGROUPCOUNT, 0&, ByVal 0&))
    Else
        DebugAppend "Failed to get siParent"
        UpdateStatus mLoadFail & sPath
        If IsComCtl6 Then
            SimpleDialog mLoadFail & sPath, TDCBF_OK_BUTTON, App.Title
        Else
            MsgBox mLoadFail & sPath, vbOKOnly, App.Title
        End If
        If CBItemExists(m_sCurPath) And (m_sCurPath <> "") Then
            i = GetItemIndex(m_sCurPath, j)
            SendMessage hCombo, CB_SETCURSEL, i, ByVal 0&
        End If
    End If
    
    'Don't even get me fucking started on the bug that this addresses:
    If (bFlagRootReset = True) Or ((InStr(sTrackPrevLoc, "\\?\usb#") = 0) And (InStr(m_sCurPath, "\\?\usb#") > 0)) Then
        bFlagRootReset = False
        If ((m_ViewModeEx = SB_VIEW_MDICON) Or (m_ViewModeEx = SB_VIEW_ICON) Or (m_ViewModeEx = SB_VIEW_XLICON)) Then
            LVResetIconCallbacks
        End If
        DebugAppend "LVLoadFolder::Did refresh", 3
    End If
    If Left$(sParPN, 8) = "\\?\usb#" Then
        bFlagRootReset = True
    End If
    'End fucked up bug fix
    
    Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
    If m_DisableWhileLoading Then EnableWindow hLVS, 1&
    'If IsRefresh Then Exit Sub
    sTrackPrevLoc = m_sCurPath
    
    If bLVEscaped Then
        UpdateStatus m_str_CancelLoad
        If mPlaySnd Then
            If bSoundCritical Then DoSound SND_CRITICAL
        End If
        bLVEscaped = False
    Else
        If mPlaySnd Then
            If bSoundNavigate Then DoSound SND_NAVIGATESTART
        End If
    End If
    
    If bSearchFld = True Then
        If mFtrPostSearch Then FooterAddSearchDone
        If mSearchAutoGroup Then
            Dim lFldrCol As Long
            lFldrCol = GroupFindFolderColumn()
            If lFldrCol <> -1& Then
                If bGV = False Then
                    lPriorGroupCol = -1
                Else
                    lPriorGroupCol = lGrpCol
                End If
                lGrpCol = lFldrCol
                SetGroupMode SBGB_Extended
                bSearchAutogrouped = True
            End If
        End If
    Else
        If bSearchAutogrouped Then 'Previous folder autogrouped
            If lPriorGroupCol = -1& Then
                SetGroupMode SBGB_None
                lGrpCol = -1
            Else
                lGrpCol = lPriorGroupCol
                SetGroupModeByCol lGrpCol
            End If
        End If
        bSearchAutogrouped = False
    End If
    
    If mDispSecZn Then
        Dim zn As URLZONE
        zn = GetFileEffectiveZone(m_sCurPath)
        UpdateZonePanel zn
        DebugAppend "Zone=" & zn
    End If
    
    RaiseEvent DirectoryChanged(sRpt, siParent, pidlFQCur)
    
    lvlftt2 = GetTickCount()
    DebugAppend "LVLoadFolder time=" & Round((lvlftt2 - lvlftt1) / 1000, 3) & "s", 11
    If bShowLoadTimeAsStatus Then
        UpdateStatus "Load Time (Standard): Total time=" & (lvlftt2 - lvlftt1) & "ms"
    End If
    Exit Sub
    e0:
    DebugAppend "LVLoadFolder->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 2000
    StopLoadingMarquee
    Call SendMessage(hLVS, WM_SETREDRAW, 1&, ByVal 0&)
    End Sub
    
    Private Sub AppendPidlRec(sPath As String, pidl1 As LongPtr, pidl2 As LongPtr)
    DebugAppend "AppendPidlRec " & sPath
    Dim i As Long, j As Long
    For i = 0 To UBound(uPidlStore)
        If uPidlStore(i).sPath = sPath Then Exit Sub 'record already exists
    Next i
    
    If (UBound(uPidlStore) = 0) And (uPidlStore(0).sPath = "") Then
        uPidlStore(0).sPath = sPath
        uPidlStore(0).pidlFQ = ILCombine(pidl1, pidl2)
    Else
        j = UBound(uPidlStore) + 1
        ReDim Preserve uPidlStore(j)
        uPidlStore(j).sPath = sPath
        uPidlStore(j).pidlFQ = ILCombine(pidl1, pidl2)
    End If
    End Sub
    
    Private Function AppendPidlRecByItem(sPath As String, psi As IShellItem) As Boolean
    Dim pidlFQ As LongPtr
    'pidlRel = ILFindLastID(pidl)
    
    DebugAppend "AppendPidlRecByItem " & sPath
    
    SHGetIDListFromObject psi, pidlFQ
    If pidlFQ Then
        AppendPidlRecByItem = True
    Else
        Exit Function
    End If
    
    Dim i As Long, j As Long
    For i = 0 To UBound(uPidlStore)
        If uPidlStore(i).sPath = sPath Then Exit Function 'record already exists
    Next i
    
    If (UBound(uPidlStore) = 0) And (uPidlStore(0).sPath = "") Then
        uPidlStore(0).sPath = sPath
        uPidlStore(0).pidlFQ = pidlFQ
    Else
        j = UBound(uPidlStore) + 1
        ReDim Preserve uPidlStore(j)
        uPidlStore(j).sPath = sPath
        uPidlStore(j).pidlFQ = pidlFQ
    End If
    End Function
    
    Private Function LVAddEntry(siChild As IShellItem, Optional iForceIndex As Long = -1, Optional iForcePos As Long = -1, Optional bForCust As Boolean = False, Optional lManualIndent As Long = -1&) As Long
    'Sync any changes with LVLoadFolder
    'Set iForceIndex to overwrite an existing entry instead of add a new one
    'Set iForcePos to insert at a position other than end of list
    Dim lAtr As SFGAO_Flags
    Dim nCur As Long, nCurFol As Long, nCurFil As Long
    Dim psf As IShellFolder
    Dim bIsFldr As Boolean, bIsZip As Boolean
    Dim lGM As Long
    Dim hr As Long
    Dim nOvr As Long
    Dim nPos As Long
    Dim lpName As LongPtr, sName As String
    Dim sNameParse As String
    Dim sNameFull As String
    Dim lpFull As LongPtr, sFull As String
    Dim lpPar As LongPtr, sParFull As String
    Dim sExt As String
    Dim crSize As LongLong
    Dim tFTC As FILETIME, tFTM As FILETIME, tFTA As FILETIME
    Dim pIcon As IShellIcon
    Dim pIconOvr As IShellIconOverlay
    Dim si2Child As IShellItem2
    Dim pStore As IPropertyStore
    Dim pidlPar As LongPtr, pidlRel As LongPtr
    Dim lpIcon As Long, lpIconOvr As Long, lpOvrN As Long
    Dim hIcon As LongPtr
    Dim lLVPos As Long
    Dim pidlFQ As LongPtr
    Dim pUnk As IUnknownUnrestricted
    Dim upi As IParentAndItem
    Dim siParent As IShellItem, si2Par As IShellItem2
    Dim sParParse As String
    Dim pCatG As ICategorizer
    Dim nCategory As Long, kCat As Long
    Dim pidlcb As LongPtr
    
    lLVPos = -1
    'If bForCust Then
    '    Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siParent)
    'Else
        siChild.GetParent siParent
    'End If
        If bFolderHasCat Then
            DebugAppend "FolderCat flag set, trying catprovider"
            Dim psf2 As IShellFolder2
            siParent.BindToHandler 0&, BHID_SFObject, IID_IShellFolder2, psf2
            If (psf2 Is Nothing) = False Then
                Dim scid As SHCOLUMNID
                psf2.MapColumnToSCID 1&, scid
                
                Dim pCatProvider As ICategoryProvider
                siParent.BindToHandler 0&, BHID_SFViewObject, IID_ICategoryProvider, pCatProvider
                If (pCatProvider Is Nothing) = False Then
                    DebugAppend "Got category provider"
                    Dim tSCGUID As UUID
                     
                    pCatProvider.GetCategoryForSCID scid, tSCGUID
                    DebugAppend "guid=" & dbg_GUIDToString(tSCGUID)
                    If IsEqualIID(tSCGUID, UUID_NULL) = 0& Then
                        Dim ppv As LongPtr
                        pCatProvider.CreateCategory tSCGUID, IID_ICategorizer, ppv
                        If ppv Then
                            vbaObjSetAddRef pCatG, ppv
                        Else
                            DebugAppend "no catg ptr"
                        End If
                            
                        If (pCatG Is Nothing) = False Then
                            DebugAppend "Got categorizer"
                            bFolderHasCat = True
                        Else
                            DebugAppend "Failed to get categorizer"
                        End If
                    Else
                        DebugAppend "LVAddEntry::No category support (SCID=NULL)"
                    End If
                Else
                    DebugAppend "LVAddEntry::No category provider found."
                End If
            End If
         End If
    
    
        If iForceIndex = -1 Then
            nCur = UBound(LVEntries)
            If nCur = 0 Then
                If LVEntries(0).sName <> "" Then nCur = nCur + 1
            Else
                nCur = nCur + 1
            End If
        Else
            nCur = iForceIndex
        End If
            sName = "": sFull = "": sNameFull = "": sNameParse = "": sExt = "": lpName = 0&: lpFull = 0&: lpIcon = 0&: lpIconOvr = 0&
            siChild.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK, lAtr
            siChild.GetDisplayName SIGDN_NORMALDISPLAY, lpName
    '    DebugAppend "ChildAttrib=" & dbg_sfgao_tostring(lAtr)
            sName = LPWSTRtoStr(lpName)
            
            If (m_HiddenPref = SBHP_UseExplorer) Then
                If (mHPInExp = False) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
            Else
                If (m_HiddenPref = SBHP_AlwaysHide) And ((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) Then GoTo nxt
            End If
            If (m_SuperHiddenPref = SBSHP_UseExplorer) Then
                If (mSHPInExp = False) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
            Else
                If (m_SuperHiddenPref = SBSHP_AlwaysHide) And (((lAtr And SFGAO_HIDDEN) = SFGAO_HIDDEN) And ((lAtr And SFGAO_SYSTEM) = SFGAO_SYSTEM)) Then GoTo nxt
            End If
            Set si2Child = siChild
            si2Child.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pStore
            siChild.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFull
            sFull = LPWSTRtoStr(lpFull)
            If InStr(sFull, "\") Then
                sNameFull = Right$(sFull, Len(sFull) - InStrRev(sFull, "\"))
            Else
                sNameFull = sName & sExt
            End If
            If (pStore Is Nothing) = False Then
                sExt = GetPropertyKeyDisplayString(pStore, PKEY_FileExtension)
                sNameParse = GetPropertyKeyDisplayString(pStore, PKEY_ParsingName)
            Else
                If InStr(sNameFull, ".") Then
                    sExt = Right$(sNameFull, Len(sNameFull) - (InStrRev(sNameFull, ".") - 1))
                Else
                    Dim sNFTmp As String, lpNFTmp As LongPtr
                    siChild.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpNFTmp
                    sNFTmp = LPWSTRtoStr(lpNFTmp)
                    If InStr(sNFTmp, ".") Then
                        sExt = Right$(sNFTmp, Len(sNFTmp) - (InStrRev(sNFTmp, ".") - 1))
                    End If
                End If
                sNameParse = sNameFull
            End If
            If m_BrowseZip Then
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) Then 'And ((lAtr And SFGAO_STREAM) = 0) Then '
                    'true folder; always show
    '                    DebugAppend "AddFolder::" & sName
                        bIsFldr = True
                        If m_FolderFilter <> "" Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                Else
                    bIsFldr = False
                    If m_Filter <> "" Then
                            If QueryShowFile(sName, m_sCurPath) = False Then GoTo nxt
                    End If
                End If
            Else
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0) Then 'Then '
                    'true folder; always show
    '                    DebugAppend "AddFolder::" & sName
                        bIsFldr = True
                        If m_FolderFilter <> "" Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                Else
                    If sExt = ".library-ms" Then
                        bIsFldr = True
                        If (m_FolderFilter <> "") And (m_FolderFilter <> "*") Then
                            If QueryShowFolder(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                    Else
                        bIsFldr = False
                        If mFoldersOnly Then GoTo nxt
                        If (m_Filter <> "") And (m_Filter <> "*") And (m_Filter <> "*.*") Then
                            If QueryShowFile(sName, m_sCurPath) = False Then GoTo nxt
                        End If
                    End If
                End If
            End If
            If (bIsFldr = True) And (mFilesOnly = True) Then GoTo nxt
            If (lAtr And SFGAO_FOLDER) = SFGAO_FOLDER Then
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = SFGAO_STREAM) Then
                    If sExt <> ".library-ms" Then
                        bIsZip = True
                    End If
                End If
            End If
            
            sParFull = StrGetPath(sFull)
            
            Dim lp5 As LongPtr
            Set si2Par = siParent
            si2Par.GetString PKEY_ParsingName, lp5
            sParParse = LPWSTRtoStr(lp5)
            
            If m_ForceExt = SBEP_AlwaysShow Then
                If sParParse <> sComp Then 'Names given to USB devices is a god damn mess
                    If (Left$(sNameFull, 3) <> "::{") And (Left$(sNameFull, 5) <> "uuid:") And ((InStr(sNameFull, "\?\usb#")) = 0) And (Left$(sNameFull, 7) <> "usb#vid") Then
                        sName = sNameFull
                    End If
                End If
            End If
            
            If (nCur > 0) Then
                If LVEntries(nCur - 1).sNameFull = sNameFull Then
                    If LVEntries(nCur - 1).sNameParsing = sNameParse Then
                        If LVEntries(nCur - 1).bDeleted = False Then
                            GoTo nxt 'Sometimes copy/paste sends two identical SHCNE_CREATE messages
                        End If
                    End If
                End If
            End If
            
            Set upi = siChild
            upi.GetParentAndItem pidlPar, psf, pidlRel
            On Error Resume Next
            If (psf Is Nothing) = False Then
    '            DebugAppend "psf is valid, set pIcon with pidlRel=" & pidlRel & ",pidl=" & pidlPar
    '            Set pIcon = psf
                Set pUnk = psf
                hr = pUnk.QueryInterface(IID_IShellIcon, pIcon)
    '            DebugAppend "QueryInterface=0x" & Hex$(hr)
                Dim pt1 As Long, pt2 As LongPtr, pt3 As Long
                psf.ParseDisplayName 0&, 0&, StrPtr(sName), pt1, pt2, pt3
        '        DebugAppend "ParseTest pidl=" & pt2 & ",atr=" & pt3
                If hr = S_OK Then
                    If pt2 = 0& Then
                        pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
                    Else
                        pIcon.GetIconOf pt2, GIL_FORSHELL, lpIcon
                    End If
    '                DebugAppend "LVAddEntry lpIcon from iface=" & lpIcon
                End If
                If (hr <> S_OK) Or (lpIcon = -1) Then
                  pidlcb = ILCombine(pidlPar, pidlRel)
    '              DebugAppend "pidlcb=" & pidlcb
                  lpIcon = GetFileIconIndexPIDL(pidlcb, SHGFI_SMALLICON)
    '              DebugAppend "lpIcon via pidlcb=" & lpIcon
                  If lpIcon = -1 Then lpIcon = 0
                  If lpIcon = 0 Then
                        Dim psfPar As IShellFolder
                        Dim pidlt1 As LongPtr, pidlrelt1 As LongPtr
                        Dim upipar As IParentAndItem
                        Set upipar = siParent
                        upipar.GetParentAndItem pidlt1, psfPar, pidlrelt1
                        If (psfPar Is Nothing) = False Then
    '                        DebugAppend "Got psfPar"
                            Dim punk2 As IUnknownUnrestricted
                            Set punk2 = psfPar
                            hr = 0&
                            hr = punk2.QueryInterface(IID_IShellIcon, pIcon)
    '                        DebugAppend "SI->icn=0x" & Hex$(hr)
                            If hr = S_OK Then
                                pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
    '                            DebugAppend "psfPar::lpIcon=" & lpIcon
                            End If
    
                        End If
                        'PASTE
                  End If
                End If
    '            If lpIcon = 0 Then
    '                DebugAppend "No icon retrieved, using parent..."
    '                If pidlPar Then
    '                    lpIcon = GetFileIconIndexPIDL(pidlPar, SHGFI_SMALLICON)
    '                Else
    '                    lpIcon = GetFileIconIndex(sParFull, SHGFI_SMALLICON)
    '                End If
    '            End If
    '            DebugAppend "lpIcon=" & lpIcon
                If lpIcon = -1 Then lpIcon = 0
            Else
                DebugAppend "psf NOT valid"
            End If
            lpIconOvr = -1
            If m_DisableOvr = False Then
                If mExtOverlay Then
                    Set pIconOvr = psf
                    pIconOvr.GetOverlayIndex pidlRel, VarPtr(lpIconOvr)
                    pIconOvr.GetOverlayIconIndex pidlRel, VarPtr(lpOvrN)
                End If
                On Error GoTo e0
        '        DebugAppend sName & " ovr=" & lpIconOvr & ", ovrn=" & lpOvrN
                If (lpIconOvr > 15) Or (lpIconOvr < 0) Then
                    'Overlay icons are a mess. On Win7 there's a bunch in root that return 16, which is invalid
                    'and will cause a crash later one, and doesn't show anything. Shares never get shown so I'm
                    'going to manually set those
                    If (lAtr And SFGAO_SHARE) = SFGAO_SHARE Then
                        lpIconOvr = 1
                    End If
                    If (lAtr And SFGAO_LINK) = SFGAO_LINK Then
                        lpIconOvr = 2
                    End If
                End If
            End If
            On Error GoTo e0
    '        DebugAppend "ovr=" & lpIconOvr
            si2Child.GetUInt64 PKEY_Size, crSize
            si2Child.GetFileTime PKEY_DateCreated, tFTC
            si2Child.GetFileTime PKEY_DateModified, tFTM
            si2Child.GetFileTime PKEY_DateAccessed, tFTA
            If iForceIndex = -1 Then
                ReDim Preserve LVEntries(nCur)
            End If
            With LVEntries(nCur)
                If bForCust Then
    '                If pidlcb Then
    '                    .pidlRel = pidlcb
    '                Else
    '                    pidlcb = ILCombine(pidlPar, pidlRel)
    '                    .pidlRel = pidlcb
    '                End If
                    .pidlRel = ILCreateFromPathW(StrPtr(sFull))
                Else
                    .pidlRel = pidlRel
                End If
                .sName = sName
                .sNameFull = sNameFull
                .sNameExt = sNameFull
                .sNameParsing = sNameParse
                .sExt = sExt
                DebugAppend "LVAddEntry " & sNameFull & ",Disp=" & sName
                .sFullPath = sFull
                .sParentFull = sParFull
                .dwAttrib = lAtr
                .bFolder = bIsFldr
                .bZip = bIsZip
                If bIsFldr Then
                    nCurFol = nCurFol + 1
                Else
    '                DebugAppend "AddFile::" & sName
                    nCurFil = nCurFil + 1
                End If
                .nIcon = lpIcon
                .nFileIcon = lpIcon
                .nOverlay = lpIconOvr
                .nFileOverlay = lpIconOvr
                If lpIconOvr > mOvrMax Then mOvrMax = lpIconOvr
                .sDateC = GetPropertyKeyDisplayString(pStore, PKEY_DateCreated)
                .sDateM = GetPropertyKeyDisplayString(pStore, PKEY_DateModified)
                .sDateA = GetPropertyKeyDisplayString(pStore, PKEY_DateAccessed)
                .ftDateC = tFTC
                .ftDateM = tFTM
                .ftDateA = tFTA
                .sType = GetPropertyKeyDisplayString(pStore, PKEY_ItemTypeText)
                .sSize = GetPropertyKeyDisplayString(pStore, PKEY_Size)
                .cSize = crSize '* 10000
                 m_CurSize = m_CurSize + .cSize
                .lTypeID = GroupGetIDForType(.sType, nCur)
                .lParam = nCur
    '            DebugAppend "LVAddEntry " & .sName & ",size=" & .cSize & ",type=" & .sType & ",mod=" & .sDateM
                If bGV Then
                    Dim lResGrp As Long
                    Select Case m_GroupMode
                        Case 0
                            .iGrp = 0
                        Case 1
                            lResGrp = GroupGetIDForAlpha(.sName)
                            .iGrp = lResGrp
                        Case 2
                            lResGrp = GroupGetIDForSize(.cSize)
                            .iGrp = lResGrp
                        Case 3
                            lResGrp = GroupGetIDForType(.sType, nCur)
                            .iGrp = lResGrp
                        Case 4
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateM), 0)
                            .iGrp = lResGrp
                        Case 5
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateC), 1)
                            .iGrp = lResGrp
                        Case 6
                            lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateA), 2)
                            .iGrp = lResGrp
                        Case 7
                            If (lGrpCol >= 0&) And (lGrpCol <= UBound(uColData)) Then
                                If (pStore Is Nothing) = False Then
                                    lResGrp = GetTextGroupId(GetPropertyKeyDisplayString(pStore, uColData(lGrpCol).pKey))
                                    .iGrp = lResGrp
                                End If
                            End If
                     End Select
                End If
                If bFolderHasCat Then
                  If (pCatG Is Nothing) = False Then
                    pCatG.GetCategory 1&, pidlRel, nCategory
                    Dim ci As CATEGORY_INFO
                    Dim sCgName As String
                    pCatG.GetCategoryInfo nCategory, ci
                    sCgName = String$(MAX_PATH, 0)
                    CopyMemory ByVal StrPtr(sCgName), ByVal VarPtr(ci.wszName(0)), MAX_PATH
                    sCgName = TrimNullW(sCgName)
                    .lCatID = IndexItemCategory(nCategory, sCgName)
                    .iGrp = GetCatGroupId(sCgName)
                    If m_GroupMode = SBGB_Extended Then GroupByCatInsertGroup (.iGrp)
                  Else
                    DebugAppend "LVAddEntry->Warning: Failed to create categorizer object in folder supporting categories."
                  End If
                Else
                    If m_GroupMode = SBGB_Extended Then GroupByTextInsertGroup (.iGrp)
                End If
            If m_GroupMode = SBGB_Type Then InsertGroupForType .sType
            End With
    
            If bThumbsActive Then
                'Generate thumbnails as added so we don't have to deactivate/reactive through ShowThumbsAPI
    
                If m_ThumbPreload Then
                    pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(nCur).sFullPath))
                     If mUsingCustomIcons Then
                        Dim hImg As LongPtr, hCIco As LongPtr, bFree As Boolean
                        hImg = -1: hCIco = -1
                        RaiseEvent QueryCustomIcon(LVEntries(nCur).sNameFull, LVEntries(nCur).sParentFull, LVEntries(nCur).sFullPath, LVEntries(nCur).bFolder, pidlFQ, mcxyCustom * m_ScaleX, hImg, hCIco, bFree)
                        If hCIco > 0& Then
                            hr = AddThumbCustom(himl_Thumb, hCIco, True, bFree)
                        ElseIf hImg > 0& Then
                            hr = AddThumbCustom(himl_Thumb, hImg, False, bFree)
                        End If
                        If hr < 0& Then GoTo atv
                    Else
    atv:
                    
                        hr = AddThumbView2(himl_Thumb, m_ThumbCXY, m_ThumbCXY, pidlFQ, LVEntries(nCur).pidlRel, LVEntries(nCur).sFullPath, LVEntries(nCur).bFolder, nCur)
                    End If
                Else
                    hr = I_IMAGECALLBACK
                End If
                
                ReDim Preserve bOvrAdded(mOvrMax + 1)
    
                LVEntries(nCur).nIcon = hr
                If (LVEntries(nCur).nOverlay) > 0 Then
    '                DebugAppend "Will set overlay " & LVEntries(nCur).nOverlay
                    If bOvrAdded(LVEntries(nCur).nOverlay) = False Then
                        'If this file has an overlay image, make sure we've copied it from
                        'the system imagelist to our thumbnail imagelist.
                        If mUsingCustomIcons Then
                            Dim hBmpO As LongPtr, hIcoO As LongPtr, bRls As Boolean
                            hBmpO = -1&: hIcoO = -1&
                            RaiseEvent QueryCustomIconOverlay(LVEntries(nCur).nOverlay, mcxyCustom * m_ScaleX, hBmpO, hIcoO, bRls)
                            If hIcoO <> -1& Then
                                nPos = ImageList_AddIcon(himl_Thumb, hIcoO)
                                If bRls Then DestroyIcon hIcoO
                            ElseIf hBmpO <> -1& Then
                                nPos = AddThumbCustom(himl_Thumb, hBmpO, False, bRls)
                            Else
                                GoTo getsysovr
                            End If
                            ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                            bOvrAdded(LVEntries(nCur).nOverlay) = True
                        Else
    getsysovr:
                            nOvr = -1
                            If (LVEntries(nCur).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                                If himlCxActual = 0& Then
                                    ImageList_GetIconSize himl_Thumb, himlCxActual, himlCyActual
                                End If
                                If LoadShortcutOverlay(himlCxActual) Then
                                    Dim hBmpOvr As LongPtr
                                    hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                                    nPos = ImageList_Add(himl_Thumb, hBmpOvr, 0&)
                                    DeleteObject hBmpOvr
                                    If nPos <> -1& Then
                                        ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                                        bOvrAdded(LVEntries(nCur).nOverlay) = True
                                        GoTo skipovr
                                    Else
                                        GoTo sysimlovr
                                    End If
                                End If
                            End If
    sysimlovr:
    
                            imlSysJM.GetOverlayImage LVEntries(nCur).nOverlay, nOvr
                            If nOvr >= 0& Then
                                imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                                nPos = ImageList_AddIcon(himl_Thumb, hIcon)
            '                    DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(nCur).nOverlay
                                Call DestroyIcon(hIcon)
                                ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(nCur).nOverlay
                                bOvrAdded(LVEntries(nCur).nOverlay) = True
                            End If
                        End If
    skipovr:
                    End If
                End If
            End If
            
            If (m_ViewMode = SB_VIEW_ICON) Or (m_ViewMode = SB_VIEW_MDICON) Or (m_ViewMode = SB_VIEW_XLICON) Then
                hr = I_IMAGECALLBACK
               
                ReDim Preserve bOvrAdded(mOvrMax + 1)
            
                LVEntries(nCur).nIcon = hr
                If (LVEntries(nCur).nOverlay) > 0 Then
            '                DebugAppend "Will set overlay " & LVEntries(nCur).nOverlay
                    If bOvrAdded(LVEntries(nCur).nOverlay) = False Then
                        'If this file has an overlay image, make sure we've copied it from
                        'the system imagelist to our thumbnail imagelist.
            '                    DebugAppend "Request overlay=" & LVEntries(nCur).nOverlay & ", last N=" & lpOvrN
                        nOvr = -1
                        If (LVEntries(nCur).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                            If himlCxActual = 0& Then
                                ImageList_GetIconSize himlLarge, himlCxActual, himlCyActual
                            End If
                            If LoadShortcutOverlay(himlCxActual) Then
                                Dim hBmpOvr2 As LongPtr
                                hBmpOvr2 = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                                nPos = ImageList_Add(himlLarge, hBmpOvr2, 0&)
                                DeleteObject hBmpOvr2
                                If nPos <> -1& Then
                                    ImageList_SetOverlayImage himlLarge, nPos, LVEntries(nCur).nOverlay
                                    bOvrAdded(LVEntries(nCur).nOverlay) = True
                                    GoTo skipovr2
                                Else
                                    GoTo sysimlovr2
                                End If
                            End If
                        End If
    sysimlovr2:
                        On Error Resume Next
                        imlSysJM.GetOverlayImage LVEntries(nCur).nOverlay, nOvr
                        If nOvr = -1 Then
                        imlSysJM.GetIcon lpOvrN, ILD_TRANSPARENT, hIcon
                        Else
                        imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                        End If
                        nPos = ImageList_AddIcon(himlLarge, hIcon)
                        Call DestroyIcon(hIcon)
                        ImageList_SetOverlayImage himlLarge, nPos, LVEntries(nCur).nOverlay
                        bOvrAdded(LVEntries(nCur).nOverlay) = True
                        On Error GoTo e0
                    End If
    skipovr2:
                End If
            End If
            
            ReDim LVEntries(nCur).ExtColData(0)
            LVEntries(nCur).ExtColData(0).cdid = lDefColIdx(0)
            If sParParse = sComp Then
                LVEntries(nCur).ExtColData(0).sDisp = sNameParse
                LVEntries(nCur).ExtColData(0).vRaw = sNameParse
            Else
                LVEntries(nCur).ExtColData(0).sDisp = sName
                LVEntries(nCur).ExtColData(0).vRaw = sName
            End If
            
            If ((bShowParentItemsInAllViews = True) Or ((m_ViewMode = SB_VIEW_DETAILS) And (bGV = False))) Then
                If (mDispParAndIndt = True) And (bFlagNoIndent = False) Then
                    If lManualIndent >= 0& Then
                        LVEntries(nCur).lIndent = lManualIndent
                    Else
                        LVEntries(nCur).lIndent = LVComputeIndent(LVEntries(nCur).sFullPath)
                    End If
                End If
            End If
            
            'In some dirs, shell notify will send create messages for items that already exist
            If LVEntryIsDupe(LVEntries(nCur), nCur) = False Then
                lLVPos = InsertListItem(LVEntries(nCur), iForcePos)
                LVPopulateColsForItem lLVPos
                If LVEntries(nCur).bFolder Then
                    nCurFolders = nCurFolders + 1
                Else
                    nCurFiles = nCurFiles + 1
                End If
            Else
                DebugAppend "LVAddEntry::Item flagged as dupe, will not insert"
                LVEntries(nCur).bDeleted = True
            End If
            Set pStore = Nothing
            Set upi = Nothing
            Set si2Child = Nothing
    '        Set siChild = Nothing
    '        Set psf = Nothing
            CoTaskMemFree pidlPar
    
            If m_GroupMode <> SBGB_None Then GroupUpdateAllFooters hLVS
    
    nxt:
    Dim sFN As String
    If nCurFolders = 1 Then
        sFN = " " & mFolderStr & ", "
    Else
        sFN = " " & mFoldersStr & ", "
    End If
    Dim sfn2 As String
    If nCurFiles = 1 Then
        sfn2 = " " & mFileStr & " ("
    Else
        sfn2 = " " & mFilesStr & " ("
    End If
    If (nCurFiles + nCurFolders) = 0 Then
        UpdateStatus mNoItemsStr, idxSizePanel
    Else
        UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2 & _
                                                    FormatFileSizeCurExB(m_CurSize, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb) & ")", idxSizePanel
    End If
    LVAddEntry = lLVPos
    
    RaiseEvent ItemAdded(sName)
    Exit Function
    e0:
        DebugAppend "LVAddEntry->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
        LVAddEntry = -2
    End Function
    
    Private Sub UpdateStatusSize()
    Dim sFN As String
    If nCurFolders = 1 Then
        sFN = " " & mFolderStr & ", "
    Else
        sFN = " " & mFoldersStr & ", "
    End If
    Dim sfn2 As String
    If nCurFiles = 1 Then
        sfn2 = " " & mFileStr & " ("
    Else
        sfn2 = " " & mFilesStr & " ("
    End If
        
        UpdateStatus CStr(nCurFolders) & sFN & CStr(nCurFiles) & sfn2 & _
                                                    FormatFileSizeCurExB(m_CurSize, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb) & ")", idxSizePanel
    
    End Sub
    
    Public Sub RedrawList()
    Dim ct As LongPtr
    ct = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    SendMessage hLVS, LVM_REDRAWITEMS, 0&, ByVal ct
    UpdateWindow hLVS
    End Sub
    
    Private Sub PaintRating(hWnd As LongPtr, PicWidth As Long, PicHeight As Long, ID1 As Long, ID2 As Long, ByVal Value As Integer, Rec As RECT)
    Dim j As Integer
    Dim lX As Long, lY As Long
    Dim DC As LongPtr
    DC = GetDC(hWnd)
    
    lY = (Rec.Top + ((Rec.Bottom - Rec.Top) / 2) - (PicHeight / 2)) * 1
    
    For j = 0 To 4
    
        lX = (Rec.Left + PicWidth * j) * 1
        
        If lX >= 0 And lY >= 0 Then
    '        Debug.Print "Draw " & lX & "," & lY & " on " & DC
            If Value <= j Then
                If ID1 = ID_Selected Then
                        DebugAppend "DrawSelected " & lX & "," & lY & " on " & DC
                End If
                ImageList_Draw lvrHIML, ID1, DC, lX, lY, ILD_TRANSPARENT
            Else
                ImageList_Draw lvrHIML, ID2, DC, lX, lY, ILD_TRANSPARENT
            End If
        End If
    Next j
    DeleteDC DC
    End Sub
    
    Private Function AddDataStreams(idx As Long) As Long
    'Adds the alternate data streams for the given index. Returns the number added.
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim nCt As Long
    Dim tStrm() As EntryStream
    Dim nStrm As Long
    ReDim tStrm(0)
    Dim hFile As LongPtr, uIOSB As IO_STATUS_BLOCK, uFSI As FILE_STREAM_INFORMATION
    Dim uBuffer() As Byte, lStreamInfo As LongPtr, lBufferLen As Long, sStreamName As String
    
    If LVEntries(idx).bFolder Then
        hFile = CreateFileW(StrPtr(LVEntries(idx).sFullPath), GENERIC_READ, FILE_SHARE_READ Or (&H2), ByVal 0&, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
    Else
        hFile = CreateFileW(StrPtr(LVEntries(idx).sFullPath), GENERIC_READ, FILE_SHARE_READ Or (&H2), ByVal 0&, OPEN_EXISTING, 0, 0)
    End If
    If hFile = -1 Then Exit Function
    
    lBufferLen = 96 * CLng(4096)
    ReDim uBuffer(1 To lBufferLen)
    If 0 = NtQueryInformationFile(hFile, uIOSB, ByVal VarPtr(uBuffer(1)), lBufferLen, FileStreamInformation) Then
    
      lStreamInfo = VarPtr(uBuffer(1))
      Do
        CopyMemory ByVal VarPtr(uFSI.NextEntryOffset), ByVal lStreamInfo, 24
        If uFSI.StreamNameLength <= 260 Then
            CopyMemory ByVal VarPtr(uFSI.StreamName(0)), ByVal lStreamInfo + 24, uFSI.StreamNameLength
        End If
        sStreamName = Left(uFSI.StreamName, uFSI.StreamNameLength \ 2)
    
        If sStreamName <> vbNullString And _
           sStreamName <> "::$DATA" Then
    
           sStreamName = Mid(sStreamName, 2)
           sStreamName = Left(sStreamName, InStr(sStreamName, ":") - 1)
    
            ReDim Preserve tStrm(nStrm)
            tStrm(nStrm).sStreamName = sStreamName
            tStrm(nStrm).cStreamSize = LargeIntToLongLong(uFSI.StreamSize)
            
            nStrm = nStrm + 1
           
        End If
        If uFSI.NextEntryOffset > 0 Then
            lStreamInfo = lStreamInfo + uFSI.NextEntryOffset
        Else
            Exit Do
        End If
      Loop
    End If
    CloseHandle hFile
    If nStrm > 0 Then
        Dim i As Long
        For i = 0 To nStrm - 1
              nCt = nCt + 1
               ReDim Preserve LVEntries(idx + nCt)
               With LVEntries(idx + nCt)
                    .lParam = idx + nCt
                    .bIsADS = True
                   .sName = LVEntries(idx).sName & ":" & tStrm(i).sStreamName
                   .sNameParsing = LVEntries(idx).sNameParsing & ":" & tStrm(i).sStreamName
                   .sNameFull = LVEntries(idx).sNameFull & ":" & tStrm(i).sStreamName
                   .sFullPath = LVEntries(idx).sFullPath & ":" & tStrm(i).sStreamName
                   .sParentFull = LVEntries(idx).sParentFull
                   .cSize = tStrm(i).cStreamSize
                   Dim vc As Variant
                   vc = CDec(tStrm(i).cStreamSize)
                   .sSize = FormatValueWithPD(vc, PKEY_Size, PDFF_DEFAULT, VT_UI8)
                   .sType = "(Alternate data stream)"
                    ReDim LVEntries(idx + nCt).ExtColData(0)
                    LVEntries(idx + nCt).ExtColData(0).cdid = lDefColIdx(0)
                    LVEntries(idx + nCt).ExtColData(0).sDisp = .sName
                    LVEntries(idx + nCt).ExtColData(0).vRaw = .sName
                    If (mDispParAndIndt = True) And (bFlagNoIndent = False) Then
                        LVEntries(idx + nCt).lIndent = lCurMaxInd ' LVComputeIndent(LVEntries(idx + nCt).sFullPath)
                    End If
                    LVEntries(idx + nCt).lIndent = LVEntries(idx + nCt).lIndent + 1
                    DebugAppend "Adding alt data streams... " & .sName & "," & .sSize & "," & vc & "," & tStrm(i).cStreamSize
               End With
               
               InsertListItem LVEntries(idx + nCt)
        Next i
    End If
    
    AddDataStreams = nCt
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.AddDataStreams->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function FormatValueWithPD(vVal As Variant, pk As PROPERTYKEY, nType As PROPDESC_FORMAT_FLAGS, vt As Integer) As String
    Dim lpsz As LongPtr
    Dim ppd As IPropertyDescription
    PSGetPropertyDescription pk, IID_IPropertyDescription, ppd
    If (ppd Is Nothing) = False Then
        Dim vrr As Variant, vrr2 As Variant
    '    vrr = vVal
        VariantToPropVariant vVal, vrr
        CopyMemory ByVal VarPtr(vrr), ByVal VarPtr(vt), 2&
        ppd.FormatForDisplay vrr, nType, lpsz
        If lpsz Then
            SysReAllocString VarPtr(FormatValueWithPD), lpsz
            CoTaskMemFree lpsz
        End If
    End If
    End Function
    
    Private Sub DoSound(sSound As String)
    PlaySound StrPtr(sSound), 0&, SND_ASYNC
    DebugAppend "PlaySound " & sSound
    End Sub
    
    Public Function StartLoadingMarquee(Optional sCaption As String) As LongPtr
        If hCombo = 0 Then Exit Function
        Dim rcEdit As RECT
        Dim hPar As LongPtr
        If m_CbType = SBCT_Simple Then
            hPar = hCBEd
        Else
            hPar = hCombo
        End If
        GetClientRect hPar, rcEdit
        EnableWindow hPar, 0&
        SendMessage hCombo, WM_SETREDRAW, 0&, ByVal 0&
        SendMessage hCBEd, WM_SETREDRAW, 0&, ByVal 0&
        Dim X As Long, Y As Long, cxOff As Long, cyOff As Long
        If m_CbType = SBCT_DropdownList Then
            X = 0&: Y = 0&
            cxOff = 2&: cyOff = 0&
        Else
            X = 1&: Y = 1&
            cxOff = 2&: cyOff = 2&
        End If
        hLoadMarq = CreateWindowExW(0&, StrPtr(PROGRESS_CLASS), 0&, WS_CHILD Or WS_VISIBLE Or PBS_MARQUEE, X, Y, (rcEdit.Right - cxOff) - (16 * m_ScaleX), rcEdit.Bottom - cyOff, hPar, 0&, App.hInstance, ByVal 0&)
        If hLoadMarq Then
            If IsMissing(sCaption) Then
                sMarqText = " " & m_sCurPathDisp
            Else
                sMarqText = " " & sCaption
            End If
            Call SendMessage(hLoadMarq, PBM_SETMARQUEE, 1, ByVal 30&)
            ' If ssc_Subclass(hLoadMarq, , 17, , , True, True) Then
            '     Call ssc_AddMsg(hLoadMarq, MSG_AFTER, WM_PAINT)
            ' End If
            Subclass2 hLoadMarq, AddressOf ProgWndProc, hLoadMarq
            StartLoadingMarquee = hLoadMarq
        End If
    End Function
    
    Public Sub StopLoadingMarquee()
        If hLoadMarq = 0& Then Exit Sub
        'ssc_UnSubclass hLoadMarq
        UnSubclass2 hLoadMarq, AddressOf ProgWndProc, hLoadMarq
        DestroyWindow hLoadMarq
        hLoadMarq = 0&
        EnableWindow hCombo, 1&
        SendMessage hCBEd, WM_SETREDRAW, 1&, ByVal 0&
        SendMessage hCombo, WM_SETREDRAW, 1&, ByVal 0&
    End Sub
    
    Private Function DrawProgressTheme(hDC As LongPtr, hWnd As LongPtr, rtRect As RECT, Valor As Long) As Boolean
        On Error Resume Next
    '    DebugAppend "DrawProgressTheme(" & CStr(Valor) & ")"
        Dim lResult     As Long
        Dim lWidth      As Long
        Dim Percent     As Long
        Dim valueRect   As RECT
        Dim lOffCY As Long
        
        SetBkColor hDC, &HFFFFFF
        If m_ViewMode = SB_VIEW_DETAILS Then
            rtRect.Top = rtRect.Top + 2: rtRect.Bottom = rtRect.Bottom - 2
        End If
        
        If IsIDE() = False Then
            lOffCY = 1&
        End If
        rtRect.Top = rtRect.Top + lOffCY
        rtRect.Bottom = rtRect.Bottom - lOffCY
        
        lResult = DrawThemeBackground(hThemeProg, hDC, PP_TRANSPARENTBAR, PBBS_PARTIAL, rtRect, rtRect)
        If lResult Then
            Call CloseThemeData(hThemeProg)
            hThemeProg = 0
        Else
            lWidth = rtRect.Right - rtRect.Left - 2
            If lWidth > 0 Then
                Percent = (Valor * lWidth) / 100
                Call SetRect(valueRect, rtRect.Left + 0, rtRect.Top + 0, rtRect.Left + 0 + Percent, rtRect.Bottom - 0)
                valueRect.Top = valueRect.Top + lOffCY
                valueRect.Bottom = valueRect.Bottom - lOffCY
                lResult = DrawThemeBackground(hThemeProg, hDC, PP_FILL, IIf(Valor > lPercentFullWarningThreshold, PBFS_ERROR, PBFS_PARTIAL), valueRect, valueRect)
            End If
        End If
    
        Dim sText As String
        Dim clrt As Long
        OleTranslateColor clrForeSubitem, 0&, clrt
        sText = Valor & " %"
        Call SetTextColor(hDC, clrt)
        Call DrawText(hDC, StrPtr(sText), Len(sText), rtRect, DT_SINGLELINE Or DT_CENTER Or DT_VCENTER)
    End Function
    
    Private Function DrawLink(hDC As LongPtr, hWnd As LongPtr, rtRect As RECT, sText As String, nItem As Long, Optional nCol As Long = 1&) As LongPtr
        On Error Resume Next
        SetBkColor hDC, &HFFFFFF
        SetBkMode hDC, TRANSPARENT
        DebugAppend "DrawLink cy=" & (rtRect.Bottom - rtRect.Top), 11
         
        DrawLink = CreateWindowExW(0&, StrPtr(WC_LINK), StrPtr(sText), WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or LWS_USEVISUALSTYLE Or LWS_TRANSPARENT, rtRect.Left, rtRect.Top, rtRect.Right - rtRect.Left, rtRect.Bottom - rtRect.Top - 2, hWnd, 0&, App.hInstance, ByVal 0&)
        SetWindowLong DrawLink, GWL_USERDATA, nItem
    '    SendMessage DrawLink, WM_PAINT, 0, ByVal 0&
    
    End Function
    
    Private Function GetItemRec(hWnd As LongPtr, ByVal Rtop As Long, ByVal Index As Long) As RECT
        GetItemRec.Top = Rtop
        GetItemRec.Left = LVIR_LABEL
        SendMessage hWnd, LVM_GETSUBITEMRECT, Index, GetItemRec
        If m_ViewMode = SB_VIEW_TILE Then 'All rect values correct except Right; so take full item rect's width
            Dim prc As RECT
            prc.Left = LVIR_SELECTBOUNDS 'LVIR_LABEL
            SendMessage hWnd, LVM_GETITEMRECT, Index, prc
            GetItemRec.Right = prc.Right
        End If
    End Function
    Private Function GetItemRec2(hWnd As LongPtr, ByVal Rtop As Long, ByVal Index As Long) As RECT
        GetItemRec2.Top = Rtop
        GetItemRec2.Left = LVIR_LABEL
        SendMessage hWnd, LVM_GETSUBITEMRECT, Index, GetItemRec2
        If m_ViewMode = SB_VIEW_TILE Then 'All rect values correct except Right; so take full item rect's width
            Dim prc As RECT
            prc.Left = LVIR_BOUNDS
            SendMessage hWnd, LVM_GETITEMRECT, Index, prc
            GetItemRec2.Right = prc.Right
        End If
    End Function
    
    Private Function RatingColumnPopup() As Long
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
    Const sSL As String = "Locked"
    
    hMenu = CreatePopupMenu()
    
    With mii
        .cbSize = LenB(mii)
         
        .fMask = MIIM_STRING Or MIIM_ID Or MIIM_STATE
        .wID = idFS_RatingLock
        .dwTypeData = StrPtr(sSL)
        .cch = Len(sSL)
        .fState = IIf(bLockRating, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, 0, True, mii)
    
    
    End With
    Call GetCursorPos(PT)
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_RIGHTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD Or TPM_VERNEGANIMATION, PT.x, PT.y, 0, hLVSHdr, 0)
    
    If idCmd Then
        Select Case idCmd
            Case idFS_RatingLock
                If bLockRating Then
                    bLockRating = False
                Else
                    bLockRating = True
                End If
        End Select
    End If
    
    Call DestroyMenu(hMenu)
    
    RatingColumnPopup = idCmd
    
    End Function
    
    Private Function SetFileRating2(llp As LongPtr, lNumberOfStars As Long) As Long
    Dim vvar As Variant
    Dim lRating As Long
    Dim isi As IShellItem2
    Dim pps As IPropertyStore
    Dim hr As Long
    Dim pvar As Variant
    
    Select Case lNumberOfStars
        Case 1: lRating = 1
        Case 2: lRating = 25
        Case 3: lRating = 50
        Case 4: lRating = 75
        Case 5: lRating = 99
        Case Else: lRating = 0
    End Select
    vvar = CVar(lRating)
    SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
    If (isi Is Nothing) Then
        DebugAppend "SetFileRating2->Failed to get isi"
        Dim pidlFQItem As LongPtr
        pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
        SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
        If pidlFQItem Then CoTaskMemFree pidlFQItem
        If (isi Is Nothing) Then
            DebugAppend "SetFileRating2->Alternate isi creation failed"
            Exit Function
        End If
    End If
    isi.GetPropertyStore GPS_OPENSLOWITEM Or GPS_READWRITE, IID_IPropertyStore, pps
    If (pps Is Nothing) = False Then
        PropVariantChangeType pvar, vvar, 0&, VT_UI4
         hr = pps.SetValue(PKEY_Rating, pvar)
            DebugAppend "SetFileRating2.return=0x" & Hex$(hr), 2
        If hr = 0 Then
            hr = pps.Commit()
        End If
        
        Set pps = Nothing
        Set isi = Nothing
    End If
    SetFileRating2 = hr
    End Function
    
    Private Function GetFileRating(sFile As String, Optional idx As Long = -1) As Long
    'Returns the star rating of a file in number of stars
    Dim isi As IShellItem2
    Dim lp As Long, lpr As Long
    Call SHCreateItemFromParsingName(StrPtr(sFile), Nothing, IID_IShellItem2, isi)
    If isi Is Nothing Then
        If idx >= 0& Then
            Dim pidl As LongPtr
            pidl = ILCombine(pidlFQCur, LVEntries(idx).pidlRel)
            SHCreateItemFromIDList pidl, IID_IShellItem, isi
            CoTaskMemFree pidl
        End If
    End If
    
    If (isi Is Nothing) = False Then
        isi.GetUInt32 uColData(lRTColIdx).pKey, lpr
        Select Case lpr
            Case 1 To 12 'sys default=1
                lp = 1
            Case 13 To 37 'default=25
                lp = 2
            Case 38 To 62 'default=50
                lp = 3
            Case 63 To 87 'default=75
                lp = 4
            Case 88 To 99 'default=99
                lp = 5
            Case Else
                lp = 0
        End Select
        GetFileRating = lp
        Set isi = Nothing
    End If
    DebugAppend "GetFileRating(" & sFile & ")=" & lpr
    End Function
    
    Private Function GetFileRatingEx(sFile As String, out_IsSupported As Boolean, Optional idx As Long = -1) As Long
    'Returns the star rating of a file in number of stars, with the additional output of knowing whether the file
    'supports ratings at all, since just the standard GetFileRating returns 0 for both unsupported and unrated
    Dim isi As IShellItem2
    Dim lp As Long, lpr As Long
    Call SHCreateItemFromParsingName(StrPtr(sFile), Nothing, IID_IShellItem2, isi)
    If isi Is Nothing Then
        If idx >= 0& Then
            Dim pidl As LongPtr
            pidl = ILCombine(pidlFQCur, LVEntries(idx).pidlRel)
            SHCreateItemFromIDList pidl, IID_IShellItem, isi
            CoTaskMemFree pidl
        End If
    End If
    
    If (isi Is Nothing) = False Then
    
        Dim hr As Long
        Dim r2 As String
        Dim pps As IPropertyStore
        Dim pk() As PROPERTYKEY
        ReDim pk(1)
        pk(0) = PKEY_Rating
        pk(1) = PKEY_PropList_PreviewDetails
    
        hr = isi.GetPropertyStoreForKeys(pk(0), 2&, GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps)
        DebugAppend "GetFileRatingEx.GetLimPStore hr=0x" & Hex$(hr)
        
        If (pps Is Nothing) = False Then
            Dim vrr As Variant, vbr As Variant
            pps.GetValue PKEY_Rating, vrr
            PropVariantToVariant vrr, vbr
            lpr = CLng(vbr)
            Select Case lpr
                Case 1 To 12 'sys default=1
                    lp = 1
                Case 13 To 37 'default=25
                    lp = 2
                Case 38 To 62 'default=50
                    lp = 3
                Case 63 To 87 'default=75
                    lp = 4
                Case 88 To 99 'default=99
                    lp = 5
                Case Else
                    lp = 0
            End Select
            GetFileRatingEx = lp
            
            r2 = GetPropertyKeyDisplayString(pps, PKEY_PropList_PreviewDetails)
            If InStr(r2, "System.Rating") Then
                out_IsSupported = True
            End If
        End If
        
        Set isi = Nothing
        
        DebugAppend "GetFileRatingEx(" & sFile & ") rt=" & GetFileRatingEx & ",sp=" & out_IsSupported
    Else
        DebugAppend "GetFileRatingEx->Could not generate IShellItem2"
    End If
    End Function
    
    Private Sub SearchOptionsPopup()
    DebugAppend "SearchOptionsPopup::Alt=" & bSearchAlt
    Dim fSkip As Long
    Dim sText As String
    Dim lLen As Long
    lLen = CLng(SendMessageW(hSearchBox, WM_GETTEXTLENGTH, 0, ByVal 0&))
    sText = String$(lLen, 0)
    Call SendMessageW(hSearchBox, WM_GETTEXT, lLen + 1, ByVal StrPtr(sText))
    mSearchTextCache = sText
    RaiseEvent FileSearchPopup(mSearchTextCache, fSkip)
    If fSkip Then Exit Sub
    
    Dim rcl As RECT
    Dim rcu As RECT
    Dim stInitial As SYSTEMTIME
    Dim dtInitial As Date
    Dim hFont As LongPtr
    Dim cyOff As Long
    
    If bSearchOptionsInheritBkColor Then
        pbSearch.BackColor = UserControl.BackColor
        lblSrch.BackColor = UserControl.BackColor
        lblKB1.BackColor = UserControl.BackColor
        lblShType.BackColor = UserControl.BackColor
        lblShSz.BackColor = UserControl.BackColor
        chkDate.BackColor = UserControl.BackColor
        chkSrSz.BackColor = UserControl.BackColor
        chkShFldr.BackColor = UserControl.BackColor
        fraSrDate.BackColor = UserControl.BackColor
        pbSearchDT.BackColor = UserControl.BackColor
        cmdSrClr.BackColor = UserControl.BackColor
        cmdSrCn.BackColor = UserControl.BackColor
        cmdSrCl.BackColor = shpSearchBk.FillColor
        cmdStartSearch.BackColor = UserControl.BackColor
        cbDateType.BackColor = UserControl.BackColor
        cbDateCmp1.BackColor = UserControl.BackColor
        cbSrSize1.BackColor = UserControl.BackColor
        cbShType.BackColor = UserControl.BackColor
    End If
    
    GetClientRect hLVS, rcl
    GetClientRect UserControl.hWnd, rcu
    SetParent pbSearch.hWnd, UserControl.ContainerHwnd
    pbSearch.Visible = True
    If bSearchAlt Then
        pbSearch.Left = UserControl.ScaleX(Parent.Controls(Ambient.DisplayName).Left, Parent.ScaleMode, UserControl.ScaleMode) * Screen.TwipsPerPixelX
    Else
        pbSearch.Left = (pbControlBox.Left * Screen.TwipsPerPixelX) + UserControl.ScaleX(Parent.Controls(Ambient.DisplayName).Left, Parent.ScaleMode, UserControl.ScaleMode) * Screen.TwipsPerPixelX
    End If
    pbSearch.Top = (UserControl.ScaleY(Parent.Controls(Ambient.DisplayName).Top, Parent.ScaleMode, UserControl.ScaleMode) + cyCombo + 4) * Screen.TwipsPerPixelY
    If m_ScaleY > 1 Then
        cyOff = 4 * m_ScaleY
    Else
        cyOff = 8 * m_ScaleY
    End If
    hDTSearch1 = CreateWindowExW(WS_EX_CLIENTEDGE Or WS_EX_LEFT Or WS_EX_LTRREADING Or WS_EX_RIGHTSCROLLBAR, _
                          StrPtr(DATETIMEPICK_CLASS), StrPtr(""), _
                          WS_CHILD Or WS_VISIBLE Or WS_OVERLAPPED Or DTS_SHORTDATEFORMAT, _
                          2&, 1&, pbSearchDT.ScaleWidth - 4&, Abs(m_cyFontDtTxt) + cyOff, _
                          pbSearchDT.hWnd, 0&, App.hInstance, ByVal 0&)
    Dim lpw As Long
    lpw = PackWords(1, 0)
    If hFontCtl Then
        SendMessageW hDTSearch1, WM_SETFONT, hFontCtl, ByVal lpw
    End If
    
    If Ambient.UserMode Then
        If bDtSC = False Then
            ' If ssc_Subclass(pbSearchDT.hWnd, 1&, 14&, , , , True) Then
            '  Call ssc_AddMsg(pbSearchDT.hWnd, MSG_BEFORE, ALL_MESSAGES)
            ' End If
            Subclass2 pbSearchDT.hWnd, AddressOf SearchDTWndProc, pbSearchDT.hWnd, 1
            bDtSC = True
        End If
    End If
    
    stInitial = DateToSystemTime(Now)
    
    SendMessageW hDTSearch1, DTM_SETSYSTEMTIME, GDT_VALID, stInitial
    stShLast1 = stInitial
    
    If chkDate.Value = vbUnchecked Then
        EnableWindow hDTSearch1, 0
    End If
    
    Dim yOff As Long, yStart As Long
    yStart = (chkShFldr.Top * Screen.TwipsPerPixelY) + (chkShFldr.Height * Screen.TwipsPerPixelY)
    If bSearchAlt Then
    '    lblSrch.Visible = False
        bSearchAltText = True
        yOff = (Abs(m_cyFontDtTxt) + (50 * m_ScaleY)) * Screen.TwipsPerPixelY
        pbSearch.Height = yStart + yOff
        yOff = (Abs(m_cyFontDtTxt) + 10) '* Screen.TwipsPerPixelY
        yStart = chkShFldr.Top + chkShFldr.Height + 6
        cmdSrClr.Top = yStart + cmdSrClr.Height + Abs(m_cyFontDtTxt)
        cmdSrCn.Top = yStart + cmdSrClr.Height + Abs(m_cyFontDtTxt)
        cmdStartSearch.Top = yStart + cmdSrClr.Height + Abs(m_cyFontDtTxt)
        Call pvCreateAltSearchBox
        bSearchAlt = False 'reset in case next call comes from after regular box is restored
    Else
        pbSearch.Height = yStart + ((40 * m_ScaleY) * Screen.TwipsPerPixelY)
        yStart = chkShFldr.Top + chkShFldr.Height
        cmdSrClr.Top = yStart + (8 * m_ScaleY)
        cmdSrCn.Top = yStart + (8 * m_ScaleY)
        cmdStartSearch.Top = yStart + (8 * m_ScaleY)
    End If
    
    
    Dim dwFrEx As WindowStylesEx
    dwFrEx = CLng(GetWindowLong(pbSearch.hWnd, GWL_EXSTYLE))
    dwFrEx = dwFrEx Or WS_EX_DLGMODALFRAME
    SetWindowLong pbSearch.hWnd, GWL_EXSTYLE, dwFrEx
    
    SetWindowPos pbSearch.hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
    
    'SetFocusAPI cmdStartSearch.hWnd
    pvSetIPAO
    End Sub
    
    Private Sub LVSetSubsetLabel()
    Dim lvg As LVGROUP
    Dim i As Long
    Dim ci As Long, ctg As Long
    
    If m_GroupSubset > 0& Then
        For i = 0 To UBound(lGrpIDs())
            lvg.Mask = LVGF_STATE Or LVGF_SUBSETITEMS
            lvg.cbSize = LenB(lvg)
            Call SendMessage(hLVS, LVM_GETGROUPINFO, lGrpIDs(i), lvg)
            ci = lvg.cItems
            lvg.Mask = LVGF_STATE Or LVGF_ITEMS
            lvg.cbSize = LenB(lvg)
            Call SendMessage(hLVS, LVM_GETGROUPINFO, lGrpIDs(i), lvg)
            ctg = lvg.cItems
            
            If (ctg = ci) And (ctg > 0&) Then 'Subset has been expanded, remove 'Show More' link
                DebugAppend "nSub=nTotal=" & ci
                With lvg
                    .Mask = LVGF_SUBSET Or LVGF_SUBSETITEMS
                    .StateMask = .StateMask Or LVGS_SUBSETED
                    .State = .State And Not LVGS_SUBSETED
                    .pszSubsetTitle = StrPtr("")
                    .cchSubsetTitle = 0&
                End With
                Call SendMessage(hLVS, LVM_SETGROUPINFO, lGrpIDs(i), ByVal VarPtr(lvg))
            End If
        Next
    End If
    End Sub
    
    Private Sub LVSetStdIcon(ByVal llp As LongPtr)
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    'DebugAppend "LVSetStdIcon " & LVEntries(llp).sName
    Dim lpIco As Long
    Dim pUnk As IUnknownUnrestricted, hr As Long
    Dim pidlcb As LongPtr
        lpIco = -1
        If mIShIcon Is Nothing Then
            If psfCur Is Nothing Then
                DebugAppend "LVSetStdIcon->psfCur Is Nothing"
            End If
            Set pUnk = psfCur
            hr = -1
            hr = pUnk.QueryInterface(IID_IShellIcon, mIShIcon)
        End If
            If LVEntries(llp).pidlRel = 0& Then
                psfCur.ParseDisplayName hLVS, 0&, StrPtr(LVEntries(llp).sNameParsing), 0&, LVEntries(llp).pidlRel, 0&
                If LVEntries(llp).pidlRel = 0& Then
                    psfCur.ParseDisplayName hLVS, 0&, StrPtr(LVEntries(llp).sNameFull), 0&, LVEntries(llp).pidlRel, 0&
                    If LVEntries(llp).pidlRel = 0& Then
                        Dim siTmp As IShellItem
                        Dim piTmp As IParentAndItem
                        SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem, siTmp
                        If (siTmp Is Nothing) = False Then
                            Dim pidlPar As LongPtr
                            Dim psfTmp As IShellFolder
    '                        SHGetIDListFromObject siTmp, pidlcb
    '                        If pidlcb Then
    '                            LVEntries(llp).pidlRel = ILFindLastID(pidlcb)
    '                            If (mIShIcon Is Nothing) = False Then
    '                                lpIco = -1
    '                                mIShIcon.GetIconOf LVEntries(llp).pidlRel, GIL_FORSHELL, lpIco
    '                                If lpIco > (-1) Then
    '                                    LVEntries(llp).nIcon = lpIco
    '                                    LVEntries(llp).nFileIcon = lpIco
    '                                    CoTaskMemFree pidlcb
    '                                    Exit Sub
    '                                Else
    '                                    GoTo havefull
    '                                    LVEntries(llp).nIcon = 0&
    '                                    LVEntries(llp).nFileIcon = 0&
    '                                End If
    '                            End If
    '                        End If
                            Set piTmp = siTmp
                            piTmp.GetParentAndItem pidlPar, psfCur, LVEntries(llp).pidlRel
                            Set pUnk = psfCur
                            hr = -1
                            hr = pUnk.QueryInterface(IID_IShellIcon, mIShIcon)
                            CoTaskMemFree pidlPar
                            If hr = S_OK Then
                                mIShIcon.GetIconOf LVEntries(llp).pidlRel, GIL_FORSHELL, lpIco
                                LVEntries(llp).nIcon = lpIco
                                LVEntries(llp).nFileIcon = lpIco
    '                            DebugAppend "lpIco@1=" & lpIco
                                Exit Sub
                            Else
                                pidlcb = ILCombine(pidlPar, LVEntries(llp).pidlRel)
                                If pidlcb Then GoTo havefull
                            End If
                        End If
                    End If
                End If
            End If
        If hr = S_OK Then
            mIShIcon.GetIconOf LVEntries(llp).pidlRel, GIL_FORSHELL, lpIco
    '                                    DebugAppend "lpIco@2=" & lpIco
    
        Else
            pidlcb = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
    havefull:
    '        Dim siwtf As IShellItem
    '        Dim lpwtf As Long
    '        SHCreateItemFromIDList pidlcb, IID_IShellItem, siwtf
    '        siwtf.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpwtf
    '        DebugAppend "ParsingPath=" & LPWSTRtoStr(lpwtf)
    '        Set siwtf = Nothing: lpwtf = 0
    '        SHCreateItemFromIDList pidlFQCur, IID_IShellItem, siwtf
    '        siwtf.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpwtf
    '        DebugAppend "ParsingPath2=" & LPWSTRtoStr(lpwtf)
            lpIco = GetFileIconIndexPIDL(pidlcb, SHGFI_LARGEICON)
            CoTaskMemFree pidlcb
        End If
    '        DebugAppend "lpIco@3=" & lpIco
        If lpIco > -1& Then
    
            LVEntries(llp).nIcon = lpIco
            LVEntries(llp).nFileIcon = lpIco
        Else
            Dim pidlcb2 As LongPtr
            pidlcb2 = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
    '              DebugAppend "pidlcb=" & pidlcb
            lpIco = GetFileIconIndexPIDL(pidlcb2, SHGFI_LARGEICON)
    '                                    DebugAppend "lpIco@4=" & lpIco
    
            If lpIco > -1& Then
                LVEntries(llp).nIcon = lpIco
                LVEntries(llp).nFileIcon = lpIco
            Else
                LVEntries(llp).nIcon = 0&
                LVEntries(llp).nFileIcon = 0&
            End If
            CoTaskMemFree pidlcb2
        End If
        
    '<EhFooter>
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.LVSetStdIcon->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
        Resume Next
    '</EhFooter>
    End Sub
    
    
    Private Function FileNameFromFullPath(sz As String) As String
    'Handles all scenarios
    Dim s1 As String, s2 As String
    If (Len(sz) < 4) And (Left$(sz, 2) <> "\\") Then
        FileNameFromFullPath = sz
        Exit Function
    End If
    If Right$(sz, 1) = "\" Then
        s1 = Left$(sz, Len(sz) - 1)
    Else
        s1 = sz
    End If
    
    If (Left$(s1, 2) = "\\") Or (Left$(s1, 3) = "::{") Then
        s1 = Mid$(s1, 3)
        If InStr(s1, "\") = 0 Then
            'Path like \\SERVER
            FileNameFromFullPath = s1
            Exit Function
        End If
    End If
        
    FileNameFromFullPath = Right$(s1, Len(s1) - InStrRev(s1, "\"))
    End Function
    
    Private Function FindCorrectParsingName(siItem As IShellItem, idx As Long) As String
    'There seems to be differences in when certain calls return certain names
    'The longest will be the correct name
    Dim snn1 As String, snn2 As String, snn3 As String
    Dim lp1 As LongPtr, lp2 As LongPtr, lp3 As LongPtr
    Dim si2 As IShellItem2
    
    
    Set si2 = siItem
    
    si2.GetString PKEY_ParsingName, lp1
    snn1 = LPWSTRtoStr(lp1)
    
    si2.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lp2
    snn2 = LPWSTRtoStr(lp2)
    snn2 = FileNameFromFullPath(snn2)
    
    si2.GetDisplayName SIGDN_PARENTRELATIVEPARSING, lp3
    snn3 = LPWSTRtoStr(lp3)
    
    If Len(snn3) > Len(snn2) Then
        If Len(snn3) > Len(snn1) Then
            FindCorrectParsingName = snn3
            LVEntries(idx).sNameParsing = snn3
            Exit Function
        ElseIf Len(snn1) > Len(snn3) Then
            FindCorrectParsingName = snn1
            LVEntries(idx).sNameParsing = snn1
            Exit Function
        Else 'equal
            FindCorrectParsingName = snn1
            LVEntries(idx).sNameParsing = snn1
            Exit Function
        End If
    Else
        If Len(snn2) > Len(snn1) Then
            FindCorrectParsingName = snn2
            LVEntries(idx).sNameParsing = snn2
            Exit Function
        ElseIf Len(snn1) > Len(snn2) Then
            FindCorrectParsingName = snn1
            LVEntries(idx).sNameParsing = snn1
            Exit Function
        Else 'equal
            FindCorrectParsingName = snn1
            LVEntries(idx).sNameParsing = snn1
            Exit Function
        End If
    End If
            
    
    End Function
    
    Private Function GetFileNameWithExt(lIdx As Long) As String
    'The longest name is the most likely to include the file extension
    Dim s1 As String, s2 As String
    Dim sFN As String
    
    sFN = FileNameFromFullPath(LVEntries(lIdx).sParentFull)
    
    s1 = LVEntries(lIdx).sName
    If Len(LVEntries(lIdx).sNameFull) > Len(s1) Then s1 = LVEntries(lIdx).sNameFull
    If Len(LVEntries(lIdx).sNameParsing) > Len(s1) Then s1 = LVEntries(lIdx).sNameParsing
    If Len(sFN) > Len(s1) Then s1 = sFN
    
    GetFileNameWithExt = s1
    
    End Function
    
    Private Sub LVPopulateColsForItem(lIdx As Long, Optional bRefresh As Boolean = False, Optional bCacheOnly As Boolean = False)
    'to be used after LVAddEntry; fills in the columns for item specified
    Dim i As Long, j As Long
    Dim lp As Long, llp As Long
    Dim lColCnt As Long
    Dim isi As IShellItem2
    Dim pps As IPropertyStore
    Dim lvi As LVITEM
    Dim sTmp As String
    Dim rtSup As Boolean
    Dim hr As Long
    Dim lECD As Long
    Dim pidlFQItem As LongPtr
    Dim nCIImg As Long
    Dim vpv As Variant, vbv As Variant
    Dim lpr As Long, szr As String
    On Error GoTo e0
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    If lColCnt = 1 Then Exit Sub 'Only name is displayed, and since it's never removed
                                 'it's already filled in, so we can exit
    
    llp = CLng(GetLVItemlParam(hLVS, lIdx))
    
    On Error GoTo e1
    
        
    For j = 1 To (lColCnt - 1)
        lp = CLng(GetHDItemlParam(hLVSHdr, j))
        lvi.Mask = LVIF_TEXT Or LVIF_DI_SETITEM
    
        If LVEntries(llp).pidlRel = 0& Then
            psfCur.ParseDisplayName hLVS, 0&, StrPtr(LVEntries(llp).sNameParsing), 0&, LVEntries(llp).pidlRel, 0&
            If LVEntries(llp).pidlRel = 0& Then
                psfCur.ParseDisplayName hLVS, 0&, StrPtr(LVEntries(llp).sNameFull), 0&, LVEntries(llp).pidlRel, 0&
            End If
        End If
        
        If uColData(lp).bFlagManual Then 'Manually inserted column
            SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
            pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
            If (isi Is Nothing) Then
                SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                If (isi Is Nothing) Then
                    DebugAppend "LVPopulateColsForItem->Alternate isi creation failed"
                End If
            End If
            RaiseEvent CustomColumnQueryData(lp, isi, pidlFQItem, LVEntries(llp).sName, LVEntries(llp).sParentFull, i, sTmp, nCIImg)
            If uColData(lp).bFlagManHasImg Then
                lvi.Mask = lvi.Mask Or LVIF_IMAGE
                lvi.iImage = nCIImg
            End If
            lECD = ColCacheIdx(lp, llp)
            Dim vrw2 As Variant
            vrw2 = CVar(sTmp)
            LVEntries(llp).ExtColData(lECD).cdid = lp
            LVEntries(llp).ExtColData(lECD).sDisp = sTmp
            LVEntries(llp).ExtColData(lECD).vRaw = vrw2
            
            lvi.cchTextMax = Len(sTmp) + 1
            lvi.pszText = StrPtr(sTmp)
            If pidlFQItem Then CoTaskMemFree pidlFQItem
        
        Else
            lECD = ColCacheIdx(lp, llp)
            Dim vrw As Variant, vbrw As Variant
            LVEntries(llp).ExtColData(lECD).cdid = lp
            Dim kk As Long
            For kk = 0 To UBound(LVEntries(llp).ExtColData)
                LVEntries(llp).ExtColData(kk).bSet = True
            Next kk
            If j <> 0 Then
                lvi.Mask = LVIF_TEXT Or LVIF_DI_SETITEM
                lvi.iImage = 0
            End If
                
            Select Case lp
    '            Case lDefColIdx(1)
    '                'For some reason, LVAddEntry can't access the Size value, even though it can access every other property.
    '                'So this routine gets ran twice, the second time with a refresh flag to fix the zero.
    '                If bRefresh Then
    '                    If (pps Is Nothing) Then
    '                        SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
    '                        If (isi Is Nothing) Then
    '                            DebugAppend "LVPopulateColsForItem->Failed to get isi"
    '                            pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
    '                            SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
    '                            If (isi Is Nothing) Then
    '                                DebugAppend "LVPopulateColsForItem->Alternate isi creation failed"
    '                            End If
    '                            If pidlFQItem Then CoTaskMemFree pidlFQItem
    '                        End If
    '                        isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
    '                    End If
    '                    Dim crSize As Currency
    '                    m_CurSize = m_CurSize - LVEntries(llp).cSize
    '                    isi.GetUInt64 PKEY_Size, crSize
    '                    LVEntries(llp).sSize = GetPropertyKeyDisplayString(pps, PKEY_Size)
    '                    LVEntries(llp).cSize = crSize '* 10000
    '                    m_CurSize = m_CurSize + LVEntries(llp).cSize
    '                    DebugAppend "LVPopulateColsForItem->UpdateSize=" & LVEntries(llp).sSize
    '                    UpdateStatusSize
    '                End If
    '                LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sSize
    '                LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).cSize)
    '                lvi.cchTextMax = Len(LVEntries(llp).sSize) + 1
    '                lvi.pszText = StrPtr(LVEntries(llp).sSize)
    '            Case lDefColIdx(2)
    '                LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sType
    '                LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).sType)
    '                lvi.cchTextMax = Len(LVEntries(llp).sType) + 1
    '                lvi.pszText = StrPtr(LVEntries(llp).sType)
    '            Case lDefColIdx(3)
    '                LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateM
    '                InitPropVariantFromFileTime LVEntries(llp).ftDateM, vrw
    '                PropVariantToVariant vrw, vbrw
    '                LVEntries(llp).ExtColData(lECD).vRaw = vbrw
    '                lvi.cchTextMax = Len(LVEntries(llp).sDateM) + 1
    '                lvi.pszText = StrPtr(LVEntries(llp).sDateM)
    '            Case lDefColIdx(4)
    '                LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateC
    '                InitPropVariantFromFileTime LVEntries(llp).ftDateC, vrw
    '                PropVariantToVariant vrw, vbrw
    '                LVEntries(llp).ExtColData(lECD).vRaw = vbrw
    '                lvi.cchTextMax = Len(LVEntries(llp).sDateC) + 1
    '                lvi.pszText = StrPtr(LVEntries(llp).sDateC)
    '            Case lDefColIdx(5)
    '                LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateA
    '                InitPropVariantFromFileTime LVEntries(llp).ftDateA, vrw
    '                PropVariantToVariant vrw, vbrw
    '                LVEntries(llp).ExtColData(lECD).vRaw = vbrw
    '                lvi.cchTextMax = Len(LVEntries(llp).sDateA) + 1
    '                lvi.pszText = StrPtr(LVEntries(llp).sDateA)
                
                Case Else
                    If (pps Is Nothing) Then
    '                    DebugAppend "Open store for " & AddBackslash(LVEntries(llp).sParentFull) & LVEntries(llp).sNameParsing
                        SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                        If (isi Is Nothing) Then
    '                        DebugAppend "Alt open store via pidl,,,"
                            pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                            SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                            If (isi Is Nothing) Then
    '                            DebugAppend "Alt open store via fullpath " & LVEntries(llp).sFullPath
                                SHCreateItemFromParsingName StrPtr(AddBackslash(LVEntries(llp).sParentFull) & LVEntries(llp).sNameParsing), Nothing, IID_IShellItem2, isi
                                If (isi Is Nothing) Then
    '                                DebugAppend "Alt Open store for " & AddBackslash(LVEntries(llp).sParentFull) & LVEntries(llp).sName
                                    SHCreateItemFromParsingName StrPtr(AddBackslash(LVEntries(llp).sParentFull) & LVEntries(llp).sName), Nothing, IID_IShellItem2, isi
                                    If (isi Is Nothing) Then
                                        DebugAppend "LVPopulateColsForItem->Alternate isi creation failed for " & LVEntries(llp).sName
                                    End If
                                End If
                            End If
    
                            If pidlFQItem Then CoTaskMemFree pidlFQItem
                        End If
                        isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
                        Dim lAtr As SFGAO_Flags
                        pps.GetValue PKEY_SFGAOFlags, vpv
                        PropVariantToVariant vpv, vbv
                        lAtr = CLng(vbv)
                        LVEntries(llp).dwAttrib = lAtr
                        If (lAtr And SFGAO_SHARE) = SFGAO_SHARE Then
                            LVEntries(llp).nOverlay = 1
                            LVEntries(llp).nFileOverlay = 1
                        End If
                        If (lAtr And SFGAO_LINK) = SFGAO_LINK Then
                            LVEntries(llp).nOverlay = 2
                            LVEntries(llp).nFileOverlay = 2
                        End If
                        If LVEntries(llp).nOverlay > mOvrMax Then mOvrMax = LVEntries(llp).nOverlay
                        
                    End If
                    If (lp = lRTColIdx) And (lvrEnable = True) Then
                        pps.GetValue PKEY_Rating, vpv
                        PropVariantToVariant vpv, vbv
                        lpr = CLng(vbv)
                        Select Case lpr
                            Case 1 To 12: LVEntries(llp).lRating = 1& 'sys default=1
                            Case 13 To 37: LVEntries(llp).lRating = 2& 'default=25
                            Case 38 To 62: LVEntries(llp).lRating = 3& 'default=50
                            Case 63 To 87: LVEntries(llp).lRating = 4& 'default=75
                            Case 88 To 99: LVEntries(llp).lRating = 5& 'default=99
                            Case Else: LVEntries(llp).lRating = 0&
                        End Select
                        szr = GetPropertyKeyDisplayString(pps, PKEY_PropList_PreviewDetails)
                        If InStr(szr, "System.Rating") Then
                            LVEntries(llp).bRatingSupport = True
                        End If
    
                        sTmp = " "
                    Else
                        sTmp = GetPropertyKeyDisplayString(pps, uColData(lp).pKey)
    '                    DebugAppend "GPKDS " & uColData(lp).szSystemName & "=" & sTmp
                    End If
                    If bDisableProgressItems = False Then
                        If (lp = lPFColIdx) And (m_SubItemProgress > 0) Then
                            If PStoreHasPF(pps) Then
                                Dim sBugCheck As String
                                sBugCheck = GetPropertyKeyDisplayString(pps, PKEY_Computer_DecoratedFreeSpace)
                                If Len(sBugCheck) < 2 Then
                                    LVEntries(llp).lPercent = -1
                                Else
                                    pps.GetValue PKEY_PercentFull, vpv
                                    PropVariantToVariant vpv, vbv
                                    LVEntries(llp).lPercent = CLng(vbv)
                                    sTmp = " "
                                    DebugAppend "LVPopulateColsForItem->SetPercent " & LVEntries(llp).sName & "=" & LVEntries(llp).lPercent
                                End If
                            Else
                                'Percent full column is visible but does not apply to item, flag to not draw bar
                                LVEntries(llp).lPercent = -1
                            End If
                        End If
                    End If
                    
                    If lp = lDefColIdx(2) Then
                        If LVEntries(llp).sType = "" Then
                            LVEntries(llp).sType = sTmp
                        Else
                            sTmp = LVEntries(llp).sType 'STOP OVERRIDING THIS
                        End If
                        If bUsedHPFforCD Then
                            LVEntries(llp).lTypeID = GroupGetIDForType(sTmp)
                        Else
                            LVEntries(llp).lTypeID = GroupGetIDForType(sTmp, llp)
                        End If
                    End If
                    If lp = lDefColIdx(1) Then
                        pps.GetValue PKEY_Size, vpv
                        PropVariantToVariant vpv, vbv
                        LVEntries(llp).cSize = CCur(vbv)
                        If LVEntries(llp).sSize = "" Then
                            LVEntries(llp).sSize = sTmp
                        Else
                            sTmp = LVEntries(llp).sSize 'If this was set somewhere, like alt data streams, we shouldn't be overriding it
                        End If
                    End If
                    
                If bGV Then
                  Dim lResGrp As Long
                  With LVEntries(llp)
                    If .iGrp = I_GROUPIDCALLBACK Then
                        Select Case m_GroupMode
                            Case 0
                                .iGrp = 0
                            Case 1
                                lResGrp = GroupGetIDForAlpha(.sName)
                                .iGrp = lResGrp
                            Case 2
                                lResGrp = GroupGetIDForSize(.cSize)
                                .iGrp = lResGrp
                            Case 3
                                If (.sType = "") Then
                                    .sType = GetPropertyKeyDisplayString(pps, PKEY_ItemTypeText)
                                End If
                                lResGrp = GroupGetIDForType(.sType, llp)
                                .iGrp = lResGrp
                                .lTypeID = lResGrp
                            Case 4
                                lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateM), 0)
                                .iGrp = lResGrp
                            Case 5
                                lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateC), 1)
                                .iGrp = lResGrp
                            Case 6
                                lResGrp = GroupGetIDForDate(FileTimeToDate(.ftDateA), 2)
                                .iGrp = lResGrp
                            Case 7
                                If (lGrpCol >= 0&) And (lGrpCol <= UBound(uColData)) Then
                                    lResGrp = GetTextGroupId(GetPropertyKeyDisplayString(pps, uColData(lGrpCol).pKey))
                                    .iGrp = lResGrp
                                End If
                         End Select
                     End If
                   If m_GroupMode = SBGB_Type Then InsertGroupForType .sType
                   If m_GroupMode = SBGB_Extended Then GroupByTextInsertGroup (.iGrp)
                  End With
                End If
                    
                    
                    lvi.cchTextMax = Len(sTmp) + 1
                    lvi.pszText = StrPtr(sTmp)
                    
                    LVEntries(llp).ExtColData(lECD).sDisp = sTmp
                    If (sTmp = "") And (uColData(lp).dwDispType = PDDT_NUMBER) Then
                        LVEntries(llp).ExtColData(lECD).vRaw = CLng(-1)
                    Else
                        pps.GetValue uColData(lp).pKey, vrw
                        hr = PropVariantToVariant(vrw, vbrw)
                        If hr = S_OK Then
                            LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                        End If
                    End If
                End Select
        End If
    '    DebugAppend "SetData " & LVEntries(llp).sName & "(" & j & ")->" & LVEntries(llp).ExtColData(lECD).sDisp
        If bCacheOnly = False Then
            lvi.iItem = lIdx
            lvi.iSubItem = j
            Call SendMessage(hLVS, LVM_SETITEMW, 0&, lvi)
        End If
    nxtcol:
    Next j
    Set pps = Nothing
    Set isi = Nothing
    Exit Sub
    e1:
        DebugAppend "LVPopulateColsForItem->Error in column loop: " & Err.Description & ", 0x" & Hex$(Err.Number)
        GoTo nxtcol
    e0:
        DebugAppend "LVPopulateColsForItem->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Sub
    
    Private Function LVGetPropCache(llp As LongPtr, lProp As Long) As String
    
    Select Case lProp
    
        Case lDefColIdx(1)
                LVGetPropCache = LVEntries(llp).sSize
        Case lDefColIdx(2)
                LVGetPropCache = LVEntries(llp).sType
        Case lDefColIdx(3)
                LVGetPropCache = LVEntries(llp).sDateM
        Case lDefColIdx(4)
                LVGetPropCache = LVEntries(llp).sDateC
        Case lDefColIdx(5)
                LVGetPropCache = LVEntries(llp).sDateA
        Case Else
            If llp <> stcIdx Then
                stcIdx = llp
                Set stcPst = Nothing
                    Dim isi As IShellItem2
                    Dim pidlFQItem As LongPtr
                    SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                    If (isi Is Nothing) Then
                        DebugAppend "LVGetPropCache->Failed to get isi"
                        pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                        SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                        If (isi Is Nothing) Then
                            DebugAppend "LVGetPropCache->Alternate isi creation failed"
                        End If
                        If pidlFQItem Then CoTaskMemFree pidlFQItem
                    End If
                    isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, stcPst
             End If
             If (stcPst Is Nothing) = False Then
                LVGetPropCache = GetPropertyKeyDisplayString(stcPst, uColData(lProp).pKey)
             End If
    End Select
    End Function
    
    Private Function LVGetEntryIndexByItem(siItem As IShellItem) As Long
    Dim lCnt As Long
    Dim i As Long
    Dim lp As LongPtr
    Dim sName As String
    Dim sFull As String
    
    LVGetEntryIndexByItem = -1
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then Exit Function
    sFull = GetShellItemFileName(siItem, SIGDN_DESKTOPABSOLUTEPARSING)
    If Len(sFull) <= Len(m_sCurPath) Then
        DebugAppend "LVGetEntry item==curpath,failing"
        Exit Function
    End If
    sName = GetShellItemFileName(siItem, SIGDN_PARENTRELATIVEPARSING)
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        If LVEntries(lp).sNameFull = sName Then
            LVGetEntryIndexByItem = i
            Exit Function
        End If
    Next
    End Function
    
    Private Sub LVRemoveEntry(siItem As IShellItem)
    Dim lCnt As Long
    Dim i As Long
    Dim sName As String
    Dim lp As LongPtr
    Dim lpn As LongPtr
    Dim bMatch As Boolean
    On Error GoTo e0
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then Exit Sub
    
    sName = GetShellItemFileName(siItem, SIGDN_DESKTOPABSOLUTEPARSING)
    If sName = "" Then
        siItem.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpn
        sName = LPWSTRtoStr(lpn)
    End If
    If sName = "" Then
        siItem.GetDisplayName SIGDN_FILESYSPATH, lpn
        sName = LPWSTRtoStr(lpn)
    End If
    DebugAppend "LVRemoveEntry " & sName
    For i = 0 To (lCnt - 1)
        bMatch = False
        lp = GetLVItemlParam(hLVS, i)
        If LVEntries(lp).sFullDAPRaw <> "" Then
            'If we have a path created by the exact same, use it
            If LVEntries(lp).sFullDAPRaw = sName Then
                bMatch = True: GoTo match
            End If
        End If
        If LVEntries(lp).sFullPath = sName Then
            bMatch = True: GoTo match
        End If
        
    match:
        If bMatch Then
    '        DebugAppend "LVRemoveEntry matched item " & i & ",idx=" & lp
            LVEntries(lp).bDeleted = True
            SendMessage hLVS, LVM_DELETEITEM, i, ByVal 0&
            m_CurSize = m_CurSize - LVEntries(lp).cSize
            If LVEntries(lp).bFolder Then
                nCurFolders = nCurFolders - 1
            Else
                nCurFiles = nCurFiles - 1
            End If
            UpdateStatusSize
            If m_GroupMode <> SBGB_None Then GroupUpdateAllFooters hLVS
            Exit Sub
        End If
    Next
    RaiseEvent ItemRemoved(sName)
    Exit Sub
    e0:
        DebugAppend "LVRemoveEntry.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub LVRenameEntry(siItem1 As IShellItem, siItem2 As IShellItem, Optional pidl1 As LongPtr = 0, Optional pidl2 As LongPtr = 0)
    Dim sNew As String, sNewFull As String
    Dim lCnt As Long
    Dim i As Long
    Dim sName As String
    Dim lp As LongPtr
    Dim lvi As LVITEM
    Dim sNP As String
    Dim sExt As String
    Dim nIcon As Long
    Dim qss1 As Boolean, qss2 As Boolean
    Dim lIdx As Long
    
    On Error GoTo e0
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then Exit Sub
    sName = GetShellItemFileName(siItem1, SIGDN_PARENTRELATIVEPARSING)
    sNew = GetShellItemFileName(siItem2, SIGDN_NORMALDISPLAY)
    sNewFull = GetShellItemFileName(siItem2, SIGDN_PARENTRELATIVEPARSING)
    sNP = GetShellItemFileName(siItem2, SIGDN_DESKTOPABSOLUTEPARSING)
    DebugAppend "LVRenameEntry " & sName & " to " & sNew
    
    Dim lAtr2 As SFGAO_Flags
    siItem2.GetAttributes SFGAO_CAPABILITYMASK Or SFGAO_CONTENTSMASK Or SFGAO_DISPLAYATTRMASK Or SFGAO_STORAGECAPMASK, lAtr2
    
    If m_BrowseZip Then
        If (lAtr2 And SFGAO_FOLDER) = SFGAO_FOLDER Then
            qss1 = QueryShowFolder(sName, m_sCurPath)
            qss2 = QueryShowFolder(sNew, m_sCurPath)
        Else
            qss1 = QueryShowFile(sName, m_sCurPath)
            qss2 = QueryShowFile(sNew, m_sCurPath)
        End If
    Else
        If ((lAtr2 And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr2 And SFGAO_STREAM) = 0) Then
            qss1 = QueryShowFolder(sName, m_sCurPath)
            qss2 = QueryShowFolder(sNew, m_sCurPath)
        Else
            If Right$(sNew, 11) = ".library-ms" Then
                qss1 = QueryShowFolder(sName, m_sCurPath)
                qss2 = QueryShowFolder(sNew, m_sCurPath)
            Else
                qss1 = QueryShowFile(sName, m_sCurPath)
                qss2 = QueryShowFile(sNew, m_sCurPath)
            End If
        End If
    End If
    If (qss2 = True) And (qss1 = False) Then
        'We have a situation. An item is being renamed that did not previously match the filters, so wouldn't be present
        'in the list, but its new name *does* match the filters. So, we'll need to instead add it as a new item.
        If bInsertNewFilterMatches Then
            DebugAppend "Item rename of previously non-matching item being diverted to LVAddEntry..."
            lIdx = LVAddEntry(siItem2)
            If lIdx <> -1 Then
                LVPopulateColsForItem lIdx, True
            End If
            Exit Sub
        End If
    End If
    If (qss2 = False) Then
        'The item no longer matches and should be removed.
        If bRemoveNewFilteredItem Then
            DebugAppend sName & " was renamed to " & sNew & ", which no longer matches the filter. Removing..."
            If bRNf Then 'We renamed it. ListView will have new name
                LVRemoveEntry siItem2
            Else
                LVRemoveEntry siItem1 'Another program renamed it, we'll still have the old name.
            End If
            Exit Sub
        End If
    End If
    
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        If LVEntries(lp).sNameFull = sName Then
            lvi.Mask = LVIF_TEXT
            lvi.iItem = i
            With LVEntries(lp)
                .sName = sNew
                .sNameFull = sNewFull
                .sFullPath = sNP
                lvi.pszText = StrPtr(.sName)
                If .bFolder = False Then
                    sExt = Right$(sNP, Len(sNP) - (InStrRev(sNP, ".") - 1))
                    If sExt <> .sExt Then
                        .sExt = sExt
                        .sType = GetShellItemPropString(siItem2, PKEY_ItemTypeText)
                            DebugAppend .sType
                            Dim lpIcon As Long
                        If (bUsedHPFforCD = True) Or (m_IconPreload = False) Then
                            lpIcon = I_IMAGECALLBACK
                        Else
                            Dim upi As IParentAndItem
                            Set upi = siItem2
                            Dim psf As IShellFolder
                            Dim pidlPar As LongPtr, pidlRel As LongPtr
                            upi.GetParentAndItem pidlPar, psf, pidlRel
                            Dim pUnk As IUnknownUnrestricted
                            Dim pIcon As IShellIcon
                            Dim hr As Long
        '                    nIcon = GetFileIconIndexPIDL(pidl2, SHGFI_SMALLICON)
                            Set pUnk = psf
                            hr = pUnk.QueryInterface(IID_IShellIcon, pIcon)
                '            DebugAppend "QueryInterface=0x" & Hex$(hr)
                            If hr = S_OK Then
                                pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
                            Else
                                Dim pidlcb As LongPtr
                                pidlcb = ILCombine(pidlPar, pidlRel)
                                lpIcon = GetFileIconIndexPIDL(pidlcb, SHGFI_SMALLICON)
                                CoTaskMemFree pidlcb
                            End If
                        End If
    '                    If nIcon <> .nIcon Then
                            .nIcon = lpIcon
                            If bThumbsActive = False Then
                                lvi.Mask = lvi.Mask Or LVIF_IMAGE
                                lvi.iImage = lpIcon
                            End If
    '                    End If
                    End If
                End If
            End With
            Call SendMessage(hLVS, LVM_SETITEMW, 0&, lvi)
            LVPopulateColsForItem CLng(lp), True
            
            Exit Sub
        End If
    Next
    Exit Sub
    e0:
        DebugAppend "LVRenameEntry.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub LVMoveItem(hLiVw As LongPtr, lItem As Long, lNewPos As Long)
    Dim lslp As Long
    Dim lcs As Long
    lslp = CLng(GetLVItemlParam(hLiVw, lItem))
    lcs = ListView_GetCheckState(hLiVw, lItem)
    SendMessage hLiVw, LVM_DELETEITEM, lItem, ByVal 0&
    Dim lNew As Long
    DebugAppend "LVMoveItem " & lslp & "=" & uColData(lslp).szDisplayName & "->" & uColData(lslp).szSystemName
    lNew = InsertLVColItem(uColData(lslp).szDisplayName, lslp, , uColData(lslp).szSystemName, lNewPos)
    If lcs = 1 Then
        ListView_SetCheckState hLiVw, lNew, 1
    End If
    ListView_SetSelectedItem hLiVw, lNew
    SendMessage hLiVw, LVM_ENSUREVISIBLE, 0&, ByVal 0&
    End Sub
    
    Private Sub AddParentsToLVItms(si As IShellItem) ', pidlFQ As Long)
    'Adds the parent folders
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim i As Long, j As Long
    Dim lid As Long
    Dim sTmp As String
    Dim siPar As IShellItem
    Dim sPath As String, lpPath As LongPtr
    Dim siItm As IShellItem
    Dim pidlPar As LongPtr
    
    If (m_ViewMode <> SB_VIEW_DETAILS) And (bShowParentItemsInAllViews = False) Then Exit Sub
    
    'bFlagNoIndent = True
    si.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
    sPath = LPWSTRtoStr(lpPath)
    DebugAppend "AddParentsToLVItms first add=" & sPath
    
    lid = LVComputeIndent(sPath)
                 If (m_CompAsRoot = True) And (sPath = sComp) Then
                    Exit Sub
    '            ElseIf (m_CompAsRoot = True) And (lid > 0) Then
    '                lid = lid + 1
                End If
    'lid = lid - 1
    DebugAppend "AddParentsToLVItms init indent=" & lid
    
    LVAddEntry si, , 0, , lid
     
    '
    
    If (si Is Nothing) Then
        DebugAppend "APTL::si disappeared!"
    End If
    
    si.GetParent siPar
    If (siPar Is Nothing) Then
        DebugAppend "APTL::Nothing"
    End If
    
    Do While ((siPar Is Nothing) = False)
        lid = lid - 1
        If lid = -1 Then Exit Do
        sPath = ""
        siPar.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
        sPath = LPWSTRtoStr(lpPath)
        DebugAppend "APTL: lid=" & lid & ",path=" & sPath
        LVAddEntry siPar, , 0, , lid
        siPar.GetParent siItm
        If (siItm Is Nothing) Then
            Set siPar = Nothing
        Else
            Set siPar = siItm
        End If
        
        If (mCustomRoot <> "") And (sPath = mCustomRoot) Then Exit Do
    Loop
    bFlagNoIndent = False
    '<EhFooter>
    Exit Sub
    
    e0:
        bFlagNoIndent = False
        DebugAppend "ucShellBrowse.AddParentsToLVItms->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
        DebugAppend "wat"
        
    '</EhFooter>
    End Sub
    
    Private Sub ExpandNames()
    'Expands the names reduced for group view/small icon
    Dim i As Long
    Dim lvi As LVITEM
    Dim nCt As Long
    
    nCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    For i = 0 To (nCt - 1)
        lvi.Mask = LVIF_TEXT
        lvi.iItem = i
        lvi.pszText = LPSTR_TEXTCALLBACKW
        SendMessage hLVS, LVM_SETITEMW, 0&, lvi
    Next i
    End Sub
    Private Sub ExpandNamesEx()
    'Expands the names reduced for group view/small icon
    Dim i As Long
    Dim lvi As LVITEM
    Dim nCt As Long
    Dim lp As LongPtr
    
    nCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    For i = 0 To (nCt - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.Mask = LVIF_TEXT
        lvi.iItem = i
        lvi.pszText = StrPtr(LVEntries(lp).sName)
        SendMessage hLVS, LVM_SETITEMW, 0&, lvi
    Next i
    End Sub
    Private Function ReduceNameDT(sName As String, cx As Long) As String
    Dim lcn As Long
    Dim lTtl As Long
    Dim lfc As Long
    Dim sTst As String
    Dim sChk As String
    sTst = sName
    lTtl = pbDetailPane.TextWidth(sName)
    If (lTtl) < cx Then
        ReduceNameDT = sName
        Exit Function
    End If
    lfc = 1
    Do
        sTst = Left$(sName, lfc) & "... "
        sChk = sTst
        lTtl = pbDetailPane.TextWidth(sChk)
        lfc = lfc + 1
    Loop While (lTtl) < cx
    
    ReduceNameDT = sTst
    End Function
    Private Function ReduceName(sName As String, cx As Long) As String
    Dim lcn As Long
    Dim lTtl As Long
    Dim lfc As Long
    Dim sTst As String
    Dim sChk As String
    sTst = sName & " XX"
    lTtl = CLng(SendMessage(hLVS, LVM_GETSTRINGWIDTHW, 0&, ByVal StrPtr(sTst)))
    If (lTtl + (16 * m_ScaleX) + (10 * m_ScaleX)) < cx Then
        ReduceName = sName
        Exit Function
    End If
    lfc = 1
    Do
        sTst = Left$(sName, lfc) & "..."
        sChk = sTst & " XX"
        lTtl = CLng(SendMessage(hLVS, LVM_GETSTRINGWIDTHW, 0&, ByVal StrPtr(sChk)))
        lfc = lfc + 1
    Loop While (lTtl + (16 * m_ScaleX) + (10 * m_ScaleX)) < cx
    
    ReduceName = sTst
    End Function
    Private Function InsertListItem(tItem As UCSBFile, Optional iForcePos As Long = -1, Optional bUseOvrIdx As Boolean = False, Optional bLoadAsSample As Boolean = False) As Long
    'bLoadAsSample sets the most common columns since we don't run a full column populate routine in the IDE Design Mode.
    Dim lvi As LVITEM
    Dim lIdx As Long
    Dim lCnt As Long
    
    
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    lvi.Mask = LVIF_IMAGE Or LVIF_TEXT Or LVIF_PARAM Or LVIF_STATE
    
    If iForcePos = -1 Then
        lvi.iItem = lCnt
    Else
        lvi.iItem = iForcePos
    End If
    lvi.iImage = tItem.nIcon
    lvi.lParam = tItem.lParam
    Dim sNx As String
    sNx = tItem.sName
    If bInGVSI Then
    If bEnableFixForGVSMICON = True Then
        sNx = ReduceName(sNx, cxSmallIconColumnWidth * m_ScaleX)
        LVEntries(tItem.lParam).sNameReduced = sNx
    End If
    End If
    
    lvi.cchTextMax = Len(sNx) '+ 1
    lvi.pszText = StrPtr(sNx)
    If (tItem.nOverlay > 0) Then
        lvi.StateMask = LVIS_OVERLAYMASK
        If bUseOvrIdx Then
            lvi.State = INDEXTOOVERLAYMASK(tItem.nOverlayIdx)
        Else
            lvi.State = INDEXTOOVERLAYMASK(tItem.nOverlay)
        End If
    End If
    If ((tItem.dwAttrib And SFGAO_HIDDEN) = SFGAO_HIDDEN) Or ((tItem.dwAttrib And SFGAO_GHOSTED) = SFGAO_GHOSTED) Then
        lvi.State = lvi.State Or LVIS_CUT
        lvi.StateMask = lvi.StateMask Or LVIS_CUT
    End If
    If bGV Then
        lvi.Mask = lvi.Mask Or LVIF_GROUPID
        lvi.iGroupId = tItem.iGrp
    End If
    If tItem.lIndent > 0& Then
        lvi.Mask = lvi.Mask Or LVIF_INDENT
        lvi.iIndent = tItem.lIndent
    End If
    
    ''Possible future work: Customize which columns items show in tile view
    'lvi.Mask = lvi.Mask Or LVIF_COLFMT 'Or LVIF_COLUMNS
    'mCurCols = Header_GetItemCount(hLVSHdr)
    '
    'Dim lCol() As Long
    'ReDim lCol(mCurCols - 1)
    'Dim lFmt() As ucsb_LVCOLUMN_fmt
    'ReDim lFmt(mCurCols - 1)
    ''j = 1
    'Dim i As Long
    'For i = 0 To UBound(lFmt)
    ''    lCol(i) = j
    '    lFmt(i) = LVCFMT_WRAP
    ''    j = j + 1
    'Next i
    'If tItem.bFolder Then
    '    lCol(0) = 2
    '    lCol(1) = 1
    'End If
    
    'lvi.cColumns = mCurCols
    'lvi.puColumns = VarPtr(lCol(0))
    'lvi.piColFmt = VarPtr(lFmt(0))
    
    lIdx = CLng(SendMessage(hLVS, LVM_INSERTITEMW, 0&, lvi))
    tItem.dwID = CLng(SendMessage(hLVS, LVM_MAPINDEXTOID, lIdx, ByVal 0&))
    'DebugAppend "InsertListItem(" & CStr(lIdx) & ")->Disp=" & tItem.sName & ",grp=" & tItem.iGrp & "[bGV=" & CStr(bGV) & "],size=" & tItem.sSize & ",icon=" & tItem.nIcon
    
    'If you explore the above, don't also call these:
    If m_ViewMode = SB_VIEW_TILE Then
        SetSingleTileInfo hLVS, lIdx
    ElseIf m_ViewMode = SB_VIEW_CONTENTS Then
        SetSingleTileInfoEx hLVS, lIdx
    End If
    
    If bLoadAsSample = True Then
        Dim hilp As LongPtr
        Dim hct As Long
        Dim szSet As String
        Dim k As Long
        Dim lvcl As LVCOLUMN
        hct = Header_GetItemCount(hLVSHdr)
        For k = 1 To hct 'Name is column 0 and will already be set
            hilp = GetHDItemlParam(hLVSHdr, k)
            Select Case uColData(hilp).szSystemName
                Case "System.ItemTypeText": szSet = tItem.sType
                Case "System.DateModified": szSet = tItem.sDateM
                Case "System.Size": szSet = tItem.sSize
                Case Else: GoTo nxt
            End Select
            ZeroMemory ByVal VarPtr(lvi), LenB(lvi)
            lvi.Mask = LVIF_TEXT
            lvi.iItem = lIdx
            lvi.pszText = StrPtr(szSet)
            lvi.iSubItem = k
            If uColData(hilp).szSystemName = "System.Size" Then
                lvcl.fmt = LVCFMT_RIGHT
                lvcl.Mask = LVCF_FMT
                SendMessageW hLVS, LVM_SETCOLUMNW, k, lvcl
            End If
            Call SendMessageW(hLVS, LVM_SETITEMW, 0&, lvi)
    nxt:
        Next k
    End If
    
    InsertListItem = lIdx
    
    End Function
    
    Private Sub LVCutSelected()
    Dim i As Long
    Dim lp As LongPtr
    Dim nSel As Long, nCt As Long
    nCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    nSel = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    If nSel = 0 Then Exit Sub
    
    'undo any previous cut of files still present; hidden items share the same flag for ghosting; don't unghost those
    For i = 0 To (nCt - 1)
        lp = GetLVItemlParam(hLVS, i)
        If (LVEntries(lp).bCut = True) And ((LVEntries(lp).dwAttrib And SFGAO_HIDDEN) = 0&) Then
            ListView_SetItemState hLVS, i, 0&, LVIS_CUT
            LVEntries(lp).bCut = False
        End If
    Next i
    
    i = LVI_NOITEM
    Do
        i = CLng(SendMessage(hLVS, LVM_GETNEXTITEM, i, ByVal LVNI_SELECTED))
        If (i <> LVI_NOITEM) Then
            lp = GetLVItemlParam(hLVS, i)
            LVEntries(lp).bCut = True
            ListView_SetItemState hLVS, i, LVIS_CUT, LVIS_CUT
        End If
    Loop Until (i = LVI_NOITEM)
            
    End Sub
    
    Private Sub LVDoPaste(Optional bForceBk As Boolean = False)
    'Handle a paste command
    If mEnablePaste = False Then Exit Sub
    Dim pdo As IDataObject
    Dim lEfct As DROPEFFECTS
    Dim siDrop As IShellItem
    On Error GoTo e0
    OleGetClipboard pdo
    If (pdo Is Nothing) Then Exit Sub
    If DataObjSupportsFormat(pdo, CF_HDROP) Then 'clipboard has files for us
        If GetPreferredEffect(pdo) = DROPEFFECT_MOVE Then
            DebugAppend "Paste as move"
            lEfct = DROPEFFECT_MOVE
        Else
            lEfct = DROPEFFECT_COPY
        End If
        If ((siFocus Is Nothing) = False) And (bForceBk = False) Then
            Dim lAtr As SFGAO_Flags
            siFocus.GetAttributes SFGAO_FOLDER, lAtr
            If (lAtr And SFGAO_FOLDER) = SFGAO_FOLDER Then
                Set siDrop = siFocus
            End If
        End If
        If (siDrop Is Nothing) Then
            Set siDrop = siCurPath
        End If
        Dim pDT As IDropTarget
        siDrop.BindToHandler 0&, BHID_SFUIObject, IID_IDropTarget, pDT
        If (pDT Is Nothing) = False Then
            Dim lpName As LongPtr
            siDrop.GetDisplayName SIGDN_NORMALDISPLAY, lpName
            DebugAppend "Go for paste on " & LPWSTRtoStr(lpName)
            pDT.DragEnter pdo, MK_LBUTTON, 0^, lEfct
            pDT.Drop pdo, MK_LBUTTON, 0^, lEfct
        Else
            If mPlaySnd Then
                If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
            End If
            DebugAppend "Fail DropTarget"
        End If
     
    End If
    Exit Sub
    e0:
        DebugAppend "LVDoPaste.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub LVSetExplSel(bOn As Boolean)
    On Error GoTo LVSetExplSel_Err
    Dim pILV As IListView
    
    SendMessage hLVS, LVM_QUERYINTERFACE, VarPtr(IID_IListView), pILV
    If (pILV Is Nothing) = False Then
        pILV.SetSelectionFlags 1, IIf(bOn, 1&, 0&)
    Else
        DebugAppend "LVSetExplSel::Failed to get IListView"
    End If
    
    Exit Sub
    
    LVSetExplSel_Err:
        DebugAppend "LVSetExplSel.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    Private Sub LVSelectAll()
    Dim nmlv As NMLISTVIEW
    
    bHoldSS = True
    ListView_SelectAll hLVS
    bHoldSS = False
    LVSetSelection
    nmlv.uOldState = LVIS_SELECTED
    
    LVProcItemChange nmlv
    End Sub
    
    Private Sub LVInvertSel()
    Dim i As Long
    Dim mx As Long
    
    mx = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    For i = 0 To (mx - 1)
        If ListView_GetItemState(hLVS, i, LVIS_SELECTED) = LVIS_SELECTED Then
            ListView_SetItemState hLVS, i, 0, LVIS_SELECTED
        Else
            ListView_SetItemState hLVS, i, LVIS_SELECTED, LVIS_SELECTED
        End If
    Next i
            
    End Sub
    
    Public Sub ListViewSetFontByHandle(hFont As LongPtr, Optional hFontHeader As LongPtr = -1&)
    'The ListView normally inherits the control's master font. You can set it independently here.
    'Specify a separate font to apply to the column header otherwise it's set to the same
    'Leave at -1 to not set it at all
    Call SendMessage(hLVS, WM_SETFONT, hFont, ByVal 1&)
    hFontLVMain = hFont
    If hFontHeader <> -1& Then
        hFontLVHdrMain = hFontHeader
        Call SendMessage(hLVSHdr, WM_SETFONT, hFontHeader, ByVal 1&)
    End If
    End Sub
    Public Sub ListViewSetFontOLE(oFont As StdFont, Optional nApplyScaling As Integer = 1, Optional oFontHdr As StdFont)
    'nApplyScaling is whether to use the same scaling factor applied in the main Font Property Set
    '0=Do not apply, 1=Apply if FontScaleForDPI option is True, 2=Apply always
    Dim uFont As IFont
    Set uFont = oFont
    If (nApplyScaling = 2) Or ((nApplyScaling = 1) And (m_FontScaleCXY = True)) Then
        uFont.SetRatio 96 * m_ScaleX, 2540
    End If
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(uFont.hFont), LenB(lftmp), lftmp
    hFontLVMain = CreateFontIndirectW(lftmp)
    Call SendMessage(hLVS, WM_SETFONT, hFontLVMain, ByVal 1&)
    If (oFontHdr Is Nothing) = False Then
        Dim uFont2 As IFont
        Set uFont2 = oFontHdr
        If (nApplyScaling = 2) Or ((nApplyScaling = 1) And (m_FontScaleCXY = True)) Then
            uFont2.SetRatio 96 * m_ScaleX, 2540
        End If
        Dim lftmp2 As LOGFONTW
        GetObjectW CLngPtr(uFont2.hFont), LenB(lftmp2), lftmp2
        hFontLVHdrMain = CreateFontIndirectW(lftmp2)
        Call SendMessage(hLVSHdr, WM_SETFONT, hFontLVHdrMain, ByVal 1&)
    End If
    End Sub
    
    Public Sub ComboSetFontByHandle(hFont As LongPtr)
    'Set independent font for the directory dropdown
    Call SendMessage(hCombo, WM_SETFONT, hFont, ByVal 1&)
    hFontDropdown = hFont
    End Sub
    Public Sub ComboSetFontOLE(oFont As StdFont, Optional nApplyScaling As Integer = 1)
    'nApplyScaling is whether to use the same scaling factor applied in the main Font Property Set
    '0=Do not apply, 1=Apply if FontScaleForDPI option is True, 2=Apply always
    Dim uFont As IFont
    Set uFont = oFont
    If (nApplyScaling = 2) Or ((nApplyScaling = 1) And (m_FontScaleCXY = True)) Then
        Set uFont = oFont
        uFont.SetRatio 96 * m_ScaleX, 2540
    End If
    Dim lftmp As LOGFONTW
    GetObjectW CLngPtr(uFont.hFont), LenB(lftmp), lftmp
    hFontDropdown = CreateFontIndirectW(lftmp)
    Call SendMessage(hCombo, WM_SETFONT, hFontDropdown, ByVal 1&)
    End Sub
    
    Private Sub DoNewFolder()
    'Creates a new folder by determining the name, creating the file, loading it as a new ListView item like LVLoadFolder,
    'then initiating a label edit on it
    Dim sPar As String
    Dim idx As Long
    Dim sFull As String
    Dim siItem As IShellItem
    Dim nli As Long
    
    sPar = m_sCurPath
    DebugAppend "DoNewFolder->m_sCurPath=" & sPar
    sFull = UniqueNameInSeq(AddBackslash(m_sCurPath) & "New folder")
    DebugAppend "DoNewFolder->Will create " & sFull
    Dim tSA As SECURITY_ATTRIBUTES
    With tSA
      .nLength = LenB(tSA)
      .lpSecurityDescriptor = 0
      .bInheritHandle = 1
    End With
    CreateDirectoryExW StrPtr(m_sCurPath), StrPtr(sFull), tSA
    
    If UBound(LVEntries) = 0 Then
        If LVEntries(0).sName <> "" Then idx = 1
    Else
        idx = UBound(LVEntries) + 1
    End If
    SHCreateItemFromParsingName StrPtr(sFull), Nothing, IID_IShellItem, siItem
    If (siItem Is Nothing) = False Then
        nli = LVAddEntry(siItem)
        DebugAppend "nli=" & nli
        bFlagNewFldr = True
        SetFocusAPI hLVS
        SendMessage hLVS, LVM_ENSUREVISIBLE, nli, ByVal 1&
        Call SendMessage(hLVS, LVM_EDITLABELW, nli, ByVal 0&)
        
    End If
    
        
    End Sub
    
    Private Function SupportsDropByIdx(idx As LongPtr) As Long
    If idx < 0 Then Exit Function
    
    If LVEntries(idx).lDropTarget > 0 Then 'This info is cached.
        If LVEntries(idx).lDropTarget > 1 Then
            SupportsDropByIdx = 1
        End If
        Exit Function 'If it's 1, False is already the default return
    Else
        Dim pDT As IDropTarget
        If LVEntries(idx).bZip Then
            LVEntries(idx).lDropTarget = 3
            SupportsDropByIdx = 1
            DebugAppend LVEntries(idx).sName & " supports drop because is zip"
            Exit Function
        End If
        If LVEntries(idx).bLink = True Then
            Dim sTgt As String, lpTgt As LongPtr
            Dim pidl As LongPtr
            Dim siLink As IShellItem, si2Link As IShellItem2
            If LVEntries(idx).pidlRel Then
                If (psfCur Is Nothing) = False Then
                    SHCreateShellItem 0&, ObjPtr(psfCur), LVEntries(idx).pidlRel, siLink
                End If
                If (siLink Is Nothing) Then
                    DebugAppend "SIDBI CSI with psfCur and pidlRel failed"
                    SHCreateShellItem pidlFQCur, 0&, LVEntries(idx).pidlRel, siLink
                    If (siLink Is Nothing) Then
                        DebugAppend "SIDBI CSI with pidlFQ and pidlRel failed"
                        pidl = ILCombine(pidlFQCur, LVEntries(idx).pidlRel)
                        SHCreateItemFromIDList pidl, IID_IShellItem, siLink
                        CoTaskMemFree pidl
                    End If
                End If
            Else
                SHCreateItemFromParsingName StrPtr(LVEntries(idx).sFullPath), Nothing, IID_IShellItem, siLink
            End If
            If (siLink Is Nothing) = False Then
                Set si2Link = siLink
               si2Link.GetString PKEY_Link_TargetExtension, lpTgt
               sTgt = LPWSTRtoStr(lpTgt)
               If sTgt <> "" Then
                If Left$(sTgt, 1) = "." Then
                    sTgt = Mid$(sTgt, 2)
                End If
                sTgt = LCase$(sTgt)
                If ExtIsExe(sTgt) Then
                    LVEntries(idx).lDropTarget = 3
                    SupportsDropByIdx = 1
                    LVEntries(idx).bLinkExe = True
                    Exit Function
                End If
             End If
            End If
        End If
        If (LVEntries(idx).bLink = True) And (LVEntries(idx).bLinkToFolder = False) Then
            LVEntries(idx).lDropTarget = 1
            SupportsDropByIdx = 0
            Exit Function
        End If
        If LVEntries(idx).pidlRel Then
            psfCur.GetUIObjectOf 0&, 1&, LVEntries(idx).pidlRel, IID_IDropTarget, 0&, pDT
            If pDT Is Nothing Then
                LVEntries(idx).lDropTarget = 1
                DebugAppend LVEntries(idx).sName & " FAILED TO GET DROPTARGET"
            Else
                DebugAppend LVEntries(idx).sName & " GOT DROPTARGET"
                If (LVEntries(idx).bFolder = True) Then
                    LVEntries(idx).lDropTarget = 2
                Else
                    LVEntries(idx).lDropTarget = 3
                End If
                SupportsDropByIdx = 1
            End If
        End If
    End If
    End Function
    
    Private Function UniqueNameInSeq(ByRef sPath As String) As String
    Dim sBuf As String
    
    SysReAllocStringLen VarPtr(sBuf), , MAX_PATH
    
    If PathYetAnotherMakeUniqueName(StrPtr(sBuf), StrPtr(sPath)) Then
        UniqueNameInSeq = Left$(sBuf, lstrlenW(StrPtr(sBuf)))
    End If
    End Function
    
    Private Sub ShowPreviewForFile(isi As IShellItem, hWnd As LongPtr, rc As RECT, objpic As Object, Optional sFileIn As String = "")
    DebugAppend "ShowPreviewForFile::Entry, previewing " & tSelectedFile.sName
    Dim iif As IInitializeWithFile
    Dim iis As IInitializeWithStream
    Dim iisi As IInitializeWithItem
    Dim pUnk As IUnknownUnrestricted
    Dim hr As Long
    Dim sFile As String, sExt As String
    Dim lp As LongPtr
    Dim tHandler As UUID
    Dim hbm As LongPtr
    On Error GoTo e0
    objpic.Cls
    If (isi Is Nothing) Then
        DebugAppend "no isi"
        If sFileIn <> "" Then
            sFile = sFileIn
        End If
    Else
        sFile = GetShellItemFileName(isi, SIGDN_DESKTOPABSOLUTEPARSING)
    End If
    
    
    sExt = tSelectedFile.sExt
    If sExt = "" Then
        sFile = GetShellItemFileName(isi, SIGDN_DESKTOPABSOLUTEPARSING)
    'sFile = GetShellItemPropString(isi, PKEY_ParsingName)
        If (Len(sFile) > InStr(sFile, "\")) And (InStr(sFile, "\") > 0) Then
            sExt = Right$(sFile, Len(sFile) - InStrRev(sFile, "\"))
            If InStr(sExt, ".") Then
                sExt = Right$(sExt, (Len(sExt) - InStrRev(sExt, ".")) + 1)
            Else
                Exit Sub
            End If
        End If
        If sExt = "" Then Exit Sub
        DebugAppend "ShowPreviewForFile::Used alt file name method to get " & sFile
    End If
    
    If (ipv Is Nothing) = False Then
        Set pPvhVis = Nothing
        ipv.Unload
        Set ipv = Nothing
    End If
    DebugAppend "ShowPreviewForFile::Init cleared"
    
    Dim lPcv As Long
    lPcv = FilePtypeL(sExt)
    If m_PreviewVidThumb Then
        If lPcv = PERCEIVED_TYPE_VIDEO Then
            DebugAppend "ShowPreviewForFile::Load manual static thumb for video."
            DebugAppend "AdvVidThumb"
            hbm = GetFileThumbnail(isi, sFile, 0&, objpic.ScaleWidth, objpic.ScaleHeight)
            objpic.Cls
            hBitmapToPictureBox objpic, hbm
            objpic.Refresh
            GoTo out
        End If
    End If
    
    hr = GetHandlerCLSID(sExt, tHandler)
    If hr = 1 Then
        DebugAppend "Got handler CLSID; attempting to create IPreviewHandler"
        UpdateStatus mLoadPvStr
        If hGlobalPV Then GlobalFree hGlobalPV
        hr = CoCreateInstance(tHandler, 0, CLSCTX_LOCAL_SERVER Or CLSCTX_INPROC_SERVER, IID_IPreviewHandler, ipv)
        If hr <> S_OK Then
            DebugAppend "CoCreateInstance failed, trying alternate args... (hr=0x" & Hex$(hr) & ")"
            hr = CoCreateInstance(tHandler, 0, CLSCTX_LOCAL_SERVER, IID_IPreviewHandler, ipv)
            DebugAppend "LOCAL hr=0x" & Hex$(hr)
            If hr <> S_OK Then
                hr = CoCreateInstance(tHandler, 0, CLSCTX_INPROC_SERVER, IID_IPreviewHandler, ipv)
                DebugAppend "INPROC hr=0x" & Hex$(hr)
            End If
        End If
    
        If (ipv Is Nothing) Then
            DebugAppend "Failed to create IPreviewHandler interface, hr=0x" & Hex$(hr)
            UpdateStatus mPvhLoadFail
            Exit Sub
        End If
        'Set iisi = ipv 'this normally can be used in place of Set pUnk / .QueryInterface, but we need the HRESULT
        Set pUnk = ipv
    '    Set iif = ipv
        Set pUnk = ipv
        If pUnk.QueryInterface(IID_IInitializeWithFile, iif) = S_OK Then
            hr = iif.Initialize(sFile, STGM_READ)
            DebugAppend "ShowPreview::InitWithFile hr=" & hr
            GoTo gpvh
        Else
            DebugAppend "IInitializeWithFile not supported."
        End If
        If pUnk.QueryInterface(IID_IInitializeWithItem, iisi) = S_OK Then
            hr = iisi.Initialize(isi, STGM_READ)
            DebugAppend "ShowPreview::InitWithItem hr=" & hr
            If hr = S_OK Then GoTo gpvh
        Else
            DebugAppend "IInitializeWithItem not supported."
        End If
    
            'use IStream
            Dim hFile As LongPtr
            Dim pStrm As IStream
            Dim lpGlobal As LongPtr
            Dim dwSize As Long
            DebugAppend "Attempting to use IStream"
            hFile = CreateFileW(StrPtr(sFile), FILE_READ_DATA, FILE_SHARE_READ, ByVal 0&, OPEN_EXISTING, 0, 0)
            If (hFile <> INVALID_HANDLE_VALUE) Then
                dwSize = GetFileSize(hFile, ByVal 0&)
                DebugAppend "Got file size=" & dwSize
                If dwSize = 0 Then Exit Sub
                hGlobalPV = GlobalAlloc(GPTR, dwSize)
                lpGlobal = GlobalLock(hGlobalPV)
                If lpGlobal Then
                    Call ReadFile(hFile, ByVal lpGlobal, dwSize, dwSize, ByVal 0&)
                    Call GlobalUnlock(hGlobalPV)
                    Call CreateStreamOnHGlobal(hGlobalPV, 1, pStrm)
    '                Set iis = ipv
                    Set pUnk = ipv
                    hr = pUnk.QueryInterface(IID_IInitializeWithStream, iis)
                    DebugAppend "QI.hr=" & hr
                    If (iis Is Nothing) Then
                        DebugAppend "IInitializeWithStream not supported."
                        Call CloseHandle(hFile)
                        GoTo out
                    Else
                        hr = iis.Initialize(pStrm, STGM_READ)
                    End If
                End If
                
                Call CloseHandle(hFile)
            Else
                DebugAppend "CreateFile failed, attempting to bind stream..."
                If (isi Is Nothing) = False Then
                    isi.BindToHandler 0&, BHID_Stream, IID_IStream, pStrm
                    If (pStrm Is Nothing) = False Then
                        DebugAppend "Created IStream..."
                        Set pUnk = ipv
                        hr = pUnk.QueryInterface(IID_IInitializeWithStream, iis)
                        DebugAppend "QI.hr=" & hr
                        If (iis Is Nothing) = False Then
                            hr = iis.Initialize(pStrm, STGM_READ)
                        End If
                    Else
                        DebugAppend "Shell item BHID_Stream failed to create IStream"
                    End If
                Else
                    DebugAppend "No shell item was available"
                End If
             End If
      
    gpvh:
        hr = ipv.SetWindow(hWnd, rc)
        hr = ipv.DoPreview()
    '    DebugAppend "DoPreview hr=" & hr
        Dim piunk As IUnknownUnrestricted
        Set piunk = ipv
        hr = piunk.QueryInterface(IID_IPreviewHandlerVisuals, pPvhVis)
        If (pPvhVis Is Nothing) = False Then
            DebugAppend "Handler implements IPreviewHandlerVisuals; setting bk color to white"
            pPvhVis.SetBackgroundColor &HFFFFFF
        End If
        isi.GetDisplayName SIGDN_NORMALDISPLAY, lp
        sFile = LPWSTRtoStr(lp)
        UpdateStatus mShowPvStr & sFile
    Else
        'images and videos aren't handled that way normally, so we'll do it another way
        DebugAppend "No registered handler; trying alternate method for images..."
        DebugAppend "Perceived type=" & lPcv
    
        If lPcv = PERCEIVED_TYPE_IMAGE Then
            If Right$(sFile, 4) = ".ico" Then
                'the below methods don't properly render icons transparent
                'so we'll use a different method that does
    '            objpic.Refresh
                'NOTE: The DoIcoPreview method was showing icons a little small; switched it out
                hbm = GetIconThumbnail(isi, sFile, 0, objpic.ScaleWidth, objpic.ScaleHeight)
    '            DebugAppend "hbm=" & hbm
                objpic.Cls
                
                If (hbm <> 0&) Then
                    hBitmapToPictureBox objpic, hbm
                Else
                    If DoIcoPreview(sFile, objpic.hDC, 32) = -1 Then
                        GoTo gfthm
                    End If
                End If
                objpic.Refresh
                UpdateStatus mShowPvStr & sFile
                GoTo out
            Else
    gfthm:
    '            hr = GetFileThumbnail3(isi, objpic.hDC, objpic.ScaleWidth, objpic.ScaleHeight)
                objpic.Refresh
                hr = 1
                If hr <> S_OK Then
                    hbm = 0
                        DebugAppend "Try GFT4"
                    hbm = GetFileThumbnail4(isi, objpic.ScaleWidth, objpic.ScaleHeight, objpic) 'Uses IThumbnailProvider or LocalThumbnailCache
                    If hbm = 0 Then
                        DebugAppend "Try GFT0"
                            hbm = GetFileThumbnail2(isi, sFile, 0, objpic.ScaleWidth, objpic.ScaleHeight) 'Uses IExtractImage
                        If hbm = 0 Then
                            DebugAppend "Try GFT2"
                        hbm = GetFileThumbnail(isi, sFile, 0&, objpic.ScaleWidth, objpic.ScaleHeight) 'Uses IShellItemImageFactory
                        End If
                    End If
    '                   hbm = GetFileThumbnail3(isi, objpic.hDC, objpic.ScaleWidth, objpic.ScaleHeight)
    '                Dim pidlFQ As Long
    '                pidlFQ = ILCombine(pidlFQCur, tSelectedFile.pidlRel)
    '                hbm = GetFileThumbnail2(Nothing, "", pidlFQ, objpic.ScaleWidth, objpic.ScaleHeight)
    '                If pidlFQ Then CoTaskMemFree pidlFQ
                    DebugAppend "hbm=" & hbm
                    If (hbm <> 0) And (hbm <> 1) Then
                        objpic.Cls
                        hBitmapToPictureBox objpic, hbm
                        objpic.Refresh
                    End If
                End If
                UpdateStatus mShowPvStr & sFile
            End If
        Else
            UpdateStatus mPvhNotFoundStr
        
        End If
    End If
    out:
    If hbm Then DeleteObject hbm
    Set iisi = Nothing
    Set iif = Nothing
    Set iis = Nothing
    
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "ShowPreviewForFile.Error->" & Err.Description & " (" & Err.Number & ")"
    End Sub
    
    Public Sub SetPreviewPictureWithStdPic(oPic As StdPicture)
    Set pbPreviewPane.Picture = oPic
    pbPreviewPane.Refresh
    End Sub
    Public Sub SetPreviewPictureWithHBITMAP(hBmp As LongPtr, Optional bDestroy As Boolean = False)
    pbPreviewPane.Cls
    hBitmapToPictureBox pbPreviewPane, hBmp
    pbPreviewPane.Refresh
    If bDestroy Then
        DeleteObject hBmp
    End If
    End Sub
    Public Sub SetPreviewPictureWithHICON(hIcon As LongPtr, cxy As Long, X As Long, Y As Long, Optional bDestroy As Boolean = False)
    If (X = 0) And (Y = 0) Then
        'not manually specified, so center
        If cxy < pbPreviewPane.ScaleHeight Then
            X = ((pbPreviewPane.ScaleWidth - cxy) / 2) '* Screen.TwipsPerPixelX
            Y = ((pbPreviewPane.ScaleHeight - cxy) / 2) '* Screen.TwipsPerPixelY
        End If
    End If
    
    RenderIcon pbPreviewPane.hDC, hIcon, cxy, X, Y
    If bDestroy Then
        DestroyIcon hIcon
    End If
    
    End Sub
    
    Private Sub LVReadAllData()
    Dim lp As LongPtr
    Dim lCt As Long
    Dim i As Long
    UpdateStatus mStrLoadColData
    lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    For i = 0 To (lCt - 1)
        lp = GetLVItemlParam(hLVS, i)
        If LVEntries(lp).ExtColData(0).bSet = False Then
            LVPopulateColsForItem i, , True
        End If
    Next i
    UpdateStatus mReadyStr
    End Sub
    
    Private Sub AnalyzeZip()
    Dim i As Long, j As Long
    DebugAppend "Enumerating Zip Files..."
    For i = 0 To UBound(LVEntries)
        If InStr(LVEntries(i).sName, ".zip") Or LVEntries(i).bFolder = True Then
            DebugAppend LVEntries(i).sName & "->bZip=" & LVEntries(i).bZip & ",bFolder=" & LVEntries(i).bFolder
        End If
    Next i
    
    End Sub
    Private Sub LVColumnClick(iCol As Long)
    Dim dwSort As Long
    Dim lp As Long
    lp = CLng(GetHDItemlParam(hLVSHdr, iCol))
    Dim lSel As Long
    
    bColIsMapped = False
    If mAlwaysSortWithISF = True Then
        If uColData(lp).nMapsTo >= 0& Then
            bColIsMapped = True
            nSFColComp = uColData(lp).nMapsTo
            dwSort = IIf(lSortD, SORT_ASCENDING, 0&)
    '        DebugAppend "ISF Column Map Sort, slow=" & ((uColData(lp).dwColState And SHCOLSTATE_SLOW) = SHCOLSTATE_SLOW) & ", ColDataRaw=0x" & Hex$(uColData(lp).dwColState)
        Else
            GoTo stdsort
        End If
    Else
    stdsort:
    '    DebugAppend "SortBy::" & uColData(lp).szDisplayName & ",disptype=0x" & Hex$(uColData(lp).dwDispType)
        ecdKey = ColCacheIdx(lp, 0)
        If mAlwaysSortWithISF = True Then
            'These first ones used IShellFolder.CompareIDs, which is being deprecated unless specifically
            'enabled with AlwaysSortWithISF, since it doesn't work in Libraries and the new method is faster.
            Select Case lp
                Case lDefColIdx(0): dwSort = eSortName Or (IIf(lSortD, SORT_ASCENDING, 0&))
                Case lDefColIdx(1): dwSort = eSortSize Or (IIf(lSortD, SORT_ASCENDING, 0&))
                Case lDefColIdx(2): dwSort = eSortType Or (IIf(lSortD, SORT_ASCENDING, 0&))
                Case lDefColIdx(3): dwSort = eSortDateM Or (IIf(lSortD, SORT_ASCENDING, 0&))
                Case lDefColIdx(4): dwSort = eSortDateC Or (IIf(lSortD, SORT_ASCENDING, 0&))
                Case lDefColIdx(5): dwSort = eSortDateA Or (IIf(lSortD, SORT_ASCENDING, 0&))
            End Select
        Else
            If uColData(lp).dwDispType = PDDT_DATETIME Then
                dwSort = eSortExtDate Or (IIf(lSortD, SORT_ASCENDING, 0&))
            ElseIf uColData(lp).dwDispType = PDDT_NUMBER Then
                dwSort = eSortExtNum Or (IIf(lSortD, SORT_ASCENDING, 0&))
            Else
                dwSort = eSortText Or (IIf(lSortD, SORT_ASCENDING, 0&))
            End If
            lSortProp = lp
        End If
        lSortK = iCol
    End If
    DebugAppend "DoLVSort lSortD=" & CStr(lSortD) & "::" & CStr(iCol Or (CBool(lSortD) And SORT_DESCENDING))
     
    Dim tt1 As Long, tt2 As Long
    tt1 = GetTickCount()
    If (mExtColPreload = False) And (lp <> lDefColIdx(0)) Then
    'If we're NOT reading data in advance..
        'We need to read all data to sort properly. If preloading is off, only name and size are loaded by default.
        LVReadAllData
    End If
    
    'AnalyzeZip
    
    If m_cbSort = 0& Then
        If mUseAdvancedSort Then
            m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
        Else
            m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
        End If
    End If
    mLastSortInfo = dwSort
    Call SendMessage(hLVS, LVM_SORTITEMS, dwSort, ByVal m_cbSort)
    tt2 = GetTickCount()
    
    DebugAppend "DoLVSort Sort time: " & CStr(tt2 - tt1) & "ms" & " (tt2=" & tt2 & ",tt1=" & tt1 & ")"
    Call SetSortArrowAPI(hLVS, lp, CInt(lSortD))
    If mAutoSelCol Then
        Call SendMessage(hLVS, LVM_SETSELECTEDCOLUMN, iCol, ByVal 0&)
    End If
    DebugAppend "DoLVSort iCol=" & iCol
    
    If bScrollToSelectedAfterSort Then
        lSel = -1&
        lSel = ListView_GetSelectedItem(hLVS)
        If lSel >= 0& Then
            SendMessage hLVS, LVM_ENSUREVISIBLE, lSel, ByVal 0&
        End If
    End If
    
    If lSortD = 1 Then
        lSortD = 0
    Else
        lSortD = 1
    End If
    RaiseEvent SortItems(lSortK, IIf(lSortD, SORT_ASCENDING, SORT_DESCENDING), uColData(lp).szSystemName, uColData(lp).szDisplayName)
    End Sub
    
    Public Function AddCustomColumn(sTitle As String, dwDispType As PROPDESC_DISPLAYTYPE, Optional lPos As Long = -1&, Optional lDefWidth As Long = -1&, Optional bHasImages As Boolean = False, Optional bShowInColumnDialog As Boolean = False) As Long
    Dim idx As Long
    
    idx = UBound(uColData) + 1
    ReDim Preserve uColData(idx)
    uColData(idx).szDisplayName = sTitle
    uColData(idx).szSystemName = mPropCust & CStr(idx)
    uColData(idx).dwDispType = dwDispType
    uColData(idx).bFlagManual = True
    uColData(idx).lManualInsertAt = lPos
    If lDefWidth > 0 Then uColData(idx).DefWidth = lDefWidth
    If bShowInColumnDialog = False Then
        uColData(idx).NoList = True
    End If
    If bHasImages Then
        uColData(idx).bFlagManHasImg = True
        If bSILSet = False Then
            ListView_SetExtendedListViewStyleEx hLVS, LVS_EX_SUBITEMIMAGES, LVS_EX_SUBITEMIMAGES
            bSILSet = True
        End If
    End If
    nAddIdx = idx
    'We need to return the index so the user can respond to data requests; setting an API timer
    'lets this function exit, returning the index, before the column is added and data requested.
    If mColTmrProc = 0& Then mColTmrProc = AddressOf AddColTimerProc ' scb_SetCallbackAddr(4, 18, , , True)
    SetTimer hLVS, WM_USER + 98, 10, mColTmrProc
    AddCustomColumn = idx
    End Function
    Private Sub ExecCustomCol()
    AddColumn uColData(nAddIdx).szSystemName
    End Sub
    Private Sub RedrawLastDetailPane()
    DebugAppend "RedrawLastDetailPane()"
    Select Case nLastDtPaneOp
        Case 0: pvCreateDetailPaneBkg
        Case 1: pvCreateItemDetailPane
        Case 2: pvCreateMultiItemDetailPane
    End Select
    End Sub
    
    Private Sub MIDPSetCount()
    'set multi-item detail pane count out of band of normal update
    'for when selection marquee is active
    If hDetailName = 0& Then Exit Sub
    If nLastDtPaneOp <> 2& Then Exit Sub
    
    Dim lCnt As Long
    lCnt = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    Dim sz As String
    sz = lCnt & " items selected"
    SetWindowTextW hDetailName, StrPtr(sz)
    End Sub
    
    Private Sub pvCreateMultiItemDetailPane()
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    DebugAppend "pvCreateMultiItemDetailPane()", 9
    nLastDtPaneOp = 2&
    bICFlag = False
    Dim upi As IParentAndItem
    Dim pIcon As IShellIcon
    Dim pidlRel As LongPtr, pidlPar As LongPtr
    Dim psf As IShellFolder
    Dim lpIcon As Long
    Dim tDraw As IMAGELISTDRAWPARAMS
    Dim cx As Long, cy As Long
    Dim cxLine As Long
    Dim cxHdr As Long
    Dim cxTyp As Long
    Dim cxNm As Long
    Dim i As Long
    Dim siCur As IShellItem
    Dim pbrc As RECT
    Dim bMultiType As Long
    Dim ullTotalSize As LongLong
    Dim sType As String
    Dim sWrite As String
    Dim tRC As RECT
    Dim sText As String
    Dim sSize As String
    Dim si2Cur As IShellItem2
    Dim vpv As Variant, vbv As Variant
    
        ResetDetailPane
        bDTPaneSingleItemActive = False
    For i = 0 To UBound(sSelectedFiles)
        SHCreateItemFromParsingName StrPtr(sSelectedFiles(i)), Nothing, IID_IShellItem, siCur
        On Error Resume Next
        Set upi = siCur
        upi.GetParentAndItem pidlPar, psf, pidlRel
        Set pIcon = psf
        pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
        If lpIcon < 1 Then
            Dim pil As IPersistIDList
            Set pil = siFocus
            pil.GetIDList pidlPar
            lpIcon = GetFileIconIndexPIDL(pidlPar, SHGFI_SMALLICON)
        End If
        On Error GoTo e0
        Call GetClientRect(pbDetailPane.hWnd, pbrc)
        imlSys32.GetIconSize cx, cy
        tDraw.cbSize = LenB(tDraw)
        cxyDTPaneIcon = pbrc.Bottom - 9
        tDraw.cx = cxyDTPaneIcon: tDraw.cy = cxyDTPaneIcon
        tDraw.fStyle = ILD_TRANSPARENT Or ILD_SCALE
        tDraw.hdcDst = pbDetailPane.hDC
        tDraw.i = lpIcon
        tDraw.x = 5: tDraw.y = 2
        If i < 10 Then
            tDraw.x = tDraw.x + (i * (2 * m_ScaleX))
            tDraw.y = tDraw.y + (i * (2 * m_ScaleY))
        End If
        If cxyDTPaneIcon > cxyLgIcn Then
            imlSysJM.Draw tDraw
        Else
            imlSys32.Draw tDraw
        End If
        If tSelectedFiles(i).sType = "" Then
            tSelectedFiles(i).sType = GetShellItemPropString(siCur, PKEY_ItemTypeText)
        End If
        If tSelectedFiles(i).sSize = "" Then
            Set si2Cur = siCur
            si2Cur.GetProperty PKEY_Size, vpv
            PropVariantToVariant vpv, vbv
            tSelectedFiles(i).cSize = CLngLng(vbv)
        End If
        If i = 0 Then
            sType = tSelectedFiles(i).sType
            ullTotalSize = tSelectedFiles(i).cSize
        Else
            If sType <> tSelectedFiles(i).sType Then
                bMultiType = True
            End If
            ullTotalSize = ullTotalSize + tSelectedFiles(i).cSize
        End If
    Next i
    If bMultiType Then
        sType = "Multiple file types"
    End If
    cxTyp = CLng(pbDetailPane.TextWidth(sType))
    tRC.Left = cxyDTPaneIcon + (20 * m_ScaleX)
    tRC.Top = 6
    tRC.Right = tRC.Left + cxTyp + 1 'trc.Left + 102
    tRC.Bottom = tRC.Top + 18
    
    If cxTyp > 120 Then
        cxHdr = tRC.Left + cxTyp
    Else
        cxHdr = tRC.Left + 120
    End If
    'DebugAppend "cxHdr=" & cxHdr
    
    sText = CStr(UBound(tSelectedFiles) + 1) & " files selected"
    cxNm = pbDetailPane.TextWidth(sText)
    Dim cxCtl As Long, cxOff As Long
    cxCtl = (cxNm * 1.25) + 2
    cxOff = cxCtl + cxyDTPaneIcon + (20 * m_ScaleX)
    'DebugAppend "txtwidth=" & cxNm & ",recalc=" & cxNm * 1.25
    If cxTyp > cxNm Then
        cxHdr = tRC.Left + cxTyp + 8
    Else
        cxHdr = tRC.Left + cxNm + 8
    End If
    'DebugAppend "Before PCP=" & sText
    
        Dim xName As Long, yName As Long
        xName = tRC.Left: yName = tRC.Top
        If hDetailName Then
            DestroyWindow hDetailName
        End If
        hDetailName = CreateWindowExW(0&, StrPtr(WC_STATIC), 0&, WS_CHILD Or WS_VISIBLE, xName, yName, cxCtl, cyDtName * m_ScaleY, pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
        If bDTHSC = False Then
            'If ssc_Subclass(pbDetailPane.hWnd, , 5&, , , True) Then
            '    ssc_AddMsg pbDetailPane.hWnd, MSG_BEFORE, ALL_MESSAGES
                Subclass2 pbDetailPane.hWnd, AddressOf DetailHeaderWndProc, pbDetailPane.hWnd
                bDTHSC = True
            'End If
        End If
        SendMessageW hDetailName, WM_SETFONT, m_hFontDtHdrAlt, ByVal 1&
        SetWindowTextW hDetailName, StrPtr(sText)
    
    
    tRC.Top = tRC.Top + (cyDtName * m_ScaleY) + (3 * m_ScaleY)
    DebugAppend "newbtm=" & tRC.Bottom & "+" & cyDtName * m_ScaleY & "+3"
    tRC.Bottom = tRC.Bottom + (cyDtName * m_ScaleY) + (7 * m_ScaleY)
    
    DrawText pbDetailPane.hDC, StrPtr(sType), -1, tRC, DT_LEFT  'Or DT_CALCRECT
    
    'Draw size
    tRC.Top = 6
    If cxHdr > cxOff Then
        tRC.Left = cxHdr + (6 * m_ScaleX)
    Else
        tRC.Left = cxOff + (6 * m_ScaleX)
    End If
    sSize = String$(MAX_PATH, 0)
    Call StrFormatByteSizeW(ullTotalSize, StrPtr(sSize), MAX_PATH)
    sSize = TrimNullW(sSize)
    sWrite = uColData(lDefColIdx(1)).szDisplayName & ": " & sSize
    tRC.Bottom = CLng(pbDetailPane.TextHeight(sWrite)) + tRC.Top
    
    cxLine = CLng(pbDetailPane.TextWidth(sWrite))
    tRC.Right = tRC.Left + cxLine
    DrawText pbDetailPane.hDC, StrPtr(sWrite), -1, tRC, DT_LEFT
    '<EhFooter>
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.pvCreateMultiItemDetailPane->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Sub pvCreateItemDetailPane()
    'For single item. Call this after LVSetSelection to use siFocus
    If Ambient.UserMode = False Then Exit Sub
    On Error GoTo e0
    'DebugAppend "pvCreateItemDetailPane()", 9
    nLastDtPaneOp = 1&
    bICFlag = False
    
    Dim upi As IParentAndItem
    Dim pIcon As IShellIcon
    Dim pidlRel As LongPtr, pidlPar As LongPtr
    Dim psf As IShellFolder
    Dim lpIcon As Long
    Dim tDraw As IMAGELISTDRAWPARAMS
    Dim cx As Long, cy As Long
    Dim px As Long, py As Long
    Dim cyLine As Long, cxLine As Long
    Dim nPropCount As Long
    Dim cxTyp As Long
    Dim cxNm As Long
    Dim cxCol As Long
    Dim pbrc As RECT
    
    If (siFocus Is Nothing) = False Then
        ResetDetailPane
        bDTPaneSingleItemActive = True
        On Error Resume Next
        Set upi = siFocus
        upi.GetParentAndItem pidlPar, psf, pidlRel
        Set pIcon = psf
        pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
        If lpIcon < 1 Then
            Dim pil As IPersistIDList
            Set pil = siFocus
            pil.GetIDList pidlPar
            lpIcon = GetFileIconIndexPIDL(pidlPar, SHGFI_SMALLICON)
        End If
        On Error GoTo e0
        Call GetClientRect(pbDetailPane.hWnd, pbrc)
    '    DebugAppend "pbh=" & pbrc.Bottom
        imlSys32.GetIconSize cx, cy
        tDraw.cbSize = LenB(tDraw)
        cxyDTPaneIcon = pbrc.Bottom - 9
        If cxyDTPaneIcon > 256 Then cxyDTPaneIcon = 256
        tDraw.cx = cxyDTPaneIcon: tDraw.cy = cxyDTPaneIcon
        tDraw.fStyle = ILD_TRANSPARENT Or ILD_SCALE
        tDraw.hdcDst = pbDetailPane.hDC
        tDraw.i = lpIcon
        tDraw.x = 5: tDraw.y = 2
        If cxyDTPaneIcon > cxyLgIcn Then
            DebugAppend "pvCreateItemDetailPane::RenderIcon->imlSysJM"
            imlSysJM.Draw tDraw
        Else
            DebugAppend "pvCreateItemDetailPane::RenderIcon->imlSys32"
            imlSys32.Draw tDraw
        End If
        
        nPropCount = PopulateDetailColumnsForItem(siFocus) 'fill in tDispProps with the properties to be displayed
                                                           'in the details pane. Explorer supplies a default, or a
                                                           'custom list if the filetype has a property handler
            
        If nPropCount Then
            Dim i As Long, j As Long, k As Long
            Dim cyText As Long
            Dim nRowAvail As Long
            Dim mx As Long
            Dim s3 As String
            cyText = pbDetailPane.TextHeight("|1LT")
            cyLine = cyText + (5 * m_ScaleY)
            nRowAvail = ((pbDetailPane.Height - cmdPropSave.Height) + (3 * m_ScaleY)) \ cyLine
            If (UBound(tDispProps) + 1) < nRowAvail Then
                mx = UBound(tDispProps)
            Else
                mx = nRowAvail - 1
            End If
            For i = 0 To mx
                If tDispProps(i).sOrig = "" Then
                    s3 = tDispProps(i).sInvite
                Else
                    s3 = tDispProps(i).sOrig
                End If
                j = pbDetailPane.TextWidth(tDispProps(i).sDispName & ": ")
                k = pbDetailPane.TextWidth(s3)
                If k > (cxMaxProp * m_ScaleX) Then k = cxMaxProp * m_ScaleX
                If k < (cxMinProp * m_ScaleX) Then k = cxMinProp * m_ScaleX
                j = j + k
                If j > cxCol Then cxCol = j
            Next i
        End If
            
        Dim sText As String
        sText = tSelectedFile.sName
        If tSelectedFile.sType = "" Then
            tSelectedFile.sType = GetShellItemPropString(siFocus, PKEY_ItemTypeText)
            If SelectedFileIndex >= 0& Then
                LVEntries(SelectedFileIndex).sType = tSelectedFile.sType
            End If
        End If
        cxTyp = CLng(pbDetailPane.TextWidth(tSelectedFile.sType & "XX"))
        cyDtName = pbDetailPane.TextHeight(tSelectedFile.sName)
        Dim xs1 As Long, xs2 As Long
        xs2 = cxyDTPaneIcon + 20 + cxTyp
        
        cxNm = pbDetailPane.TextWidth(sText & "XX")
        Dim cxMaster As Long
        If cxTyp > cxNm Then
            cxMaster = cxTyp
        Else
            cxMaster = cxNm
        End If
        Dim cxAvail As Long
        cxAvail = pbDetailPane.Width - (cxyDTPaneIcon + 20)
        
        If ((cxMaster) + (cxCol + (4 * m_ScaleX) + (18 * m_ScaleX))) > cxAvail Then
            If cxMaster > (cxAvail) Then cxMaster = (cxAvail - (4 * m_ScaleX))
        Else
            If cxMaster > (cxAvail * 0.25) Then cxMaster = (cxAvail * 0.25)
        End If
        
        If cxNm > cxTyp Then cxTyp = cxNm
        If cxTyp > cxNm Then cxNm = cxTyp
        Dim tRC As RECT
        tRC.Left = cxyDTPaneIcon + 20
        tRC.Top = 6
        tRC.Right = tRC.Left + cxMaster + 1 'trc.Left + 102
        tRC.Bottom = tRC.Top + (cyDtName + 2) ' 18
        
        Dim xName As Long, yName As Long
        xName = tRC.Left: yName = tRC.Top
        If hDetailName Then
            DestroyWindow hDetailName
        End If
    
        If True Then 'If hDetailName = 0 Then
            If hDetailName Then DestroyWindow hDetailName
            hDetailName = CreateWindowExW(0&, StrPtr(WC_STATIC), 0&, WS_CHILD Or WS_VISIBLE Or SS_ENDELLIPSIS, xName, yName, cxMaster, cyDtName + (2 * m_ScaleY), pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
            If bDTHSC = False Then
                'If ssc_Subclass(pbDetailPane.hWnd, , 5&, , , True, True) Then
                '    ssc_AddMsg pbDetailPane.hWnd, MSG_BEFORE, ALL_MESSAGES
                    Subclass2 pbDetailPane.hWnd, AddressOf DetailHeaderWndProc, pbDetailPane.hWnd
                    bDTHSC = True
                'End If
            End If
            SendMessageW hDetailName, WM_SETFONT, m_hFontDtHdrAlt, ByVal 1&
    
        End If
    
        If InStr(sText, vbNullChar) Then
            sText = Left$(sText, InStr(sText, vbNullChar) - 1)
        End If
    
        SetWindowTextW hDetailName, StrPtr(sText)
       
        tRC.Top = tRC.Top + (cyDtName) + (6 * m_ScaleY)
        tRC.Bottom = tRC.Top + (cyDtName) + (2 * m_ScaleY)
        
        sText = ReduceNameDT(tSelectedFile.sType, cxMaster)
        DrawText pbDetailPane.hDC, StrPtr(sText), -1, tRC, DT_LEFT
        
        'note to self: no need to use entire different method for read-only properties, just disable edit window
        If nPropCount Then
            Dim xfn As Long
            Dim rcdtn As RECT
            GetClientRect hDetailName, rcdtn
            xs1 = cxyDTPaneIcon + 20 + rcdtn.Right
            xs2 = cxyDTPaneIcon + 20 + pbDetailPane.TextWidth(tSelectedFile.sType)
            If xs1 > xs2 Then
                xfn = xs1
            Else
                xfn = xs2
            End If
            
            pvCreatePropTextArray cxMaster + cxyDTPaneIcon + 20
                
        End If
            
    '    End If
    idpout:
        SetWindowPos hDetailName, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE Or SWP_NOMOVE
        pbDetailPane.Refresh
        Set pIcon = Nothing
        Set psf = Nothing
        CoTaskMemFree pidlPar
        Set upi = Nothing
    End If
    
    Exit Sub
    e0:
    DebugAppend "pvCreateItemDetailPane.Error->" & Err.Description & ",0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub ResetDetailPane()
    On Error GoTo e0
    Dim i As Long
    pbDetailPane.Cls
    For i = 0 To UBound(tDispProps)
        If tDispProps(i).hAlt Then
            DestroyWindow tDispProps(i).hAlt
            tDispProps(i).hAlt = 0&
        End If
        If tDispProps(i).hEdit Then
            DestroyWindow tDispProps(i).hEdit
            'zUnThunk tDispProps(i).hEdit, SubclassThunk
            tDispProps(i).hEdit = 0&
        End If
    Next
    cmdPropSave.Visible = False
    cmdPropCancel.Visible = False
    
    bPropEditActive = False
    Exit Sub
    e0:
        DebugAppend "ResetDetailPane->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    'This didn't work out for me, but if you wanted to play with these in the PopulateDetailColumnsForItem function
    'below, here's what I tried:
    '                                Dim ppd2 As IPropertyDescription2
    '                                Dim punk2 As IUnknown
    '
    '                                Set punk2 = ppd
    '                                Dim hrp2 As Long
    '                                hrp2 = punk2.QueryInterface(IID_IPropertyDescription2, ppd2)
    '                                If hrp2 = S_OK Then
    '                                    Dim lpp2 As Long, spp2 As String
    '                                    On Error GoTo e1
    '                                    DebugAppend "Got PropDesc2 for " & .szSystemName
    ''                                    hrp2 = 0&
    ''                                    spp2 = String$(MAX_PATH, 0)
    ''                                    hrp2 = ppd.IsValueCanonical(vrpvb)
    ''                                    hrp2 = PSGetImageReferenceForValue(.pkey, vrp, lpp2)
    ''                                    DebugAppend "lpp2=" & lpp2
    '                                    hrp2 = ppd2.GetImageReferenceForValue(vrp, lpp2)
    '                                    spp2 = LPWSTRtoStr(lpp2)
    '                                    DebugAppend "ppd2.GIRFV hr=0x" & Hex$(hrp2) & ",str=" & TrimNullW(spp2)
    '                                End If
    
    Private Function PopulateDetailColumnsForItem(siItem As IShellItem) As Long
    'If the file type has a property handler, the system properties registered under
    'HKEY_CLASSES_ROOT\SystemFileAssociations\[extension]\PreviewDetails are used
    'Other the default set is used, or if there's an error and neither is returned
    'a failsafe is provided using only Date Modified
    Dim pps As IPropertyStore
    Dim si2 As IShellItem2
    Dim ppcp As IPropertyStoreCapabilities
    Dim ppd As IPropertyDescription
    Dim i As Long, j As Long, k As Long
    Dim nCol As Long
    Dim sTmpPr As String
    Dim bOk As Boolean
    Dim sProp() As String
    Set si2 = siFocus
    si2.GetPropertyStore GPS_OPENSLOWITEM Or GPS_BESTEFFORT, IID_IPropertyStore, pps
    Set ppcp = pps
    Dim sTPR As String
    sTPR = GetPropertyKeyDisplayString(pps, PKEY_PropList_PreviewDetails)
    DebugAppend "PopulateDetailColumnsForItem PropList_PreviewDetails=" & sTPR
    If Left$(sTPR, 5) = "prop:" Then sTPR = Mid$(sTPR, 6)
    
    If sTPR = "" Then
        sTPR = "System.DateModified"
        DebugAppend "WARNING: No preview details for " & tSelectedFile.sName
    End If
    sProp = Split(sTPR, ";")
    ReDim tDispProps(0)
    nDispProp = 0
    For i = 0 To UBound(sProp)
        nCol = GetColBySysName(sProp(i))
        If nCol <> -1 Then
            With uColData(nCol)
            
    '                    DebugAppend "Prop=" & .szSystemName & ",def=" & ((.dwTypeFlags And PDTF_DEFAULT) = PDTF_DEFAULT) & ",query=" & ((.dwTypeFlags And PDTF_ISQUERYABLE) = PDTF_ISQUERYABLE) & ",fulltext=" & ((.dwTypeFlags = PDTF_INCLUDEINFULLTEXTQUERY) = PDTF_INCLUDEINFULLTEXTQUERY) & ",stack=" & ((.dwTypeFlags = PDTF_CANSTACKBY) = PDTF_CANSTACKBY) & ",purge=" & ((.dwTypeFlags And PDTF_CANBEPURGED) = PDTF_CANBEPURGED) & ",innate=" & ((.dwTypeFlags And PDTF_ISINNATE) = PDTF_ISINNATE) & ",flagsys=" & ((.dwTypeFlags And PDTF_ISSYSTEMPROPERTY) = PDTF_ISSYSTEMPROPERTY) & ",cangroup=" & ((.dwTypeFlags And PDTF_CANGROUPBY) = PDTF_CANGROUPBY) & ",istree=" & ((.dwTypeFlags And PDTF_ISTREEPROPERTY) = PDTF_ISTREEPROPERTY) & ",viewable=" & ((.dwTypeFlags And PDTF_ISVIEWABLE) = PDTF_ISVIEWABLE)
                If ((.dwTypeFlags And PDTF_ISVIEWABLE) = PDTF_ISVIEWABLE) Or ((.dwTypeFlags And PDTF_CANGROUPBY) = PDTF_CANGROUPBY) Then 'Property always hidden without this flag
                    bOk = True
                    sTmpPr = GetPropertyKeyDisplayString(pps, .pKey, False)
                    If (Left$(sProp(i), 1&)) = "*" Then 'Hide if empty
                        bOk = False
                        
                        If sTmpPr <> "" Then bOk = True
                    End If
                    Dim uAtr As SFGAO_Flags, uAtrCP As SFGAO_Flags
                    siItem.GetAttributes SFGAO_READONLY Or SFGAO_SYSTEM, uAtr
                    siCurPath.GetAttributes SFGAO_READONLY Or SFGAO_SYSTEM, uAtrCP
                    
                    If ((uAtr And SFGAO_READONLY) = SFGAO_READONLY) And (sTmpPr = "") Then
                        'hide if empty and non-writable due to attrib
                        bOk = False
                    End If
                    
                    Dim fWrite As Long
                    'Fonts outside the system font folder don't have System.Fonts. preview details...
                    'Fonts inside the folder do, however they cannot be edited despite reporting themselves as editable... so manually disable
                    If InStr(sTPR, "System.Fonts.") Then
                        fWrite = 1&
                    Else
                        fWrite = ppcp.IsPropertyWritable(VarPtr(.pKey))
                    End If
                    If ((fWrite <> S_OK) Or ((uAtrCP And SFGAO_SYSTEM) = SFGAO_SYSTEM)) And (sTmpPr = "") Then bOk = False
                        
                        
                    If bOk Then
                            Dim vrp As Variant, vrpvb As Variant
    '                            DebugAppend "DispProp=" & .szSystemName & ",def=" & .IsDefProp & ",innate=" & ((.dwTypeFlags And PDTF_ISINNATE) = PDTF_ISINNATE) & ",flagsys=" & ((.dwTypeFlags And PDTF_ISSYSTEMPROPERTY) = PDTF_ISSYSTEMPROPERTY) & ",cangroup=" & ((.dwTypeFlags And PDTF_CANGROUPBY) = PDTF_CANGROUPBY) & ",istree=" & ((.dwTypeFlags And PDTF_ISTREEPROPERTY) = PDTF_ISTREEPROPERTY) & ",viewable=" & ((.dwTypeFlags And PDTF_ISVIEWABLE) = PDTF_ISVIEWABLE)
                        ReDim Preserve tDispProps(nDispProp)
                        tDispProps(nDispProp).sSysName = .szSystemName
                        tDispProps(nDispProp).sDispName = .szDisplayName
                        tDispProps(nDispProp).nCol = nCol
                        tDispProps(nDispProp).sOrig = sTmpPr
    '                    DebugAppend .szSystemName & ".fWrite=" & fWrite
                        If ((uAtr And SFGAO_READONLY) = SFGAO_READONLY) Or ((uAtrCP And SFGAO_SYSTEM) = SFGAO_SYSTEM) Then
                            tDispProps(nDispProp).fReadOnly = 1&
                        End If
                        If ((.dwTypeFlags And PDTF_ISINNATE) = PDTF_ISINNATE) Or (fWrite <> S_OK) Then
                            tDispProps(nDispProp).fReadOnly = 1&
                        Else
                            'Write access to the property store will be denied if the file is Read Only, flag it early
                            If (uAtr And SFGAO_READONLY) = SFGAO_READONLY Then
                                tDispProps(nDispProp).fReadOnly = 1&
                            End If
    '                                DebugAppend "WritableProp=" & .szSystemName & ",def=" & .IsDefProp & ",innate=" & ((.dwTypeFlags And PDTF_ISINNATE) = PDTF_ISINNATE) & ",flagsys=" & ((.dwTypeFlags And PDTF_ISSYSTEMPROPERTY) = PDTF_ISSYSTEMPROPERTY) & ",cangroup=" & ((.dwTypeFlags And PDTF_CANGROUPBY) = PDTF_CANGROUPBY) & ",istree=" & ((.dwTypeFlags And PDTF_ISTREEPROPERTY) = PDTF_ISTREEPROPERTY) & ",viewable=" & ((.dwTypeFlags And PDTF_ISVIEWABLE) = PDTF_ISVIEWABLE)
    
                        End If
                        tDispProps(nDispProp).sInvite = GetPropertyKeyEditInvite(.pKey)
                        tDispProps(nDispProp).dwDispType = GetPropertyKeyDataType(.pKey)
                        If tDispProps(nDispProp).dwDispType = PDDT_BOOLEAN Then
                            'I can't find any file where an editable boolean property appears in an Explorer details pane, so I'm unable
                            'to test/implement this. A full dump of the system property store suggests these are so rare a user is very
                            'unlikely to encounter and want/be able to edit anyway
                            tDispProps(nDispProp).fReadOnly = 1&
                        End If
                        If tDispProps(nDispProp).dwDispType = PDDT_DATETIME Then
                            pps.GetValue .pKey, vrp
                            PropVariantToVariant vrp, tDispProps(nDispProp).vOrigForDT
                        End If
                        If tDispProps(nDispProp).dwDispType = PDDT_NUMBER Then
                            pps.GetValue .pKey, vrp
                            PropVariantToVariant vrp, vrpvb
                            tDispProps(nDispProp).nVarTypeForNumber = VarType(vrpvb)
                            tDispProps(nDispProp).vNumberValue = vrpvb
    '                                DebugAppend "PDDT_NUMBER type=" & tDispProps(nDispProp).nVarTypeForNumber
                        End If
                        If tDispProps(nDispProp).dwDispType = PDDT_ENUMERATED Then
                            On Error GoTo e1
                                    DebugAppend .szSystemName & " type=0x" & Hex$(tDispProps(nDispProp).dwDispType)
                            pps.GetValue .pKey, vrp
                            PropVariantToVariant vrp, vrpvb
    '                                DebugAppend "Value=" & CStr(vrpvb)
                            tDispProps(nDispProp).vEnumeratedValue = vrpvb
    '                                DebugAppend "VarType=" & VarType(vrpvb)
                            If VarType(vrpvb) = vbEmpty Then
                                tDispProps(nDispProp).vEnumeratedIsEmpty = True
                            End If
                            Set ppd = Nothing
    '                            GoTo skipenum
                            PSGetPropertyDescription .pKey, IID_IPropertyDescription, ppd
    'snip
                            If (ppd Is Nothing) Then
                                DebugAppend "Failed to get IPropertyDescription"
                            End If
                            Dim pETL As IPropertyEnumTypeList
                            Dim pET As IPropertyEnumType
                            Dim nEnumType As PROPENUMTYPE
                            Dim lpInitIdx As Long
                            Dim nTCt As Long
                            Dim vr1 As Variant, vr2 As Variant, vr3 As Variant, vr4 As Variant
                            Dim vb1 As Variant, vb2 As Variant, vb3 As Variant, vb4 As Variant
                            Dim lpTemp As LongPtr, sTemp As String, l1 As Long, l2 As Long, s1 As String, s2 As String
                            ppd.GetEnumTypeList IID_IPropertyEnumTypeList, pETL
                            If (pETL Is Nothing) = False Then
    '                                    DebugAppend "Got ETL for " & .szSystemName
                                pETL.GetCount nTCt
                                If nTCt > 0 Then
    '                                    DebugAppend "typect=" & nTCt
                                pETL.FindMatchingIndex vrp, l1
    '                                    DebugAppend "MatchingIndex=" & l1
                                tDispProps(nDispProp).lEnumeratedInitialIndex = l1
                                ReDim tDispProps(nDispProp).sEnumerated(nTCt - 1)
                                ReDim tDispProps(nDispProp).vEnumerated(nTCt - 1)
                                For j = 0 To (nTCt - 1)
                                    pETL.GetAt j, IID_IPropertyEnumType, pET
                                    If (pET Is Nothing) = False Then
                                         pET.GetEnumType nEnumType
    '                                            DebugAppend "nEnumType=" & nEnumType
                                        If nEnumType = PET_DEFAULTVALUE Then
                                            pET.GetDisplayText lpTemp
    '                                                DebugAppend "PET_DEFAULTVALUE str=" & LPWSTRtoStr(lpTemp)
                                        End If
                                        If (nEnumType = PET_DISCRETEVALUE) Then
                                            pET.GetRangeMinValue vr1
                                            pET.GetRangeSetValue vr2
                                            PropVariantToVariant vr1, vb1
                                            PropVariantToVariant vr2, vb2
    '                                                DebugAppend "PET_DISCRETEVALUE v1=" & CStr(vb1) & ",v2=" & CStr(vb2)
                                            pET.GetValue vr3
                                             
                                            PropVariantToVariant vr3, vb3
    '                                                DebugAppend "PET_DISCRETEVALUE vr3=" & CStr(vb3)
                                            pET.GetDisplayText lpTemp
                                            tDispProps(nDispProp).sEnumerated(j) = LPWSTRtoStr(lpTemp)
                                            tDispProps(nDispProp).vEnumerated(j) = vr3
    '                                                DebugAppend "PET_DISCRETEVALUE str=" & tDispProps(nDispProp).sEnumerated(j)
                                            If tDispProps(nDispProp).vEnumeratedIsEmpty = False Then
    '                                                    DebugAppend "Comp " & CLng(tDispProps(nDispProp).vEnumeratedValue) & "|" & CLng(vb1)
                                            End If
                                        End If
                                        If (nEnumType = PET_RANGEDVALUE) Then
                                            pET.GetRangeMinValue vr1
                                            pET.GetRangeSetValue vr2
                                            PropVariantToVariant vr1, vb1
                                            PropVariantToVariant vr2, vb2
    '                                        DebugAppend "PET_RANGEDVALUE v1=" & CStr(vb1) & ",v2=" & CStr(vb2)
                                            pET.GetDisplayText lpTemp
                                            tDispProps(nDispProp).sEnumerated(j) = LPWSTRtoStr(lpTemp)
                                            If CLng(vb2) = 0& Then
                                                tDispProps(nDispProp).vEnumerated(j) = vr1
                                            Else
                                                tDispProps(nDispProp).vEnumerated(j) = vr2
                                            End If
                                            tDispProps(nDispProp).vEnumeratedIsRanged = True
    '                                                DebugAppend "PET_RANGEDVALUE str=" & tDispProps(nDispProp).sEnumerated(j)
                                        End If
                                        If nEnumType = PET_ENDRANGE Then
                                            pET.GetValue vr3
                                            pET.GetRangeMinValue vr4
                                            PropVariantToVariant vr3, vb3
                                            PropVariantToVariant vr4, vb4
    '                                                DebugAppend "PET_ENDRANGE v3=" & CStr(vb3) & ",v4=" & CStr(vb4)
                                            tDispProps(nDispProp).vEnumeratedEndRange = vr3
                                        End If
                                    End If
                                Next j
                            Else
    '                                    DebugAppend "typect=0"
                            End If
                            
                        End If
                    End If
    skipenum:
                        nDispProp = nDispProp + 1&
                        
                        'hWnd is populated later when we draw edit boxes
                    End If
                End If
    
        
            End With
        
        
        Else
            DebugAppend "Couldn't find prop: " & sProp(i)
        End If
    nxt:
    Next
    PopulateDetailColumnsForItem = nDispProp
    On Error GoTo 0
    Exit Function
    e1:
        DebugAppend "Error: " & Replace(Err.Description, vbLf, ": ") & ", 0x" & Hex$(Err.Number)
        Resume Next
    End Function
    
    Private Function GetColBySysName(ByVal sSys As String) As Long
    'Gets a uColData index by the system name
    Dim i As Long
    If Left$(sSys, 1) = "*" Then sSys = Mid$(sSys, 2)
    For i = 0 To UBound(uColData)
        If uColData(i).szSystemName = sSys Then
            GetColBySysName = i
            Exit Function
        End If
    Next
    GetColBySysName = -1&
    End Function
    
    Private Sub MapCurrentColumns()
        'The best way to sort items is with IShellFolder.CompareIDs
        'So we'll scan the current IShellFolder's columns that are supported by that,
        'and flag the column data entry so when that column is clicked, we know what
        'it is mapped to (if any). It's set to -1 by default for unsupported columns
        'which are then processed the old, manual way.
        On Error GoTo out
        Dim psf2 As IShellFolder2
        Set psf2 = psfCur
        Dim sd As SHCOLUMNID
        Dim pk As PROPERTYKEY
        Dim i As Long
        Dim idx As Long
        Dim szpk As String
        lDefColISF(0) = -1
        lDefColISF(1) = -1
        lDefColISF(2) = -1
        lDefColISF(3) = -1
        lDefColISF(4) = -1
        lDefColISF(5) = -1
        For i = 0 To UBound(uColData)
            uColData(i).nMapsTo = -1
        Next i
        i = 0
        Do
            sd.fmtid.Data1 = 0
            psf2.MapColumnToSCID i, sd
            If sd.fmtid.Data1 = 0 Then Exit Do
            
            idx = LookupColFromPK(sd.fmtid, sd.pid)
            If idx >= 0& Then
                uColData(idx).nMapsTo = i
            End If
            If idx = lDefColIdx(0) Then lDefColISF(0) = i
            If idx = lDefColIdx(1) Then lDefColISF(1) = i
            If idx = lDefColIdx(2) Then lDefColISF(2) = i
            If idx = lDefColIdx(3) Then lDefColISF(3) = i
            If idx = lDefColIdx(4) Then lDefColISF(4) = i
            If idx = lDefColIdx(5) Then lDefColISF(5) = i
            
            If i > 5000 Then
                szpk = dbg_PKEYToString(pk)
                DebugAppend "Never got zero. " & szpk, 11
                Exit Do
            End If
            i = i + 1
        Loop
    out:
        
    
    End Sub
    
    
    Private Function PSSUCCEEDED(hr As Long) As Boolean
    If (hr = INPLACE_S_TRUNCATED) Or (hr = S_OK) Then
        PSSUCCEEDED = True
    End If
    End Function
    
    Private Function WritePropertyChanges() As Long
    Dim i As Long
    Dim sNew As String
    Dim pps As IPropertyStore
    Dim si2 As IShellItem2
    Dim bChange As Boolean
    Dim vr As Variant, vbvr As Variant
    
    On Error GoTo e0
    
    For i = 0 To UBound(tDispProps)
        If (tDispProps(i).dwDispType = PDDT_STRING) And (tDispProps(i).fReadOnly = S_OK) Then
            sNew = GetEditWindowTextW(tDispProps(i).hEdit)
            If tDispProps(i).bWrite Then
    '            dbg_stringbytes sNew
    '            dbg_stringbytes tDispProps(i).sOrig
                DebugAppend "WriteString " & sNew & " <> " & tDispProps(i).sOrig
                If (pps Is Nothing) Then
                    Set si2 = siFocus
                    si2.GetPropertyStore GPS_OPENSLOWITEM Or GPS_READWRITE, IID_IPropertyStore, pps
                    If pps Is Nothing Then
                        DebugAppend "Failed to open property store for read/write for " & tSelectedFile.sName
                        WritePropertyChanges = E_FAIL
                        Exit Function
                    End If
                End If
                DebugAppend "WritePropertyChange " & tDispProps(i).sSysName & "=" & sNew
                pps.SetValue uColData(tDispProps(i).nCol).pKey, CVar(sNew)
                tDispProps(i).sOrig = sNew
                bChange = True
                RaiseEvent FileDetailsWrite(sSelectedFile, tDispProps(i).sSysName, tDispProps(i).sOrig)
            End If
        End If
        If (tDispProps(i).dwDispType = PDDT_NUMBER) And (tDispProps(i).fReadOnly = S_OK) Then
            sNew = GetEditWindowTextW(tDispProps(i).hEdit)
            On Error GoTo e1
            If tDispProps(i).bWrite Then
                DebugAppend "WriteNumber " & CLng(sNew) & " <> " & CLng(tDispProps(i).vNumberValue)
                Dim lNum As Long
                lNum = CLng(sNew)
                vbvr = CVar(lNum)
                VariantToPropVariant vbvr, vr
                If (tDispProps(i).nVarTypeForNumber <> vbEmpty) And (tDispProps(i).nVarTypeForNumber <> vbLong) Then
                    PropVariantChangeType vr, vbvr, 0&, tDispProps(i).nVarTypeForNumber
                End If
                On Error GoTo e0
                If (pps Is Nothing) Then
                    Set si2 = siFocus
                    si2.GetPropertyStore GPS_OPENSLOWITEM Or GPS_READWRITE, IID_IPropertyStore, pps
                    If pps Is Nothing Then
                        DebugAppend "Failed to open property store for read/write for " & tSelectedFile.sName
                        WritePropertyChanges = E_FAIL
                        Exit Function
                    End If
                End If
                DebugAppend "WritePropertyChange " & tDispProps(i).sSysName & "=" & sNew
                pps.SetValue uColData(tDispProps(i).nCol).pKey, vr
                tDispProps(i).sOrig = sNew
                bChange = True
                RaiseEvent FileDetailsWrite(sSelectedFile, tDispProps(i).sSysName, tDispProps(i).sOrig)
            End If
            On Error GoTo e0
        End If
        If (tDispProps(i).dwDispType = PDDT_DATETIME) And (tDispProps(i).fReadOnly = S_OK) Then
            Dim dtNew As Date
            Dim stVal As SYSTEMTIME, ftVal As FILETIME, ftUtc As FILETIME
            
    '        If tDispProps(i).hAlt Then
            If tDispProps(i).bUseNewST Then
    '            SendMessage tDispProps(i).hAlt, DTM_GETSYSTEMTIME, GDT_VALID, ByVal VarPtr(stVal)
                stVal = tDispProps(i).stNewForDT
                dtNew = SystemTimeToDate(stVal)
                DebugAppend "WriteDateTime " & CStr(dtNew)
                If DestroyWindow(tDispProps(i).hAlt) Then
                    tDispProps(i).hAlt = 0&
                End If
                vbvr = CVar(dtNew)
                SystemTimeToFileTime stVal, ftVal
                LocalFileTimeToFileTime ftVal, ftUtc
                InitPropVariantFromFileTime ftUtc, vr
                If (pps Is Nothing) Then
                    Set si2 = siFocus
                    si2.GetPropertyStore GPS_OPENSLOWITEM Or GPS_READWRITE, IID_IPropertyStore, pps
                    If pps Is Nothing Then
                        DebugAppend "Failed to open property store for read/write for " & tSelectedFile.sName
                        WritePropertyChanges = E_FAIL
                        Exit Function
                    End If
                End If
                
                If PSSUCCEEDED(pps.SetValue(uColData(tDispProps(i).nCol).pKey, vr)) Then
    
                    tDispProps(i).sOrig = CStr(dtNew)
                    tDispProps(i).vOrigForDT = vbvr
                    tDispProps(i).bUseNewST = False
                    ShowWindow tDispProps(i).hEdit, SW_SHOW
                    SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sOrig)
                    bChange = True
                    RaiseEvent FileDetailsWrite(sSelectedFile, tDispProps(i).sSysName, tDispProps(i).sOrig)
                End If
            End If
        End If
        If (tDispProps(i).dwDispType = PDDT_ENUMERATED) And (tDispProps(i).fReadOnly = S_OK) Then
            Dim lIndex As Long
             
            
    '        If tDispProps(i).hAlt Then
            If tDispProps(i).bEnumeratedUseNewIndex Then
    '            lIndex = SendMessageW(tDispProps(i).hAlt, CB_GETCURSEL, 0&, ByVal 0&)
                lIndex = tDispProps(i).lEnumeratedNewIndex
                If DestroyWindow(tDispProps(i).hAlt) Then
                    tDispProps(i).hAlt = 0&
                End If
                If lIndex <> -1 Then
                    
                    If (pps Is Nothing) Then
                        Set si2 = siFocus
                        si2.GetPropertyStore GPS_OPENSLOWITEM Or GPS_READWRITE, IID_IPropertyStore, pps
                        If pps Is Nothing Then
                            DebugAppend "Failed to open property store for read/write for " & tSelectedFile.sName
                            WritePropertyChanges = E_FAIL
                            Exit Function
                        End If
                    End If
                    
                    If PSSUCCEEDED(pps.SetValue(uColData(tDispProps(i).nCol).pKey, tDispProps(i).vEnumerated(lIndex))) Then
                        tDispProps(i).sOrig = tDispProps(i).sEnumerated(lIndex)
                        tDispProps(i).lEnumeratedInitialIndex = lIndex
                        tDispProps(i).bEnumeratedUseNewIndex = False
                        ShowWindow tDispProps(i).hEdit, SW_SHOW
                        SendMessageW tDispProps(i).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(i).sOrig)
                        bChange = True
                        RaiseEvent FileDetailsWrite(sSelectedFile, tDispProps(i).sSysName, tDispProps(i).sOrig)
                    End If
                End If
            End If
        End If
        If (tDispProps(i).dwDispType = PDDT_BOOLEAN) And (tDispProps(i).fReadOnly = S_OK) Then
            'PLACEHOLDER: Not implemented in the display/edit field either as no properties seem
            '             to use this at all. If you are implementing this, just do like above
            '             except using boolean as the propvariant subtype.
        End If
    Next i
    If bChange Then
        mWPCFlag = True
        sWPCFlag = sSelectedFile
        WritePropertyChanges = pps.Commit()
        If WritePropertyChanges = S_OK Then
            DebugAppend "WritePropertyChanges succeeded."
        Else
            mWPCFlag = False
            DebugAppend "WritePropertyChanges failed, hr=0x" & Hex$(WritePropertyChanges)
        End If
        Set pps = Nothing
    End If
    Exit Function
    
    e0:
        DebugAppend "WritePropertyChanges.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
        Exit Function
    e1:
        DebugAppend "WritePropertyChanges.RunningError->" & Err.Description & ", 0x" & Hex$(Err.Number)
        Resume Next
    End Function
     
    Private Sub pvCreateDetailPaneBkg()
    DebugAppend "pvCreateDetailPaneBkg.Entry, paneltop/sizertop=" & pbDetailPane.Top & "," & pbDetailSizer.Top
    If Ambient.UserMode = False Then Exit Sub
    nLastDtPaneOp = 0&
    Dim upi As IParentAndItem
    Dim pIcon As IShellIcon
    Dim pidlRel As LongPtr, pidlPar As LongPtr
    Dim psf As IShellFolder
    Dim lpIcon As Long
    Dim tDraw As IMAGELISTDRAWPARAMS
    Dim cx As Long, cy As Long
    Dim pbrc As RECT
    DebugAppend "pvCreateDetailPaneBkg.SetHandler"
    On Error GoTo e0
    bDTPaneSingleItemActive = False
    If (siCurPath Is Nothing) = False Then
        ResetDetailPane
        On Error Resume Next
        Set upi = siCurPath
        upi.GetParentAndItem pidlPar, psf, pidlRel
        Set pIcon = psf
        DebugAppend "pvCreateDetailPaneBkg.pidlPar=" & pidlPar & ",pidlrel=" & pidlRel
        pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
        If lpIcon = -1 Then
            Dim pidlc As LongPtr
            pidlc = ILCombine(pidlPar, pidlRel)
            lpIcon = GetFileIconIndexPIDL(pidlc, SHGFI_LARGEICON)
    '        DebugAppend "New icon=" & lpIcon
            CoTaskMemFree pidlc
        End If
        If lpIcon < 1 Then
            Dim pil As IPersistIDList
            Set pil = siFocus
            pil.GetIDList pidlPar
            lpIcon = GetFileIconIndexPIDL(pidlPar, SHGFI_SMALLICON)
        End If
        On Error GoTo e0
        Call GetClientRect(pbDetailPane.hWnd, pbrc)
    '    DebugAppend "pbh=" & pbrc.Bottom
        imlSys32.GetIconSize cx, cy
        tDraw.cbSize = LenB(tDraw)
        cxyDTPaneIcon = (pbrc.Bottom + (cySysBorder) * 2) ' - 9
        If cxyDTPaneIcon > 256 Then cxyDTPaneIcon = 256
        tDraw.cx = cxyDTPaneIcon: tDraw.cy = cxyDTPaneIcon
        tDraw.fStyle = ILD_TRANSPARENT Or ILD_SCALE
        tDraw.hdcDst = pbDetailPane.hDC
        tDraw.i = lpIcon
        tDraw.x = 5: tDraw.y = 2
    '    DebugAppend "btm=" & pbrc.Bottom & ",cx=" & tDraw.CX & ",icn=" & cxyDTPaneIcon & ",sys=" & cxyLgIcn
        If cxyDTPaneIcon > cxyLgIcn Then
    '        DebugAppend "Draw from JM"
            imlSysJM.Draw tDraw
        Else
    '        DebugAppend "Draw from 32"
    '        DebugAppend "pvCreateDetailPaneBkg.tDraw.i=" & lpIcon & ",cx=" & tDraw.CX & ",cy=" & tDraw.CY
            imlSys32.Draw tDraw
        End If
        Dim lCnt As Long
        lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
        
        Dim tRC As RECT
        tRC.Left = cxyDTPaneIcon + 10
        tRC.Top = 6
        tRC.Right = tRC.Left + 82
        tRC.Bottom = tRC.Top + 18
        
        Dim sText As String
        If lCnt = 1 Then
            sText = "1 item"
        Else
            sText = CStr(lCnt) & " items"
        End If
        Dim xName As Long, yName As Long
        xName = tRC.Left: yName = tRC.Top
        If hDetailName Then
            DestroyWindow hDetailName
        End If
        hDetailName = CreateWindowExW(0&, StrPtr(WC_STATIC), 0&, WS_CHILD Or WS_VISIBLE, xName, yName, 150, cyDtName * m_ScaleY, pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
        If bDTHSC = False Then
            'If ssc_Subclass(pbDetailPane.hWnd, , 5&, , , True) Then
            '    ssc_AddMsg pbDetailPane.hWnd, MSG_BEFORE, ALL_MESSAGES
                Subclass2 pbDetailPane.hWnd, AddressOf DetailHeaderWndProc, pbDetailPane.hWnd
                bDTHSC = True
            'End If
        End If
        DebugAppend "SetDetailBkg font=" & m_hFontDtHdrAlt, 444
        SendMessageW hDetailName, WM_SETFONT, m_hFontDtHdrAlt, ByVal 1&
        SetWindowTextW hDetailName, StrPtr(sText)
        pbDetailPane.Refresh
        Set pIcon = Nothing
        Set psf = Nothing
        CoTaskMemFree pidlPar
        Set upi = Nothing
    End If
    Exit Sub
    e0:
    DebugAppend "pvCreateDetailPaneBkg.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub pvCreatePropTextArray(xStart As Long)
    'Up until v9.5, this was a complete mess. The code was a hacked together disaster,
    'and property names were frequently truncated, or giant gaps existed, and that's
    'when everything went right.
    'In v9.5, this sub was re-written from scratch. It took hours and hours and hours
    'and hours, but everything is now perfect and I made the effort to have clear,
    'clean, properly layed out code. Properties no longer get truncated, there's no
    'longer giant gaps, even with very long property names.
    On Error GoTo e0
    Dim rc As RECT, pbrc As RECT
    Dim i As Long, j As Long, k As Long, L As Long
    Dim s1 As String, s2 As String, s3 As String
    Dim xEdit As Long, yEdit As Long
    Dim sWrite As String
    Dim nCol As Long, nRow As Long
    Dim xAvail As Long
    Dim nRowAvail As Long
    Dim cyLine As Long
    Dim xCur As Long
    Dim cxCol As Long
    Dim bf1 As Boolean
    Dim cxEdit As Long
    Dim cyText As Long
    
    xAvail = pbDetailPane.ScaleWidth - xStart - (4 * m_ScaleX)
    cyText = pbDetailPane.TextHeight("|1LT")
    cyLine = cyText + (5 * m_ScaleY)
    DebugAppend "pbDetailPane.Height=" & pbDetailPane.Height & ",cmdPropSave.Height=" & cmdPropSave.Height & ",m_ScaleY=" & m_ScaleY & ",cyLine=" & cyLine & ",cyText=" & cyText
    nRowAvail = ((pbDetailPane.Height - cmdPropSave.Height) + (3 * m_ScaleY)) \ cyLine
    Dim tdpCols() As DPColStruct
    Dim nClCt As Long
    Dim pc As Long
    Dim cmi As Long
    Dim dwFlags As Long
    xStart = (xStart) + (4 * m_ScaleX)
    
    'First, group the properties by column now that we know how many rows each can have
    'We just store a reference to the index in tDispProps, don't want to copy structs
    'themselves, since there's extensive code surrounding updating, saving, subclassing,
    'and providing alt controls.
    ReDim tdpCols(0)
    For i = 0 To UBound(tDispProps)
        ReDim tdpCols(nCol).tDP(nRowAvail - 1)
        For k = 0 To nRowAvail - 1
            If bf1 = False Then
                tdpCols(nCol).tDP(k) = pc
                If pc = UBound(tDispProps) Then
                    bf1 = True
                End If
            Else
                'We're out of properties but there's still room in this columns,
                'so make sure to provide a value indicating it's invalid, rather
                'than 0, which would duplicate the very first property.
                tdpCols(nCol).tDP(k) = -1
            End If
            pc = pc + 1
        Next k
        If bf1 Then Exit For
        nCol = nCol + 1
        ReDim Preserve tdpCols(nCol)
    Next i
    
    'Next we'll determine if there's enough space to display even the 1st column
    'We do that by finding the widest property in the 1st column, subject to the
    'min/max edit box size.
    For i = 0 To UBound(tdpCols(0).tDP)
      If tdpCols(0).tDP(i) <> -1& Then
        If tDispProps(tdpCols(0).tDP(i)).sOrig = "" Then
            s3 = tDispProps(tdpCols(0).tDP(i)).sInvite
        Else
            s3 = tDispProps(tdpCols(0).tDP(i)).sOrig
        End If
    '    j = pbDetailPane.TextWidth(tDispProps(tdpCols(0).tDP(i)).sDispName & ": ")
    '    k = pbDetailPane.TextWidth(StripCommonControlChars(s3))
        j = TextWidthW(pbDetailPane.hDC, tDispProps(tdpCols(0).tDP(i)).sDispName & ": ")
        k = TextWidthW(pbDetailPane.hDC, StripCommonControlChars(s3))
        If k > (cxMaxProp * m_ScaleX) Then k = cxMaxProp * m_ScaleX
        If k < (cxMinProp * m_ScaleX) Then k = cxMinProp * m_ScaleX
        j = j + k
        If j > cxCol Then cxCol = j
      End If
    Next i
    If cxCol > xAvail Then
    '    DebugAppend "NoStart cxCol=" & cxCol & ",xAvail=" & xAvail, 444
        Exit Sub 'Not even enough room for 1 column
    End If
    
    'We're displaying columns. The steps are as follows:
    '1-Determine starting x position. xCur is the current offset from start (0 for the 1st
    '  col), cxCol is the width of the previous column (also 0 first time), and an offset.
    '2-Find the widest prop name, and widest edit box, independently, we need to know both
    '3-Verify there's enough space left to add this column, if not, we're done
    '4-We know the total column size, so create edit boxes with cx=total-maxeditwidth
    '  It's positioned with the right edge at the total column width. All the edit boxes
    '  in the column have a cx=the widest one.
    '5-Whatever is left is the rect for the property name, which is right aligned
    '  next to the left aligned edit control. Remember we found the max label cx
    '  independently, and all labels in the column get that size, so nothing is cut off.
    '6-Set the initial contents/cue banners and subclass the edit controls.
    cxCol = 0&
    Dim maxLbl As Long, maxEdit As Long
    For i = 0 To UBound(tdpCols)
        xCur = xCur + (cxCol) + (yDetailSpacer * m_ScaleX)
        maxLbl = 0: maxEdit = 0
        For k = 0 To UBound(tdpCols(i).tDP)
            If tdpCols(i).tDP(k) = -1 Then Exit For
            If tDispProps(tdpCols(i).tDP(k)).sOrig = "" Then
                s3 = tDispProps(tdpCols(i).tDP(k)).sInvite
            Else
                s3 = tDispProps(tdpCols(i).tDP(k)).sOrig
            End If
    '        j = pbDetailPane.TextWidth(StripCommonControlChars(s3))
    '        L = pbDetailPane.TextWidth(tDispProps(tdpCols(i).tDP(k)).sDispName & ": ")
            j = TextWidthW(pbDetailPane.hDC, StripCommonControlChars(s3))
            L = TextWidthW(pbDetailPane.hDC, tDispProps(tdpCols(i).tDP(k)).sDispName & ": ")
            If L > maxLbl Then
                maxLbl = L
            End If
            If j > maxEdit Then
                maxEdit = j
                cmi = k
            End If
        Next k
        If maxEdit > (cxMaxProp * m_ScaleX) Then maxEdit = cxMaxProp * m_ScaleX
        If maxEdit < (cxMinProp * m_ScaleX) Then maxEdit = cxMinProp * m_ScaleX
        DebugAppend "msxLbl=" & maxLbl & ",maxEdit=" & maxEdit, 444
        cxCol = maxLbl + maxEdit
        'cxCol now holds the widest width of this column, and cmi which row that is
        If tDispProps(tdpCols(i).tDP(cmi)).sOrig = "" Then
            s1 = tDispProps(tdpCols(i).tDP(cmi)).sInvite
        Else
            s1 = tDispProps(tdpCols(i).tDP(cmi)).sOrig
        End If
        
        If (xCur + cxCol) > xAvail Then
            DebugAppend "NoCol xCur=" & xCur & ",xStart=" & xStart & ",cxCol=" & cxCol & ",xAvail=" & xAvail, 444
            Exit For 'Not enough space to draw this column
        End If
    '    cxEdit = pbDetailPane.TextWidth(StripCommonControlChars(s1))
        cxEdit = TextWidthW(pbDetailPane.hDC, StripCommonControlChars(s1))
        If cxEdit > (cxMaxProp * m_ScaleX) Then cxEdit = cxMaxProp * m_ScaleX
        cxEdit = cxEdit + (2 * m_ScaleX)
        'Make edit boxes cxEdit wide
        For k = 0 To UBound(tdpCols(i).tDP)
            If tdpCols(i).tDP(k) = -1 Then Exit For
            dwFlags = WS_CHILD Or WS_VISIBLE Or ES_AUTOHSCROLL
            If (tDispProps(tdpCols(i).tDP(k)).fReadOnly <> S_OK) Then
                dwFlags = dwFlags Or ES_READONLY 'Or WS_DISABLED
                If bAllowCopyFromReadOnlyProps = False Then
                    dwFlags = dwFlags Or WS_DISABLED
                End If
            Else
                bPropEditActive = True
            End If
            If tDispProps(tdpCols(i).tDP(k)).dwDispType = PDDT_NUMBER Then
                dwFlags = dwFlags Or ES_NUMBER
            End If
            DebugAppend "xStart=" & xStart & ", xCur=" & xCur & ",cxEdit=" & cxEdit & ",cxCol=" & cxCol, 444
            xEdit = xStart + xCur + (cxCol - cxEdit)
            yEdit = 3 + (k * (cyText + (3 * m_ScaleY)))
            tDispProps(tdpCols(i).tDP(k)).hEdit = CreateWindowExW(0&, StrPtr(WC_EDIT), 0&, dwFlags, xEdit, yEdit, cxEdit, cyText + (2 * m_ScaleY), pbDetailPane.hWnd, 0&, App.hInstance, ByVal 0&)
            SendMessageW tDispProps(tdpCols(i).tDP(k)).hEdit, WM_SETFONT, m_hFontDtAlt, ByVal 1&
            If tDispProps(tdpCols(i).tDP(k)).fReadOnly = S_OK Then
                SendMessageW tDispProps(tdpCols(i).tDP(k)).hEdit, EM_SETCUEBANNER, 0&, ByVal StrPtr(tDispProps(tdpCols(i).tDP(k)).sInvite)
            End If
            If tDispProps(tdpCols(i).tDP(k)).sOrig <> "" Then
                SendMessageW tDispProps(tdpCols(i).tDP(k)).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(tDispProps(tdpCols(i).tDP(k)).sOrig)
            End If
            ' If ssc_Subclass(tDispProps(tdpCols(i).tDP(k)).hEdit, , 6, , , True, True) Then
            '     ssc_AddMsg tDispProps(tdpCols(i).tDP(k)).hEdit, MSG_BEFORE, ALL_MESSAGES
            ' End If
            Subclass2 tDispProps(tdpCols(i).tDP(k)).hEdit, AddressOf DetailBoxWndProc, tDispProps(tdpCols(i).tDP(k)).hEdit
            
            rc.Left = xStart + xCur - (2 * m_ScaleX)
            rc.Right = xEdit
            rc.Top = yEdit
            rc.Bottom = yEdit + cyText + (2 * m_ScaleY)
            sWrite = tDispProps(tdpCols(i).tDP(k)).sDispName & ": "
            DrawText pbDetailPane.hDC, StrPtr(sWrite), -1, rc, DT_RIGHT
        Next k
    Next i
    
    'Dump columns:
    For i = 0 To UBound(tdpCols)
       For k = 0 To UBound(tdpCols(i).tDP)
           If tdpCols(i).tDP(k) <> -1 Then DebugAppend "Column " & i & ",Row " & k & "=" & tDispProps(tdpCols(i).tDP(k)).sDispName, 444
       Next k
    Next i
    
    On Error GoTo 0
    Exit Sub
    e0:
    DebugAppend "pvCreatePropTextArray.Error->" & Err.Description, 444
    
    End Sub
    
    Private Sub pvCreateStatusBar()
    Dim hFont As LongPtr
    Dim dwStyle As Long
    dwStyle = WS_CHILD Or WS_VISIBLE Or CCS_BOTTOM Or SBARS_TOOLTIPS  'Or WS_THICKFRAME Or WS_CLIPSIBLINGS Or WS_BORDER--- i was trying
                                                   'to get a bottom border when CC6 was enabled; none of these worked
                                                   'in case someone wanted to keep trying
    If m_CtlBorder = SBCBS_Thicker Then
        dwStyle = dwStyle Or SBARS_SIZEGRIP
    End If
    
    m_hStatusBar = CreateWindowExW(0&, StrPtr(STATUSCLASSNAME), 0, dwStyle, 0, UserControl.ScaleHeight, UserControl.ScaleWidth, cyStatusBar, UserControl.hWnd, 0, App.hInstance, ByVal 0&)
    hFont = GetStockObject(DEFAULT_GUI_FONT)
    Call SendMessageW(m_hStatusBar, WM_SETFONT, hFont, ByVal 1&)
    
    SBAddPanel sbNormal, , , sbSpring, "Status"
    If (m_StatusSP = False) And (mDispSecZn = True) Then
        SBAddPanel sbNormal, , , sbContents, "Not loaded    "
        idxSizePanel = 3
        idxZonePanel = 2
    Else
        idxZonePanel = 0
        idxSizePanel = 2
    End If
    If (m_StatusSP = False) Then SBAddPanel sbNormal, , , sbContents, "0 " & mFilesStr
    If (m_StatusBar = True) And (m_Mode <> SBCTL_DrivesOnly) And (m_Mode <> SBCTL_DirOnly) And (m_Mode <> SBCTL_DirOnlyWithCtls) Then
        ShowWindow m_hStatusBar, SW_SHOW
        Dim rcsb As RECT
        GetClientRect m_hStatusBar, rcsb
        
    Else
        ShowWindow m_hStatusBar, SW_HIDE
    End If
    Dim rct As RECT
    SetWindowPos m_hStatusBar, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE
    GetClientRect UserControl.hWnd, rct
    
    If m_ScaleY <= 1 Then
        cyStatusBar = 22&
    Else
        cyStatusBar = 22 + (6 * m_ScaleY)
    End If
    SendMessage m_hStatusBar, SB_SETMINHEIGHT, cyStatusBar, ByVal 0&
    If IsComCtl6 = False Then
    If bStatusBarInheritCtlBkColor Then
        Dim clrSBBK As Long
        OleTranslateColor clrCtBack, 0&, clrSBBK
        SendMessage m_hStatusBar, SB_SETBKCOLOR, 0&, ByVal clrSBBK
        'Note: The StatusBar background color cannot be changed when Common Controls 6.0 are in use
    End If
    End If
    If (m_StatusBar = False) Or ((m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls)) Then
        ShowWindow m_hStatusBar, SW_HIDE
    Else
        ShowWindow m_hStatusBar, SW_SHOW
    End If
    UserControl_Resize
    UserControl_Resize
    End Sub
    
    Private Sub SBAddPanel(Optional ByVal Style As ucsb_sbPanelStyleConstants = [sbNormal], _
                        Optional ByVal MinWidth As Long = MIN_PANELWIDTH, _
                        Optional ByVal Width As Long, _
                        Optional ByVal Autosize As sbAutosizeStyleConstants = [sbNoAutosize], _
                        Optional ByVal Text As String = vbNullString, _
                        Optional ByVal TipText As String = vbNullString, _
                        Optional ByVal IconIndex As Long = -1)
         
      Dim lDummy() As Long
      Dim hIcon    As LongPtr
       
        If (m_hStatusBar) Then
             
            '-- Increase panel count
            m_lPanelCount = m_lPanelCount + 1
             
            '-- Add new panel
            ReDim lDummy(1 To m_lPanelCount)
            Call SendMessage(m_hStatusBar, SB_SETPARTS, m_lPanelCount, lDummy(1))
             
            '-- Style/Text
            Call SendMessageW(m_hStatusBar, SB_SETTEXTW, (m_lPanelCount - 1) Or Style, ByVal StrPtr(Text))
             
            '-- Tip text
            Call SendMessageW(m_hStatusBar, SB_SETTIPTEXTW, (m_lPanelCount - 1), ByVal StrPtr(TipText))
             
            '-- Icon
            If (IconIndex <> -1) Then
                hIcon = ImageList_GetIcon(m_hImageList, IconIndex, 0)
                If (hIcon) Then
                    Call SendMessage(m_hStatusBar, SB_SETICON, (m_lPanelCount - 1), ByVal hIcon)
                End If
            End If
             
            '-- Store panel info
            ReDim Preserve m_uPanelInfo(0 To m_lPanelCount)
            With m_uPanelInfo(m_lPanelCount)
                .lStyle = Style
                .lMinWidth = MinWidth * m_ScaleX
                .lWidth = IIf((Width * m_ScaleX) < (MinWidth * m_ScaleX), MinWidth * m_ScaleX, Width * m_ScaleX)
                .eAutosize = Autosize
                .sText = Text
                .sTipText = TipText
                .lIconIndex = IIf(hIcon, IconIndex, -1)
            End With
             
            '-- Finaly, resize
            Call pvResizePanels
        End If
    End Sub
    
    Private Sub SBSetPanelText(ByVal Panel As Long, ByVal sText As String, Optional ByVal sTipText As String = "")
        If (m_hStatusBar And pvIsValidPanel(Panel)) Then
             
            Call SendMessageW(m_hStatusBar, SB_SETTEXTW, (Panel - 1) Or m_uPanelInfo(Panel).lStyle, ByVal StrPtr(sText))
            If sTipText = "" Then
                If UserControl.TextWidth(sText) > m_uPanelInfo(Panel).lWidth Then
                    Call SendMessageW(m_hStatusBar, SB_SETTIPTEXTW, (Panel - 1), ByVal StrPtr(sText))
                End If
            Else
                Call SendMessageW(m_hStatusBar, SB_SETTIPTEXTW, (Panel - 1), ByVal StrPtr(sTipText))
            End If
            m_uPanelInfo(Panel).sText = sText
            m_uPanelInfo(Panel).sTipText = sTipText
            Call pvResizePanels
        End If
    
    End Sub
    
    Private Sub UpdateZonePanel(zn As URLZONE)
    Dim nIdx As Long
    
    nIdx = GetZoneIdx(zn)
    If nIdx >= 0& Then
        If arZones(nIdx).hIconSm Then
            Dim sTxt As String
            sTxt = arZones(nIdx).szDisp
            Call SendMessageW(m_hStatusBar, SB_SETTEXTW, idxZonePanel - 1, ByVal StrPtr(sTxt))
            Call SendMessage(m_hStatusBar, SB_SETICON, idxZonePanel - 1, ByVal arZones(nIdx).hIconSm)
        Else
            Call SendMessageW(m_hStatusBar, SB_SETTEXTW, idxZonePanel - 1, ByVal StrPtr(arZones(nIdx).szDisp))
        End If
        m_uPanelInfo(idxZonePanel).sText = sTxt
        m_uPanelInfo(idxZonePanel).sTipText = sTxt
        Call pvResizePanels
    End If
    
    End Sub
    
    Private Sub pvResizePanels()
       
      Const BORDER_PAD  As Long = 14
      Const GRIP_WIDTH  As Long = 16 + BORDER_PAD
      Const ICON_WIDTH  As Long = 16 + BORDER_PAD
       
      Dim lWidths()     As Long
      Dim lPanel        As Long
      Dim lBarWidth     As Long
      Dim lSpringWidth  As Long
      Dim lSpringPanels As Long
       
        If (m_lPanelCount) Then
             
            '-- Bar width
            If ((GetWindowLong(m_hStatusBar, GWL_STYLE) And SBARS_SIZEGRIP) = 0) Then
                lBarWidth = UserControl.ScaleWidth
              Else
                lBarWidth = UserControl.ScaleWidth - GRIP_WIDTH
            End If
             
            '-- Calculate remain width for 'spring-panels' and
            '   calculate width for 'contents-panels'
            For lPanel = 1 To m_lPanelCount
                 
                With m_uPanelInfo(lPanel)
                 
                    Select Case .eAutosize
                         
                        Case [sbNoAutosize]
                             
                            lSpringWidth = lSpringWidth + .lWidth
                         
                        Case [sbSpring]
                             
                            lSpringPanels = lSpringPanels + 1
                         
                        Case [sbContents]
                         
                            .lWidth = 2 * BORDER_PAD
                            If (Len(.sText)) Then
                                .lWidth = (.lWidth) + UserControl.TextWidth(.sText)
                                'DebugAppend "pvResizePanels TextWidth(" & .sText & ")=" & UserControl.TextWidth(.sText)
                                If mDispSecZn Then
                                    If lPanel = 2 Then
                                        .lWidth = .lWidth + 32 * m_ScaleX 'Account for the ZoneIcon
                                    End If
                                End If
                            End If
                            If (.lIconIndex <> -1) Then
                                .lWidth = .lWidth + ICON_WIDTH
                            End If
                            If (.lWidth < .lMinWidth) Then
                                .lWidth = .lMinWidth
                            End If
                            lSpringWidth = lSpringWidth + .lWidth
                    End Select
                End With
            Next lPanel
             
            '-- Divide up
            If (lSpringPanels) Then
                For lPanel = 1 To m_lPanelCount
                    With m_uPanelInfo(lPanel)
                        If (.eAutosize = [sbSpring]) Then
                            .lWidth = (lBarWidth - lSpringWidth) \ lSpringPanels
                            'DebugAppend "pvResizePanels panel(" & lPanel & "): lBarWidth=" & lBarWidth & ",lSpringWidth=" & lSpringWidth & ",lWidth=" & .lWidth

                            If ((.lWidth * m_ScaleX) < (.lMinWidth * m_ScaleX)) Then
                                .lWidth = .lMinWidth * m_ScaleX
                            End If
                        End If
                    End With
                Next lPanel
            End If
             
            '-- Dim. buffer for parts coords.
            ReDim lWidths(0 To m_lPanelCount)
             
            '-- Calculate parts (panel right coords.)
            For lPanel = 1 To m_lPanelCount
                With m_uPanelInfo(lPanel)
                    lWidths(lPanel) = lWidths(lPanel - 1) + .lWidth
                    If (lWidths(lPanel) > lBarWidth) Then
                        lWidths(lPanel) = lBarWidth
                    End If
                End With
            Next lPanel
             
            '-- Last panel padding
            If (m_uPanelInfo(m_lPanelCount).eAutosize = [sbSpring]) Then
                lWidths(m_lPanelCount) = lBarWidth
            End If
             
            '-- Finaly, assign parts
            Call SendMessage(m_hStatusBar, SB_SETPARTS, m_lPanelCount, lWidths(1))
        End If
    End Sub
     
    Private Function pvIsValidPanel(ByVal lPanel As Long) As Boolean
        pvIsValidPanel = (lPanel >= 1 And lPanel <= m_lPanelCount)
    End Function
    
    Private Function GetComboTextW(hEdit As LongPtr) As String
    Dim bytS() As Byte
    Dim ch As Long
    ch = CLng(SendMessageW(hEdit, WM_GETTEXTLENGTH, 0, ByVal 0&) * 2&)
    If ch = 0& Then Exit Function
    ch = ch + 1&
    ReDim Preserve bytS(ch)
    ch = CLng(SendMessageW(hEdit, WM_GETTEXT, ch, ByVal VarPtr(bytS(0)))) * 2& - 1&
            If ch >= 0& Then
                ReDim Preserve bytS(ch)
            End If
    GetComboTextW = CStr(bytS)
    End Function
    
    Private Sub LVAdjustLabelWidth()
    If mLMMaxCX > 0& Then
        If (m_ViewMode = SB_VIEW_LIST) Then ' Or (m_ViewMode = SB_VIEW_SMALLICON) Then
            Dim lOld As Long
            Dim lMax As Long
            lOld = CLng(SendMessage(hLVS, LVM_GETCOLUMNWIDTH, 0, ByVal 0&))
            lMax = (mLMMaxCX * m_ScaleX) '+ 20
            If lOld > lMax Then
                SendMessage hLVS, LVM_SETCOLUMNWIDTH, 0, ByVal lMax
            End If
        End If
    End If
    End Sub
    Private Function LVComputeIndent(sPP As String) As Long
    'Supply the full parsing path to a file or folder to compute the indent
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim nCt As Long
    Dim sTmp As String
    
    If Left$(sPP, 2) = "\\" Then
        sTmp = Mid$(sPP, 3)
    Else
        sTmp = sPP
    End If
    
    sTmp = Replace$(sTmp, "\\\?\", "\")
    sTmp = Replace$(sTmp, "\\?\", "\")
    nCt = InStrC(sTmp, "\")
    
    If mCustomRoot <> "" Then
        Dim nRtCt As Long
        nRtCt = InStrC(mCustomRoot, "\")
        nCt = nCt - nRtCt
    End If
    
    LVComputeIndent = nCt
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.LVComputeIndent->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Sub RemoveParentsFromLV()
    'If ShowParentTreeInList is enabled, but the view changes, we need a routine to remove the items as they're no longer any different
    Dim i As Long
    Dim lCt As Long
    Dim lp As LongPtr
    Dim sItm As IShellItem
    Dim lvi As LVITEM
    lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    For i = (lCt - 1) To 0 Step -1
        lp = GetLVItemlParam(hLVS, i)
        If (lCurMaxInd > 0) And (LVEntries(lp).lIndent < lCurMaxInd) Then
            SendMessage hLVS, LVM_DELETEITEM, i, ByVal 0&
            LVEntries(lp).bDeleted = True
        Else
            lvi.Mask = LVIF_INDENT
            lvi.iItem = i
            lvi.iIndent = 0&
            SendMessage hLVS, LVM_SETITEMW, 0&, lvi
            LVEntries(lp).lIndent = 0& 'If we switch view back, there'd be no parents but everything still indented. Just leave it for a full refresh.
        End If
    Next i
    lCurMaxInd = 0&
    End Sub
    
    Private Function InStrC(OrigString As String, Chars As String, Optional CaseSensitive As Boolean = False) As Long
    'Count of substring matches
    Dim lLen As Long
    Dim lCharLen As Long
    Dim lAns As Long
    Dim sInput As String
    Dim sChar As String
    Dim lCtr As Long
    Dim lEndOfLoop As Long
    Dim bytCompareType As Byte
    
    sInput = OrigString
    If sInput = "" Then Exit Function
    lLen = Len(sInput)
    lCharLen = Len(Chars)
    lEndOfLoop = (lLen - lCharLen) + 1
    bytCompareType = IIf(CaseSensitive, vbBinaryCompare, vbTextCompare)
    
        For lCtr = 1 To lEndOfLoop
            sChar = Mid(sInput, lCtr, lCharLen)
            If StrComp(sChar, Chars, bytCompareType) = 0 Then lAns = lAns + 1
        Next
    
    InStrC = lAns
    
    End Function
    Private Function VerifyHistIdx(sCur As String) As Boolean
    'Confirm LVLoadFolder end hist index points to loaded dir
    If AddBackslash(sCur) = AddBackslash(sHistory(nHistIdx)) Then
        VerifyHistIdx = True
    End If
    End Function
    
    Private Function FileAttribsToSFGAO(dwAtr As FILE_ATTRIBUTES) As SFGAO_Flags
    If (dwAtr And FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY Then FileAttribsToSFGAO = FileAttribsToSFGAO Or SFGAO_FOLDER
    If (dwAtr And FILE_ATTRIBUTE_HIDDEN) = FILE_ATTRIBUTE_HIDDEN Then FileAttribsToSFGAO = FileAttribsToSFGAO Or SFGAO_HIDDEN Or SFGAO_GHOSTED
    If (dwAtr And FILE_ATTRIBUTE_ENCRYPTED) = FILE_ATTRIBUTE_ENCRYPTED Then FileAttribsToSFGAO = FileAttribsToSFGAO Or SFGAO_ENCRYPTED
    If (dwAtr And FILE_ATTRIBUTE_READONLY) = FILE_ATTRIBUTE_READONLY Then FileAttribsToSFGAO = FileAttribsToSFGAO Or SFGAO_READONLY
    If (dwAtr And FILE_ATTRIBUTE_SYSTEM) = FILE_ATTRIBUTE_SYSTEM Then FileAttribsToSFGAO = FileAttribsToSFGAO Or SFGAO_SYSTEM
    End Function
    
    Private Function GetNextTabHandle(hLast As LongPtr, bShift As Boolean) As LongPtr
    'Controls the tab order; takes the last focused tab and returns the next in the cycle, or
    'the previous if needed for Shift+Tab.
    'There's 4 independent tab cycles, the main form, the column popup, the search popup, and
    'the details pane.
    
    Dim tTO() As LongPtr
    Dim nz As Long
    ReDim tTO(0)
    If m_CbType = SBCT_DropdownList Then
        tTO(0) = hCombo
    Else
        tTO(0) = hCBEd
    End If
    If m_UpButton Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hUpButton
    If (m_NavBtnType = SBNB_Normal) And (bBackEnable = True) Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hStdBackButton
    If (m_NavBtnType = SBNB_Normal) And (bEnableFwd = True) Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hStdFwdButton
    If m_ViewButton Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hViewButton
    If m_BookmarkButton Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hBkmButton
    If hSearchBox And (bFlagSearchDisable = False) Then nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = hSearchBox
    nz = nz + 1: ReDim Preserve tTO(nz): tTO(nz) = -1
        
    Dim i As Long, j As Long, k As Long
    For i = 0 To UBound(tTO)
        If tTO(i) = hLast Then
            If bShift Then
                If i = 0& Then
                    GetNextTabHandle = hLVSHdr
                Else
                    GetNextTabHandle = tTO(i - 1)
    '                Debug.Print "i-=" & i
                End If
            Else
                GetNextTabHandle = tTO(i + 1)
    '            Debug.Print "i+=" & i
            End If
            Exit Function
        End If
        
    Next i
    If hLast = hLVS Then
        If bShift Then
            GetNextTabHandle = tTO(UBound(tTO))
        Else
            
            GetNextTabHandle = hLVSHdr
        End If
    End If
    If hLast = hLVSHdr Then
        If bShift Then
            GetNextTabHandle = hLVS
        Else
            GetNextTabHandle = tTO(0)
        End If
    End If
    
    If hLast = hLVC Then
        If bShift Then
            GetNextTabHandle = chkColFilter.hWnd
        Else
            GetNextTabHandle = txtColCX.hWnd
        End If
        Exit Function
    End If
    If hLast = txtColCX.hWnd Then
        If bShift Then
            GetNextTabHandle = hLVC
        Else
            GetNextTabHandle = cmdColOK.hWnd
        End If
        Exit Function
    End If
    If hLast = cmdColOK.hWnd Then
        If bShift Then
            GetNextTabHandle = txtColCX.hWnd
        Else
            GetNextTabHandle = cmdColCancel.hWnd
        End If
        Exit Function
    End If
    If hLast = cmdColCancel.hWnd Then
        If bShift Then
            GetNextTabHandle = cmdColOK.hWnd
        Else
            GetNextTabHandle = chkColFilter.hWnd
        End If
        Exit Function
    End If
    If hLast = chkColFilter.hWnd Then
        If bShift Then
            GetNextTabHandle = cmdColCancel.hWnd
        Else
            GetNextTabHandle = hLVC
        End If
        Exit Function
    End If
    
    If (hSearchBoxAlt <> 0&) And (hLast = hSearchBoxAlt) Then
        If bShift Then
            GetNextTabHandle = chkShFldr.hWnd
        Else
            GetNextTabHandle = cmdStartSearch.hWnd
        End If
        Exit Function
    End If
    If hLast = chkSrSz.hWnd Then
        If bShift Then
            GetNextTabHandle = cmdSrCl.hWnd
        Else
            If chkSrSz.Value = vbChecked Then
                GetNextTabHandle = cbSrSize1.hWnd
            Else
                GetNextTabHandle = cbShType.hWnd
            End If
        End If
        Exit Function
    End If
    If hLast = cbSrSize1.hWnd Then
        If bShift Then
            GetNextTabHandle = chkSrSz.hWnd
        Else
            GetNextTabHandle = txtSrSize1.hWnd
        End If
        Exit Function
    End If
    If hLast = txtSrSize1.hWnd Then
        If bShift Then
            GetNextTabHandle = cbSrSize1.hWnd
        Else
            GetNextTabHandle = cbShType.hWnd
        End If
        Exit Function
    End If
    If hLast = cbShType.hWnd Then
        If bShift Then
            If chkSrSz.Value = vbChecked Then
                GetNextTabHandle = txtSrSize1.hWnd
            Else
                GetNextTabHandle = chkSrSz.hWnd
            End If
        Else
            GetNextTabHandle = chkDate.hWnd
        End If
        Exit Function
    End If
    If hLast = chkDate.hWnd Then
        If bShift Then
            GetNextTabHandle = cbShType.hWnd
        Else
            If chkDate.Value = vbChecked Then
                GetNextTabHandle = cbDateType.hWnd
            Else
                GetNextTabHandle = chkShFldr.hWnd
            End If
        End If
        Exit Function
    End If
    If hLast = cbDateType.hWnd Then
        If bShift Then
            GetNextTabHandle = chkDate.hWnd
        Else
            GetNextTabHandle = cbDateCmp1.hWnd
        End If
        Exit Function
    End If
    If hLast = cbDateCmp1.hWnd Then
        If bShift Then
            GetNextTabHandle = cbDateType.hWnd
        Else
            GetNextTabHandle = hDTSearch1
        End If
        Exit Function
    End If
    If hLast = hDTSearch1 Then
        If bShift Then
            GetNextTabHandle = cbDateCmp1.hWnd
        Else
            GetNextTabHandle = chkShFldr.hWnd
        End If
        Exit Function
    End If
    If hLast = chkShFldr.hWnd Then
        If bShift Then
            If chkDate.Value = vbChecked Then
                GetNextTabHandle = hDTSearch1
            Else
                GetNextTabHandle = chkDate.hWnd
            End If
        Else
            If hSearchBoxAlt Then
                GetNextTabHandle = hSearchBoxAlt
            Else
                GetNextTabHandle = cmdStartSearch.hWnd
            End If
        End If
        Exit Function
    End If
    If hLast = cmdStartSearch.hWnd Then
        If bShift Then
            If hSearchBoxAlt Then
                GetNextTabHandle = hSearchBoxAlt
            Else
                GetNextTabHandle = chkShFldr.hWnd
            End If
        Else
            If cmdSrCn.Enabled = True Then
                GetNextTabHandle = cmdSrCn.hWnd
            Else
                GetNextTabHandle = cmdSrClr.hWnd
            End If
        End If
        Exit Function
    End If
    If hLast = cmdSrCn.hWnd Then
        If bShift Then
            GetNextTabHandle = cmdStartSearch.hWnd
        Else
            GetNextTabHandle = cmdSrClr.hWnd
        End If
        Exit Function
    End If
    If hLast = cmdSrClr.hWnd Then
        If bShift Then
            If cmdSrCn.Enabled = True Then
                GetNextTabHandle = cmdSrCn.hWnd
            Else
                GetNextTabHandle = cmdStartSearch.hWnd
            End If
        Else
            GetNextTabHandle = cmdSrCl.hWnd
        End If
        Exit Function
    End If
    If hLast = cmdSrCl.hWnd Then
        If bShift Then
            GetNextTabHandle = cmdSrClr.hWnd
        Else
            GetNextTabHandle = chkSrSz.hWnd
        End If
        Exit Function
    End If
    
    If m_DtPane Then
        If hLast = cmdPropSave.hWnd Then
            If bShift Then
                For i = UBound(tDispProps) To 0 Step -1
                    If tDispProps(i).hAlt <> 0& Then
                        GetNextTabHandle = tDispProps(i).hAlt
                        Exit Function
                    End If
                    If tDispProps(i).hEdit <> 0& Then
                        GetNextTabHandle = tDispProps(i).hEdit
                        Exit Function
                    End If
                Next i
            Else
                GetNextTabHandle = cmdPropCancel.hWnd
                Exit Function
            End If
        End If
        If hLast = cmdPropCancel.hWnd Then
            If bShift Then
                GetNextTabHandle = cmdPropSave.hWnd
            Else
                GetNextTabHandle = hLVS
            End If
            Exit Function
        End If
        For i = 0 To UBound(tDispProps)
            DebugAppend "i=" & i & ",ub=" & UBound(tDispProps), 2
            If ((tDispProps(i).hEdit <> 0&) And (hLast = tDispProps(i).hEdit)) Or ((tDispProps(i).hAlt <> 0&) And (hLast = tDispProps(i).hAlt)) Then
                If bShift Then
                    If i > 0 Then
                        If tDispProps(i - 1).hAlt <> 0& Then
                            GetNextTabHandle = tDispProps(i - 1).hAlt
                            Exit Function
                        End If
                        If tDispProps(i - 1).hEdit <> 0& Then
                            GetNextTabHandle = tDispProps(i - 1).hEdit
                            Exit Function
                        End If
                    Else
                        GetNextTabHandle = hLVS
                        Exit Function
                    End If
                Else
                    If i < UBound(tDispProps) Then
                        For k = (i + 1) To UBound(tDispProps)
                            If ((tDispProps(k).hAlt <> 0&)) Then
                                GetNextTabHandle = tDispProps(k).hAlt
                                Exit Function
                            End If
                            If ((tDispProps(k).hEdit <> 0&)) Then
                                DebugAppend "Send to " & tDispProps(k).sDispName, 2
                                GetNextTabHandle = tDispProps(k).hEdit
                                Exit Function
                            End If
                        Next k
                        If cmdPropSave.Visible = True Then
                            GetNextTabHandle = cmdPropSave.hWnd
                        Else
                            DebugAppend "Focus To lvs", 2
                            GetNextTabHandle = hLVS
                        End If
                        Exit Function
        
                    Else
                        If cmdPropSave.Visible = True Then
                            GetNextTabHandle = cmdPropSave.hWnd
                        Else
                            DebugAppend "Focus To lvs", 2
                            GetNextTabHandle = hLVS
                        End If
                        Exit Function
                    End If
                    Exit Function
                End If
            End If
            
        Next i
    End If
    End Function
    
    Public Sub SetFocusOnFiles(Optional bSelFirstIfNoPrev As Boolean = False, Optional bSelFirstMustBeFile As Boolean = True)
    'bSelFirstIfNoPrev will select the first item if no item previously had focus
    mSelFirstIfNoPrev = bSelFirstIfNoPrev
    mSelFirstMustBeFile = bSelFirstMustBeFile
    If mTmrProc = 0& Then mTmrProc = AddressOf FocusTimerProc ' scb_SetCallbackAddr(4, 11, , , True)
    SetTimer hLVS, WM_USER + 99, 10, mTmrProc
    End Sub
    
    Private Sub DoSetFocus()
    FastDoEvents 'DoEvents
    SetFocusAPI hLVS
    
    If mSelFirstIfNoPrev Then
        mSelFirstIfNoPrev = False 'Cancel for the next call
        Dim i As Long, j As Long, k As Long
        i = ListView_GetSelectedItem(hLVS)
        If i = LVI_NOITEM Then
            If mSelFirstMustBeFile Then
                Dim lCt As Long
                Dim lp As LongPtr
                lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
                For j = 0 To (lCt - 1)
                    lp = GetLVItemlParam(hLVS, j)
                    If LVEntries(lp).bFolder = False Then
                        k = j
                        Exit For
                    End If
                Next j
            End If
            ListView_SetSelectedItem hLVS, k
        End If
    End If
    End Sub
    
    Public Sub SetFocusOnDropdown()
    If mTmrProc = 0& Then mTmrProc = AddressOf FocusTimerProc ' scb_SetCallbackAddr(4, 11, , , True)
    SetTimer hCombo, WM_USER + 98, 10, mTmrProc
    End Sub
    
    Private Sub DoCBFocus()
    FastDoEvents 'DoEvents
    SetFocusAPI hCombo
    End Sub
    
    Private Sub pvCreateCombo()
    DebugAppend "pvCreateCombo()", 2000
    Dim dwStyle As Long
    dwStyle = WS_CHILD Or WS_VISIBLE Or CBS_AUTOHSCROLL Or WS_TABSTOP
    If (m_CbType = SBCT_Simple) And ((m_Mode <> SBCTL_DirOnly) And (m_Mode <> SBCTL_DrivesOnly) And (m_Mode <> SBCTL_DirOnlyWithCtls)) Then m_CbType = m_def_CbType
    If m_CbType = SBCT_Dropdown Then dwStyle = dwStyle Or CBS_DROPDOWN
    If m_CbType = SBCT_DropdownList Then dwStyle = dwStyle Or CBS_DROPDOWNLIST
    If m_CbType = SBCT_Simple Then dwStyle = dwStyle Or CBS_SIMPLE
    Dim rcuc As RECT
    Dim cbnx As Long, cbny As Long
    GetClientRect UserControl.hWnd, rcuc
    cbnx = (lOffBkBtn) + (lOffFwBtn) + (2 * m_ScaleX)
    Dim cbcy As Long
    If m_CbType = SBCT_Simple Then
        cbcy = rcuc.Bottom - 4
    Else
        cbcy = m_MinDropCY * m_ScaleY
        If (mFixedDropHeight > 0&) Then
            If mFixedDropHeight > m_MinDropCY Then
                cbcy = mFixedDropHeight * m_ScaleY
            End If
        Else
            If (rcuc.Bottom - 12) > cbcy Then cbcy = (rcuc.Bottom - 12)
        End If
    End If
    
    hCombo = CreateWindowExW(WS_EX_NOACTIVATE, StrPtr(WC_COMBOBOXEX), 0, dwStyle, _
                            cbnx, 3 * m_ScaleY, m_MinDropCX, cbcy, _
                            UserControl.hWnd, 0&, App.hInstance, 0&)
    
    hCBBox = SendMessageW(hCombo, CBEM_GETCOMBOCONTROL, 0, ByVal 0&)
    hCBEd = SendMessageW(hCombo, CBEM_GETEDITCONTROL, 0, ByVal 0&)
    
    SendMessageW hCombo, WM_SETFONT, hFontLVMain, ByVal 1&
    
    If m_CbType = SBCT_Simple Then
        'CBEM_GETEDITCONTROL doesn't work when style is CBS_SIMPLE. Nor does GetComboBoxInfo.
        'Only way is to manually find the edit window.
        Dim hBox As LongPtr
        hBox = FindWindowEx(hCombo, 0&, "ComboBox", vbNullString)
        hCBEd = FindWindowEx(hBox, 0, "Edit", vbNullString)
    End If
    If m_Mode = SBCTL_FilesOnly Then ShowWindow hCombo, SW_HIDE
    If (m_EditCB = False) Then
        SendMessage hCBEd, EM_SETREADONLY, 1&, ByVal 0&
    End If
    Call SendMessageW(hCombo, CB_SETDROPPEDWIDTH, m_MinDropCX, ByVal 0&)
    If m_HideComboIcons = False Then
        himlPtr16 = ObjPtr(imlSys16)
        Call SendMessageW(hCombo, CBEM_SETIMAGELIST, 0, ByVal himlPtr16)
    End If
    Dim rc As RECT
    Call GetClientRect(hCombo, rc)
    cyCombo = rc.Bottom + (4 * m_ScaleY)
    DebugAppend "pvCreateCombo cyCombo=" & cyCombo
    cyDefCbo = cyCombo
    'cbny = (cyThemeButtonB - rc.Bottom) / 2
    'Now you would think that's the way you vertically center the combobox relative to the nav buttons
    'You would be wrong.
    'The combobox always gets resized vertically through some mysterious process, which makes the
    'alignment wind up off. I spent hours trying to isolate exactly when and how much this change
    'would occur. First tracked it to CBEM_SETIMAGELIST, which made cy increase. So set that first,
    'then center. Ah but no: After you do that, somewhere else, somehow, cy is reduced, once again
    'throwing off alignment. Absolutely can not track down how, where, or why.
    'So then, just use a base value and scale it for whatever, no?
    'No.
    '3 pixels will not work for 100% scale, it has to be 4.
    'But 4 * scale will not work for >100% scale, it has to be 3 * scale.
    'jfc with this. If your screen/settings still won't align it right after this, go ahead and inform
    'me so that I can proceed to throw myself off the highest building I can find.
    If m_ScaleY = 1 Then
        cbny = 4
    Else
        cbny = 4 * m_ScaleY
    End If
    SetWindowPos hCombo, 0&, cbnx, cbny, 0&, 0&, SWP_NOSIZE Or SWP_NOZORDER
    If m_Mode = SBCTL_FilesOnly Then cyCombo = 0&
    
    If Ambient.UserMode Then
        ' If ssc_Subclass(hCombo, , 4, , , True, True) Then
        '     ssc_AddMsg hCombo, MSG_BEFORE, ALL_MESSAGES
        ' End If
        Subclass2 hCombo, AddressOf CBWndProc, hCombo
        If hCBEd Then
            ' If ssc_Subclass(hCBEd, , 4, , , True, True) Then
            '     ssc_AddMsg hCBEd, MSG_BEFORE, ALL_MESSAGES
            ' End If
            Subclass2 hCBEd, AddressOf CBWndProc, hCBEd
        End If
        EnumRoot
        If m_LockNav Then
            EnableWindow hCombo, 0
        End If
        
        SendMessage hCombo, CBEM_SETEXTENDEDSTYLE, CBES_EX_TEXTENDELLIPSIS, ByVal CBES_EX_TEXTENDELLIPSIS
        If m_CBXNoIcons Then
            SendMessage hCombo, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, ByVal CBES_EX_NOEDITIMAGE
        End If
        
        If (m_CbType = SBCT_Dropdown) Or (m_CbType = SBCT_Simple) Then
            If mAutoComp And m_EditCB Then
                InitAutoComplete
                pAutoComp.Enable 1&
            End If
        End If
    End If
    End Sub
    
    Private Sub pvDrawBack(fState As ucsb_NAV_BB_STATE, Optional bForceRedraw As Boolean = False)
    If fState = iNavStateCur Then
        If bForceRedraw = False Then Exit Sub
    End If
    If (m_Mode <> SBCTL_DirAndFiles) And (m_Mode <> SBCTL_DirOnlyWithCtls) Then Exit Sub
    
    'DebugAppend "pvDrawBack " & fState & "/" & iNavStateCur
    Dim rc As RECT
    rc.Left = 0
    rc.Top = 0
    rc.Right = cxThemeButtonB '* m_ScaleX
    rc.Bottom = cyThemeButtonB '* m_ScaleY
    If m_hBackBtn = pbBackBtn.hWnd Then
        pbBackBtn.Cls
        DrawThemeBackground hThemeNav, pbBackBtn.hDC, NAV_BACKBUTTON, fState, rc, ByVal 0&
        pbBackBtn.Refresh
    ElseIf m_hBackBtn = pbBackBtnAlt.hWnd Then
        pbBackBtnAlt.Cls
        DrawThemeBackground hThemeNav, pbBackBtnAlt.hDC, NAV_BACKBUTTON, fState, rc, ByVal 0&
        pbBackBtnAlt.Refresh
    End If
    iNavStateCur = fState
    End Sub
    Private Sub pvDrawFwd(fState As ucsb_NAV_FB_STATE, Optional bForceRedraw As Boolean = False)
    If fState = iFwdNavStateCur Then
        If bForceRedraw = False Then Exit Sub
    End If
    If (m_Mode <> SBCTL_DirAndFiles) And (m_Mode <> SBCTL_DirOnlyWithCtls) Then Exit Sub
    'DebugAppend "pvDrawBack " & fState & "/" & iNavStateCur
    Dim rc As RECT
    rc.Left = 0
    rc.Top = 0
    rc.Right = cxThemeButtonF '* m_ScaleX
    rc.Bottom = cyThemeButtonF '* m_ScaleY
    If m_hFwdBtn = pbFwdBtn.hWnd Then
        pbFwdBtn.Cls
        DrawThemeBackground hThemeNav, pbFwdBtn.hDC, NAV_FORWARDBUTTON, fState, rc, ByVal 0&
        pbFwdBtn.Refresh
    ElseIf m_hFwdBtn = pbFwdBtnAlt.hWnd Then
        pbFwdBtnAlt.Cls
        DrawThemeBackground hThemeNav, pbFwdBtnAlt.hDC, NAV_FORWARDBUTTON, fState, rc, ByVal 0&
        pbFwdBtnAlt.Refresh
    End If
    iFwdNavStateCur = fState
    End Sub
    
    Private Sub pvCreateSearchBox()
    Dim cyOff As Long
    Dim yOff As Long
    
    Dim dwStyle As WindowStyles
    dwStyle = WS_CHILD Or WS_VISIBLE Or ES_AUTOHSCROLL Or WS_BORDER 'Or WS_TABSTOP
    
    If m_ScaleY > 1 Then
        yOff = 2 * m_ScaleY
        cyOff = 7 * m_ScaleY
    Else
        yOff = 2
        cyOff = 10 * m_ScaleY
    End If
    cyDefSBox = Abs(PropFont.Size) + cyOff + 2
    hSearchBox = CreateWindowExW(0&, StrPtr(WC_EDIT), 0&, dwStyle, 1&, yOff, pbSearchContainer.ScaleWidth - 4, cyDefSBox, _
                                pbSearchContainer.hWnd, 0&, App.hInstance, ByVal 0&)
                                
    'SendMessageW hSearchBox, WM_SETFONT, m_hFontDtTxt, ByVal 1&
    SendMessageW hSearchBox, WM_SETFONT, m_hFontMain, ByVal 1&
    
    If bFlagSearchDisable Then
        EnableWindow hSearchBox, 0&
    End If
                                
    If (hIcoSearchBox16 <> 0) Or (hIcoSearchBox20 <> 0) Or (hIcoSearchBox24 <> 0) Then
        SetEditControlMargin hSearchBox, 0, 22 + (4 * (m_ScaleX - 1))
    End If
    
    If Ambient.UserMode Then
        ' If ssc_Subclass(hSearchBox, , 12, , , True, True) Then
        '     ssc_AddMsg hSearchBox, MSG_BEFORE, WM_NOTIFYFORMAT, WM_LBUTTONDOWN, WM_LBUTTONUP ', WM_SETFOCUS
        '     ssc_AddMsg hSearchBox, MSG_AFTER, ALL_MESSAGES
        ' End If
        Subclass2 hSearchBox, AddressOf SearchBoxWndProc, hSearchBox
    End If
    If Ambient.UserMode Then
        If bSBSC1 = False Then
        'If ssc_Subclass(pbSearchContainer.hWnd, , 16) Then
        '    ssc_AddMsg pbSearchContainer.hWnd, MSG_BEFORE, ALL_MESSAGES
            Subclass2 pbSearchContainer.hWnd, AddressOf SearchEditBkWndProc, pbSearchContainer.hWnd
            bSBSC1 = True
        'End If
        End If
    End If
    PaintIcon hSearchBox
    End Sub
    
    Private Sub pvCreateAltSearchBox()
    Dim cyOff As Long
    Dim yOff As Long
    
    Dim dwStyle As WindowStyles
    dwStyle = WS_CHILD Or WS_VISIBLE Or ES_AUTOHSCROLL Or WS_BORDER 'Or WS_TABSTOP
    
    If m_ScaleY > 1 Then
        yOff = 0
        cyOff = 7 * m_ScaleY
    Else
        yOff = 2
        cyOff = 8 * m_ScaleY
    End If
    DebugAppend "CreateAltSearchBox width=" & pbSearch.Width
    hSearchBoxAlt = CreateWindowExW(0&, StrPtr(WC_EDIT), 0&, dwStyle, 4 * m_ScaleX, chkShFldr.Top + chkShFldr.Height + 6, (pbSearch.Width / Screen.TwipsPerPixelX) - (10 * m_ScaleY), Abs(m_cyFontDtTxt) + cyOff, _
                                pbSearch.hWnd, 0&, App.hInstance, ByVal 0&)
                                
    'SendMessageW hSearchBoxAlt, WM_SETFONT, m_hFontDtTxt, ByVal 1& '
    SendMessageW hSearchBoxAlt, WM_SETFONT, hFontCtl, ByVal 1& '
                              
    If Ambient.UserMode Then
        ' If ssc_Subclass(hSearchBoxAlt, , 15, , , True, True) Then
        '     ssc_AddMsg hSearchBoxAlt, MSG_BEFORE, ALL_MESSAGES 'WM_NOTIFYFORMAT, WM_LBUTTONDOWN, WM_LBUTTONUP ', WM_SETFOCUS
        '     ssc_AddMsg hSearchBoxAlt, MSG_AFTER, ALL_MESSAGES
        ' End If
        Subclass2 hSearchBoxAlt, AddressOf AltSearchBoxWndProc, hSearchBoxAlt
    End If
    
    SendMessage hSearchBoxAlt, EM_SETCUEBANNER, 0&, ByVal StrPtr(mSrchAltCue)
    
    End Sub
    
    Private Sub SetSearchBoxCue()
    On Error GoTo e0
    Dim sCue As String
    Dim cxCue As Long, cxBox As Long, dwMar As Long
    If bFlagSearchDisable = False Then
        'Clear the text when loading a new folder; if it's disabled, we're in a
        'Search Results folder, so leave the search string that produced it up
        SendMessage hSearchBox, WM_SETTEXT, 0&, ByVal 0&
    End If
    sCue = Replace$(mSearchBoxInvite, "%d", m_sCurPathDisp)
    'The cue banner does not respect the edit control margins, therefore
    'we'll need to calculate the widths and if needed compact the path
    'manually. The search box uses the same font as the details pane, so
    'that's a convenient place to get the hDC from
    cxCue = UserControl.TextWidth(sCue)
    dwMar = CLng(SendMessage(hSearchBox, EM_GETMARGINS, 0&, ByVal 0&))
    Dim rc As RECT
    GetClientRect hSearchBox, rc
    cxBox = (rc.Right) - HiWord(dwMar)
    If cxCue > cxBox Then
        If m_ScaleX = 1 Then
            PathCompactPath GetDC(hSearchBox), sCue, cxBox - 8
        Else
            PathCompactPath GetDC(hSearchBox), sCue, cxBox - (8 * m_ScaleX)
        End If
    End If
    SendMessage hSearchBox, EM_SETCUEBANNER, 0&, ByVal StrPtr(sCue)
    Exit Sub
    e0:
        DebugAppend "SetSearchBoxCue->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub SetEditControlMargin(hWnd As LongPtr, iLeftRight As Integer, lMargin As Long)
    If iLeftRight = 0 Then
        Call SendMessage(hWnd, EM_SETMARGINS, EC_LEFTMARGIN, ByVal lMargin)
    Else
        Call SendMessage(hWnd, EM_SETMARGINS, EC_RIGHTMARGIN, ByVal (lMargin * &H10000))
    End If
    End Sub
    
    Private Function IsRootChild(Optional sPath As String = "", Optional siItem As IShellItem) As Boolean
    'Specify either or, not both
    If bWillLoadSearchFt Then IsRootChild = True: Exit Function 'We're adding a Search Result. It won't pass the normal check, but should definitely be a child.
    
    If (siItem Is Nothing) = False Then
        Dim lpName As LongPtr, sName As String
        siItem.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpName
        sName = LPWSTRtoStr(lpName)
        If Left$(sName, Len(mCustomRootCompare)) = mCustomRootCompare Then
            IsRootChild = True
            Exit Function
        End If
    End If
    If sPath <> "" Then
        If Left$(sPath, Len(mCustomRootCompare)) = mCustomRootCompare Then
            IsRootChild = True
            Exit Function
        End If
    End If
    End Function
    
    Private Sub EnumRoot()
    DebugAppend "EnumRoot", 2000
    'Create default view... desktop and computer
    Dim siDesk As IShellItem
    Dim siChild As IShellItem, siChild2 As IShellItem
    Dim pEnum As IEnumShellItems, penum2 As IEnumShellItems
    Dim upi As IParentAndItem
    Dim psf As IShellFolder
    Dim pIcon As IShellIcon
    Dim pIconOvr As IShellIconOverlay
    Dim lpIconOvr As Long, lpIconOvr2 As Long
    Dim pidlDesktop As LongPtr
    Dim pidlPar As LongPtr, pidlRel As LongPtr
    Dim lpIcon As Long
    Dim pcl As Long, pcl2 As Long
    Dim nCur As Long
    Dim lAtr As SFGAO_Flags
    Dim lpName As LongPtr, sName As String
    Dim lpFull As LongPtr, sFull As String
    Dim hr As Long
    On Error GoTo e0
    ReDim cbItems(0)
    cbItems(0).iIndnt = 0
    cbItems(0).sFullPath = "0"
    cbItems(0).lSearchIdx = -1&
    nCur = 1
    If m_CompAsRoot Or (m_Mode = SBCTL_DrivesOnly) Then
        SHGetKnownFolderItem FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siDesk
        DebugAppend "EnumRoot::SetRoot=Computer", 2
    ElseIf mCustomRoot <> "" Then
        Dim lpTemp As LongPtr
        Dim sPath As String
        sPath = mCustomRoot
        DebugAppend "EnumRoot::SetRoot(Custom)=" & mCustomRoot, 2
        If (Left$(sPath, 1) = "%") And (Right$(sPath, 1) = "%") Then
            sPath = Mid$(sPath, 2, Len(sPath) - 2)
            sPath = Environ(sPath)
            DebugAppend "Environ shortcut=" & sPath
        End If
        Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siDesk)
        If m_Mode = SBCTL_DrivesOnly Then
          If Len(sPath) > 3 Then
            If InStr(sPath, ":\") Then
                sPath = Left$(sPath, 3)
                Set siDesk = Nothing
                Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siDesk)
            End If
          End If
        End If
        If (siDesk Is Nothing) Then
            If sPath = sRecentPl Then
                SHGetKnownFolderItem FOLDERID_Recent, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siDesk
            End If
        End If
        If (siDesk Is Nothing) Then
            'See if it's a folder name in the current path; particularly useful for typed navigation in the dir dropdown
            sPath = AddBackslash(m_sCurPath) & sPath
            Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siDesk)
        End If
        If (siDesk Is Nothing) And (Left$(sPath, 3) = "::{") Then
            'virtual item fallback
            Dim sh As String
            sh = "shell:" & sPath
            Call SHCreateItemFromParsingName(StrPtr(sh), Nothing, IID_IShellItem, siDesk)
        End If
        If (siDesk Is Nothing) Then
            Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siDesk)
            DebugAppend "Custom root is not valid, defaulting to Desktop", 2
        End If
        siDesk.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpTemp
        mCustomRootCompare = LPWSTRtoStr(lpTemp)
    Else
        Call SHCreateItemFromIDList(VarPtr(0&), IID_IShellItem, siDesk)
        DebugAppend "EnumRoot::SetRoot=Desktop", 2
    End If
    If (siDesk Is Nothing) = False Then
        DebugAppend "Got siDesk"
        siDesk.GetDisplayName SIGDN_NORMALDISPLAY, lpName
        sName = LPWSTRtoStr(lpName)
        DebugAppend "EnumRoot::sName=" & sName
        Dim pPst As IPersistIDList
        Set pPst = siDesk
        pPst.GetIDList pidlDesktop
        Set upi = siDesk
        upi.GetParentAndItem pidlDesktop, psf, pidlRel
        Dim pUnk As IUnknownUnrestricted
        Set pUnk = psf
        hr = pUnk.QueryInterface(IID_IShellIcon, pIcon)
        lpIcon = -1&
        If hr = S_OK Then
            pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
        Else
            lpIcon = GetFileIconIndexPIDL(pidlDesktop, SHGFI_SMALLICON)
        End If
        If lpIcon = -1 Then
            Dim pidlDesktop2 As LongPtr
            pidlDesktop2 = GetPIDLFromFolderID(hWnd, CSIDL_DESKTOP)
            lpIcon = GetFileIconIndexPIDL(pidlDesktop2, SHGFI_SMALLICON)
            CoTaskMemFree pidlDesktop2
        End If
        cbItems(0).nIcon = lpIcon
        cbItems(0).sDisp = sName
        cbItems(0).bIsDefItem = True
        CBX_InsertItem hCombo, sName, lpIcon
        DebugAppend "Insertitem n=" & sName & ",i=" & lpIcon
        CoTaskMemFree pidlDesktop
        siDesk.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
        If (pEnum Is Nothing) = False Then
            Do While (pEnum.Next(1&, siChild, pcl) = S_OK)
                siChild.GetAttributes SFGAO_FOLDER Or SFGAO_FILESYSANCESTOR Or SFGAO_STREAM, lAtr
                siChild.GetDisplayName SIGDN_NORMALDISPLAY, lpName
                sName = LPWSTRtoStr(lpName)
    '           DebugAppend "Child=" & sName & ",attrib=" & dbg_sfgao_tostring(lAtr), 9
                If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) Then
                
                    siChild.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFull
                    sFull = LPWSTRtoStr(lpFull)
                    Dim fShow As Long: fShow = 1
                    RaiseEvent FilterDropdown(sName, sFull, siChild, fShow)
                    If fShow = 0 Then GoTo nxt
                    If (m_Mode = SBCTL_DrivesOnly) Then
                        If Right$(sFull, 2) <> ":\" Then GoTo nxt
                    End If
                    DebugAppend "Insert n=" & sName & ",full=" & sFull
    '                If (Right$(sFull, 4) = ".zip") Or (Right$(sFull, 4) = ".cab") Then GoTo nxt 'TEMP: GET AROUND THIS ANOTHER WAY
                    If (m_BrowseZip = False) And ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = SFGAO_STREAM) Then GoTo nxt 'Zip folder not folder
                    ReDim Preserve cbItems(nCur)
                    cbItems(nCur).sFullPath = sFull
                    cbItems(nCur).iIndnt = 1
                    cbItems(nCur).lSearchIdx = -1
                    Set upi = siChild
                    upi.GetParentAndItem pidlPar, psf, pidlRel
                    Set pIcon = psf
                    pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
                    On Error Resume Next
                    Set pIconOvr = psf
                    pIconOvr.GetOverlayIndex pidlRel, VarPtr(lpIconOvr)
                    On Error GoTo e0
                    cbItems(nCur).nIcon = lpIcon
                    cbItems(nCur).sDisp = sName
                    cbItems(nCur).bIsDefItem = True
                    CBX_InsertItem hCombo, sName, lpIcon, lpIconOvr, nCur, -1, 1
                    CoTaskMemFree pidlPar
                    nCur = nCur + 1
                    If (UCase$(sFull) = sComp) Or (UCase$(sFull) = sComp2) Or (UCase$(sFull) = sLibRoot) Or (UCase$(sFull) = sLibRoot2) Then
                        'Autoexpand the Computer (drive list etc) and Libraries
    
                                        
    '                    DebugAppend "colstate=" & scolx
                        siChild.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, penum2
                        If (penum2 Is Nothing) = False Then
                            Do While (penum2.Next(1&, siChild2, pcl2) = S_OK)
                                siChild2.GetAttributes SFGAO_FOLDER Or SFGAO_STREAM, lAtr
                                If (lAtr And SFGAO_FOLDER) = SFGAO_FOLDER Then
                                    siChild2.GetDisplayName SIGDN_NORMALDISPLAY, lpName
                                    sName = LPWSTRtoStr(lpName)
                                    siChild2.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFull
                                    sFull = LPWSTRtoStr(lpFull)
                                    fShow = 1
                                    RaiseEvent FilterDropdown(sName, sFull, siChild2, fShow)
                                    If fShow = 0 Then GoTo nxt2
                                    DebugAppend "Insert n=" & sName & ",full=" & sFull
    '                                If (Right$(sFull, 4) = ".zip") Or (Right$(sFull, 4) = ".cab") Then GoTo nxt 'TEMP: GET AROUND THIS ANOTHER WAY
                                    If (m_BrowseZip = False) And ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = SFGAO_STREAM) Then GoTo nxt 'Zip folder not folder
                                    ReDim Preserve cbItems(nCur)
                                    cbItems(nCur).sFullPath = sFull
                                    cbItems(nCur).iIndnt = 2
                                    cbItems(nCur).lSearchIdx = -1
                                    cbItems(nCur).bIsDefItem = True
                                    Set upi = siChild2
                                    upi.GetParentAndItem pidlPar, psf, pidlRel
                                    Set pIcon = psf
                                    pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
                                    On Error Resume Next
                                    Set pIconOvr = psf
                                    pIconOvr.GetOverlayIndex pidlRel, VarPtr(lpIconOvr2)
                                    On Error GoTo e0
                                    cbItems(nCur).nIcon = lpIcon
                                    cbItems(nCur).sDisp = sName
                                    CBX_InsertItem hCombo, sName, lpIcon, lpIconOvr2, nCur, -1, 2
                                    CoTaskMemFree pidlPar
                                    nCur = nCur + 1
                                End If
    nxt2:
                            Loop
                        End If
                    End If
                End If
    nxt:
            Loop
        Else
            DebugAppend "No enum"
        End If
    Else
        DebugAppend "No siDesk"
    End If
    Exit Sub
    e0:
    DebugAppend "EnumRoot->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Function InitCustomSet(sTitle As String, out_idx As Long, Optional nIcon As Long = 0&) As Long
    'Creates a virtual folder entry off of the root where a set of files from multiple locations will reside
    Dim nCur As Long
    If nIcon <= 0& Then
       If nIcon = -1 Then
         Dim lp As LongPtr
         SHGetKnownFolderIDList FOLDERID_SavedSearches, KF_FLAG_DEFAULT, 0&, lp
         nIcon = GetFileIconIndexPIDL(lp, SHGFI_SMALLICON)
       ElseIf nIcon = 0& Then
        nIcon = GetFolderStdIcon()
        End If
    End If
    nCustomSetIcon = nIcon
    
    nCur = UBound(cbItems)
    nCur = nCur + 1
    ReDim Preserve cbItems(nCur)
    cbItems(nCur).sFullPath = "*CUSTOM"
    cbItems(nCur).iIndnt = 0
    cbItems(nCur).nIcon = nIcon
    cbItems(nCur).lSearchIdx = -1
    cbItems(nCur).bNoIdentMembers = True
    cbItems(nCur).sDisp = sTitle
    out_idx = nCur
    InitCustomSet = CBX_InsertItem(hCombo, sTitle, nIcon, , nCur)
    
    End Function
    
    Private Sub FixChildren(sLP As String)
    Dim tCTF() As CBEntry
    Dim i As Long, j As Long, k As Long
    Dim lCnt As Long
    Dim lp As LongPtr
    Dim lIdx As Long
    Dim lInd As Long
    
    ReDim tCTF(0)
    
    lCnt = CLng(SendMessage(hCombo, CB_GETCOUNT, 0&, ByVal 0&))
    
    For i = (lCnt - 1) To 0 Step -1
        lp = GetCBXItemlParam(hCombo, i)
        If PathIsChild(sLP, cbItems(lp).sFullPath) Then
            ReDim Preserve tCTF(k)
            tCTF(k) = cbItems(lp)
            tCTF(k).lKey = CLng(lp)
            cbItems(lp).bDeleted = True
            SendMessage hCombo, CBEM_DELETEITEM, i, ByVal 0&
            k = k + 1
        End If
    Next i
    
    Dim siAdd As IShellItem
    For i = 0 To UBound(tCTF)
    '    DebugAppend "LocateParent for " & GetPathParent(tCTF(i).sFullPath)
    '    lIdx = GetItemIndex(GetPathParent(tCTF(i).sFullPath), lInd)
    '    If lIdx >= 0& Then
    '        lp = GetCBXItemlParam(hCombo, lIdx)
    '        DebugAppend "FixChildren::Insert " & tCTF(i).sDisp & " under " & cbItems(lp).sDisp
    '        CBX_InsertItem hCombo, tCTF(i).sDisp, tCTF(i).nIcon, , tCTF(i).lKey, lIdx + 1, tCTF(i).iIndnt
    '    End If
        SHCreateItemFromParsingName StrPtr(tCTF(i).sFullPath), Nothing, IID_IShellItem, siAdd
        If (siAdd Is Nothing) = False Then
            bSuppress = True
            AddStandardFSItem siAdd, lInd, False
            bSuppress = False
        End If
        Set siAdd = Nothing
    Next i
    
    End Sub
    
    Private Function GetPathParent(sPath As String) As String
    If Len(sPath) > 3 Then
        If InStr(sPath, "\") Then
            GetPathParent = Left$(sPath, InStrRev(sPath, "\") - 1)
        End If
    End If
    If Len(GetPathParent) = 2 Then
        GetPathParent = GetPathParent & "\"
    End If
    End Function
    
    Private Function GetPathRoot(sPath As String) As String
    On Error GoTo e0
    If sPath = "" Then Exit Function
    Dim sTmp As String, s2 As String, s3 As String
    Dim sOut As String
    If Len(sPath) > 3 Then
        If Left$(sPath, 3) = "::{" Then
            If Left$(sPath, Len(sLibRoot2)) = sLibRoot2 Then 'Libraries root is on the local drive
                DebugAppend "Set library drive root " & mWinDrive
                GetPathRoot = mWinDrive
                Exit Function
            End If
        End If
    End If
    If Left$(sPath, 2) = "\\" Then
        'Network path
        'Note: For the purposes this function is used, we recognize the root a \\SERVER if that's the full path
        '      However, when a share is given, \\SERVER\Share, the share is given as the root.
        sTmp = Mid$(sPath, 3)
        If InStr(sTmp, "\") Then
            s2 = Left$(sTmp, InStr(sTmp, "\") - 1)
            s3 = Mid$(sTmp, InStr(sTmp, "\") + 1)
            If InStr(s3, "\") Then
                s3 = Left$(s3, InStr(s3, "\") - 1)
            End If
            sOut = s2 & "\" & s3
        Else
            sOut = sTmp
        End If
        
        
        
        sOut = "\\" & sOut
    Else
        If Len(sPath) > 3 Then
            If InStr(sPath, "\") Then
                sOut = Left$(sPath, InStr(sPath, "\"))
            Else
                sOut = sPath
            End If
        Else
            sOut = sPath
        End If
    End If
    GetPathRoot = sOut
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.GetPathRoot->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    Private Function PathIsChild(sPar As String, sCh As String) As Boolean
    If (sPar <> "") And (sCh <> "") Then
        If Len(sCh) > Len(sPar) Then
            If Left$(sCh, Len(sPar)) = sPar Then
                PathIsChild = True
            End If
        End If
    End If
    End Function
    
    Private Function FileIsExecutable(idx As LongPtr) As Boolean
    Dim sName As String
    Dim sExt As String
    If idx < 0& Then Exit Function
    If LVEntries(idx).bLinkExe = True Then
        FileIsExecutable = True
        Exit Function
    End If
    If Len(LVEntries(idx).sNameFull) > Len(LVEntries(idx).sName) Then
        sName = LVEntries(idx).sNameFull
    Else
        sName = LVEntries(idx).sName
    End If
    If Len(sName) < 4 Then Exit Function
    If InStr(sName, ".") Then
        sExt = Right$(sName, Len(sName) - InStrRev(sName, "."))
        FileIsExecutable = ExtIsExe(LCase$(sExt))
    End If
        
        
    End Function
    Private Function ExtIsExe(sExt As String) As Boolean
    If (sExt = "exe") Or (sExt = "bat") Or (sExt = "com") Or (sExt = "scr") Or (sExt = "scf") Then
        ExtIsExe = True
    End If
    End Function
    
    Public Sub AppendCustomFolder(sFullPath As String)
    'Add an additional file to a currently displayed custom file set
    Dim i As Long
    Dim siFile As IShellItem
    If ((UBound(sCustomSet) = 0) And (sCustomSet(0) = "")) Then Exit Sub
    
    i = UBound(sCustomSet) + 1
    ReDim Preserve sCustomSet(i)
    sCustomSet(i) = sFullPath
    nCustomSet = i
    
    Set siFile = Nothing
    Call SHCreateItemFromParsingName(StrPtr(sCustomSet(i)), Nothing, IID_IShellItem, siFile)
    If (siFile Is Nothing) = False Then
        LVAddEntry siFile, , , True
    End If
    
    End Sub
    
    Public Function DisplayCustomFolder() As Boolean
    If nCustomSet >= 0& Then
        PopulateCustomSet
        DisplayCustomFolder = True
    End If
    End Function
    
    Public Sub CreateCustomFolder(sTitle As String, sFullPaths() As String, Optional nIcon As Long = 0&, Optional lpapk As LongPtr = 0, Optional npk As Long = 0&)
    'Creates a virtual folder containing any group of files from anywhere on the system; e.g. like showing search results
    If bBlockLoad Then Exit Sub
            '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    'Clear any old preview
    Set pbPreviewPane.Picture = Nothing
    If (ipv Is Nothing) = False Then
        Set pPvhVis = Nothing
        ipv.Unload
    End If
    
    If (UBound(sFullPaths) = 0) And (PathFileExistsW(StrPtr(sFullPaths(0))) = 0&) Then
        'Remove set
        ReDim sCustomSet(0)
        nCustomSet = -1&
        nCustomSetIcon = 0&
        Call SendMessage(hCombo, CBEM_DELETEITEM, lCustomSetIdx, ByVal 0&)
        lCustomSetIdx = 0&
        bFlagCustomFolderHasColSet = False
        Exit Sub
    End If
    Dim bGotName As Boolean
    
    If npk > 0 Then
        Dim pks() As PROPERTYKEY
        Dim lcs() As Long
        Dim j As Long, k As Long
        ReDim pks(npk - 1)
        CopyMemory pks(0), ByVal lpapk, npk * LenB(pks(0))
        Dim i As Long
        For i = 0 To UBound(pks)
            If IsEqualPKEY(pks(i), PKEY_ItemNameDisplay) Then
                bGotName = True
                Exit For
            End If
        Next i
        If bGotName Then
            ReDim lcs(npk - 1)
        Else
            ReDim lcs(npk)
            lcs(0) = lDefColIdx(0)
            k = 1
        End If
        For i = 0 To UBound(pks)
            j = LookupColFromPK2(pks(i))
            If j >= 0 Then
                lcs(k) = j
                k = k + 1
            End If
        Next i
        bFlagCustomFolderHasColSet = True
    End If
    
    Dim lLoc As Long
    lCustomSetIdx = InitCustomSet(sTitle, lLoc, nIcon)
    Call SendMessage(hCombo, CB_SETCURSEL, lCustomSetIdx, ByVal 0&)
     
    sCustomSet = sFullPaths
    nCustomSet = UBound(sCustomSet)
    
    bFlagNoIndent = True
    PopulateCustomSet
    bFlagNoIndent = False
    
    If npk > 0 Then
        cbItems(lLoc).lColSet = lcs
        UpdateColumns lLoc
    End If
    '<EhFooter>
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.CreateCustomFolder->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Sub PopulateCustomSet()
    Dim i As Long
    Dim siFile As IShellItem
    StopNotify
    bCustActive = True
    'First clear the current items
    If (pLVF Is Nothing) = False Then
        If bFooterDoReload Then
            FooterRemove
        Else
            pLVF.RemoveAllButtons
        End If
        Set pLVF = Nothing
    End If
    Call SendMessage(hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&)
    If bThumbsActive Then
        ImageList_Remove himl_Thumb, -1
    End If
    nCurFolders = 0
    nCurFiles = 0
    ReDim LVEntries(0)
    mOvrMax = 0
    sSelectedFile = ""
    tSelectedFile.sName = ""
    tSelectedFile.sFullPath = ""
    ReDim sSelectedFiles(0)
    ReDim tSelectedFiles(0)
    ReDim sSelectedFileNames(0)
    ReDim sSelectedFilesOnly(0)
    ReDim sSelectedFilesOnlyFull(0)
    ReDim sSelectedFoldersOnly(0)
    ReDim sSelectedFoldersOnlyFull(0)
    Set siFocus = Nothing
    m_CurSize = 0
    Dim sPath As String
    sPath = "*CUSTOM"
    If sPath <> m_sCurPath Then 'if equal it's a refresh, so don't duplicate in history
            sPrevPath = m_sCurPath
            m_sCurPath = sPath
    End If
    
    For i = 0 To UBound(sCustomSet)
        Set siFile = Nothing
        Call SHCreateItemFromParsingName(StrPtr(sCustomSet(i)), Nothing, IID_IShellItem, siFile)
        If (siFile Is Nothing) = False Then
            LVAddEntry siFile, , , True
        End If
    Next i
    m_sCurPath = sPath
    If mPlaySnd Then
        If bSoundNavigate Then DoSound SND_NAVIGATESTART
    End If
    
    Call SHGetDesktopFolder(psfCur)
    pvCreateDetailPaneBkg
    End Sub
    
    Public Sub ExecFileSearch(sPattern As String)
    If bBlockLoad Then Exit Sub
    mSpec = sPattern
    'DoFileSearch 'Old method is deprecated but not removed yet if you want to switch it back.
    
    Dim pName As ICondition
    Dim pFact As IConditionFactory2
    Set pFact = New ConditionFactory
        
    If (pFact Is Nothing) = False Then
        Dim nCOP As CONDITION_OPERATION
        
        'First, set Name
        If (sPattern <> "") And (sPattern <> "*.*") And (sPattern <> "*") Then 'Only create a condition if it's not 'All Files'
            If InStr(sPattern, "*") Or InStr(sPattern, "?") Then
                nCOP = COP_DOSWILDCARDS
            Else
                nCOP = COP_VALUE_CONTAINS
            End If
            pFact.CreateStringLeaf PKEY_ItemNameDisplay, nCOP, StrPtr(sPattern), 0&, CONDITION_CREATION_DEFAULT, IID_ICondition, pName
            mSearchTextCache = sPattern
            If (pName Is Nothing) = False Then
                ExecFileSearchEx siCurPath, pName
            Else
                DebugAppend "ExecFileSearch->Failed to create condition."
            End If
        End If
    Else
        DebugAppend "ExecFileSearch->Failed to create condition factory."
    End If
    End Sub
    
    Public Sub ExecFileSearchExB(sPattern As String, psiaScope As IShellItemArray)
    If bBlockLoad Then Exit Sub
    mSpec = sPattern
    'DoFileSearch 'Old method is deprecated but not removed yet if you want to switch it back.
    
    Dim sPath As String, sSFolder As String
    Dim pName As ICondition
    Dim pFact As IConditionFactory2
    Set pFact = New ConditionFactory
       
    If (pFact Is Nothing) = False Then
        Dim nCOP As CONDITION_OPERATION
        
        'First, set Name
        If (sPattern <> "") And (sPattern <> "*.*") And (sPattern <> "*") Then 'Only create a condition if it's not 'All Files'
            If InStr(sPattern, "*") Or InStr(sPattern, "?") Then
                nCOP = COP_DOSWILDCARDS
            Else
                nCOP = COP_VALUE_CONTAINS
            End If
            pFact.CreateStringLeaf PKEY_ItemNameDisplay, nCOP, StrPtr(sPattern), 0&, CONDITION_CREATION_DEFAULT, IID_ICondition, pName
            mSearchTextCache = sPattern
            
            If (pName Is Nothing) = False Then
                Dim pSearchFact As ISearchFolderItemFactory
                Set pSearchFact = New SearchFolderItemFactory
                sSFolder = mLibRootDisp
                If nsiSearch > 0 Then
                    sSFolder = SearchGetDispIdx(sSFolder)
                End If
                Dim piaScope As IShellItemArray
                pSearchFact.SetScope piaScope
                pSearchFact.SetDisplayName StrPtr(mFldrSrch & sSFolder)
                If nsiSearch = 0 Then
                    ReDim psiSearch(0)
                    nsiSearch = 1
                Else
                    ReDim Preserve psiSearch(nsiSearch)
                    nsiSearch = nsiSearch + 1
                End If
                pSearchFact.SetCondition pName
                RaiseEvent FileSearchStart(mSearchTextCache, pName, sPath, piaScope)
                pSearchFact.GetShellItem IID_IShellItem, psiSearch(nsiSearch - 1).siSearch
                If (psiSearch(nsiSearch - 1).siSearch Is Nothing) = False Then
                    pSearchFact.GetIDList psiSearch(nsiSearch - 1).pidl
                    psiSearch(nsiSearch - 1).sPath = sPath
                    psiSearch(nsiSearch - 1).sDisp = sSFolder
                    psiSearch(nsiSearch - 1).lParam = nsiSearch - 1
                    bUseSearchMarkup = True
                    SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
                    bWillLoadSearchFt = True
                    Set siDirect = psiSearch(nsiSearch - 1).siSearch
                    bFlagNoIndent = True
                    LVLoadFolder "", True, , , , nsiSearch - 1
                    bFlagNoIndent = False
    '                If mFtrPostSearch Then FooterAddSearchDone
                    UpdateStatus mSearchDone
                    Set mCacheSearchCond = pName
    '                dbg_OpenCommonFileDialogTo psiSearch(nsiSearch - 1)
                Else
                    DebugAppend "ExecSearch->Failed to get IShellItem from search factory", 11
                End If
                Set pName = Nothing
            Else
                DebugAppend "ExecFileSearch->Failed to create condition."
            End If
        End If
    Else
        DebugAppend "ExecFileSearch->Failed to create condition factory."
    End If
    End Sub
    
    
    Private Sub DoFileSearch()
    If bBlockLoad Then Exit Sub
    'DEPRECATED
    'Leaving this code here for now, but it's no longer active.
    'See the ExecSearch sub for the new search method, which is far superior
    Dim psi As IShellItem
    Dim piesi As IEnumShellItems
    Dim isia As IShellItemArray
    'Dim pidl As LongPtr
    Dim pFile As IShellItem
    Dim lpName As LongPtr, lpFolder As LongPtr
    Dim sName As String, sFolder As String
    Dim sDisp As String
    Dim pcl As Long
    Dim sTarget As String
    Dim sStart As String
    Dim lAtr As SFGAO_Flags
    Dim i As Long
    
    If lCustomSetIdx Then
        'Remove set - Can't have a custom dir and a search results dir at the same time
        ReDim sCustomSet(0)
        nCustomSet = -1&
        nCustomSetIcon = 0&
        Call SendMessage(hCombo, CBEM_DELETEITEM, lCustomSetIdx, ByVal 0&)
        lCustomSetIdx = 0&
    End If
    
    ReDim sTmpSearchSet(0)
    kTmpSearchCt = 0
    'pidl = ILCreateFromPathW(StrPtr(Text1.Text))
    'SHCreateItemFromIDList pidl, IID_IShellItem, psi
    siCurPath.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, piesi
    If (piesi Is Nothing) Then
        DebugAppend "DFS:No enum"
        Exit Sub
    End If
    Do While piesi.Next(1&, pFile, pcl) = S_OK
        pFile.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFolder
        pFile.GetAttributes SFGAO_FOLDER Or SFGAO_DROPTARGET Or SFGAO_STREAM, lAtr
        If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0&) Then 'folder but not zip
            If (lAtr And SFGAO_DROPTARGET) = SFGAO_DROPTARGET Then
                UpdateStatus mSearchCD & LPWSTRtoStr(lpFolder)
                ScanDeep pFile
            End If
        Else
            pFile.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpName
            sName = LPWSTRtoStr(lpName)
            sDisp = Right$(sName, Len(sName) - InStrRev(sName, "\"))
            If PathMatchSpecW(StrPtr(sDisp), StrPtr(mSpec)) Then
                DebugAppend "Found match: " & sName
                ReDim Preserve sTmpSearchSet(kTmpSearchCt)
                sTmpSearchSet(kTmpSearchCt) = sName
                kTmpSearchCt = kTmpSearchCt + 1
                If kTmpSearchCt = 1 Then
                   CreateCustomFolder mSrchResStr, sTmpSearchSet, -1&
                   FastDoEvents 'DoEvents
                   AddColumn "System.ItemFolderPathDisplayNarrow"
                   FastDoEvents 'DoEvents
                ElseIf kTmpSearchCt > 1 Then
                   AppendCustomFolder sName
                   FastDoEvents 'DoEvents
                End If
            End If
            sDisp = ""
        End If
    Loop
    'Call CoTaskMemFree(pidl)
    pvCreateDetailPaneBkg
    'If (UBound(sTmpSearchSet) = 0) And (sTmpSearchSet(0) = "") Then
    '    Beep
    '    UpdateStatus mNoResStr
    'End If
    UpdateStatus mSearchDone
    End Sub
    
    Private Sub ScanDeep(psiLoc As IShellItem)
    'for recursive scan
    Dim piesi As IEnumShellItems
    Dim pFile As IShellItem
    Dim lpName As LongPtr
    Dim sName As String
    Dim sDisp As String
    Dim pcl As Long
    Dim lAtr As SFGAO_Flags
    
    '
    'If UBound(sTmpSearchSet) = 0 Then
    '    If sTmpSearchSet(0) = "" Then
    '        i = 0
    '    Else
    '        i = 1
    '    End If
    'Else
    '    i = UBound(sTmpSearchSet) + 1
    'End If
    
    psiLoc.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, piesi
    Do While piesi.Next(1&, pFile, pcl) = S_OK
        pFile.GetAttributes SFGAO_FOLDER Or SFGAO_DROPTARGET Or SFGAO_STREAM, lAtr
        If ((lAtr And SFGAO_FOLDER) = SFGAO_FOLDER) And ((lAtr And SFGAO_STREAM) = 0&) Then 'folder but not zip
            If (lAtr And SFGAO_DROPTARGET) = SFGAO_DROPTARGET Then
                pFile.GetDisplayName SIGDN_FILESYSPATH, lpName
                UpdateStatus mSearchCD & LPWSTRtoStr(lpName)
                ScanDeep pFile
            End If
        Else
            pFile.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpName
            sName = LPWSTRtoStr(lpName)
            sDisp = Right$(sName, Len(sName) - InStrRev(sName, "\"))
            If PathMatchSpecW(StrPtr(sDisp), StrPtr(mSpec)) Then
                DebugAppend "Found match: " & sName
                ReDim Preserve sTmpSearchSet(kTmpSearchCt)
                sTmpSearchSet(kTmpSearchCt) = sName
                kTmpSearchCt = kTmpSearchCt + 1
                If kTmpSearchCt = 1 Then
                   CreateCustomFolder mSrchResStr, sTmpSearchSet, -1&
                   FastDoEvents 'DoEvents
                   AddColumn "System.ItemFolderPathDisplayNarrow"
                   FastDoEvents 'DoEvents
                ElseIf kTmpSearchCt > 1 Then
                   AppendCustomFolder sName
                   FastDoEvents 'DoEvents
                End If
            End If
        End If
    Loop
    End Sub
    
    Private Function GetPKeyFromSysName(szSys As String) As PROPERTYKEY
    PSGetPropertyKeyFromName StrPtr(szSys), GetPKeyFromSysName
    End Function
    
    Private Function ProcessColumns(siItem As IShellItem) As Long
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim psv As IShellView
    Dim pfv As IFolderView
    Dim lCEn As Long
    Dim i As Long, j As Long
    Dim lpPath As LongPtr, sPath As String
    siItem.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpPath
    sPath = LPWSTRtoStr(lpPath)
    If bKeepColumns Then
        For i = 0 To UBound(cbItems)
            If (cbItems(i).sFullPath = sPath) And (cbItems(i).bDeleted = False) Then
                cbItems(i).lColSet = lKeepColSet
                SetColumns i
                Exit Function
            End If
        Next i
    End If
    
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = sPath) And (cbItems(i).bDeleted = False) Then
            If cbItems(i).bUseColset Then
                DebugAppend "ProcessColumns: Skip load, bUseColSet for " & sPath & ", nColData=" & UBound(uColData) & ", nVisMap=" & UBound(cbItems(i).bUCDVisMap)
                If UBound(cbItems(i).bUCDVisMap) <> UBound(uColData) Then
                    DebugAppend "ProcessColumns->Warning: Bad visibility map, reloading"
                    GoTo outcol
                End If
                For j = 0 To UBound(uColData)
                    'we're restoring the column data visibility so the old folder doesn't control the Column Select box
                    uColData(j).NoList = cbItems(i).bUCDVisMap(j)
                Next j
                SetColumns i
                Exit Function
            End If
    outcol:
            lCEn = i
            Exit For
        End If
    Next i
    procfull:
    DebugAppend "ProcessColumns pathidx=" & lCEn
    DebugAppend "ub=" & UBound(cbItems) & "last=" & cbItems(UBound(cbItems)).sFullPath & ",cur=" & sPath
    'Set defaults in case any of the below fails
    ReDim cbItems(lCEn).lColSet(UBound(lFBCol))  'set fallback columns to user selected defaults
    For i = 0 To UBound(lFBCol)
        cbItems(lCEn).lColSet(i) = lFBCol(i)
    Next i
    cbItems(lCEn).bUseColset = True
    If m_ColLock <> SBCL_None Then 'dont load explorer default columns
        SetColumns lCEn
        Exit Function
    End If
    If Right$(sPath, 11) = ".library-ms" Then
        'While library subfolders display custom headers, the virtual object won't
        'but Explorer does, and we're mimicing Explorer, so instead use the columns
        'of its default save folder, which should have the custom set for content type
        Dim pSL As ShellLibrary
        Set pSL = New ShellLibrary
        Dim siLibDef As IShellItem
        pSL.LoadLibraryFromItem siItem, STGM_READ
        pSL.GetDefaultSaveFolder DSFT_DETECT, IID_IShellItem, siLibDef
        If (siLibDef Is Nothing) = False Then
            siLibDef.BindToHandler 0&, BHID_SFViewObject, IID_IShellView, psv
        End If
    End If
    If (psv Is Nothing) Then
        siItem.BindToHandler 0&, BHID_SFViewObject, IID_IShellView, psv
    End If
    If (psv Is Nothing) = False Then
        DebugAppend "MyComp::Get ShellView"
        Set pfv = psv
        If (pfv Is Nothing) = False Then
            DebugAppend "MyComp::Get FolderView"
            Dim pcolmg As IColumnManager
            Set pcolmg = pfv
            If (pcolmg Is Nothing) = False Then
                Dim ccxt As Long
                pcolmg.GetColumnCount CM_ENUM_VISIBLE, ccxt
                DebugAppend "Got colmgt,ct=" & ccxt
                Dim ccit As Long
                Dim cpk() As PROPERTYKEY
                Dim tCI As CM_COLUMNINFO
                Dim szCCNm As String
                Dim ucl As Long
                Dim lppk As LongPtr
                
                ReDim cpk(ccxt - 1)
                
    'Shouldn't be needed: ClearCustomPKEYs
                
                pcolmg.GetColumns CM_ENUM_VISIBLE, cpk(0), ccxt
                cbItems(lCEn).bUseColset = True
                If ccxt < 1 Then
                    'failed to get specific default columns, use default
                    '(moved to above in case of failure to even get this far)
                Else
    '                If (sPath = sComp) Or (sPath = sComp2) Then
                        If bForceAddPercentFull Then
                            For ccit = 1 To ccxt
                                If IsEqualPKEY(cpk(ccit - 1), PKEY_FreeSpace) Then
                                    
                                    ReDim Preserve cpk(UBound(cpk) + 1)
                                    cpk(UBound(cpk)) = PKEY_PercentFull
                                    ccxt = ccxt + 1
                                    If m_ViewMode = SB_VIEW_TILE Then
                                        ReDim Preserve cpk(UBound(cpk) + 1)
                                        cpk(UBound(cpk)) = PKEY_Computer_DecoratedFreeSpace
                                        ccxt = ccxt + 1
                                    End If
                                    cbItems(lCEn).bHasProgress = True
                                    Exit For
                                
                                End If
                            Next ccit
                            
                        End If
    '                End If
                    ReDim cbItems(lCEn).lColSet(ccxt - 1)
                    For ccit = 1 To ccxt
                        'DebugAppend "VisPkey=" & Hex$(cpk(ccit - 1).fmtid.Data1)
                        ucl = LookupColFromPK(cpk(ccit - 1).fmtid, cpk(ccit - 1).pid)
                        cbItems(lCEn).lColSet(ccit - 1) = ucl
                        PSGetNameFromPropertyKey cpk(ccit - 1), lppk
                        DebugAppend ucl & " NameLookup=" & LPWSTRtoStr(lppk)
                        If (ucl = -1) Then
                            DebugAppend "ProcessColumns(ENUM_VIS)::Unknown PKEY, reading data for custom..."
                            ZeroMemory tCI, LenB(tCI) 'otherwise old name data corrupts the new name
                            tCI.cbSize = LenB(tCI)
                            tCI.dwMask = CM_MASK_NAME Or CM_MASK_DEFAULTWIDTH Or CM_MASK_STATE Or CM_MASK_IDEALWIDTH Or CM_MASK_WIDTH
                            pcolmg.GetColumnInfo cpk(ccit - 1), tCI
                            szCCNm = WCHARtoSTR(tCI.wszName)
                            DebugAppend "ColumnInfo::cb=" & tCI.cbSize & ",mask=0x" & Hex$(tCI.dwMask) & ",state=0x" & Hex$(tCI.dwState) & ",cxDef=" & tCI.uDefaultWidth & ",cxIdeal=" & tCI.uIdealWidth & ",cx=" & tCI.uWidth & ",name=" & szCCNm
                            If szCCNm <> "" Then
                                If (tCI.dwState And CM_STATE_VISIBLE) = CM_STATE_VISIBLE Then
                                    ucl = AppendCustomPKEY(cpk(ccit - 1), tCI.uDefaultWidth, tCI.dwState, szCCNm, sPath)
                                    cbItems(lCEn).lColSet(ccit - 1) = ucl
                                End If
                            End If
                        Else
                            If uColData(ucl).bFlagCustom Then 'custom flags reuse PKEYs for unrelated properties; update entry
                                ZeroMemory tCI, LenB(tCI)
                                tCI.cbSize = LenB(tCI)
                                tCI.dwMask = CM_MASK_NAME Or CM_MASK_DEFAULTWIDTH Or CM_MASK_STATE Or CM_MASK_IDEALWIDTH Or CM_MASK_WIDTH
                                pcolmg.GetColumnInfo cpk(ccit - 1), tCI
                                szCCNm = WCHARtoSTR(tCI.wszName)
                                If (szCCNm <> "") And (szCCNm <> uColData(ucl).szDisplayName) Then
                                    uColData(ucl).szDisplayName = szCCNm
                                    uColData(ucl).dwCustColState = tCI.dwState
                                    uColData(ucl).ColVis = True
                                    uColData(ucl).szCustomFor = sPath
                                End If
                            End If
                        End If
                    Next
                End If
                For i = 0 To UBound(uColData)
                    uColData(i).NoList = True
                Next i
                pcolmg.GetColumnCount CM_ENUM_ALL, ccxt
                ReDim cpk(ccxt - 1)
                pcolmg.GetColumns CM_ENUM_ALL, cpk(0), ccxt
                    For ccit = 1 To ccxt
    '                    DebugAppend "VisPkey=" & dbg_PKEYToString(cpk(ccit - 1))
                        ucl = LookupColFromPK(cpk(ccit - 1).fmtid, cpk(ccit - 1).pid)
                        PSGetNameFromPropertyKey cpk(ccit - 1), lppk
                        If ccit < 20 Then DebugAppend ucl & " NameLookup=" & LPWSTRtoStr(lppk)
                        If (ucl = -1) Then
                            DebugAppend "ProcessColumns(ENUM_ALL)::Unknown PKEY, reading data for custom..."
                            ZeroMemory tCI, LenB(tCI)
                            tCI.cbSize = LenB(tCI)
                            tCI.dwMask = CM_MASK_NAME Or CM_MASK_DEFAULTWIDTH Or CM_MASK_STATE Or CM_MASK_IDEALWIDTH Or CM_MASK_WIDTH
                            pcolmg.GetColumnInfo cpk(ccit - 1), tCI
                            szCCNm = WCHARtoSTR(tCI.wszName)
                            DebugAppend "ColumnInfo::cb=" & tCI.cbSize & ",mask=0x" & Hex$(tCI.dwMask) & ",state=0x" & Hex$(tCI.dwState) & ",cxDef=" & tCI.uDefaultWidth & ",cxIdeal=" & tCI.uIdealWidth & ",cx=" & tCI.uWidth & ",name=" & szCCNm
                            If szCCNm <> "" Then
                                ucl = AppendCustomPKEY(cpk(ccit - 1), tCI.uDefaultWidth, tCI.dwState, szCCNm, sPath)
                                uColData(ucl).NoList = False
                            End If
                        ElseIf (ucl > UBound(uColData)) Then
                            DebugAppend "ucl>ub"
                        Else
                            If uColData(ucl).bFlagCustom Then 'custom flags reuse PKEYs for unrelated properties; update entry
                                ZeroMemory tCI, LenB(tCI)
                                tCI.cbSize = LenB(tCI)
                                tCI.dwMask = CM_MASK_NAME Or CM_MASK_DEFAULTWIDTH Or CM_MASK_STATE Or CM_MASK_IDEALWIDTH Or CM_MASK_WIDTH
                                pcolmg.GetColumnInfo cpk(ccit - 1), tCI
                                szCCNm = WCHARtoSTR(tCI.wszName)
                                If (szCCNm <> "") And (szCCNm <> uColData(ucl).szDisplayName) Then
                                    uColData(ucl).szDisplayName = szCCNm
                                    uColData(ucl).dwCustColState = tCI.dwState
                                    uColData(ucl).ColVis = False
                                    uColData(ucl).szCustomFor = sPath
                                End If
                            End If
                            uColData(ucl).NoList = False
    '                        DebugAppend "FullColSet->" & uColData(ucl).szDisplayName & "=" & uColData(ucl).szSystemName
                        End If
                    Next ccit
                ReDim cbItems(lCEn).bUCDVisMap(UBound(uColData))
                For i = 0 To UBound(uColData)
                    cbItems(lCEn).bUCDVisMap(i) = uColData(i).NoList
                Next i
    
                SetColumns lCEn
            End If
        End If
    End If
    
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.ProcessColumns->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function EnumComputerPaths(siaComp As IShellItemArray) As Long
    'Returns the paths of local hard drives. Excludes various virtual objects sometimes listed in Computer
    Dim pEnum As IEnumShellItems
    Dim siComp As IShellItem
    Dim kfm As KnownFolderManager
    Set kfm = New KnownFolderManager
    Dim kfComp As IKnownFolder
    Dim siChild As IShellItem
    Dim upi As IParentAndItem
    Dim pidlAr() As LongPtr, pidl1 As LongPtr, pidl2 As LongPtr, cItems As Long
    Dim psf As IShellFolder
    Dim pcl As Long
    Dim sPath As String, lpPath As LongPtr
    ReDim pidlAr(0)
    kfm.GetFolder FOLDERID_ComputerFolder, kfComp
    If (kfComp Is Nothing) = False Then
        kfComp.GetShellItem KF_FLAG_DEFAULT, IID_IShellItem, siComp
        If (siComp Is Nothing) = False Then
            siComp.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
            If (pEnum Is Nothing) = False Then
                Do While (pEnum.Next(1&, siChild, pcl) = S_OK)
                    siChild.GetDisplayName SIGDN_FILESYSPATH, lpPath
                    sPath = LPWSTRtoStr(lpPath)
                    If Len(sPath) = 3 Then
                        If Right$(sPath, 2) = ":\" Then
                            Set upi = siChild
                            upi.GetParentAndItem pidl1, psf, pidl2
                            ReDim Preserve pidlAr(cItems)
                            pidlAr(cItems) = pidl2
                            cItems = cItems + 1
                        End If
                    End If
                Loop
            Else
                EnumComputerPaths = -1
            End If
        Else
            EnumComputerPaths = -2
        End If
    Else
        EnumComputerPaths = -3
    End If
    
    If cItems > 0& Then
        SHCreateShellItemArray 0&, psf, cItems, ByVal VarPtr(pidlAr(0)), siaComp
    Else
        EnumComputerPaths = -4
    End If
    
    End Function
    
    Private Function EnumRecentPlacesPaths(siaRecent As IShellItemArray) As Long
    Dim siPl As IShellItem
    Dim pEnum As IEnumShellItems
    Dim siChild As IShellItem
    Dim siTar As IShellItem
    Dim upi As IParentAndItem
    Dim psf As IShellFolder
    Dim pidl1 As LongPtr, pidl2 As LongPtr
    Dim sTar As String
    Dim pidl As LongPtr
    Dim pcl As Long
    Dim pidlAr() As LongPtr, cItems As Long
    On Error GoTo e0
    DebugAppend "EnumRecentPlacesPaths->Entry"
    SHCreateItemFromParsingName StrPtr("shell:::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}"), Nothing, IID_IShellItem, siPl
    If (siPl Is Nothing) = False Then
        siPl.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
        If (pEnum Is Nothing) = False Then
            Do While (pEnum.Next(1&, siChild, pcl) = S_OK)
                sTar = ""
                pidl = 0
                pidl = GetLinkTargetPIDL(siChild)
                If pidl Then
                    ReDim Preserve pidlAr(cItems)
                    pidlAr(cItems) = pidl
                    cItems = cItems + 1
                Else
                    sTar = GetLinkTargetPP(siChild)
                    If sTar <> "" Then
                        SHCreateItemFromParsingName StrPtr(sTar), Nothing, IID_IShellItem, siTar
                        If (siTar Is Nothing) = False Then
                            Set upi = siTar
                            upi.GetParentAndItem pidl1, psf, pidl2
                            pidl = ILCombine(pidl1, pidl2)
                            ReDim Preserve pidlAr(cItems)
                            pidlAr(cItems) = pidl
                            cItems = cItems + 1
                        End If
                    End If
                End If
            Loop
        Else
            DebugAppend "EnumRecentPlacesPaths->No enum"
            EnumRecentPlacesPaths = -1
        End If
    Else
        DebugAppend "EnumRecentPlacesPaths->No item"
        EnumRecentPlacesPaths = -2
    End If
    
    If cItems > 0 Then
        SHCreateShellItemArrayFromIDLists cItems, ByVal VarPtr(pidlAr(0)), siaRecent
    Else
        EnumRecentPlacesPaths = -3
    End If
    Exit Function
    e0:
        DebugAppend "EnumRecentPlacesPaths->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
                
    Private Function EnumLibraryPaths(siaLibs As IShellItemArray) As Long
    'You can't search the library root directly, but you can list all libraries and their folders
    DebugAppend "EnumLibraryPaths->Entry"
    Dim pSL As IShellLibrary
    Set pSL = New ShellLibrary
    Dim siLibRoot As IShellItem
    Dim pEnum As IEnumShellItems
    Dim pcl As Long, pcl2 As Long
    Dim siLibItem As IShellItem
    Dim kfm As KnownFolderManager
    Set kfm = New KnownFolderManager
    Dim kfLib As IKnownFolder
    Dim pidlCol() As LongPtr, cItems As Long
    Dim upi As IParentAndItem
    Dim psf As IShellFolder
    Dim siaLib As IShellItemArray
    Dim pEnumLib As IEnumShellItems
    Dim siLibFolder As IShellItem
    Dim pidl1 As LongPtr, pidl2 As LongPtr
    Dim sln As String, lpn As LongPtr
    
    ReDim pidlCol(0)
    
    kfm.GetFolder FOLDERID_Libraries, kfLib
    DebugAppend "EnumLibraryPaths->Got folder"
    
    If (kfLib Is Nothing) = False Then
        kfLib.GetShellItem KF_FLAG_DEFAULT, IID_IShellItem, siLibRoot
        DebugAppend "EnumLibraryPaths->Got siLibRoot"
        If (siLibRoot Is Nothing) = False Then
            siLibRoot.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
            DebugAppend "EnumLibraryPaths->Got pEnum"
            If (pEnum Is Nothing) = False Then
                Do While (pEnum.Next(1&, siLibItem, pcl) = S_OK)
                    siLibItem.GetDisplayName SIGDN_NORMALDISPLAY, lpn
                    sln = LPWSTRtoStr(lpn)
                    DebugAppend "EnumLibraryPaths->Add lib " & sln
                    pSL.LoadLibraryFromItem siLibItem, STGM_READ
                    pSL.GetFolders LFF_ALLITEMS, IID_IShellItemArray, siaLib
                    If (siaLib Is Nothing) = False Then
                        siaLib.EnumItems pEnumLib
                        If (pEnumLib Is Nothing) = False Then
                            Do While (pEnumLib.Next(1&, siLibFolder, pcl2) = S_OK)
                                Set upi = siLibFolder
                                upi.GetParentAndItem pidl1, psf, pidl2
                                ReDim Preserve pidlCol(cItems)
                                pidlCol(cItems) = ILCombine(pidl1, pidl2)
                                cItems = cItems + 1
                            Loop
                        Else
                            DebugAppend "EnumLibraryPaths->Warning: Couldn't enum library"
                        End If
                    Else
                        DebugAppend "EnumLibraryPaths->Warning: Couldn't get folder array."
                    End If
                Loop
            Else
                EnumLibraryPaths = -1
            End If
        Else
            EnumLibraryPaths = -2
        End If
    Else
        EnumLibraryPaths = -3
    End If
    If cItems > 0& Then
        DebugAppend "EnumLibraryPaths->Create array..."
        SHCreateShellItemArrayFromIDLists cItems, ByVal VarPtr(pidlCol(0)), siaLibs
        DebugAppend "EnumLibraryPaths->Created array"
    Else
        EnumLibraryPaths = -4
    End If
    End Function
    
    
    Private Function GetCondition(ppCondition As ICondition) As Long
    'Translates the Search settings into an ICondition object
    Set ppCondition = Nothing
    GetCondition = -1
    Dim pFact As IConditionFactory2
    Set pFact = New ConditionFactory
    
    'Supported conditions:
    Dim pKind As ICondition
    Dim pSize As ICondition
    Dim pName As ICondition
    Dim pDate1 As ICondition
    Dim pAttrib As ICondition
    
    Dim aCds() As ICondition
    ReDim aCds(0)
    Dim nCds As Long
    ' ReDim pNames(0)
    If (pFact Is Nothing) = False Then
        Dim nCOP As CONDITION_OPERATION
        
        'First, set Name
            Dim sText As String
            Dim lLen As Long
            Dim hText As LongPtr
            If hSearchBoxAlt Then
                hText = hSearchBoxAlt
            Else
                hText = hSearchBox
            End If
            lLen = CLng(SendMessageW(hText, WM_GETTEXTLENGTH, 0, ByVal 0&))
            sText = String$(lLen, 0)
            Call SendMessageW(hText, WM_GETTEXT, lLen + 1, ByVal StrPtr(sText))
            mSearchTextCache = sText
            
            If InStr(sText, ";") Then
                Dim sQuery As String
                sQuery = Replace$(sText, ";", " OR ")
                Dim pQM As QueryParserManager
                Dim pQP As IQueryParser
                Set pQM = New QueryParserManager
             
                pQM.CreateLoadedParser StrPtr("SystemIndex"), LOCALE_USER_DEFAULT, IID_IQueryParser, pQP
                If (pQP Is Nothing) = False Then
                    Dim pQS As IQuerySolution
    '                DebugAppend "SearchQuery=" & sQuery
                    Set pQS = pQP.Parse(StrPtr(sQuery), Nothing)
                    If (pQS Is Nothing) = False Then
                        Dim pTmpCon As ICondition
                        pQS.GetQuery pTmpCon, Nothing
                        If (pTmpCon Is Nothing) = False Then
                            Dim cst As SYSTEMTIME
                            GetLocalTime cst
                            pQS.Resolve pTmpCon, SQRO_DONT_SPLIT_WORDS, cst, pName
                            If (pName Is Nothing) = False Then
                                Set aCds(nCds) = pName
                                nCds = nCds + 1
                            Else
                                DebugAppend "GetCondition->Failed IQuerySolution.Resolve", 11
                            End If
                        Else
                            DebugAppend "GetCondition->Failed IQuerySolution.GetQuery", 11
                        End If
                    Else
                        DebugAppend "GetCondition->Failed IQueryParse.Parse", 11
                    End If
                Else
                    DebugAppend "GetCondition->Failed QueryParserManager.CreateLoadedParser", 11
                End If
                    
                        
            
            Else
                If (sText <> "") And (sText <> "*.*") And (sText <> "*") Then 'Only create a condition if it's not 'All Files'
                    If InStr(sText, "*") Or InStr(sText, "?") Then
                        nCOP = COP_DOSWILDCARDS
                    Else
                        nCOP = COP_VALUE_CONTAINS
                    End If
                    
                    pFact.CreateStringLeaf PKEY_ItemNameDisplay, nCOP, StrPtr(sText), 0&, CONDITION_CREATION_DEFAULT, IID_ICondition, pName
                    Set aCds(nCds) = pName
                    nCds = nCds + 1
                End If
            End If
        If bSearchExt Then
            'Exclude folders unless included
            If chkShFldr.Value = vbUnchecked Then
                pFact.CreateStringLeaf PKEY_FileAttributes, COP_VALUE_NOTCONTAINS, StrPtr("D"), 0&, CONDITION_CREATION_DEFAULT, IID_ICondition, pAttrib
                ReDim Preserve aCds(nCds)
                Set aCds(nCds) = pAttrib
                nCds = nCds + 1
            End If
        
            If chkSrSz.Value = vbChecked Then
                Select Case cbSrSize1.ListIndex
                    Case 0: nCOP = COP_LESSTHAN
                    Case 1: nCOP = COP_EQUAL
                    Case 2: nCOP = COP_GREATERTHAN
                    Case Else: GoTo sizeend
                End Select
                pFact.CreateIntegerLeaf PKEY_Size, nCOP, CLng(txtSrSize1.Text) * 1024, CONDITION_CREATION_DEFAULT, IID_ICondition, pSize
                ReDim Preserve aCds(nCds)
                Set aCds(nCds) = pSize
                nCds = nCds + 1
            End If
    
    sizeend:
            'Kind
            If cbShType.ListIndex > 0 Then
                Dim nKind As Long
                nKind = cbShType.ListIndex - 1 'ListIndex starts at 0 but we inserted (any) at the start
                pFact.CreateStringLeaf PKEY_Kind, COP_EQUAL, StrPtr(sKindVals(nKind)), 0&, CONDITION_CREATION_DEFAULT, IID_ICondition, pKind
                ReDim Preserve aCds(nCds)
                Set aCds(nCds) = pKind
                nCds = nCds + 1
            End If
        
            'DateTime
            Dim stVal As SYSTEMTIME
            Dim dtNew As Date
            Dim ftVal As FILETIME, ftUtc As FILETIME
            Dim vr As Variant
            Dim pkDate As PROPERTYKEY
            SendMessage hDTSearch1, DTM_GETSYSTEMTIME, GDT_VALID, ByVal VarPtr(stVal)
            dtNew = SystemTimeToDate(stVal)
            DebugAppend "SearchDateTime " & CStr(dtNew)
            SystemTimeToFileTime stVal, ftVal
            LocalFileTimeToFileTime ftVal, ftUtc
            InitPropVariantFromFileTime ftUtc, vr
            
            Select Case cbDateType.ListIndex
                Case 0: pkDate = PKEY_DateModified
                Case 1: pkDate = PKEY_DateCreated
                Case 2: pkDate = PKEY_DateAccessed
            End Select
            Select Case cbDateCmp1.ListIndex
                Case 0: nCOP = COP_LESSTHAN
                Case 1: nCOP = COP_GREATERTHAN
            End Select
            pFact.CreateLeaf pkDate, nCOP, vr, 0&, StrPtr(LOCALE_NAME_USER_DEFAULT), Nothing, Nothing, Nothing, CONDITION_CREATION_DEFAULT, IID_ICondition, pDate1
            If (pDate1 Is Nothing) = False Then
                DebugAppend "GetCondition->Created DT leaf"
                ReDim Preserve aCds(nCds)
                Set aCds(nCds) = pDate1
                nCds = nCds + 1
            Else
                DebugAppend "GetCondition->Failed to create DateTime condition"
            End If
                
        ''TODO --> CREATE ADDITIONAL ITEMS
        End If
        DebugAppend "GetCondition->Finalizing..."
        If UBound(aCds) = 0 Then
            'Only one condition, don't need an array
            Set ppCondition = aCds(0)
        Else
            pFact.CreateCompoundFromArray CT_AND_CONDITION, aCds(0), nCds, CONDITION_CREATION_DEFAULT, IID_ICondition, ppCondition
        End If
        If (ppCondition Is Nothing) = False Then GetCondition = S_OK
    
        Set pFact = Nothing
    Else
        DebugAppend "GetCondition->Failed to create factory."
    End If
    
    End Function
    
    Private Function CreateSearchLibrary(pObC As IObjectCollection) As Long
    Set pObC = Nothing
    Dim pLib As IShellLibrary
    Set pLib = New ShellLibrary
    If (pLib Is Nothing) = False Then
        CreateSearchLibrary = pLib.GetFolders(LFF_ALLITEMS, IID_IObjectCollection, pObC)
        DebugAppend "CreateSearchLibrary->Failed to create ShellLibrary"
    End If
    End Function
    
    Private Function CreateSearchScope(ppia As IShellItemArray) As Long
    Set ppia = Nothing
    Dim pObjects As IObjectCollection
    Dim hr As Long
    
    Dim lp As LongPtr, sPath As String
    siCurPath.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lp
    sPath = LPWSTRtoStr(lp)
    
    If Left$(sPath, Len(sLibRoot)) = sLibRoot Then
    
        Dim pLibTmp As IShellLibrary
        Set pLibTmp = New ShellLibrary
        pLibTmp.LoadLibraryFromItem siCurPath, STGM_READ 'Check if it's a a real library-- if it is, we need to get the folder array directly or search fails
        pLibTmp.GetFolders LFF_ALLITEMS, IID_IShellItemArray, ppia
        If (ppia Is Nothing) = False Then 'Valid Library, proceed here.
            Exit Function
        End If
    End If
    
    If CreateSearchLibrary(pObjects) = S_OK Then
        pObjects.AddObject ByVal ObjPtr(siCurPath)
        
        Set ppia = pObjects
        Set pObjects = Nothing
        
        CreateSearchScope = hr
    End If
    
    End Function
    
    Private Function SearchGetDispIdx(sDisp As String) As String
    Dim i As Long
    Dim k As Long
    Dim s1 As String, s2 As String
    k = 1
    For i = 0 To UBound(psiSearch)
        s1 = psiSearch(i).sDisp
        If InStr(s1, "<") Then
            s1 = Left$(s1, InStr(s1, " <") - 1)
        End If
        s2 = sDisp
        If InStr(s2, "<") Then
            s2 = Left$(s2, InStr(s2, " <") - 1)
        End If
        
        If s1 = s2 Then
            k = k + 1
        End If
    Next i
    If k > 1 Then
        SearchGetDispIdx = sDisp & " <" & k & ">"
    Else
        SearchGetDispIdx = sDisp
    End If
    End Function
    
    Private Function IsVBCtl(hWnd As LongPtr) As Boolean
    Select Case hWnd
         Case txtColCX.hWnd: IsVBCtl = True
         Case chkColFilter.hWnd: IsVBCtl = True
         Case cmdColOK.hWnd: IsVBCtl = True
         Case cmdColCancel.hWnd: IsVBCtl = True
         Case cmdPropSave.hWnd: IsVBCtl = True
         Case cmdPropCancel.hWnd: IsVBCtl = True
    
    End Select
    End Function
    Private Function SearchFindIdxByDisp(sDisp As String) As Long
    Dim i As Long
    
    For i = 0 To UBound(psiSearch)
        If psiSearch(i).sDisp = sDisp Then
            SearchFindIdxByDisp = i
            Exit Function
        End If
    Next i
    SearchFindIdxByDisp = -1&
    End Function
    
    Public Sub ExecFileSearchEx(pLocation As IShellItem, pConditions As ICondition)
    If bBlockLoad Then Exit Sub
    Dim pObjects As IObjectCollection
    Dim ppia As IShellItemArray
    Dim lp As LongPtr, sPath As String
    Dim sSFolder As String
    
    pLocation.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lp
    sPath = LPWSTRtoStr(lp)
    lp = 0
    pLocation.GetDisplayName SIGDN_NORMALDISPLAY, lp
    sSFolder = LPWSTRtoStr(lp)
    If nsiSearch > 0 Then
        sSFolder = SearchGetDispIdx(sSFolder)
    End If
    
    If Left$(sPath, Len(sLibRoot)) = sLibRoot Then
        Dim pLibTmp As IShellLibrary
        Set pLibTmp = New ShellLibrary
        pLibTmp.LoadLibraryFromItem siCurPath, STGM_READ 'Check if it's a a real library-- if it is, we need to get the folder array directly or search fails
        pLibTmp.GetFolders LFF_ALLITEMS, IID_IShellItemArray, ppia
        If (ppia Is Nothing) = False Then 'Valid Library, proceed here.
            GoTo defcsl
        End If
    End If
    defcsl:
    If (ppia Is Nothing) Then
        If CreateSearchLibrary(pObjects) = S_OK Then
            pObjects.AddObject ByVal ObjPtr(pLocation)
            Set ppia = pObjects
        End If
    End If
    
    Dim pSearchFact As ISearchFolderItemFactory
    Set pSearchFact = New SearchFolderItemFactory
    pSearchFact.SetScope ppia
    pSearchFact.SetDisplayName StrPtr(mFldrSrch & sSFolder)
    pSearchFact.SetGroupColumn PKEY_ItemFolderPathDisplayNarrow
    If (pConditions Is Nothing) = False Then
        If nsiSearch = 0 Then
            ReDim psiSearch(0)
            nsiSearch = 1
        Else
            ReDim Preserve psiSearch(nsiSearch)
            nsiSearch = nsiSearch + 1
        End If
        pSearchFact.SetCondition pConditions
        RaiseEvent FileSearchStart(mSearchTextCache, pConditions, sPath, ppia)
        pSearchFact.GetShellItem IID_IShellItem, psiSearch(nsiSearch - 1).siSearch
        If (psiSearch(nsiSearch - 1).siSearch Is Nothing) = False Then
            DebugAppend "psiSearch=" & sSFolder
            pSearchFact.GetIDList psiSearch(nsiSearch - 1).pidl
            psiSearch(nsiSearch - 1).sPath = sPath
            psiSearch(nsiSearch - 1).sDisp = sSFolder
            psiSearch(nsiSearch - 1).lParam = nsiSearch - 1
            Set siDirect = psiSearch(nsiSearch - 1).siSearch
            bUseSearchMarkup = True
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
            bFlagNoIndent = True
            LVLoadFolder "", True, , , , nsiSearch - 1
            bFlagNoIndent = False
            UpdateStatus mSearchDone
            Set mCacheSearchCond = pConditions
        Else
            DebugAppend "ExecFileSearchEx->Failed to get IShellItem from search factory"
        End If
    Else
        DebugAppend "ExecFileSearchEx->Failed to get ICondition"
    End If
    Set ppia = Nothing
     
    End Sub
    
    Private Sub ExecSearchInNewLoc(siaScope As IShellItemArray, sPath As String, sDispName As String)
    'Use the cached conditions from the last search in a new location
    Dim sSFolder As String
    sSFolder = sDispName
    If nsiSearch > 0 Then
        sSFolder = SearchGetDispIdx(sSFolder)
    End If
    Dim pSearchFact As ISearchFolderItemFactory
    Set pSearchFact = New SearchFolderItemFactory
    pSearchFact.SetScope siaScope
    pSearchFact.SetDisplayName StrPtr(mFldrSrch & sSFolder)
    If (mCacheSearchCond Is Nothing) = False Then
        If nsiSearch = 0 Then
            ReDim psiSearch(0)
            nsiSearch = 1
        Else
            ReDim Preserve psiSearch(nsiSearch)
            nsiSearch = nsiSearch + 1
        End If
        pSearchFact.SetCondition mCacheSearchCond
        RaiseEvent FileSearchStart(mSearchTextCache, mCacheSearchCond, sPath, siaScope)
        pSearchFact.GetShellItem IID_IShellItem, psiSearch(nsiSearch - 1).siSearch
        If (psiSearch(nsiSearch - 1).siSearch Is Nothing) = False Then
            DebugAppend "psiSearch=" & sSFolder
            pSearchFact.GetIDList psiSearch(nsiSearch - 1).pidl
            psiSearch(nsiSearch - 1).sPath = sPath
            psiSearch(nsiSearch - 1).sDisp = sSFolder
            psiSearch(nsiSearch - 1).lParam = nsiSearch - 1
            Set siDirect = psiSearch(nsiSearch - 1).siSearch
            bUseSearchMarkup = True
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
            bWillLoadSearchFt = True
            bFlagNoIndent = True
            LVLoadFolder "", True, , , , nsiSearch - 1
            bFlagNoIndent = False
    '        If mFtrPostSearch Then FooterAddSearchDone
            UpdateStatus mSearchDone
        Else
            DebugAppend "ExecFileSearchEx->Failed to get IShellItem from search factory"
        End If
    Else
        DebugAppend "ExecFileSearchEx->Failed to get ICondition"
    End If
    
    End Sub
    
    Private Sub ExecSearch(Optional bSearchLibRoot As Boolean = False)
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim pSearchFact As ISearchFolderItemFactory
    Set pSearchFact = New SearchFolderItemFactory
    Dim lp As LongPtr
    Dim hr As Long
    Dim sPath As String, sSFolder As String
    If bSearchLibRoot Then
        sSFolder = mLibRootDisp
        sPath = sLibRoot2
    Else
        siCurPath.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lp
        sPath = LPWSTRtoStr(lp)
        lp = 0&
        siCurPath.GetDisplayName SIGDN_NORMALDISPLAY, lp
        sSFolder = LPWSTRtoStr(lp)
    End If
    If nsiSearch > 0 Then
        sSFolder = SearchGetDispIdx(sSFolder)
    End If
    
    If (pSearchFact Is Nothing) = False Then
        Dim piaScope As IShellItemArray
        If bSearchLibRoot Then
            hr = EnumLibraryPaths(piaScope)
        Else
            hr = CreateSearchScope(piaScope)
        End If
        If hr = S_OK Then
            pSearchFact.SetScope piaScope
            pSearchFact.SetDisplayName StrPtr(mFldrSrch & sSFolder)
            Dim pCond As ICondition
            If GetCondition(pCond) = S_OK Then
                If nsiSearch = 0 Then
                    ReDim psiSearch(0)
                    nsiSearch = 1
                Else
                    ReDim Preserve psiSearch(nsiSearch)
                    nsiSearch = nsiSearch + 1
                End If
                pSearchFact.SetCondition pCond
                DebugAppend "SearchFactory Condition Set", 11
                RaiseEvent FileSearchStart(mSearchTextCache, pCond, sPath, piaScope)
                pSearchFact.GetShellItem IID_IShellItem, psiSearch(nsiSearch - 1).siSearch
                If (psiSearch(nsiSearch - 1).siSearch Is Nothing) = False Then
                    pSearchFact.GetIDList psiSearch(nsiSearch - 1).pidl
                    psiSearch(nsiSearch - 1).sPath = sPath
                    psiSearch(nsiSearch - 1).sDisp = sSFolder
                    psiSearch(nsiSearch - 1).lParam = nsiSearch - 1
                    bUseSearchMarkup = True
                    SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
                    bWillLoadSearchFt = True
                    Set siDirect = psiSearch(nsiSearch - 1).siSearch
                    bFlagNoIndent = True
                    LVLoadFolder "", True, , , , nsiSearch - 1
                    bFlagNoIndent = False
    '                If mFtrPostSearch Then FooterAddSearchDone
                    UpdateStatus mSearchDone
                    Set mCacheSearchCond = pCond
    '                dbg_OpenCommonFileDialogTo psiSearch(nsiSearch - 1)
                Else
                    DebugAppend "ExecSearch->Failed to get IShellItem from search factory", 11
                End If
                Set pCond = Nothing
            Else
                DebugAppend "ExecSearch->Failed to get ICondition", 11
            End If
            Set piaScope = Nothing
        Else
            DebugAppend "ExecSearch->Failed to set scope", 11
        End If
        Set pSearchFact = Nothing
    Else
        DebugAppend "ExecSearch->Failed to create search factory.", 11
    End If
                
    '<EhFooter>
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.ExecSearch->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Sub EnumPropKind()
    'The entries for Kind vary from version to version of Windows
    'And the display text can be localized.
    'So create a current enumeration of the values for the Search feature
    Dim ppd As IPropertyDescription
    Dim i As Long
    PSGetPropertyDescription PKEY_Kind, IID_IPropertyDescription, ppd
    Dim pETL As IPropertyEnumTypeList
    Dim pET As IPropertyEnumType
    Dim nEnumType As PROPENUMTYPE
    Dim nTCt As Long
    Dim vr1 As Variant
    Dim vb1 As Variant
    Dim lpTemp As LongPtr
    ppd.GetEnumTypeList IID_IPropertyEnumTypeList, pETL
    If (pETL Is Nothing) = False Then
        pETL.GetCount nTCt
        ReDim sKindVals(nTCt - 1): ReDim sKindTxt(nTCt - 1)
        For i = 0 To (nTCt - 1)
            pETL.GetAt i, IID_IPropertyEnumType, pET
            If (pET Is Nothing) = False Then
                pET.GetValue vr1
                pET.GetDisplayText lpTemp
                PropVariantToVariant vr1, vb1
                sKindVals(i) = CStr(vb1)
                sKindTxt(i) = LPWSTRtoStr(lpTemp)
            End If
        Next i
    End If
    End Sub
    
    Private Function AddStandardFSItem(siItem As IShellItem, lIndTrack As Long, Optional bAsOpen As Boolean = True, Optional lSetSearchIdx As Long = -1&) As Long
    'This is to restrict recursive adding to standard file system paths
    'I'm not sure how well things would work trying to do it like this
    'for paths that we can't guarantee start with a normal drive letter
    
    'lIndTrack is for recursion; pass a variable that = 0 to it on the initial call
    
    On Error GoTo hErr
    Dim siParent As IShellItem
    Dim pIcon As IShellIcon
    Dim psf As IShellFolder
    Dim upi As IParentAndItem
    Dim pUnk As IUnknownUnrestricted
    Dim hr As Long
    Dim pidlPar As LongPtr, pidlRel As LongPtr
    Dim lpIcon As Long
    Dim lpName As LongPtr, sName As String
    Dim lpFull As LongPtr, sFull As String
    Dim lpFull2 As LongPtr, sFull2 As String
    Dim nCur As Long
    Dim lIdx As Long
    Dim lInd As Long
    Dim lFirstIndex As Long
    Dim fShow As Long
    If (mCustomRootEnforce = True) And (mCustomRoot <> "") Then
        If IsRootChild(, siItem) = False Then Exit Function
    End If
    
    'If hCombo = 0& Then Exit Function
    siItem.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFull
    sFull = LPWSTRtoStr(lpFull)
    'DebugAppend "sFull=" & sFull
    siItem.GetDisplayName SIGDN_NORMALDISPLAY, lpName
    sName = LPWSTRtoStr(lpName)
    fShow = 1
    RaiseEvent FilterDropdown(sName, sFull, siItem, fShow)
    If fShow = 0 Then Exit Function
 
    lFirstIndex = GetItemIndex(sFull, lIndTrack)
    If lFirstIndex >= 0& Then
        AddStandardFSItem = lFirstIndex
        DebugAppend "AddStandardFSItem::Already exists(" & AddStandardFSItem & ")->" & sFull, 2
        Exit Function
    End If
    'DebugAppend "AddStandardFSItem::Item does not exist, adding...", 2
    siItem.GetParent siParent
    If (siParent Is Nothing) = False Then
        siParent.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpFull2
        sFull2 = LPWSTRtoStr(lpFull2)
        If m_CompAsRoot = False Then
            If sFull2 = mDeskFolder Then
                sFull2 = "0"
            End If
        End If
        lIdx = GetItemIndex(sFull2, lInd)
    '    DebugAppend "old indent=" & lInd
        If lIdx = -1 Then
            'no parent found; so add the parent item first, recursively
            lIdx = AddStandardFSItem(siParent, lInd, False) 'only our last level should have the open icon
        End If
    End If

    nCur = UBound(cbItems)
    nCur = nCur + 1
    ReDim Preserve cbItems(nCur)
    cbItems(nCur).sFullPath = sFull
    cbItems(nCur).iIndnt = lInd + 1
    cbItems(nCur).lSearchIdx = lSetSearchIdx
    Set upi = siItem
    upi.GetParentAndItem pidlPar, psf, pidlRel
    'Set pIcon = psf
    Set pUnk = psf
    hr = pUnk.QueryInterface(IID_IShellIcon, pIcon)
    If hr = S_OK Then
        If bAsOpen Then
            pIcon.GetIconOf pidlRel, GIL_OPENICON, lpIcon
        Else
            pIcon.GetIconOf pidlRel, GIL_FORSHELL, lpIcon
        End If
    Else
    '    DebugAppend "AddStandardFSItem::Using alt icon method"
        Dim pidlcb As LongPtr
        pidlcb = ILCombine(pidlPar, pidlRel)
        lpIcon = GetFileIconIndexPIDL(pidlcb, SHGFI_SMALLICON)
        If lpIcon = -1 Then lpIcon = 0
    End If
    cbItems(nCur).nIcon = lpIcon
    cbItems(nCur).sDisp = sName
    'DebugAppend "ItemFull=" & sFull
    'DebugAppend "Parent=" & sFull2
    'DebugAppend "Insert order " & (lIdx + 1) & ", to parent=" & cbItems(lIdx).sDisp
    Dim lParIdx1 As Long, lParInd1 As Long, lParLP1 As LongPtr
    lParIdx1 = GetItemIndex(sFull2, lParInd1)
    lParLP1 = GetCBXItemlParam(hCombo, lParIdx1)
    'DebugAppend "RevIdx=" & lParIdx1 & ",RevPath=" & cbItems(lParLP1).sDisp
    'CBX_InsertItem hCombo, sName, lpIcon, , nCur, lIdx+1, lInd + 1
    CoTaskMemFree pidlPar
    lIndTrack = lInd + 1
    AddStandardFSItem = CBX_InsertItem(hCombo, sName, lpIcon, , nCur, (IIf(nAdjustOrder > 0, lIdx + nAdjustOrder, lIdx + 1)), lInd + 1) ' lIdx + 1
    Exit Function
    hErr:
        DebugAppend "AddStandardFSItem.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Private Function GetItemIndex(sFull As String, out_idnt As Long) As Long
    Dim i As Long
    Dim cbxi As COMBOBOXEXITEMW
    GetItemIndex = -1
    For i = 0 To UBound(cbItems)
        cbxi = CBX_GetItemW(hCombo, i)
        If (sFull = cbItems(cbxi.lParam).sFullPath) And (cbItems(cbxi.lParam).bDeleted = False) Then
            GetItemIndex = i
            out_idnt = cbItems(cbxi.lParam).iIndnt
            Exit Function
        End If
    Next i
    End Function
    
    Private Function CBItemExists(sFull As String) As Boolean
    Dim i As Long
    For i = 0 To UBound(cbItems)
        If (sFull = cbItems(i).sFullPath) And (cbItems(i).bDeleted = False) Then
            CBItemExists = True
            Exit Function
        End If
    Next
    End Function
    
    Private Function CBRemoveItemAndChildren(sFolder As String) As Long
    'Removes a ComboBox entry and its children
    On Error GoTo e0
    DebugAppend "CBRemoveItemAndChildren(" & sFolder & ")"
    Dim i As Long
    Dim lp As LongPtr
    Dim lCnt As Long
    
    CBRemoveItemAndChildren = -1
    
    lCnt = CLng(SendMessage(hCombo, CB_GETCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then Exit Function 'Should never be the case but w/e
    
    For i = (lCnt - 1) To 0 Step -1
        lp = GetCBXItemlParam(hCombo, i)
        If lp >= 0& Then
            If Len(cbItems(lp).sFullPath) Then
                If Left$(cbItems(lp).sFullPath, Len(sFolder)) = sFolder Then
                    SendMessage hCombo, CBEM_DELETEITEM, i, ByVal 0&
                    cbItems(lp).bDeleted = True
                End If
            End If
        End If
    Next i
    
    If nCurrentCBItemIndex > UBound(cbItems) Then
        'Set the index to the last folder added
        nCurrentCBItemIndex = UBound(cbItems)
    End If
     
    Exit Function
    e0:
        DebugAppend "ucShellBrowse.CBRemoveItemAndChildren->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    Public Sub UpdateStatus(sText As String, Optional nPanel As Long = 1&, Optional bWriteToDebug As Boolean = False)
    If mStatusText = sText Then Exit Sub
    If nPanel > 1& Then
        If m_StatusSP Then Exit Sub
    End If
    
    SBSetPanelText nPanel, sText
    If nPanel = 1& Then 'send message for main panel only
        mStatusText = sText
        RaiseEvent StatusMessage(sText)
    End If
    If bWriteToDebug = True Then
        DebugAppend "UpdateStatus: " & sText, 999
    End If
    End Sub
    
    Private Function GetRegistryValueW(lKeyType As Long, sPath As String, sKey As String) As String
    Dim hKey As LongPtr
    Dim R As Long
    Dim sRes As String
    Dim lDataLen As Long
    Dim lType As Long
    R = RegOpenKeyExW(lKeyType, StrPtr(sPath), 0, KEY_QUERY_VALUE, hKey)
    R = RegQueryValueExW(hKey, StrPtr(sKey), 0, lType, 0, lDataLen)
    sRes = String$(lDataLen, 0)
    R = RegQueryValueExW(hKey, StrPtr(sKey), 0, REG_SZ, StrPtr(sRes), lDataLen)
    GetRegistryValueW = TrimNullW(sRes)
    R = RegCloseKey(hKey)
    End Function
    
    Public Sub RefreshTree()
    Attribute RefreshTree.VB_Description = "Reloads the directory dropdown."
    'Rebuilds treeview
    If Ambient.UserMode Then
        bSuppress = True
        DestroyWindow hCombo
        pvCreateCombo
        
        Dim li As Long
        Dim idx As Long
        Dim siItem As IShellItem
        Dim sPath As String, lpPath As LongPtr
        '    Call SHCreateItemFromIDList(pidlt, IID_IShellItem, siItem)
        Call SHCreateItemFromParsingName(StrPtr(m_sCurPath), Nothing, IID_IShellItem, siItem)
        If m_Mode = SBCTL_DrivesOnly Then
            siItem.GetDisplayName SIGDN_FILESYSPATH, lpPath
            sPath = LPWSTRtoStr(lpPath)
            If Len(sPath) > 3 Then
                If InStr(sPath, ":\") Then
                    sPath = Left$(sPath, 3)
                    Set siItem = Nothing
                    Call SHCreateItemFromParsingName(StrPtr(sPath), Nothing, IID_IShellItem, siItem)
                End If
            End If
        End If
        idx = AddStandardFSItem(siItem, li, True)
        Call SendMessage(hCombo, CB_SETCURSEL, idx, ByVal 0&)
        bSuppress = False
        UserControl_Resize
    End If
    End Sub
    
    Public Sub RefreshView()
    Attribute RefreshView.VB_Description = "Reloads the folder currently displayed in the ListView."
    'LVLoadFolder m_sCurPath, , True, siCurPath, True
    Set siDirect = siCurPath
    LVLoadFolder "", True, , , True
    End Sub
    
    Private Sub LVResetIcons()
    Dim i As Long
    Dim lp As LongPtr
    Dim lvi As LVITEM
    Dim n As Long
    DebugAppend "LVResetIcons"
    n = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    For i = 0 To (n - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.Mask = LVIF_IMAGE
        lvi.iItem = i
        lvi.iImage = LVEntries(lp).nFileIcon
        LVEntries(lp).nIcon = LVEntries(lp).nFileIcon
        LVEntries(lp).nOverlay = LVEntries(lp).nFileOverlay
        If LVEntries(lp).nOverlay > 0 Then
            lvi.Mask = lvi.Mask Or LVIF_STATE
            lvi.StateMask = LVIS_OVERLAYMASK
            lvi.State = INDEXTOOVERLAYMASK(LVEntries(lp).nOverlay)
        End If
        If ((LVEntries(lp).dwAttrib And SFGAO_HIDDEN) = SFGAO_HIDDEN) Or ((LVEntries(lp).dwAttrib And SFGAO_GHOSTED) = SFGAO_GHOSTED) Then
            lvi.Mask = lvi.Mask Or LVIF_STATE
            lvi.State = lvi.State Or LVIS_CUT
            lvi.StateMask = lvi.StateMask Or LVIS_CUT
        End If
        SendMessage hLVS, LVM_SETITEM, 0&, lvi
        DebugAppend "Set item " & i & " to " & lvi.iImage ', 11
    Next i
    End Sub
    
    Private Sub LVResetIconCallbacks()
    Dim i As Long
    Dim lp As LongPtr
    Dim lvi As LVITEM
    Dim n As Long
    DebugAppend "LVResetIconCallbacks"
    ReDim SysImgCache(0)
    nSysImgCache = 0
    n = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    For i = 0 To (n - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.Mask = LVIF_IMAGE
        lvi.iItem = i
        lvi.iImage = I_IMAGECALLBACK
        LVEntries(lp).nIcon = I_IMAGECALLBACK
    
        SendMessage hLVS, LVM_SETITEM, 0&, lvi
    Next i
    End Sub
    
    Private Sub SwitchView(lNewView As ucsb_LV_VIEW, Optional bInit As Boolean = False)
    On Error GoTo hErr
    If IsVMRestricted(lNewView) Then Exit Sub
    If Ambient.UserMode = False Then Exit Sub
    If (m_ViewModeEx = lNewView) And (bInit = False) Then
        DebugAppend "SwitchView->m_ViewModeEx=lNewView, exiting" ', 4
        Exit Sub 'oldmode=newmode
    End If
    UpdateStatus m_str_SwVw
    DebugAppend "SwitchView " & lNewView & "|" & m_ViewMode & ", bForcedDFS=" & bForcedDFSCol ', 3
    Dim lOldView As ShellBrowseView
    Dim lIdx As Long
    Dim i As Long
    Dim hr As Long
    m_ViewModeEx = lNewView
    Call SendMessage(hLVS, LVM_SETICONSPACING, 0&, ByVal PackWords(-1, -1))
    If lNewView = LV_VIEW_ICON Then
        cxyDispL = (cxyLargeIcons * mActualZoom)
        DebugAppend "Set Icon Size=" & cxyDispL, 2
    End If
    If lNewView = LV_VIEW_MDICON Then
        cxyDispL = cxyMediumIcons * mActualZoom
        lNewView = LV_VIEW_ICON
        DebugAppend "Set Icon Size=" & cxyDispL, 2
    End If
    If lNewView = LV_VIEW_XLICON Then
        cxyDispL = cxyXLIcons * mActualZoom
        If cxyDispL > 256 Then cxyDispL = 256
        lNewView = LV_VIEW_ICON
        DebugAppend "Set Icon Size=" & cxyDispL, 2
    End If
    DebugAppend "cxyDispL=" & cxyDispL, 11
    If bInit Then GoTo strt
    lOldView = m_ViewMode
    If (Ambient.UserMode = True) Or (lNewView <= 3&) Then
    
    If (lOldView = SB_VIEW_THUMBNAIL) Or (m_ViewMode = SB_VIEW_CUSTOM) Or (lOldView = SB_VIEW_ICON) Then
        ReDim SysImgCache(0)
        nSysImgCache = 0
        SendMessage hLVS, LVM_SETCALLBACKMASK, 0&, ByVal 0&
    End If
    If lOldView = SB_VIEW_TILE Then
        'Clear up any columns we force added for Computer/Devices
        'If bForcedDFSCol Then
        If m_SubItemFreeSpc > 0 Then
            For i = 0 To UBound(cbItems)
                If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
                    lIdx = i
                    Exit For
                End If
            Next i
            ResetSpecialCols
    
            If m_SubItemFreeSpc > 0 Then
                'PKEY_Computer_DecoratedFreeSpace hidden column
                RemoveFromCurColSet lIdx, lDFSColIdx
                Call SendMessage(hLVS, LVM_DELETECOLUMN, m_SubItemFreeSpc, ByVal 0&)
                uColData(lDFSColIdx).ColVis = False
                ResetSpecialCols
                bForcedDFSCol = False
            End If
            If bForcedPFCol Then
                RemoveFromCurColSet lIdx, lPFColIdx
                Call SendMessage(hLVS, LVM_DELETECOLUMN, m_SubItemProgress, ByVal 0&)
                uColData(lPFColIdx).ColVis = False
                ResetSpecialCols
                bForcedPFCol = False
            End If
            If bForcedTypeCol Then
                RemoveFromCurColSet lIdx, lDefColIdx(2)
                Call SendMessage(hLVS, LVM_DELETECOLUMN, m_SubItemType, ByVal 0&)
                uColData(lDefColIdx(2)).ColVis = False
                ResetSpecialCols
                bForcedTypeCol = False
            End If
            UpdateColumns lIdx, True
    
        End If
    End If
    If IsComCtl6 = False Then
        'Switching during runtime is not supported prior to 6.0, so we'll try
        'destroying and recreating. Group View isn't supported before 6 no
        'matter what so at least we don't have to worry about that!
        If (lNewView = LV_VIEW_THUMBNAIL) Or (lNewView = LV_VIEW_CUSTOM) Then
            m_ViewMode = LV_VIEW_ICON 'temporary since switching it in ShowThumbs would fail
        Else
            m_ViewMode = lNewView
        End If
        DebugAppend "SwitchView NoComCtl6->Unsubclassing..."
        'ssc_UnSubclass hLVS
        UnSubclass2 hLVS, AddressOf ucWndProc, hLVS
        DebugAppend "SwitchView NoComCtl6->Unsubclassed, destroying..."
        DestroyWindow hLVS
        InitLV
        bSuppress = True
        For i = 0 To UBound(LVEntries)
            If LVEntries(i).bDeleted = False Then
                InsertListItem LVEntries(i)
            End If
        Next i
        For i = 0 To UBound(cbItems)
            If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
                lIdx = i
                Exit For
            End If
        Next i
        UpdateColumns lIdx, True
        If lNewView = LV_VIEW_THUMBNAIL Then
            m_ViewMode = SB_VIEW_THUMBNAIL 'Now we can change it
            mUsingCustomIcons = False
            ShowThumbsAPI
        End If
        If lNewView = LV_VIEW_CUSTOM Then
            m_ViewMode = SB_VIEW_CUSTOM
            mUsingCustomIcons = True
            ShowThumbsAPI
        End If
        If m_cbSort = 0& Then
            If mUseAdvancedSort Then
                'm_cbSort = scb_SetCallbackAddr(3, 20)
                m_cbSort = AddressOf LVSortProcAdv
            Else
                'm_cbSort = scb_SetCallbackAddr(3, 2)
                m_cbSort = AddressOf LVSortProc
            End If
        End If
        mLastSortInfo = eSortName
        Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
        GoTo out
    End If
    
    If (lOldView = SB_VIEW_DETAILS) Then
        If (mDispParAndIndt = True) Then
            If (bShowParentItemsInAllViews = False) Then
                RemoveParentsFromLV
            End If
        End If
    End If
    
    If m_HideIcons Then
        If bLimitHideIconViewToLogical = False Then
            If (lNewView <> LV_VIEW_DETAILS) And (lNewView <> LV_VIEW_LIST) Then Exit Sub
        End If
    End If
    If (lOldView = LV_VIEW_THUMBNAIL) Or (lOldView = LV_VIEW_CUSTOM) Then
        'switching out of thumbview
        If m_HideIcons = False Then
            Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&) 'Will be set back through RefreshView
            ImageList_Destroy himl_Thumb
            Call SendMessage(hLVS, LVM_SETIMAGELIST, LVSIL_NORMAL, ByVal ObjPtr(imlSys32))
            Call SendMessage(hLVS, LVM_SETIMAGELIST, LVSIL_SMALL, ByVal ObjPtr(imlSys16))
            bThumbsActive = False
            LVResetIcons
        End If
        RefreshView
    End If
    If (lOldView = SB_VIEW_ICON) Then
        'Switching out of Icon modes (now same method as Thumbnails)
        If m_HideIcons = False Then
            Call SendMessage(hLVS, WM_SETREDRAW, 0&, ByVal 0&) 'Will be set back through RefreshView
            ImageList_Destroy himlLarge
            Call SendMessage(hLVS, LVM_SETIMAGELIST, LVSIL_SMALL, ByVal ObjPtr(imlSys16))
            Call SendMessage(hLVS, LVM_SETIMAGELIST, LVSIL_NORMAL, ByVal ObjPtr(imlSys32))
        End If
        RefreshView
        LVResetIcons
    End If
    strt:
    m_ViewMode = lNewView
    If m_ViewMode <= 3 Then
        DebugAppend "SwitchView::StandardSet,vw=" & m_ViewMode
        If m_ViewMode = SB_VIEW_ICON Then
            ReDim SysImgCache(0)
            nSysImgCache = 0
            bFlagSwitch1 = True
            LVSwitchToLgIcon
            bFlagSwitch1 = False
            GoTo out
        End If
        DebugAppend "SwitchView::CRITTEST, sending LVM_SETVIEW"
        hr = CLng(SendMessage(hLVS, LVM_SETVIEW, m_ViewMode, ByVal 0&))
        DebugAppend "LVM_SETVIEW 0x" & Hex$(hr)
        LVAdjustLabelWidth
        If (lOldView = SB_VIEW_CONTENTS) And (lNewView = LV_VIEW_DETAILS) Then RefreshView
        If (m_ViewMode = SB_VIEW_SMALLICON) And (bGV = True) Then
            bInGVSI = True
            SendMessage hLVS, LVM_SETCOLUMNWIDTH, -1&, ByVal CLng(cxSmallIconColumnWidth * m_ScaleX)
            RefreshView
        End If
        If (lOldView = SB_VIEW_SMALLICON) And (bGV = True) And (bEnableFixForGVSMICON = True) Then
            ExpandNames
        End If
    ElseIf m_ViewMode = SB_VIEW_TILE Then
        For i = 0 To UBound(cbItems)
            If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
                lIdx = i
                Exit For
            End If
        Next i
        If cbItems(lIdx).bHasProgress Then
            TileViewProgressEnsureCols
        End If
        If (lOldView = SB_VIEW_CONTENTS) Then
            SendMessage hLVS, LVM_SETCALLBACKMASK, 0&, ByVal 0&
            hr = CLng(SendMessage(hLVS, LVM_SETVIEW, LV_VIEW_ICON, ByVal 0&))
            RefreshView
        End If
        SetTileView hLVS
    ElseIf m_ViewMode = SB_VIEW_CONTENTS Then
        SetTileViewEx hLVS
    ElseIf m_ViewMode = SB_VIEW_THUMBNAIL Then
        If m_HideIcons = False Then
            If pThumbCache Is Nothing Then
                Set pThumbCache = New LocalThumbnailCache
            End If
            mUsingCustomIcons = False
            ShowThumbsAPI
        End If
    ElseIf m_ViewMode = SB_VIEW_CUSTOM Then
        If m_HideIcons = False Then
            mUsingCustomIcons = True
            ShowThumbsAPI
        End If
    End If
    End If
    out:
    UpdateStatus mReadyStr
    Exit Sub
    hErr:
        DebugAppend "ucShellBrowse.SwitchView->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Sub
    
    Private Sub TileViewProgressEnsureCols()
    ResetSpecialCols
    If m_SubItemProgress = 0 Then
        DebugAppend "TileViewPEC->Add PercentFull"
        pvAddColumnByPKEY PKEY_PercentFull
        bForcedPFCol = True
    End If
    If m_SubItemFreeSpc = 0 Then
        DebugAppend "TileViewPEC->Add " & uColData(lDFSColIdx).szDisplayName
        pvAddColumnByPKEY PKEY_Computer_DecoratedFreeSpace
        bForcedDFSCol = True
    End If
    If m_SubItemType = 0 Then
        DebugAppend "TileViewPEC->Add Type"
        AddTypeColumn
        bForcedTypeCol = True
    End If
    ResetSpecialCols
    End Sub
    
    Public Sub NavGoBack(): DoBack: End Sub
    Public Sub NavGoForward(): DoForward: End Sub
    Public Sub NavOpenParent()
    If m_LockNav Then Exit Sub
    If bBlockLoad = True Then Exit Sub
    OpenParent
    End Sub
    
    Private Sub DoBack()
    If m_LockNav Then Exit Sub
    If bBlockLoad = True Then Exit Sub
    Dim siFB As IShellItem
    Dim i As Long
    If sPrevPath <> "" Then
        bSuppress = True
        nHistIdx = nHistIdx - 1
        If nHistIdx = -1 Then nHistIdx = 0
        If nHistIdx = 0 Then
            EnableWindow hStdBackButton, 0&
            pvDrawBack NAV_BB_DISABLED
            bBackEnable = False
        End If
        Dim lIdx As Long, lInd As Long
        lIdx = GetItemIndex(sHistory(nHistIdx), lInd)
        Call SendMessage(hCombo, CB_SETCURSEL, lIdx, ByVal 0&)
        bHistoryOp = True
        If Left$(sHistory(nHistIdx), 3) = "::{" Then
            'Virtual locations can be problematic on Win10, so create fallback from the pidl store
            For i = 0 To UBound(uPidlStore)
                If sHistory(nHistIdx) = uPidlStore(i).sPath Then
                    SHCreateItemFromIDList uPidlStore(i).pidlFQ, IID_IShellItem, siFB
                    LVLoadFolder sHistory(nHistIdx), , True, siFB
                    Exit For
                End If
            Next i
            If siFB Is Nothing Then
                DebugAppend "Failed to load virtual location pidl for history nav fallback."
            End If
        Else
            DebugAppend "DoBack.LoadHistoryPath(" & nHistIdx & ")=" & sHistory(nHistIdx)
            DebugAppend sHistory(1)
            LVLoadFolder sHistory(nHistIdx)
        End If
        DebugAppend "HistIdx=" & nHistIdx
        bEnableFwd = True
        EnableWindow hStdFwdButton, 1&
        pvDrawFwd NAV_FB_NORMAL
        bHistoryOp = False
        bSuppress = False
    End If
    End Sub
    Private Sub DoForward()
    If m_LockNav Then Exit Sub
    If bBlockLoad = True Then Exit Sub
    If bEnableFwd = False Then Exit Sub
    If nHistIdx = UBound(sHistory) Then Exit Sub 'nowhere to go
        bSuppress = True
        nHistIdx = nHistIdx + 1
        If nHistIdx = -1 Then nHistIdx = 0
        If nHistIdx = UBound(sHistory) Then
            DebugAppend "SET DISABLE FORWARD"
            bEnableFwd = False
            EnableWindow hStdFwdButton, 0&
            pvDrawFwd NAV_FB_DISABLED
        End If
        Dim lIdx As Long, lInd As Long, i As Long
        lIdx = GetItemIndex(sHistory(nHistIdx), lInd)
        Call SendMessage(hCombo, CB_SETCURSEL, lIdx, ByVal 0&)
        bHistoryOp = True
        If Left$(sHistory(nHistIdx), 3) = "::{" Then
            'Virtual locations can be problematic on Win10, so create fallback from the pidl store
            Dim siFB As IShellItem
            For i = 0 To UBound(uPidlStore)
                If sHistory(nHistIdx) = uPidlStore(i).sPath Then
                    SHCreateItemFromIDList uPidlStore(i).pidlFQ, IID_IShellItem, siFB
                    LVLoadFolder sHistory(nHistIdx), , True, siFB
                    Exit For
                End If
            Next i
            If siFB Is Nothing Then
                DebugAppend "Failed to load virtual location pidl for history nav fallback."
            End If
        Else
            LVLoadFolder sHistory(nHistIdx)
        End If
        DebugAppend "HistIdx=" & nHistIdx
        bBackEnable = True
        pvDrawBack NAV_BB_NORMAL
        EnableWindow hStdBackButton, 1&
        bHistoryOp = False
        bSuppress = False
    
    End Sub
    
    Private Sub DirSelForDrivesOnly(lItem As Long)
    'No calling LVLoadFolder in Drives Only mode, but we need to update what's reported as selected
    Dim lIdx As LongPtr
    lIdx = GetCBXItemlParam(hCombo, lItem)
    m_sCurPath = cbItems(lIdx).sFullPath
    If (m_sCurPath = sComp) Or (m_sCurPath = sComp2) Or (m_sCurPath = "0") Then
        Dim pKFM As KnownFolderManager
        Dim pKFC As IKnownFolder
        Set pKFM = New KnownFolderManager

        pKFM.GetFolder FOLDERID_ComputerFolder, pKFC
        pKFC.GetIDList KF_FLAG_DEFAULT, pidlFQCur
        Set siCurPath = Nothing
        pKFC.GetShellItem KF_FLAG_DEFAULT, IID_IShellItem, siCurPath
        m_sCurPath = sComp
    Else
        Set siCurPath = Nothing
        SHCreateItemFromParsingName StrPtr(m_sCurPath), Nothing, IID_IShellItem, siCurPath
        pidlFQCur = ILCreateFromPathW(StrPtr(m_sCurPath))
    End If
    RaiseEvent DirectoryChanged(m_sCurPath, siCurPath, pidlFQCur)
    End Sub
    
    Private Sub DirNavigate(lItem As Long)
    'user clicked on a new path in the dropdown
    On Error GoTo e0
    DebugAppend "DirNavigate item=" & lItem & ",sup=" & bSuppress
    If bSuppress Then Exit Sub
    Dim sFull As String
    Dim lIdx As Long
    lIdx = CLng(GetCBXItemlParam(hCombo, lItem))
    If (lIdx = 0) And (mCustomRoot <> "") Then
        sFull = mCustomRoot
    Else
        sFull = cbItems(lIdx).sFullPath
    End If
    If sFull = "*CUSTOM" Then
        bFlagNoIndent = True
        PopulateCustomSet
        If bFlagCustomFolderHasColSet Then UpdateColumns lIdx
        bFlagNoIndent = False
    ElseIf cbItems(lIdx).lSearchIdx >= 0& Then
        Set siDirect = psiSearch(cbItems(lIdx).lSearchIdx).siSearch
        bWillLoadSearchFt = True
        bFlagNoIndent = True
        LVLoadFolder "", True
        bFlagNoIndent = False
    Else
        LVLoadFolder sFull
    End If
    Exit Sub
    e0:
    DebugAppend "DirNavigate->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Sub
    
    Private Function LVEntryIsDupe(t1 As UCSBFile, Optional nIdxExc As Long = -1&) As Boolean
    Dim i As Long
    For i = 0 To UBound(LVEntries)
        If (nIdxExc >= 0&) And (i = nIdxExc) Then GoTo nxt
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).sParentFull = t1.sParentFull Then
                If LVEntries(i).pidlRel = t1.pidlRel Then
                    LVEntryIsDupe = True
                    Exit Function
                End If
                If LVEntries(i).cSize = t1.cSize Then
                    If LVEntries(i).sName = t1.sName Then
                     If LVEntries(i).sDateM = t1.sDateM Then
                        LVEntryIsDupe = True
                        Exit Function
                     End If
                   End If
                End If
            End If
        End If
    nxt:
    Next i
    End Function
    
    Private Sub SaveNewLink(sLink As String, sPath As String, Optional sIconFile As String = vbNullString, Optional ByVal lIcon As Long = 0, _
                           Optional ByVal iHK As Integer = 0, Optional sArgs As String = vbNullString, Optional sDesc As String = vbNullString, _
                           Optional ByVal pidl As LongPtr = 0, Optional sWorkDir As String = vbNullString, Optional sRelPath As String = vbNullString, _
                           Optional swc As SHOWWINDOW = SW_NORMAL)
    
    On Error GoTo e0
    
    Dim cSL As ShellLinkW
    Dim ipf As IPersistFile
    
    Set cSL = New ShellLinkW
    Set ipf = cSL
    With cSL
        .SetPath (sPath)
        .SetArguments sArgs
        .SetDescription sDesc
        .SetIconLocation sIconFile, lIcon
        .SetHotkey iHK
        .SetShowCmd swc
        .SetRelativePath sRelPath, 0
        .SetWorkingDirectory sWorkDir
        If pidl Then .SetIDList pidl
        
        .Resolve 0, SLR_UPDATE
        
    End With
    
    ipf.Save sLink, 0
    
    Set ipf = Nothing
    Set cSL = Nothing
    
    Exit Sub
    
    e0:
    DebugAppend "SaveNewLink.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Sub
    
    Private Function PStoreHasPF(pps As IPropertyStore) As Boolean
    If GetPropertyKeyDisplayString(pps, PKEY_PercentFull) <> "" Then
        PStoreHasPF = True
    End If
    
    End Function
    
    Private Function ClipboardSetText(ByVal sText As String) As Long
    'copy unicode text to clipboard
    Dim hMem As LongPtr, pMem As LongPtr
    Dim hr As LongPtr, ner As Long
    sText = sText ' & vbNullChar & vbNullChar
    DebugAppend "ClipSet.Entry"
    If OpenClipboard(UserControl.hWnd) Then
       Call EmptyClipboard
        hMem = GlobalAlloc(GHND, LenB(sText) + 2)
        pMem = GlobalLock(hMem)
        If pMem Then
            CopyMemory ByVal pMem, ByVal StrPtr(sText), LenB(sText)
            Call GlobalUnlock(hMem)
            hr = SetClipboardData(CF_UNICODETEXT, hMem)
            ner = Err.LastDllError' GetLastError()
            If hr = 0 Then DebugAppend "ClipSetText.SetClipboardData failed, Handle=" & Hex$(hr) & ",lasterr=" & Hex$(ner)
        End If
        Call CloseClipboard
    Else
    
        DebugAppend "ClipSetText.Couldn't open clipboard"
    End If
    
    End Function
    
    Private Sub InitImageLists()
    
    '<EhHeader>
    On Error GoTo e0
    
    '</EhHeader>zz
    If (imlSys16 Is Nothing) Then
        SHGetImageList SHIL_SYSSMALL, IID_IImageList, imlSys16
    End If
    
    If (imlSys32 Is Nothing) Then
        SHGetImageList SHIL_EXTRALARGE, IID_IImageList2, imlSys32
    End If
    imlSys32.GetIconSize cxLVIcon, cyLVIcon
    
    If (imlSysJM Is Nothing) Then
        SHGetImageList SHIL_JUMBO, IID_IImageList, imlSysJM
    End If
    
    LVR_InitIML
    
    Dim hIcon As LongPtr
    
    ' Dim lp    As Long
    
    Dim cxy   As Long
    
    ImageList_CoCreateInstance CLSID_ImageList, 0&, IID_IImageList2, imlMisc
    imlMisc.Initialize 32, 32, ILC_COLOR32, 1, 1
    
    On Error GoTo e1
    
    cxy = 20 * m_ScaleX
    cxyMenuImages = cxy
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_VIEW, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxView
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_BKM, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxBkm
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_GOBACK, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxBack
    DestroyIcon hIcon
    'lp = GetThemeBitmap(hThemeNav, NAV_FORWARDBUTTON, NAV_FB_NORMAL, 0&, GBF_DIRECT, hIcon)
    '
    'imlMisc.ReplaceIcon -1, hbitmaptohicon(hIcon), iidxFwd
    'DeleteObject hIcon
    
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_UP, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxUp
    DestroyIcon hIcon
    imlMisc.Resize cxy, cxy
    
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNBACK, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxMnBack
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNFWD, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxMnFwd
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNLGICON, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLgIcon
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNSMICON, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxSmIcon
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNLIST, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxList
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNDETAILS, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxDetail
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNTILE, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxTile
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNTHUMB, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxThumb
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNCUST, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxCust
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNPASTE, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxPaste
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNREFRESH, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxRefresh
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNNEWF, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxNewFldr
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNSORTA, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxSortA
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_MNSORTD, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxSortD
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LOTOP, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoTop
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LODTL, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoDtl
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LOPRV, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoPrv
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LOBAR, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoBar
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LOTRV, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoTrv
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_LOSTA, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoSta
    DestroyIcon hIcon
    hIcon = PBEncodedIconTohIcon(pbidx_ICO_SRCHBOX, cxy, cxy)
    imlMisc.ReplaceIcon -1, hIcon, iidxLoSrch
    DestroyIcon hIcon
    Exit Sub
    
    e0:
    DebugAppend "ucShellBrowse.InitImageLists->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    Exit Sub
    
    e1:
    DebugAppend "ucShellBrowse.InitImageLists->Failed to load images from resource file, falling back to on-form graphics. "
    
    Resume Next
    
    End Sub
    
    Private Sub DestroyImageLists()
    If lvrHIML Then ImageList_Destroy lvrHIML
    If himlFooter Then ImageList_Destroy himlFooter
    If himlHdrMV Then ImageList_Destroy himlHdrMV
    If himl_Thumb Then ImageList_Destroy himl_Thumb
    If ObjPtr(imlMisc) Then ImageList_Destroy ObjPtr(imlMisc)
    If himlLarge Then ImageList_Destroy himlLarge
    
    Set imlSys16 = Nothing
    Set imlSys32 = Nothing
    Set imlSysJM = Nothing
    Set imlMisc = Nothing
    
    End Sub
    
    Private Sub LVR_InitIML()
    On Error GoTo e0
    
    DebugAppend "Initializing Rating column"
    
    If bDisableRatingStars Then
        lvrEnable = False
        Exit Sub
    End If
    If lvrHIML Then Exit Sub
    
    lvrHIML = ImageList_Create(18, 18, ILC_COLOR32, 3, 0)
    
    
    On Error GoTo e1
    If PBEncodedPNGtoHIML(pbidx_PNG_RTNORM, lvrHIML) = False Then GoTo e1
    If PBEncodedPNGtoHIML(pbidx_PNG_RTHOT, lvrHIML) = False Then GoTo e1
    If PBEncodedPNGtoHIML(pbidx_PNG_RTOFF, lvrHIML) = False Then GoTo e1
    
     
    ReDim lvrData(0)
    lrLastIndex = -1
    lvrEnable = True
    
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "LVR_InitIML.Error->" & Err.Description & " (" & Err.Number & ")"
    Exit Sub
    e1:
    DebugAppend "Rating images missing; will use text (editing disabled)"
    
    End Sub
    
    Private Sub InitFonts()
    Dim ncm As NONCLIENTMETRICS
    ncm.cbSize = LenB(ncm)
    Dim hr As Long
    
    hr = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0&, ncm, 0&)
    m_hFontDtTxt = CreateFontIndirect(ncm.lfCaptionFont)
    m_cyFontDtTxt = Abs(ncm.lfCaptionFont.LFHeight)
    ncm.lfCaptionFont.LFHeight = (-MulDiv(10, GetDeviceCaps(GetDC(0), LOGPIXELSY), 72))
    m_hFontDtHdr = CreateFontIndirect(ncm.lfCaptionFont)
    
    
    m_hFontMsg = CreateFontIndirect(ncm.lfMessageFont)
    
    'Font and DPI issues are an ongoing problem; if you're trying to get it right here's some of what I tried:
    'Dim sFace As String
    'Dim i As Long
    'With ncm.lfCaptionFont
    'For i = LBound(ncm.lfCaptionFont.LFFaceName) To UBound(ncm.lfCaptionFont.LFFaceName)
    '    sFace = sFace & Chr$(ncm.lfCaptionFont.LFFaceName(i))
    'Next i
    'sFace = Replace$(sFace, vbNullChar, "")
    'DebugAppend "CaptionFont:face=" & sFace & ",pitch=" & Hex$(.LFPitchAndFamily) & ",charset=" & .LFCharset & ",weight=" & .LFWeight
    'DebugAppend "OtherParams:clpprec=" & .LFClipPrecision & ",escpm=" & .LFEscapement & ",orn=" & .LFOrientation & ",outprec=" & .LFOutPrecision & ",cx=" & .LFWidth
    'sFace = ""
    'For i = LBound(ncm.lfMessageFont.LFFaceName) To UBound(ncm.lfMessageFont.LFFaceName)
    '    sFace = sFace & Chr$(ncm.lfMessageFont.LFFaceName(i))
    'Next i
    'DebugAppend "MessageFont:face=" & sFace & ",qual=" & ncm.lfCaptionFont.LFQuality & ",cy=" & ncm.lfCaptionFont.LFHeight & " (10pt=" & m_FtDtHdr.LFHeight & ")"
    'sFace = ""
    'End With
    End Sub
    
    Private Sub InitRVM()
    On Error GoTo e0
    
    Dim sItm() As String
    Dim sTmp As String
    Dim i As Long
    Dim bHF As Boolean
    
    sTmp = mStrRVM
    For i = 0 To 8
        If InStr(sTmp, CStr(i)) Then
            bRVM(i) = True
        Else
            bRVM(i) = False
            bHF = True
        End If
    Next i
    
    If bHF = False Then 'We kind of need at least one...
        bRVM(1) = False
    End If
    
    Exit Sub
    
    e0:
        DebugAppend "ucShellBrowse.InitRVM->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Function IsVMRestricted(nMode As ShellBrowseView) As Boolean
    '0=XLIcon,1=LgIcon,2=MedIcon,3=SmIcon,4=List,5=Detail,6=Tile,7=Content,8=Thumbnail
    Select Case nMode
         Case SB_VIEW_XLICON: IsVMRestricted = bRVM(0)
         Case SB_VIEW_ICON: IsVMRestricted = bRVM(1)
         Case SB_VIEW_MDICON: IsVMRestricted = bRVM(2)
         Case SB_VIEW_SMALLICON: IsVMRestricted = bRVM(3)
         Case SB_VIEW_LIST: IsVMRestricted = bRVM(4)
         Case SB_VIEW_DETAILS: IsVMRestricted = bRVM(5)
         Case SB_VIEW_TILE: IsVMRestricted = bRVM(6)
         Case SB_VIEW_CONTENTS: IsVMRestricted = bRVM(7)
         Case SB_VIEW_THUMBNAIL: IsVMRestricted = bRVM(8)
    End Select
    End Function
    Private Sub InitPKeys()
    'loads columns for display...
    'the problem here is all the properties we want, those displayed by explorer,
    'are not contained in a single PDEF_ enumeration. PDEF_VIEWABLE and PDEF_COLUMN
    'each have keys we want that the other doesn't have, but PDEF_ALL has ones we
    'DON'T want to display. So, to get all desirable keys, it is neccessary to merge
    'VIEWABLE and COLUMN
    Dim i As Long, k As Long
    Dim ppsys As IPropertySystem
    Dim pProp As IPropertyDescription
    Dim pPropList As IPropertyDescriptionList
    Dim nProp As Long
    Dim lpProp As LongPtr
    Dim sProp As String
    Dim sSysN As String
    Dim lpk As PROPERTYKEY
    Dim dwFlag As PROPDESC_TYPE_FLAGS
    Dim dwDisp As PROPDESC_DISPLAYTYPE
    Dim dwView As PROPDESC_VIEW_FLAGS
    Dim dwColSt As SHCOLSTATEF
    
    DebugAppend "Initializing Display Columns..."
    PSGetPropertySystem IID_IPropertySystem, ppsys
    ppsys.EnumeratePropertyDescriptions PDEF_COLUMN, IID_IPropertyDescriptionList, pPropList
    pPropList.GetCount nProp
    ReDim uColData(0)
    For i = 0 To (nProp - 1)
        pPropList.GetAt i, IID_IPropertyDescription, pProp
        pProp.GetDisplayName lpProp
        sProp = LPWSTRtoStr(lpProp)
        pProp.GetCanonicalName lpProp
        sSysN = LPWSTRtoStr(lpProp)
    '    DebugAppend "LoadProp Disp=" & sProp & ",Sys=" & sSysN
        If (sProp = "") And (sSysN <> "") Then
            sProp = sSysN
        End If
        If sProp <> "" Then
            ReDim Preserve uColData(k)
            uColData(k).szDisplayName = sProp & ""
            pProp.GetPropertyKey lpk
            uColData(k).pKey.fmtid = lpk.fmtid
            uColData(k).pKey.pid = lpk.pid
            pProp.GetDefaultColumnWidth uColData(k).DefWidth
            If uColData(k).DefWidth < 30 Then
                uColData(k).DefWidth = uColData(k).DefWidth * 8 'always seems to be 1/8th what it should be
            End If
            uColData(k).szSystemName = sSysN
            pProp.GetTypeFlags PDTF_MASK_ALL, dwFlag
            uColData(k).dwTypeFlags = dwFlag
            
            pProp.GetDisplayType dwDisp
            uColData(k).dwDispType = dwDisp
            
            pProp.GetViewFlags dwView
            uColData(k).dwViewFlags = dwView
            
            pProp.GetColumnState dwColSt
            uColData(k).dwColState = dwColSt
            
            If uColData(k).szSystemName = "System.FileName" Then
                DebugAppend "SYSTEM.FILENAME: 0x" & Hex$(uColData(k).pKey.fmtid.Data1) & ",0x" & Hex$(uColData(k).pKey.fmtid.Data2) & ",last=0x" & Hex$(uColData(k).pKey.fmtid.Data4(7)) & ",pid=" & uColData(k).pKey.pid
                Dim pkt As PROPERTYKEY
                pkt = GetPKeyFromSysName("System.FileName")
    '             DebugAppend "SYSTEM.FILENAME-CHK: 0x" & Hex$(pkt.fmtid.Data1) & ",0x" & Hex$(pkt.fmtid.Data2) & ",last=0x" & Hex$(pkt.fmtid.Data4(7)) & ",pid=" & pkt.pid
               
             End If
            If uColData(k).szSystemName = "System.ItemNameDisplay" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = True
                uColData(k).ColVis = True
                uColData(k).pos = 0
                lDefColIdx(0) = k
                mn_sName2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.Size" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = True
                uColData(k).ColVis = True
                uColData(k).pos = 1
                lDefColIdx(1) = k
                mn_sSize2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.ItemTypeText" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = True
                uColData(k).ColVis = True
                uColData(k).pos = 2
                lDefColIdx(2) = k
                mn_sType2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.DateModified" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = True
                uColData(k).ColVis = True
                uColData(k).pos = 3
                lDefColIdx(3) = k
                mn_sMod2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.DateCreated" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = False
                uColData(k).pos = 4
                lDefColIdx(4) = k
                mn_sCrd2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.DateAccessed" Then
                uColData(k).IsDefProp = True
                uColData(k).Visible = False
                uColData(k).pos = 5
                lDefColIdx(5) = k
                mn_sAcc2 = uColData(k).szDisplayName
            End If
            If uColData(k).szSystemName = "System.Rating" Then
                lRTColIdx = k
            End If
            If IsEqualPKEY(uColData(k).pKey, PKEY_PropList_PreviewDetails) Then
                lRTSColIdx = k
            End If
            k = k + 1
        End If
    Next i
    'now repeat and merge for PDEF_COLUMN
    
    PSGetPropertySystem IID_IPropertySystem, ppsys
    ppsys.EnumeratePropertyDescriptions PDEF_ALL, IID_IPropertyDescriptionList, pPropList
    pPropList.GetCount nProp
    For i = 0 To (nProp - 1)
        pPropList.GetAt i, IID_IPropertyDescription, pProp
        pProp.GetDisplayName lpProp
        sProp = LPWSTRtoStr(lpProp)
        pProp.GetCanonicalName lpProp
        sSysN = LPWSTRtoStr(lpProp)
        If (sProp = "") And (sSysN <> "") Then
            sProp = sSysN
        End If
        If sProp <> "" Then
            pProp.GetPropertyKey lpk
            If PropKeyIsLoaded(lpk) Then GoTo nxt2
    '        DebugAppend "AddProp " & sSysN
            ReDim Preserve uColData(k)
            uColData(k).szSystemName = sSysN
            uColData(k).szDisplayName = sProp & ""
            pProp.GetDisplayType dwDisp
            uColData(k).dwDispType = dwDisp
            pProp.GetViewFlags dwView
            uColData(k).dwViewFlags = dwView
            pProp.GetTypeFlags PDTF_MASK_ALL, dwFlag
            uColData(k).dwTypeFlags = dwFlag
            pProp.GetColumnState dwColSt
            uColData(k).dwColState = dwColSt
            
            uColData(k).pKey.fmtid = lpk.fmtid
            uColData(k).pKey.pid = lpk.pid
            pProp.GetDefaultColumnWidth uColData(k).DefWidth
            If uColData(k).DefWidth < 21 Then
                uColData(k).DefWidth = uColData(k).DefWidth * 8 'always seems to be 1/8th what it should be
            End If
            uColData(k).NoList = True 'most of these props arent meant for user display, but a couple appear
                                      'as columns in weird locations; as a compromise, they're loaded in case
                                      'a folder has them as a default (Computer, Network come to mind), but we
                                      'won't list them in the columns selection list
            If uColData(k).szSystemName = "System.PercentFull" Then
                lPFColIdx = k
            End If
            If uColData(k).szSystemName = "System.Computer.DecoratedFreeSpace" Then
                lDFSColIdx = k
            End If
    
            If (uColData(k).szSystemName = "System.Software.HelpLink") Or (uColData(k).szSystemName = "System.Software.SupportUrl") Then  'Or(uColData(k).szSystemName = "System.Software.UpdateInfoUrl") Then
                uColData(k).bFlagIsLink = True
            End If
            If uColData(k).szSystemName = "System.Rating" Then
                lRTColIdx = k
            End If
            If IsEqualPKEY(uColData(k).pKey, PKEY_PropList_PreviewDetails) Then
                lRTSColIdx = k
            End If
            k = k + 1
        End If
    nxt2:
    Next i
    PSGetPropertySystem IID_IPropertySystem, ppsys
    ppsys.EnumeratePropertyDescriptions PDEF_VIEWABLE, IID_IPropertyDescriptionList, pPropList
    pPropList.GetCount nProp
    For i = 0 To (nProp - 1)
        pPropList.GetAt i, IID_IPropertyDescription, pProp
        pProp.GetDisplayName lpProp
        sProp = LPWSTRtoStr(lpProp)
        pProp.GetCanonicalName lpProp
        sSysN = LPWSTRtoStr(lpProp)
        If (sProp = "") And (sSysN <> "") Then
            sProp = sSysN
        End If
        If sProp <> "" Then
            pProp.GetPropertyKey lpk
            If PropKeyIsLoaded(lpk) Then GoTo nxt
    '        DebugAppend "LOAD VIEWABLE NOT IN ALL: " & sSysN
            ReDim Preserve uColData(k)
            uColData(k).szSystemName = sSysN
            uColData(k).szDisplayName = sProp & ""
            uColData(k).pKey.fmtid = lpk.fmtid
            uColData(k).pKey.pid = lpk.pid
            pProp.GetDefaultColumnWidth uColData(k).DefWidth
            If uColData(k).DefWidth < 21 Then
                uColData(k).DefWidth = uColData(k).DefWidth * 8 'always seems to be 1/8th what it should be
            End If
            pProp.GetTypeFlags PDTF_MASK_ALL, dwFlag
            uColData(k).dwTypeFlags = dwFlag
            pProp.GetDisplayType dwDisp
            uColData(k).dwDispType = dwDisp
            pProp.GetColumnState dwColSt
            uColData(k).dwColState = dwColSt
            
            k = k + 1
        End If
    nxt:
    Next i
    
    ReDim lColKey(k + 1)
    DebugAppend "Added " & k & " columns"
    End Sub
    
    Private Function AppendCustomPKEY(pk As PROPERTYKEY, lDefWidth As Long, dwState As CM_STATE, sName As String, sPath As String) As Long
    Dim idx As Long
    idx = UBound(uColData) + 1
    ReDim Preserve uColData(idx)
    uColData(idx).pKey = pk
    If lDefWidth < 30& Then
        uColData(idx).DefWidth = 120&
    Else
        uColData(idx).DefWidth = lDefWidth
    End If
    uColData(idx).dwCustColState = dwState
    uColData(idx).szDisplayName = sName
    uColData(idx).bFlagCustom = True
    uColData(idx).szCustomFor = sPath 'We don't want these highly specialized columns in the ColMenu or ColList for other folders
    bUCDhasCust = True
    AppendCustomPKEY = idx
    DebugAppend "AppendCustomPKEY(" & idx & ")->" & sName & "::" & dbg_PKEYToString(pk)
    End Function
    
    Private Sub ClearCustomPKEYs()
    If bUCDhasCust = False Then Exit Sub
    Dim nCol As Long
    Dim uNew() As ColumnData
    ReDim uNew(0)
    Dim i As Long
    
    For i = 0 To UBound(uColData)
        If uColData(i).bFlagCustom = False Then
            ReDim Preserve uNew(nCol)
            uNew(nCol) = uColData(i)
            nCol = nCol + 1
        End If
    Next i
    
    uColData = uNew
    bUCDhasCust = False
    
    End Sub
    
    Private Function LookupColFromPK(fmtid As UUID, pid As Long) As Long
    Dim pk As PROPERTYKEY
    pk.fmtid = fmtid
    pk.pid = pid
    Dim i As Long
    
    For i = 0 To UBound(uColData)
        If IsEqualPKEY(uColData(i).pKey, pk) Then
            LookupColFromPK = i
    '        DebugAppend "PKeyMatch/" & Hex$(pk.fmtid.Data1) & "/" & Hex$(uColData(i).pkey.fmtid.Data1) & "/" & uColData(i).szSystemName
            Exit Function
        End If
    Next i
    LookupColFromPK = -1
    End Function
    
    Private Function LookupColFromPK2(pk As PROPERTYKEY) As Long
    Dim i As Long
    
    For i = 0 To UBound(uColData)
        If IsEqualPKEY(uColData(i).pKey, pk) Then
            LookupColFromPK2 = i
    '        DebugAppend "PKeyMatch/" & Hex$(pk.fmtid.Data1) & "/" & Hex$(uColData(i).pkey.fmtid.Data1) & "/" & uColData(i).szSystemName
            Exit Function
        End If
    Next i
    LookupColFromPK2 = -1
    End Function
    
    Private Function IsEqualPKEY(pk1 As PROPERTYKEY, pk2 As PROPERTYKEY) As Boolean
    If pk1.pid <> pk2.pid Then Exit Function
    If IsEqualIID(pk1.fmtid, pk2.fmtid) Then
        IsEqualPKEY = True
    End If
    End Function
    
    Private Sub ShowColMenu()
    If m_ColLock = SBCL_LockNoUser Then Exit Sub 'user column selection disabled
    'Displays the right click menu for ListView2
    'Only way to get images on a popup menu not visible on the main bar
    Dim hMenu As LongPtr
    Dim mii As MENUITEMINFOW
    Dim PT As POINT
    Dim idCmd As Long
    Dim lPos As Long
    Dim i As Long, j As Long
    Dim lp As LongPtr
    Dim lAdd() As Long, nAdd As Long
    hMenu = CreatePopupMenu()
    ReDim lAdd(0)
    lAdd(0) = -1
    With mii
        .cbSize = LenB(mii)
        DebugAppend "construct col menu"
        'name
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        .wID = idName
        .dwTypeData = StrPtr(mn_sName2)
        .cch = Len(mn_sName2)
        .fState = MFS_DISABLED Or MFS_CHECKED
        Call InsertMenuItemW(hMenu, 0, True, mii)
        Dim nPos As Long
        nPos = 1
        
        'size
        If uColData(lDefColIdx(1)).ColVis = True Or (uColData(lDefColIdx(1)).NoList = False) Then
        .wID = idSize
        .dwTypeData = StrPtr(mn_sSize2)
        .cch = Len(mn_sSize2)
        .fState = IIf(uColData(lDefColIdx(1)).ColVis, MFS_CHECKED, MFS_UNCHECKED)
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        End If
        'type
        If uColData(lDefColIdx(2)).ColVis = True Or (uColData(lDefColIdx(2)).NoList = False) Then
        .wID = idType
        .dwTypeData = StrPtr(mn_sType2)
        .cch = Len(mn_sType2)
        .fState = IIf(uColData(lDefColIdx(2)).ColVis, MFS_CHECKED, MFS_UNCHECKED)
    
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        End If
    
        'modified
        If uColData(lDefColIdx(3)).ColVis = True Or (uColData(lDefColIdx(3)).NoList = False) Then
        .wID = idMod
        .dwTypeData = StrPtr(mn_sMod2)
        .cch = Len(mn_sMod2)
        .fState = IIf(uColData(lDefColIdx(3)).ColVis, MFS_CHECKED, MFS_UNCHECKED)
    
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        End If
        
        'created
        If uColData(lDefColIdx(4)).ColVis = True Or (uColData(lDefColIdx(4)).NoList = False) Then
        .wID = idCrd
        .dwTypeData = StrPtr(mn_sCrd2)
        .cch = Len(mn_sCrd2)
        .fState = IIf(uColData(lDefColIdx(4)).ColVis, MFS_CHECKED, MFS_UNCHECKED)
    
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        End If
        
        'accessed
        If uColData(lDefColIdx(5)).ColVis = True Or (uColData(lDefColIdx(5)).NoList = False) Then
        .wID = idAcc
        .dwTypeData = StrPtr(mn_sAcc2)
        .cch = Len(mn_sAcc2)
        .fState = IIf(uColData(lDefColIdx(5)).ColVis, MFS_CHECKED, MFS_UNCHECKED)
    
        Call InsertMenuItemW(hMenu, nPos, True, mii)
        nPos = nPos + 1
        End If
        End With
        lPos = nPos
      
        For i = 0 To UBound(uColData)
            With uColData(i)
                If (.IsDefProp = False) And (.ColVis = True) Then
                    mii.fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_DATA
                    mii.wID = idColMnBase + i
                    mii.cch = Len(.szDisplayName)
                    mii.dwTypeData = StrPtr(.szDisplayName)
                    mii.dwItemData = i
                    mii.fState = MFS_CHECKED
                    Call InsertMenuItemW(hMenu, lPos, True, mii)
                    lPos = lPos + 1
                End If
            End With
        Next i
       If ColCurrentHidden <= 10 Then
        DebugAppend "<10"
         For i = 0 To UBound(uColData)
            With uColData(i)
                If (.ColVis = False) And (.NoList = False) And (.IsDefProp = False) Then
                DebugAppend "ColData n=" & .szDisplayName & ",nolist=" & .NoList & ",colvis=" & .ColVis
                    If (.bFlagCustom = True) Then
    '                    DebugAppend "CustColMenuEntry for=" & .szCustomFor & ",mscp=" & m_sCurPath
                        If m_sCurPath <> .szCustomFor Then GoTo flnxt
                    End If
                    mii.fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_DATA
                    mii.wID = idColMnBase + i
                    mii.cch = Len(.szDisplayName)
                    mii.dwTypeData = StrPtr(.szDisplayName)
                    mii.dwItemData = i
                    mii.fState = MFS_UNCHECKED
                    Call InsertMenuItemW(hMenu, lPos, True, mii)
                    lPos = lPos + 1
                    ReDim Preserve lAdd(nAdd)
                    lAdd(nAdd) = i: nAdd = nAdd + 1
                End If
            End With
    flnxt:
          Next i
        End If
        For i = 0 To UBound(uColData)
            With uColData(i)
                If (.IsDefProp = False) And (.ColVis = False) And (.NoList = False) And (.bFlagRecent = True) Then
                    For j = 0 To UBound(lAdd)
                        If lAdd(j) = i Then GoTo rcnxt
                    Next j
                    If (.bFlagCustom = True) Then
                        If m_sCurPath <> .szCustomFor Then GoTo rcnxt
                    End If
                    mii.fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_DATA
                    mii.wID = idColMnBase + i
                    mii.cch = Len(.szDisplayName)
                    mii.dwTypeData = StrPtr(.szDisplayName)
                    mii.dwItemData = i
                    mii.fState = MFS_UNCHECKED
                    Call InsertMenuItemW(hMenu, lPos, True, mii)
                    lPos = lPos + 1
                End If
            End With
    rcnxt:
        Next i
       
        
        With mii
    
        'Sep
        .fMask = MIIM_ID Or MIIM_TYPE
        .fType = MFT_SEPARATOR
        .wID = 0
        Call InsertMenuItemW(hMenu, lPos, True, mii)
        lPos = lPos + 1
        'more
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        .wID = idMore
        .dwTypeData = StrPtr(mn_sMore)
        .cch = Len(mn_sMore)
        If bColSelActive Then
            .fState = MFS_DISABLED
        Else
            .fState = MFS_ENABLED
        End If
        Call InsertMenuItemW(hMenu, lPos, True, mii)
        
        If m_ColLock = SBCL_None Then
            'lock
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .wID = idLockCol
            .dwTypeData = StrPtr(mn_sLock)
            .cch = Len(mn_sLock)
            .fState = IIf(bKeepColumns, MFS_CHECKED, MFS_UNCHECKED)
            Call InsertMenuItemW(hMenu, lPos, True, mii)
        End If
    End With
    
    Call GetCursorPos(PT)
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_HORIZONTAL Or TPM_RETURNCMD, PT.x, PT.y, 0, hLVS, 0)
    If idCmd Then
        Select Case idCmd
            Case idName
                'Never enabled
    
            Case idSize
                If uColData(lDefColIdx(1)).ColVis Then
                    Call RemoveSizeColumn
                Else
                    Call AddSizeColumn
                End If
    
            Case idType
                DebugAppend "type col vis=" & uColData(lDefColIdx(3)).ColVis
                If uColData(lDefColIdx(2)).ColVis Then
                    Call RemoveTypeColumn
                Else
                    Call AddTypeColumn
                End If
    
            Case idMod
                If uColData(lDefColIdx(3)).ColVis Then
                    Call RemoveDtModColumn
                Else
                    Call AddDtModColumn
                End If
                
            Case idCrd
                If uColData(lDefColIdx(4)).ColVis Then
                    Call RemoveDtCrdColumn
                Else
                    Call AddDtCrdColumn
                End If
    
            Case idAcc
                If uColData(lDefColIdx(5)).ColVis Then
                    Call RemoveDtAccColumn
                Else
                    Call AddDtAccColumn
                End If
                
            Case idMore
                LoadColumnSelect
                
            Case idLockCol
                If bKeepColumns Then
                    bKeepColumns = False
                    lKeepColIdx = -1
                Else
                    bKeepColumns = True
                    lKeepColIdx = nCurrentCBItemIndex
                    lKeepColSet = cbItems(lKeepColIdx).lColSet
                    DebugAppend "KeepColIdx=" & lKeepColIdx
                    If lKeepColIdx > -1 Then
                        DebugAppend "KeepColIdx.bUseColSet=" & cbItems(lKeepColIdx).bUseColset
                    End If
                End If
    
            Case idColMnBase To (idColMnBase + UBound(uColData))
                lp = idCmd - idColMnBase
                DebugAppend uColData(lp).szSystemName & ".vis=" & uColData(lp).Visible & ",colvis=" & uColData(lp).ColVis ', 3
                Dim lIdx As Long, lCl As Long
                DebugAppend "m_sCurPath =" & m_sCurPath
                For i = 0 To UBound(cbItems)
    '                DebugAppend "CheckCB=" & cbItems(i).sFullPath
                    If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
                        lIdx = i
                        Exit For
                    End If
                Next i
                If uColData(lp).ColVis = True Then
                    RemoveFromCurColSet lIdx, CLng(lp)
                
                Else
                    lCl = UBound(cbItems(lIdx).lColSet)
                    lCl = lCl + 1
                    ReDim Preserve cbItems(lIdx).lColSet(lCl)
                    cbItems(lIdx).lColSet(lCl) = lp
                End If
                UpdateColumns lIdx
                    
        End Select
    End If
    
    Call DestroyMenu(hMenu)
    
    DebugAppend "idCmd=" & idCmd
    
    End Sub
     
    Private Function ColCurrentHidden() As Long
    Dim i As Long
    Dim C As Long
    For i = 0 To UBound(uColData)
        If uColData(i).ColVis = False Then
            If uColData(i).NoList = False Then C = C + 1
        End If
    Next i
    ColCurrentHidden = C
    End Function
    
    Private Sub RemoveFromCurColSet(lIdx As Long, n As Long)
    DebugAppend "RemoveCol(" & lIdx & "," & n & ")"
    Dim lSetN() As LongPtr
    Dim i As Long
    Dim k As Long
    DebugAppend "use=" & cbItems(lIdx).bUseColset
    DebugAppend "ub=" & UBound(cbItems(lIdx).lColSet)
    ReDim lSetN(UBound(cbItems(lIdx).lColSet) - 1)
    
    For i = 0 To UBound(cbItems(lIdx).lColSet)
        If cbItems(lIdx).lColSet(i) <> n Then
            lSetN(k) = cbItems(lIdx).lColSet(i)
            k = k + 1
        End If
    Next i
    ReDim cbItems(lIdx).lColSet(UBound(lSetN))
    For i = 0 To UBound(lSetN)
        cbItems(lIdx).lColSet(i) = lSetN(i)
    Next i
    
    End Sub
    
    Private Sub AddSizeColumn()
    Dim i As Long
    Dim lIdx As Long
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim Preserve cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet) + 1)
    cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet)) = lDefColIdx(1)
    UpdateColumns lIdx
    
    End Sub
    
    Private Sub RemoveSizeColumn()
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lDefColIdx(1)
    UpdateColumns lIdx 'UpdateColumns will update uColData
    
    End Sub
    
    Private Sub AddTypeColumn()
    Dim i As Long
    Dim lIdx As Long
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim Preserve cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet) + 1)
    cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet)) = lDefColIdx(2)
    UpdateColumns lIdx
    End Sub
    
    Private Sub RemoveTypeColumn()
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lDefColIdx(2)
    UpdateColumns lIdx 'UpdateColumns will update uColData
    
        
    End Sub
    
    Private Sub AddDtModColumn()
    Dim i As Long
    Dim lIdx As Long
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim Preserve cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet) + 1)
    cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet)) = lDefColIdx(3)
    UpdateColumns lIdx
    
    End Sub
    
    Private Sub RemoveDtModColumn()
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lDefColIdx(3)
    UpdateColumns lIdx 'UpdateColumns will update uColData
    End Sub
    
    Private Sub AddDtCrdColumn()
    Dim i As Long
    Dim lIdx As Long
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim Preserve cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet) + 1)
    cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet)) = lDefColIdx(4)
    UpdateColumns lIdx
    
    End Sub
    
    Private Sub RemoveDtCrdColumn()
    
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lDefColIdx(4)
    UpdateColumns lIdx 'UpdateColumns will update uColData
    
    
    End Sub
    
    Private Sub AddDtAccColumn()
    Dim i As Long
    Dim lIdx As Long
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    ReDim Preserve cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet) + 1)
    cbItems(lIdx).lColSet(UBound(cbItems(lIdx).lColSet)) = lDefColIdx(5)
    UpdateColumns lIdx
    End Sub
    
    Private Sub RemoveDtAccColumn()
    
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lDefColIdx(5)
    UpdateColumns lIdx 'UpdateColumns will update uColData
    
    
    End Sub
    
    Public Sub RemoveCustomColumn(lColID As Long)
    Dim i As Long
    Dim lIdx As Long
    
    For i = 0 To UBound(cbItems)
        If (cbItems(i).sFullPath = m_sCurPath) And (cbItems(i).bDeleted = False) Then
            lIdx = i
            Exit For
        End If
    Next i
    RemoveFromCurColSet lIdx, lColID
    UpdateColumns lIdx 'UpdateColumns will update uColData
    
    End Sub
    
    Public Sub RemoveColumnByPropName(sSystemName As String)
    Dim idx As Long
    idx = -1
    idx = GetColBySysName(sSystemName)
    If idx >= 0& Then
        RemoveCustomColumn idx 'This function is really by ID; it's just that's the best way to ID custom cols so was added that way
    End If
        
    End Sub
    
    Public Sub RemoveColumnByPKEY(pkey_varptr As LongPtr)
    Dim pk As PROPERTYKEY
    
    If pkey_varptr Then
        CopyMemory ByVal VarPtr(pk), ByVal pkey_varptr, LenB(pk)
    Else
        DebugAppend "RemoveColumnByPKEY::No pointer to PKEY"
        Exit Sub
    End If
    
    Dim idx As Long
    idx = LookupColFromPK2(pk)
    If idx >= 0& Then
        RemoveCustomColumn idx 'This function is really by ID; it's just that's the best way to ID custom cols so was added that way
    End If
    
    End Sub
    'Public Sub RemoveColumnByPKEY(pk As PROPERTYKEY)
    'Dim idx As Long
    'idx = LookupColFromPK2(pk)
    'If idx >= 0& Then
    '    RemoveCustomColumn idx 'This function is really by ID; it's just that's the best way to ID custom cols so was added that way
    'End If
    'End Sub
    
    Private Sub ResetSpecialCols()
    'If columns before Ratings or Percent Full are removed, their index change needs to be recognized
    DebugAppend "ResetSpecialCols()"
    Dim hct As Long
    Dim i As Long
    Dim lp As LongPtr
    lvrCol = 0
    m_SubItemType = 0
    m_SubItemSize = 0
    m_SubItemProgress = 0
    m_SubItemFreeSpc = 0
    mLinkCol = 0
    hct = Header_GetItemCount(hLVSHdr)
    For i = 0 To (hct - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
        If lp = lRTColIdx Then
            lvrCol = i
        End If
        If lp = lPFColIdx Then
            m_SubItemProgress = i
        End If
        If lp = lDefColIdx(2) Then
            m_SubItemType = i
        End If
        If lp = lDefColIdx(1) Then
            m_SubItemSize = i
        End If
        If lp = lDFSColIdx Then
            m_SubItemFreeSpc = i
        End If
        If (uColData(lp).bFlagIsLink = True) And (mLinkCol = 0) Then 'Only allow 1 link column due to redraw bug
            mLinkCol = i
        End If
    Next i
    DebugAppend "ResetSpecialCols, m_SubItemProgress=" & m_SubItemProgress
    
    End Sub
    
    Private Sub UpdateColumns(lpi As Long, Optional bRefreshExisting As Boolean = False)
    'Updates the current view
    On Error GoTo e0
    Dim i As Long, j As Long, k As Long
    Dim cc As Long
    Dim lColCnt As Long
    Dim lp As Long
    Dim llp As Long
    Dim bAdd As Boolean
    Dim lvi As LVITEM
    Dim bVis As Boolean
    Dim bDelFlag As Boolean
    Dim lSetC() As LongPtr, nSetC As Long
    Dim hr As Long
    Dim lECD As Long
    
    UpdateStatus mStrLoadColData
    'first, reconcile uColData with the current folder's colgroup
    For i = 0 To UBound(uColData)
        For j = 0 To UBound(cbItems(lpi).lColSet)
            If cbItems(lpi).lColSet(j) = i Then
                bVis = True
                Exit For
            Else
                bVis = False
            End If
        Next j
        uColData(i).Visible = bVis
    Next i
    DebugAppend "UpdateColumns->Finished reconcile; proceeding,refresh=" & bRefreshExisting
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    'next, delete unused columns
    If lColCnt > 1 Then
        For i = (lColCnt - 1) To 1 Step -1
            lp = CLng(GetHDItemlParam(hLVSHdr, i))
            uColData(lp).ColVis = True
            If uColData(lp).Visible = False Then
                DebugAppend "UpdateColumns->Delete " & uColData(lp).szDisplayName
                bDelFlag = True
                Call SendMessage(hLVS, LVM_DELETECOLUMN, i, ByVal 0&)
                If lp = lRTColIdx Then
                    lvrCol = 0
                End If
                If lp = lPFColIdx Then
                    m_SubItemProgress = 0
                End If
                If lp = lDFSColIdx Then
                    m_SubItemFreeSpc = 0
                End If
                If lp = lDefColIdx(2) Then
                    m_SubItemType = 0
                End If
                lColCnt = lColCnt - 1
                uColData(lp).ColVis = False
            End If
        Next i
    End If
    If bDelFlag Then ResetSpecialCols
    'Now, insert new columns, and save their positions- these will be the
    'only ones that we need to set; don't want to spend time setting what
    'is already set
    k = 1
    ReDim lSetC(0)
    For i = 1 To 5 'first, insert visible default columns ahead of others
        If (uColData(lDefColIdx(i)).Visible = True) And (uColData(lDefColIdx(i)).ColVis = True) Then
            k = k + 1 'adjust insert order; maintain default column sequence
        End If
        If (uColData(lDefColIdx(i)).Visible = True) And (uColData(lDefColIdx(i)).ColVis = False) Then
            cc = InsertListColumn(lDefColIdx(i), k)
            bAdd = True
            ReDim Preserve lSetC(nSetC)
            lSetC(nSetC) = cc
            If cc > (-1) Then k = k + 1
            nSetC = nSetC + 1
        End If
    Next i
    lColCnt = Header_GetItemCount(hLVSHdr)
    k = lColCnt 'reset position to end of list
    For i = 0 To UBound(uColData)
        If (uColData(i).Visible = True) And (uColData(i).ColVis = False) And (uColData(i).IsDefProp = False) Then
            If (uColData(i).bFlagManual = True) And (uColData(i).lManualInsertAt <> -1&) Then
                cc = InsertListColumn(i, uColData(i).lManualInsertAt)
            Else
                cc = InsertListColumn(i, k)
            End If
            bAdd = True
            ReDim Preserve lSetC(nSetC)
            lSetC(nSetC) = cc
            If cc > (-1) Then k = k + 1
            nSetC = nSetC + 1
        End If
    Next i
    
    If (bAdd = False) And (bRefreshExisting = False) Then Exit Sub 'No columns have been inserted, so no need to run an update loop
    Dim lCnt As Long
    'Finally, populate only the columns that are newly added (lSetC)
    lColCnt = Header_GetItemCount(hLVSHdr)
    If lColCnt = 1 Then GoTo out 'Only name is displayed, and since it's never removed
                                 'it's already filled in, so we can exit
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    'Dim lvi As LVITEM
    Dim pps As IPropertyStore
    Dim isi As IShellItem2
    Dim sTmp As String
    Dim tsct As Long
    Dim lCrCl As Long
    Dim lStart As Long
    Dim rtSup As Boolean
    Dim pidlFQItem As LongPtr
    Dim nCIImg As Long
    DebugAppend "UpdateColumns::lSetC=" & dbg_sfromlarray(lSetC)
    ResetSpecialCols
    If bRefreshExisting Then
        lStart = 1
        tsct = lColCnt - 1
    Else
        lStart = 0
        tsct = UBound(lSetC)
    End If
    On Error GoTo nxtitm
    For i = 0 To (lCnt - 1)
        llp = CLng(GetLVItemlParam(hLVS, i))
        On Error GoTo nxtcol
        For j = lStart To tsct
            lvi.Mask = LVIF_TEXT Or LVIF_DI_SETITEM
            If bRefreshExisting Then
                lCrCl = j
            Else
                lCrCl = CLng(lSetC(j))
            End If
            lp = CLng(GetHDItemlParam(hLVSHdr, CLng(lCrCl)))
            'lDefColIdx(0) is Name, and is never removed
            If uColData(lp).bFlagManual Then 'Manually inserted column
                SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                If (isi Is Nothing) Then
                    SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                    If (isi Is Nothing) Then
                        DebugAppend "UpdateColumns->Alternate isi creation failed"
                    End If
                End If
                nCIImg = -1
                sTmp = ""
                RaiseEvent CustomColumnQueryData(lp, isi, pidlFQItem, LVEntries(llp).sName, LVEntries(llp).sParentFull, i, sTmp, nCIImg)
    
                If (uColData(lp).bFlagManHasImg = True) And (nCIImg >= 0) Then
                    lvi.Mask = lvi.Mask Or LVIF_IMAGE
                    lvi.iImage = nCIImg
                End If
                
                lECD = ColCacheIdx(lp, llp)
                Dim vrw2 As Variant
                vrw2 = CVar(sTmp)
                LVEntries(llp).ExtColData(lECD).cdid = lp
                LVEntries(llp).ExtColData(lECD).sDisp = sTmp
                LVEntries(llp).ExtColData(lECD).vRaw = vrw2
               
                lvi.cchTextMax = Len(sTmp) + 1
                lvi.pszText = StrPtr(sTmp)
                If pidlFQItem Then CoTaskMemFree pidlFQItem
            Else
                lECD = ColCacheIdx(lp, llp)
                Dim vrw As Variant, vbrw As Variant
                LVEntries(llp).ExtColData(lECD).cdid = lp
                If (mExtColPreload = True) Or (bFlagNoPL = True) Then
                Select Case lp
                    Case lDefColIdx(1)
                        LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sSize
                        LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).cSize)
                        lvi.cchTextMax = Len(LVEntries(llp).sSize) + 1
                        lvi.pszText = StrPtr(LVEntries(llp).sSize)
                    Case lDefColIdx(2)
                        LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sType
                        LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).sType)
                        lvi.cchTextMax = Len(LVEntries(llp).sType) + 1
                        lvi.pszText = StrPtr(LVEntries(llp).sType)
                    Case lDefColIdx(3)
                        LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateM
                        InitPropVariantFromFileTime LVEntries(llp).ftDateM, vrw
                        PropVariantToVariant vrw, vbrw
                        LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                        lvi.cchTextMax = Len(LVEntries(llp).sDateM) + 1
                        lvi.pszText = StrPtr(LVEntries(llp).sDateM)
                    Case lDefColIdx(4)
                        LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateC
                        InitPropVariantFromFileTime LVEntries(llp).ftDateC, vrw
                        PropVariantToVariant vrw, vbrw
                        LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                        lvi.cchTextMax = Len(LVEntries(llp).sDateC) + 1
                        lvi.pszText = StrPtr(LVEntries(llp).sDateC)
                    Case lDefColIdx(5)
                        LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateA
                        InitPropVariantFromFileTime LVEntries(llp).ftDateA, vrw
                        PropVariantToVariant vrw, vbrw
                        LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                        lvi.cchTextMax = Len(LVEntries(llp).sDateA) + 1
                        lvi.pszText = StrPtr(LVEntries(llp).sDateA)
                    Case Else
    
                        If (pps Is Nothing) Then
                            SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                            If (isi Is Nothing) Then
                                DebugAppend "UpdateColumns->Failed to get isi"
                                pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                                SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                                If (isi Is Nothing) Then
                                    DebugAppend "UpdateColumns->Alternate isi creation failed"
                                End If
                                If pidlFQItem Then CoTaskMemFree pidlFQItem
                            End If
                            isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
                        End If
                        If (lp = lRTColIdx) And (lvrEnable = True) Then
        '                    LVEntries(llp).lRating = GetFileRating(LVEntries(llp).sFullPath, llp)
                            rtSup = False
                            LVEntries(llp).lRating = GetFileRatingEx(LVEntries(llp).sFullPath, rtSup, llp)
                            LVEntries(llp).bRatingSupport = rtSup
                            sTmp = " "
                        Else
                            sTmp = GetPropertyKeyDisplayString(pps, uColData(lp).pKey)
                        End If
                        If (lp = lPFColIdx) And (m_SubItemProgress > 0) Then
                            If PStoreHasPF(pps) Then
                                Dim pv As Variant, vbv As Variant
                                pps.GetValue PKEY_PercentFull, pv
                                PropVariantToVariant pv, vbv
                                LVEntries(llp).lPercent = CLng(vbv)
                                sTmp = " "
                                DebugAppend "UpdateColumns->SetPercent " & LVEntries(llp).sName & "=" & LVEntries(llp).lPercent
                            Else
                                'Percent full column is visible but does not apply to item, flag to not draw bar
                                LVEntries(llp).lPercent = -1
                            End If
                        End If
        '                DebugAppend "UpdateColumns->UpdateColumns.SetText->ColLP=" & lp & ",ColDesc=" & uColData(lp).szSystemName & ",SetTo=" & sTmp
                        lvi.cchTextMax = Len(sTmp) + 1
                        lvi.pszText = StrPtr(sTmp)
                        
                        LVEntries(llp).ExtColData(lECD).sDisp = sTmp
                        If (sTmp = "") And (uColData(lp).dwDispType = PDDT_NUMBER) Then
                            LVEntries(llp).ExtColData(lECD).vRaw = CLng(-1)
                        Else
                            pps.GetValue uColData(lp).pKey, vrw
                            hr = PropVariantToVariant(vrw, vbrw)
                            If hr = S_OK Then
                                LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                            End If
                        End If
                End Select
            Else
                lvi.cchTextMax = 0&
                lvi.pszText = LPSTR_TEXTCALLBACKW
            End If
            End If
            lvi.iItem = i
            lvi.iSubItem = lCrCl
            Call SendMessage(hLVS, LVM_SETITEMW, 0&, lvi)
    nxtcol:
        Next j
        Set pps = Nothing 'close property store for this listitem before moving to next
        Set isi = Nothing
    nxtitm:
    Next i
    out:
    UpdateStatus mReadyStr
    Set pps = Nothing
    Set isi = Nothing
    Exit Sub
    e0:
    DebugAppend "ucShellBrowse.UpdateColumns->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    
    End Sub
    
    Private Function DoCacheEntry(sFull As String) As Long
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim i As Long
    For i = 0 To UBound(MainCache)
        If MainCache(i).sParsingPath = sFull Then
            DoCacheEntry = i
            Exit Function
        End If
    Next i
    
    If MainCache(0).sParsingPath = "" Then
        DoCacheEntry = 0
        Exit Function
    End If
    
    ReDim Preserve MainCache(UBound(MainCache) + 1)
    DoCacheEntry = UBound(MainCache)
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.DoCacheEntry->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 2
    '</EhFooter>
    End Function
    
    Private Function ColCacheIdx(id As Long, lIdx As Long) As Long
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim i As Long
    Dim j As Long
    Dim nMax As Long
    
    For i = 0 To UBound(LVEntries(lIdx).ExtColData)
        If LVEntries(lIdx).ExtColData(i).cdid = id Then
            ColCacheIdx = i
            Exit Function
        End If
    Next i
    
    nMax = UBound(LVEntries(lIdx).ExtColData) + 1
    ReDim Preserve LVEntries(lIdx).ExtColData(nMax)
    LVEntries(lIdx).ExtColData(nMax).cdid = id
    ColCacheIdx = nMax
    Exit Function
    
    
    
    
    'If LVEntries(lIdx).ExtColData(0).cdid = 0 Then
    '    LVEntries(lIdx).ExtColData(0).cdid = id
    '    ColCacheIdx = 0
    '    Exit Function
    'End If
    'Dim lub As Long
    'lub = UBound(LVEntries(lIdx).ExtColData) + 1
    'ReDim Preserve LVEntries(lIdx).ExtColData(lub)
    'LVEntries(lIdx).ExtColData(lub).cdid = id
    'ColCacheIdx = lub
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.ColCacheIdx->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    Private Sub SetColumns(lPathIndex As Long, Optional lIndexToUse As Long = -1)
    'Configures columns when a new location is opened
    'If adjusting an existing location, use UpdateColumns instead
    On Error GoTo e0
    DebugAppend "SetColumns(" & lPathIndex & ")=" '& Join(cbItems(lPathIndex).lColSet, ",")
    
    Dim i As Long, j As Long, k As Long
    Dim cc As Long
    Dim pps As IPropertyStore
    Dim isi As IShellItem2
    Dim lColCnt As Long
    Dim lvi As LVITEM
    Dim sTmp As String
    Dim lColsToSet() As Long, lCSet As Long
    Dim lCnt As Long
    Dim lp As Long, llp As Long
    Dim hr As Long
    Dim bVis As Boolean
    Dim rtSup As Boolean
    Dim PFColForcePos As Long
    Dim pidlFQItem As LongPtr
    Dim nCIImg As Long
    Dim lECD As Long
    Dim vpv As Variant, vbv As Variant
    Dim lpr As Long, szr As String
    'first, reconcile uColData with the current folder's colgroup
    For i = 0 To UBound(uColData)
        For j = 0 To UBound(cbItems(lPathIndex).lColSet)
            If cbItems(lPathIndex).lColSet(j) = i Then
                bVis = True
                Exit For
            Else
                bVis = False
            End If
        Next j
        uColData(i).Visible = bVis
    Next i
    DebugAppend "SetColumns->Finished reconcile"
        
    
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    ReDim lColsToSet(0)
    Dim pkSet() As PROPERTYKEY, npkSet As Long
    Dim pdSet() As IPropertyDescription 'Also avoid looking up the Property Description every time
    ReDim pkSet(0): ReDim pdSet(0)
    'Scan current columns. If it shouldn't be visible, remove it. If it should, mark it for data update.
    For i = (lColCnt - 1) To 1 Step -1
        lp = CLng(GetHDItemlParam(hLVSHdr, i))
    
        uColData(lp).ColVis = True
        If uColData(lp).Visible = False Then
            DebugAppend "SetColumns->Remove " & uColData(lp).szSystemName
            Call SendMessage(hLVS, LVM_DELETECOLUMN, i, ByVal 0&)
            If lp = lRTColIdx Then
                lvrCol = 0
            End If
            If lp = lPFColIdx Then
                m_SubItemProgress = 0
            End If
            If lp = lDFSColIdx Then
                m_SubItemFreeSpc = 0
            End If
            If lp = lDefColIdx(2) Then
                m_SubItemType = 0
            End If
            lColCnt = lColCnt - 1
            uColData(lp).ColVis = False
        Else
            ReDim Preserve lColsToSet(lCSet)
            lColsToSet(lCSet) = i
            lCSet = lCSet + 1
        End If
    Next i
    k = lColCnt
    For i = 1 To 5 'first, insert visible default columns
        If (uColData(lDefColIdx(i)).Visible = True) And (uColData(lDefColIdx(i)).ColVis = False) Then
            cc = InsertListColumn(lDefColIdx(i), k)
            If cc > (-1) Then k = k + 1
        End If
    Next i
    For i = 0 To UBound(uColData)
        If (uColData(i).Visible = True) And (uColData(i).ColVis = False) And (uColData(i).IsDefProp = False) Then
            If i = lPFColIdx Then
                If k > 2 Then
                    PFColForcePos = 2
                Else
                    PFColForcePos = k
                End If
            End If
            If (uColData(i).bFlagManual = True) And (uColData(i).lManualInsertAt <> -1&) Then
                cc = InsertListColumn(i, uColData(i).lManualInsertAt)
            Else
                cc = InsertListColumn(i, IIf(i = lPFColIdx, PFColForcePos, k))
            End If
            If cc > (-1) Then k = k + 1
        End If
    Next i
    
    ResetSpecialCols
    'Now populate the columns
    
    'First
    'DebugAppend "SetColumns->lp(0)=" & lp
    Dim tmphr As Long
    lColCnt = Header_GetItemCount(hLVSHdr)
    For i = (lColCnt - 1) To 1 Step -1
        lp = CLng(GetHDItemlParam(hLVSHdr, i))
        'Read it into the keyset if needed
        If (lp <> lDefColIdx(0)) And (lp <> lDefColIdx(1)) And (lp <> lDefColIdx(2)) And (lp <> lDefColIdx(3)) And (lp <> lDefColIdx(4)) And (lp <> lDefColIdx(5)) Then
            ReDim Preserve pkSet(npkSet)
            ReDim Preserve pdSet(npkSet)
            pkSet(npkSet) = uColData(lp).pKey
            tmphr = PSGetPropertyDescription(pkSet(npkSet), IID_IPropertyDescription, pdSet(npkSet))
    '        DebugAppend "PDhr=0x" & Hex$(tmphr), 11
            uColData(lp).lParam = npkSet
            npkSet = npkSet + 1
        End If
    Next i
    
    DebugAppend "SetColumns->lColCnt=" & lColCnt & ",set=" & UBound(cbItems(lPathIndex).lColSet) ' & ",itms=" & lCnt
    If lColCnt = 1 Then Exit Sub 'Only name is displayed, and since it's never removed
                                 'it's already filled in, so we can exit
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    DebugAppend "SetColumns->SetData"
    On Error GoTo nxtitm
    For i = 0 To (lCnt - 1)
        llp = CLng(GetLVItemlParam(hLVS, i))
    '    On Error GoTo nxtcol
        For j = 1 To (lColCnt - 1)
            lvi.Mask = LVIF_TEXT Or LVIF_DI_SETITEM
            lp = CLng(GetHDItemlParam(hLVSHdr, j))
            'lDefColIdx(0) is Name, and is never removed
            If uColData(lp).bFlagManual Then 'Manually inserted column
                SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                If (isi Is Nothing) Then
                    SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                    If (isi Is Nothing) Then
                        DebugAppend "UpdateColumns->Alternate isi creation failed"
                    End If
                End If
                RaiseEvent CustomColumnQueryData(lp, isi, pidlFQItem, LVEntries(llp).sName, LVEntries(llp).sParentFull, i, sTmp, nCIImg)
                If uColData(lp).bFlagManHasImg Then
                    lvi.Mask = lvi.Mask Or LVIF_IMAGE
                    lvi.iImage = nCIImg
                End If
                lECD = ColCacheIdx(lp, llp)
                Dim vrw2 As Variant
                vrw2 = CVar(sTmp)
                LVEntries(llp).ExtColData(lECD).cdid = lp
                LVEntries(llp).ExtColData(lECD).sDisp = sTmp
                LVEntries(llp).ExtColData(lECD).vRaw = vrw2
                
                lvi.cchTextMax = Len(sTmp) + 1
                lvi.pszText = StrPtr(sTmp)
                If pidlFQItem Then CoTaskMemFree pidlFQItem
            Else
                lECD = ColCacheIdx(lp, llp)
                Dim vrw As Variant, vbrw As Variant
                LVEntries(llp).ExtColData(lECD).cdid = lp
                If (mExtColPreload = True) Or (bFlagNoPL = True) Then
                    Select Case lp
                        Case lDefColIdx(1)
            '                DebugAppend "SetColumns::SetSize=" & LVEntries(llp).sSize & ",itm=" & LVEntries(llp).sName
                            LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sSize
                            LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).cSize)
                            lvi.cchTextMax = Len(LVEntries(llp).sSize) + 1
                            lvi.pszText = StrPtr(LVEntries(llp).sSize)
                        Case lDefColIdx(2)
                            LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sType
                            LVEntries(llp).ExtColData(lECD).vRaw = CVar(LVEntries(llp).sType)
                            lvi.cchTextMax = Len(LVEntries(llp).sType) + 1
                            lvi.pszText = StrPtr(LVEntries(llp).sType)
                        Case lDefColIdx(3)
                            LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateM
                            InitPropVariantFromFileTime LVEntries(llp).ftDateM, vrw
                            PropVariantToVariant vrw, vbrw
                            LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                            lvi.cchTextMax = Len(LVEntries(llp).sDateM) + 1
                            lvi.pszText = StrPtr(LVEntries(llp).sDateM)
                        Case lDefColIdx(4)
                            LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateC
                            InitPropVariantFromFileTime LVEntries(llp).ftDateC, vrw
                            PropVariantToVariant vrw, vbrw
                            LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                            lvi.cchTextMax = Len(LVEntries(llp).sDateC) + 1
                            lvi.pszText = StrPtr(LVEntries(llp).sDateC)
                        Case lDefColIdx(5)
                            LVEntries(llp).ExtColData(lECD).sDisp = LVEntries(llp).sDateA
                            InitPropVariantFromFileTime LVEntries(llp).ftDateA, vrw
                            PropVariantToVariant vrw, vbrw
                            LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                            lvi.cchTextMax = Len(LVEntries(llp).sDateA) + 1
                            lvi.pszText = StrPtr(LVEntries(llp).sDateA)
    
                        Case Else
    
                            If (pps Is Nothing) Then
                                SHCreateItemFromParsingName StrPtr(AddBackslash(LVEntries(llp).sParentFull) & LVEntries(llp).sNameParsing), Nothing, IID_IShellItem2, isi
                                If (isi Is Nothing) Then
                                    pidlFQItem = ILCombine(pidlFQCur, LVEntries(llp).pidlRel)
                                    SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
                                    If (isi Is Nothing) Then
                                        SHCreateItemFromParsingName StrPtr(LVEntries(llp).sFullPath), Nothing, IID_IShellItem2, isi
                                        If (isi Is Nothing) Then
                                            DebugAppend "SetColumns->Alternate isi creation failed"
                                        End If
                                    End If
                                    If pidlFQItem Then CoTaskMemFree pidlFQItem
                                End If
        '                        isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
                                isi.GetPropertyStoreForKeys pkSet(0), npkSet, GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
                            End If
            '                If (pps Is Nothing) Then
            '                    DebugAppend "Failed to get propertystore"
            '                Else
            '                    DebugAppend "Property store retrieved"
            '                End If
                            If (lp = lRTColIdx) And (lvrEnable = True) Then
            '                    LVEntries(llp).lRating = GetFileRating(LVEntries(llp).sFullPath, llp)
        '                        rtSup = False
        '                        LVEntries(llp).lRating = GetFileRatingEx(LVEntries(llp).sFullPath, rtSup, llp)
        '                        LVEntries(llp).bRatingSupport = rtSup
                                pps.GetValue PKEY_Rating, vpv
                                PropVariantToVariant vpv, vbv
                                lpr = CLng(vbv)
                                Select Case lpr
                                    Case 1 To 12: LVEntries(llp).lRating = 1& 'sys default=1
                                    Case 13 To 37: LVEntries(llp).lRating = 2& 'default=25
                                    Case 38 To 62: LVEntries(llp).lRating = 3& 'default=50
                                    Case 63 To 87: LVEntries(llp).lRating = 4& 'default=75
                                    Case 88 To 99: LVEntries(llp).lRating = 5& 'default=99
                                    Case Else: LVEntries(llp).lRating = 0&
                                End Select
                                szr = GetPropertyDisplayString(pps, pdSet(uColData(lRTSColIdx).lParam), pkSet(uColData(lRTSColIdx).lParam)) 'PKEY_PropList_PreviewDetails
                                If InStr(szr, "System.Rating") Then
                                    LVEntries(llp).bRatingSupport = True
                                End If
        
                                sTmp = " "
                            Else
                                sTmp = GetPropertyDisplayString(pps, pdSet(uColData(lp).lParam), pkSet(uColData(lp).lParam))
                            End If
                            If bDisableProgressItems = False Then
                                If (lp = lPFColIdx) And (m_SubItemProgress > 0) Then
                                    If PStoreHasPF(pps) Then
                                        Dim sBugCheck As String
                                        sBugCheck = GetPropertyKeyDisplayString(pps, PKEY_Computer_DecoratedFreeSpace)
                                        If Len(sBugCheck) < 2 Then
                                            LVEntries(llp).lPercent = -1
                                        Else
                                            pps.GetValue PKEY_PercentFull, vpv
                                            PropVariantToVariant vpv, vbv
                                            LVEntries(llp).lPercent = CLng(vbv)
                                            sTmp = " "
                                            DebugAppend "SetColumns->SetPercent " & LVEntries(llp).sName & "=" & LVEntries(llp).lPercent
                                        End If
                                    Else
                                        'Percent full column is visible but does not apply to item, flag to not draw bar
                                        LVEntries(llp).lPercent = -1
                                    End If
                                End If
                            End If
                            lvi.cchTextMax = Len(sTmp) + 1
                            lvi.pszText = StrPtr(sTmp)
                            
                            LVEntries(llp).ExtColData(lECD).sDisp = sTmp
                            If (sTmp = "") And (uColData(lp).dwDispType = PDDT_NUMBER) Then
                                LVEntries(llp).ExtColData(lECD).vRaw = CLng(-1)
                            Else
                                pps.GetValue uColData(lp).pKey, vrw
                                hr = PropVariantToVariant(vrw, vbrw)
                                If hr = S_OK Then
                                    LVEntries(llp).ExtColData(lECD).vRaw = vbrw
                                End If
                            End If
                    End Select
                Else
                    lvi.cchTextMax = 0&
                    lvi.pszText = LPSTR_TEXTCALLBACKW
                End If
            End If
    setcuritem:
            lvi.iItem = i
            lvi.iSubItem = j
            Call SendMessage(hLVS, LVM_SETITEMW, 0&, lvi)
    nxtcol:
        Next j
        Set pps = Nothing 'close property store for this listitem before moving to next
        Set isi = Nothing
    nxtitm:
    Next i
    Set pps = Nothing
    Set isi = Nothing
    Exit Sub
    e0:
    DebugAppend "ucShellBrowse.SetColumns->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 3
    
    End Sub
    
    Private Function InsertListColumn(lKey As Long, lIdx As Long) As Long
    'Inserts a property column; lKey is the index of the column in uColData
    DebugAppend "InsertListColumn " & uColData(lKey).szSystemName, 11
    Dim tCol As LVCOLUMNW
    Dim lPos As Long
    Dim tHDI As HDITEMW
    InsertListColumn = -1
    With tCol
        .Mask = LVCF_TEXT Or LVCF_WIDTH Or LVCF_MINWIDTH
        .cchTextMax = Len(uColData(lKey).szDisplayName)
        .pszText = StrPtr(uColData(lKey).szDisplayName)
        .CX = uColData(lKey).DefWidth * m_ScaleX '100
        .cxMin = m_HdrMinCX
        If .CX < 30 Then .CX = .CX * 7
        DebugAppend "excol defwidth=" & .CX
        lPos = CLng(SendMessageW(hLVS, LVM_INSERTCOLUMNW, lIdx, tCol))
        If lPos > 0 Then
            If (lKey = lRTColIdx) And (lvrEnable = True) Then
                DebugAppend "Check Ratings column, i=" & lKey & ",nm=" & uColData(lKey).szSystemName & ",pos=" & lPos, 3
                lvrCol = lPos
                LVR_InitIML
                Dim sLVSh2 As String
                sLVSh2 = uColData(lKey).szDisplayName
                tHDI.Mask = HDI_FORMAT Or HDI_TEXT Or HDI_LPARAM
                tHDI.fmt = HDF_SPLITBUTTON Or HDF_STRING
                tHDI.cchTextMax = Len(uColData(lKey).szDisplayName)
                tHDI.lParam = lKey
                tHDI.pszText = StrPtr(uColData(lKey).szDisplayName)
            Else
                If (lKey = lPFColIdx) Then
                    m_SubItemProgress = lPos
                    DebugAppend "Set m_SubItemProgress=" & lPos
                End If
                tHDI.Mask = HDI_LPARAM
                tHDI.lParam = lKey
            End If
            Call SendMessageW(hLVSHdr, HDM_SETITEMW, lPos, tHDI)
            uColData(lKey).ColVis = True
            InsertListColumn = lPos
        End If
    
    End With
    End Function
    
    Private Sub LoadColumnSelect()
    DebugAppend "LoadColumnSelect()"
    Dim i As Long
    Dim rcl As RECT
    Dim rcx As RECT
    Dim rfr As RECT
    Dim rcu As RECT
    bLoadDone = False
    DebugAppend "LoadColumnSelect::pbColumns Init cx,cy=" & pbColumns.Width & "," & pbColumns.Height
    If Ambient.UserMode Then
        ' If ssc_Subclass(pbColumns.hWnd, , 8, , , True) Then
        '     Call ssc_AddMsg(pbColumns.hWnd, MSG_BEFORE, ALL_MESSAGES)
        ' End If
        Subclass2 pbColumns.hWnd, AddressOf ColWndProc, pbColumns.hWnd
    End If
    chkColFilter.Value = vbUnchecked
    GetClientRect hLVS, rcl
    GetClientRect UserControl.hWnd, rcu
    SetParent pbColumns.hWnd, UserControl.ContainerHwnd
    pvCreateColListView
    DebugAppend "rcu.l=" & rcu.Left & ",sc=" & m_ScaleX
    chkColFilter.Visible = True
    lblColCap.BackColor = shpColTitle.FillColor ' UserControl.BackColor
    lblColCap.Refresh
    lblColCap.Height = 270 * m_ScaleY
    shpColTitle.Height = lblColCap.Height + 18
    shpColTitle.Width = pbColumns.Width - 6
    If bColumnSelectInheritBkColor Then
        Dim clrt As Long
        OleTranslateColor clrBack, 0&, clrt
        SendMessageW hLVC, LVM_SETBKCOLOR, 0, ByVal clrt
        SendMessageW hLVC, LVM_SETTEXTBKCOLOR, 0, ByVal CLR_NONE
        Dim clrf As Long
        OleTranslateColor clrFore, 0&, clrf
        SendMessage hLVC, LVM_SETTEXTCOLOR, 0, ByVal clrf
        pbColumns.BackColor = UserControl.BackColor
        lblColCX.BackColor = UserControl.BackColor
        cmdColOK.BackColor = UserControl.BackColor
        cmdColCancel.BackColor = UserControl.BackColor
        chkColFilter.BackColor = UserControl.BackColor
    End If
    
    If IsComCtl6 = False Then
        chkColFilter.Visible = False 'Unsupported due to lack of group mode without cc6
    End If
    
    pbColumns.Visible = True
    ' pbColumns.Left = Extender.Left + 40
    ' pbColumns.Top = Extender.Top + 40
    pbColumns.Left = UserControl.ScaleX(Parent.Controls(Ambient.DisplayName).Left, Parent.ScaleMode, UserControl.ScaleMode) * Screen.TwipsPerPixelX
    pbColumns.Top = (UserControl.ScaleY(Parent.Controls(Ambient.DisplayName).Top, Parent.ScaleMode, UserControl.ScaleMode) + cyCombo + 4) * Screen.TwipsPerPixelY
    If bColSelWidthInit = False Then pbColumns.Width = pbColumns.Width * m_ScaleX: bColSelWidthInit = True
    DebugAppend "LoadColumnSelect::pbColumns pt2a cx,cy=" & pbColumns.Width & "," & pbColumns.Height & ",TPPY=" & Screen.TwipsPerPixelY & ",x=" & pbColumns.Left & ",y=" & pbColumns.Top & ",ex=" & Extender.left & ",ey=" & Extender.top '& ",spX=" & setposX & ",spY=" & setposY
    If rcl.Bottom > 180 Then
        pbColumns.Height = (rcl.Bottom) * Screen.TwipsPerPixelY
    Else
        pbColumns.Height = (180) * Screen.TwipsPerPixelY
    End If
    If (pbColumns.Width / Screen.TwipsPerPixelX) < cxMinColWin Then
        pbColumns.Width = cxMinColWin * Screen.TwipsPerPixelX
    End If
    DebugAppend "LoadColumnSelect::pbColumns pt2b cx,cy=" & pbColumns.Width & "," & pbColumns.Height & ",TPPY=" & Screen.TwipsPerPixelY
    hColCX = CreateWindowExW(0&, StrPtr(WC_STATIC), 0&, WS_CHILD Or WS_VISIBLE, 8, rcx.Bottom + (20 * m_ScaleY), 36 * m_ScaleX, 18 * m_ScaleY, pbColumns.hWnd, 0&, App.hInstance, ByVal 0&)
    SendMessageW hColCX, WM_SETFONT, m_hFontDtHdr, ByVal 1& '
    SetWindowTextW hColCX, StrPtr("Width")
    SetNumbersOnly txtColCX.hWnd
    
    Dim dwFr As WindowStyles
    dwFr = CLng(GetWindowLong(pbColumns.hWnd, GWL_STYLE))
    dwFr = dwFr Or WS_BORDER Or WS_THICKFRAME
    SetWindowLong pbColumns.hWnd, GWL_STYLE, dwFr
    
    SetWindowPos pbColumns.hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
    Dim rzx As Long, rzy As Long
    If rfr.Right < cxMinColWin Then
        rzx = cxMinColWin
    Else
        rzx = rfr.Right
    End If
    If rfr.Bottom < cyMinColWin Then
        rzy = cyMinColWin
    Else
        rzy = rfr.Bottom
    End If
    DebugAppend "LoadColSelect.A->DoColSelectResize " & rzx & "," & rzy
    DoColSelectResize rzx - 30, rzy
    DebugAppend "LoadColumnSelect::pbColumns pt3 cx,cy=" & pbColumns.Width & "," & pbColumns.Height
    Dim lPos As Long
    DebugAppend "Add ColHead;proceed w/ ub=" & UBound(uColData) & ",dciub=" & UBound(lDefColIdx) & ",1=" & lDefColIdx(1)
    For i = 0 To UBound(uColData)
        If (i <> lDefColIdx(0)) And (i <> lDefColIdx(1)) And (i <> lDefColIdx(2)) And (i <> lDefColIdx(3)) And (i <> lDefColIdx(4)) And (i <> lDefColIdx(5)) Then
            If (uColData(i).ColVis = False) And (uColData(i).NoList = False) Then
                If (uColData(i).bFlagCustom = True) Then
                    If m_sCurPath <> uColData(i).szCustomFor Then GoTo rcnxt
                End If
    '            dbg_chkdupes uColData(i).szDisplayName, i
                If bBlankLoaded Then
                    If uColData(i).szDisplayName = uColData(i).szSystemName Then GoTo rcnxt
                End If
                lPos = InsertLVColItem(uColData(i).szDisplayName, i)
                If uColData(i).Visible = True Then
                     ListView_SetCheckState hLVC, lPos, 1
                End If
            End If
        Else
            DebugAppend "SkipCol " & uColData(i).szDisplayName
        End If
    rcnxt:
    Next i
    If m_ColSortCallback = 0& Then m_ColSortCallback = AddressOf LVColSortProc ' scb_SetCallbackAddr(3&, 7&)
    Call SendMessage(hLVC, LVM_SORTITEMS, 0&, ByVal m_ColSortCallback)
    
    DebugAppend "LoadColumnSelect->First sort"
    Dim lColCnt As Long
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    Dim lOrder() As Long
    Dim lp As LongPtr
    ReDim lOrder(lColCnt - 1)
    SendMessage hLVSHdr, HDM_GETORDERARRAY, lColCnt, ByVal VarPtr(lOrder(0))
    For i = UBound(lOrder) To 0 Step -1
        lp = GetHDItemlParam(hLVSHdr, lOrder(i))
        lPos = InsertLVColItem(uColData(lp).szDisplayName, lp)
        If uColData(lp).Visible = True Then
            ListView_SetCheckState hLVC, lPos, 1
        End If
    Next i
    ListView_SetItemState hLVC, 0&, LVIS_CUT, LVIS_CUT
    'For i = 0 To UBound(uColData)
    '    If (uColData(i).IsDefProp = False) And (uColData(i).ColVis = True) Then 'Used to check NoList--but should be here if loaded
    '
    '        DebugAppend "VisExtColAdd " & uColData(i).szSystemName & ",wasNoList=" & uColData(i).NoList
    '        lPos = InsertLVColItem(uColData(i).szDisplayName, i)
    '        If uColData(i).Visible = True Then
    '            ListView_SetCheckState hLVC, lPos, 1
    '        End If
    '    End If
    'Next i
    'DebugAppend "LoadColumnSelect->Added vis cols"
    ''add default columns last; don't want them mixed in with others(uColData(lDefColIdx(i)).ColVis = True) Or
    'For i = 5 To 0 Step -1
    '    If (uColData(lDefColIdx(i)).NoList = False) Then
    ''        DebugAppend "ColAdd2 " & uColData(lDefColIdx(i)).szDisplayName
    '        lPos = InsertLVColItem(uColData(lDefColIdx(i)).szDisplayName, lDefColIdx(i), iif(i = 0, 1, 0))
    '        If uColData(lDefColIdx(i)).Visible = True Then
    '            ListView_SetCheckState hLVC, lPos, 1
    '        End If
    '
    '    End If
    '    If i = 0 Then
    '        ListView_SetItemState hLVC, lPos, LVIS_CUT, LVIS_CUT
    '    End If
    'Next i
    DebugAppend "Added def props; final total cnt=" & SendMessage(hLVC, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    
    bLoadDone = True
    bColSelActive = True
    
    
    Dim rcfn As RECT
    GetClientRect pbColumns.hWnd, rcfn
    DebugAppend "LoadColSelect.B->DoColSelectResize " & rcfn.Right & "," & rcfn.Bottom
    DoColSelectResize CLng(rcfn.Right), CLng(rcfn.Bottom)
    pvCreateUpDownForCol
    DebugAppend "LoadColumnSelect::pbColumns pt4 cx,cy=" & pbColumns.Width & "," & pbColumns.Height
    pvSetIPAO
    End Sub
    
    Private Sub DoColSelectResize(cx As Long, cy As Long)
    DebugAppend "DoColSelectResize" & cx & "," & cy
    Dim rcx As RECT
    SetWindowPos hLVC, 0&, 0&, 0&, CLng(cx) - (0& * m_ScaleX), CLng(cy) - (65& * m_ScaleY), SWP_NOMOVE
    GetClientRect hLVC, rcx
    SetWindowPos cmdColOK.hWnd, 0&, rcx.Right - (80& * m_ScaleX), rcx.Bottom + (20& * m_ScaleY), 0&, 0&, SWP_NOSIZE '
    SetWindowPos cmdColCancel.hWnd, 0&, rcx.Right - (48& * m_ScaleX), rcx.Bottom + (20& * m_ScaleY), 0&, 0&, SWP_NOSIZE
    SetWindowPos txtColCX.hWnd, 0&, (45& * m_ScaleX), rcx.Bottom + (20& * m_ScaleY), 0&, 0&, SWP_NOSIZE
    SetWindowPos chkColFilter.hWnd, 0&, 6&, rcx.Bottom + (44& * m_ScaleY), 0&, 0&, SWP_NOSIZE
    SetWindowPos hColCX, 0&, 8&, rcx.Bottom + (20& * m_ScaleY), 0&, 0&, SWP_NOSIZE
    shpColTitle.Width = pbColumns.Width - 6
    
    If bLVCAdv = False Then
        Dim lvcol As LVCOLUMNW
        lvcol.Mask = LVCF_WIDTH
        lvcol.CX = rcx.Right - 6
        Call SendMessage(hLVC, LVM_SETCOLUMNW, 0&, lvcol)
    End If
    
    UpdateWindow hColCX
    RedrawWindow hColCX, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE
    SendMessage hUpDown, UDM_SETBUDDY, hLVC, ByVal 0&
    
    End Sub
    
    Private Function GetStrRet(lpStr As STRRET, pidlRel As LongPtr) As String
    
    Dim lpp As LongPtr
    StrRetToStrW lpStr, 0, lpp
    GetStrRet = LPWSTRtoStr(lpp)
    
    ' Dim lpsz As LongPtr         ' string pointer
    ' Dim uOffset As Long    ' offset to the string pointer
    
    ' Select Case (lpStr.uType)
    
    '     ' The 1st UINT (Long) of the array points to a Unicode
    '     ' str which *should* be allocated & freed.
    '     Case STRRET_WSTR
    '     #If Win64 Then
    '         'On x64, we need to account for alignment padding... STRRET is actually a union, and the pointer we're
    '         'actually after wil have 4 bytes of padding before it on x64, because it has to be placed at a multiple
    '         'of the pointer size. On x86 the pointer size is 4 bytes, so there's no padding.
    '         MoveMemory lpsz, ByVal VarPtr(lpStr.cStr(0)) + 4, 8
    '     #Else
    '         MoveMemory lpsz, lpStr.cStr(0), 4
    '     #End If
    '     GetStrRet = GetStrFromPtrW(lpsz)
    '     Call CoTaskMemFree(lpsz)
        
    '     ' The 1st UINT (Long) of the array points to the location
    '     ' (uOffset bytes) to the ANSI str in the pidl.
    '     Case STRRET_OFFSET
    '     MoveMemory uOffset, lpStr.cStr(0), LenB(lpsz)
    '     GetStrRet = GetStrFromPtrA(pidlRel + uOffset)
        
    '     ' The display name is returned in cStr.
    '     Case STRRET_CSTR
    '     #If Win64 Then
    '         GetStrRet = GetStrFromPtrA(VarPtr(lpStr.cStr(0)) + 4)
    '     #Else
    '         GetStrRet = GetStrFromPtrA(VarPtr(lpStr.cStr(0)))
    '     #End If
    
    ' End Select

    End Function
    Private Function GetStrFromBufferA(sz As String) As String
      If InStr(sz, vbNullChar) Then
        GetStrFromBufferA = Left$(sz, InStr(sz, vbNullChar) - 1)
      Else
        ' If sz had no null char, the Left$ function
        ' above would return a zero length string ("").
        GetStrFromBufferA = sz
      End If
    End Function
    Private Function GetStrFromBufferW(sz As String) As String
      If InStr(sz, vbNullChar) Then
        GetStrFromBufferW = Left$(sz, InStr(sz, vbNullChar & vbNullChar) - 1)
      Else
        ' If sz had no null char, the Left$ function
        ' above would return a zero length string ("").
        GetStrFromBufferW = sz
      End If
    End Function
    
    ' Returns an ANSI string from a pointer to a Unicode string.
    
    Private Function GetStrFromPtrW(lpszW As LongPtr) As String
      Dim sRtn As String
      sRtn = String$(lstrlenW(ByVal lpszW) * 2, 0)   ' 2 bytes/char
    '  sRtn = String$(WideCharToMultiByte(CP_ACP, 0, ByVal lpszW, -1, 0, 0, 0, 0), 0)
      Call WideCharToMultiByte(CP_ACP, 0, ByVal lpszW, -1, ByVal sRtn, Len(sRtn), 0, 0)
      GetStrFromPtrW = GetStrFromBufferA(sRtn)
    End Function
    
    Private Function TextWidthW(ByVal hDC As LongPtr, ByVal sString As String) As Long
      Dim lptr As LongPtr
      Dim s As SIZE
      If LenB(sString) Then
        lptr = StrPtr(sString)
        If Not (lptr = 0) Then
          GetTextExtentPoint32W hDC, lptr, Len(sString), s
          TextWidthW = s.cx
        End If
      End If
    End Function
    Private Function TextHeightW(ByVal hDC As LongPtr, ByVal sString As String) As Long
      Dim lptr As LongPtr
      Dim s As SIZE
      If LenB(sString) Then
        lptr = StrPtr(sString)
        If Not (lptr = 0) Then
          GetTextExtentPoint32W hDC, lptr, Len(sString), s
          TextHeightW = s.cy
        End If
      End If
    End Function
    
        
    Private Sub InitAutoComplete()
    Set pAutoComp = New AutoComplete
    Set pACL = New ACListISF
    Dim pAC2 As IACList2
    Set pAC2 = pACL
    pAC2.SetOptions dwAutoCompListFlags
    pAutoComp.Init hCBEd, pACL, vbNullString, vbNullString
    pAutoComp.SetOptions dwAutoCompFlags
    End Sub
    
    Public Sub AutoCompleteFlagAdjust(Optional dwACO As AUTOCOMPLETEOPTIONS = ACO_AUTOAPPEND, Optional dwACL As AUTOCOMPLETELISTOPTIONS = ACLO_FILESYSDIRS)
    dwAutoCompFlags = dwACO
    dwAutoCompListFlags = dwACL
    If (pAutoComp Is Nothing) = False Then
        pAutoComp.SetOptions dwAutoCompFlags
        Dim pAC2 As IACList2
        Set pAC2 = pACL
        pAC2.SetOptions dwAutoCompListFlags
    End If
    End Sub
    
    Private Sub CalcTopBottomSpace(lTop As Long, lBtm As Long)
        Dim vPT As POINT, vpt2 As POINT
        Dim vRect As RECT
        Dim hParentForm As LongPtr
        
        hParentForm = GetAncestor(UserControl.hWnd, GA_ROOT)
        GetClientRect hParentForm, vRect
        ClientToScreen hParentForm, vPT
        ClientToScreen UserControl.hWnd, vpt2
        lTop = vpt2.y - vPT.y
        lBtm = vRect.Bottom - lTop
        DebugAppend "OnTop=" & lTop & ",OnBtm=" & lBtm
    
    End Sub
    
    '*-
    Private Sub ShowViewMenu(Optional bk As Boolean = False)
    If bBlockLoad Then
        If mPlaySnd Then
            If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
        End If
        Exit Sub
    End If
    If (bk = True) And (m_EnableViewMenu = False) Then Exit Sub
    Dim mii As MENUITEMINFOW
    Dim hMenu As LongPtr
    Dim hSubmenuG As LongPtr, hSubmenuS As LongPtr, hSubmenuB As LongPtr, hSubmenuL As LongPtr
    Dim hBkSubMenu As LongPtr
    Dim i As Long, j As Long, k As Long
    Dim PT As POINT
    Dim idCmd As Long
    Dim lColCnt As Long
    Dim lp As LongPtr
    Dim sCol As String
    Dim bNF As Boolean
    Dim uAtr As SFGAO_Flags
    Dim hMnIcon As LongPtr
    Dim lCnt As Long
    Dim hBmpRes() As LongPtr, nBmpRes As Long
    ReDim hBmpRes(0)
    
    
    hMenu = CreatePopupMenu()
    
    hSubmenuG = CreateMenu()
    hSubmenuS = CreateMenu()
    hSubmenuB = CreateMenu()
    hSubmenuL = CreateMenu()
    
    Dim nObj As Long
    Dim siBkm As IShellItem
    Dim bCurIsBkmd As Boolean
    Dim arBkms() As String
    
    On Error GoTo e0
    
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    
    
    lColCnt = Header_GetItemCount(hLVSHdr)
    For i = 0 To (lColCnt - 1)
        lp = GetHDItemlParam(hLVSHdr, i)
            sCol = uColData(lp).szDisplayName
            
            With mii
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
                .cch = Len(sCol)
                .dwTypeData = StrPtr(sCol)
                .wID = widBaseS + j
                If i = lSortK Then
                    .fState = MFS_CHECKED
                Else
                    .fState = MFS_UNCHECKED
                End If
                InsertMenuItemW hSubmenuS, j, True, mii
            
                .wID = widBaseG + k
                    
                If lp = lGrpCol Then
                    .fState = MFS_CHECKED
                Else
                    .fState = MFS_UNCHECKED
                End If
                If bFolderHasCat Then
                    If bCatGrpActive Then
                        .fState = MFS_UNCHECKED
                    End If
                End If
                InsertMenuItemW hSubmenuG, k, True, mii
                
                j = j + 1: k = k + 1
                
            End With
    Next
    mii.cbSize = LenB(mii)
    mii.fMask = MIIM_TYPE
    mii.fType = MFT_SEPARATOR
    InsertMenuItemW hSubmenuS, j, True, mii
    
    mii.fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
    mii.cch = Len(mnv_sSortAsc)
    mii.dwTypeData = StrPtr(mnv_sSortAsc)
    mii.fState = IIf(lSortD = 0, MFS_UNCHECKED, MFS_CHECKED)
    mii.wID = widSortAsc
    On Error Resume Next
    imlMisc.GetIcon iidxSortA, ILD_TRANSPARENT, hMnIcon
    If hMnIcon Then
        mii.fMask = mii.fMask Or MIIM_BITMAP
        mii.hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
        ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = mii.hbmpItem: nBmpRes = nBmpRes + 1
        DestroyIcon hMnIcon: hMnIcon = 0&
    End If
    On Error GoTo e0
    
    InsertMenuItemW hSubmenuS, j + 1, True, mii
    
    mii.cch = Len(mnv_sSortDsc)
    mii.dwTypeData = StrPtr(mnv_sSortDsc)
    mii.fState = IIf(lSortD = 0, MFS_CHECKED, MFS_UNCHECKED)
    mii.wID = widSortDsc
    On Error Resume Next
    mii.hbmpItem = 0&
    imlMisc.GetIcon iidxSortD, ILD_TRANSPARENT, hMnIcon
    If hMnIcon Then
        mii.fMask = mii.fMask Or MIIM_BITMAP
        mii.hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
        ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = mii.hbmpItem: nBmpRes = nBmpRes + 1
        DestroyIcon hMnIcon: hMnIcon = 0&
    End If
    On Error GoTo e0
    
    InsertMenuItemW hSubmenuS, j + 2, True, mii
    
    With mii
        .cbSize = LenB(mii)
        .fMask = MIIM_TYPE
        .fType = MFT_SEPARATOR
        InsertMenuItemW hSubmenuG, k, True, mii
        k = k + 1
        .cbSize = LenB(mii)
        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
        
        If bFolderHasCat Then
            .cch = Len(mnv_GrpCat)
            .dwTypeData = StrPtr(mnv_GrpCat)
            .fState = IIf(bCatGrpActive, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widGrpCat
            InsertMenuItemW hSubmenuG, k, True, mii
            k = k + 1
        End If
        
        .cch = Len(mnv_sNN)
        .dwTypeData = StrPtr(mnv_sNN)
        .fState = IIf((lGrpCol = -1) And (bCatGrpActive = False), MFS_CHECKED, MFS_UNCHECKED)
        .wID = widGrpNone
        InsertMenuItemW hSubmenuG, k, True, mii
    End With 'end group/sort submenu
    If bk Then
        If mEnableBookmark Then
            If (pbControlBox.Visible = False) Or ((pbControlBox.Visible = True) And (m_BookmarkButton = False)) Then
                'Add bookmark menu only if not present in control box
                DebugAppend "BkmStr=" & m_Bookmarks
            
                If InStr(m_Bookmarks, "|") Then
                    arBkms = Split(m_Bookmarks, "|")
                    For i = 0 To UBound(arBkms)
                        If arBkms(i) = m_sCurPath Then
                            bCurIsBkmd = True
                            Exit For
                        End If
                    Next i
                Else
                    If m_Bookmarks = m_sCurPath Then
                        bCurIsBkmd = True
                    End If
                End If
            
                If (m_Bookmarks <> "") And (m_Bookmarks <> "|") Then
                    arBkms = Split(m_Bookmarks, "|")
                    DebugAppend "BkmCt=" & (UBound(arBkms) + 1)
                    nObj = (UBound(arBkms) + 1)
                    For i = 0 To UBound(arBkms)
                        DebugAppend "Bkm" & i & "=" & arBkms(i)
                    Next i
                Else
                    nObj = 0
                    DebugAppend "No bookmarks in list"
                End If
            
                If mSFinBKM Then hBkSubMenu = GenerateSpecialFolderMenu(hBmpRes)
                nBmpRes = UBound(hBmpRes) + 1
                With mii
                    .cbSize = LenB(mii)
                    DebugAppend "construct bkm menu"
                    Dim trkbm As Long
                    'name
                    .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
                    .wID = widBkmAdd
                    .dwTypeData = StrPtr(mn_sBkmAdd)
                    .cch = Len(mn_sBkmAdd)
                    .fState = IIf(bCurIsBkmd, MFS_DISABLED, MFS_ENABLED)
                    
                    Call InsertMenuItemW(hSubmenuB, trkbm, True, mii)
                    trkbm = trkbm + 1
                    
                    .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
                    .wID = widBkmRem
                    .dwTypeData = StrPtr(mn_sBkmRem)
                    .cch = Len(mn_sBkmRem)
                    .fState = IIf(bCurIsBkmd, MFS_ENABLED, MFS_DISABLED)
                    Call InsertMenuItemW(hSubmenuB, trkbm, True, mii)
                    trkbm = trkbm + 1
                    
                    'clear
                    .fMask = MIIM_ID Or MIIM_STRING
                    .wID = widBkmClr
                    .dwTypeData = StrPtr(mn_sBkmClr)
                    .cch = Len(mn_sBkmClr)
                    Call InsertMenuItemW(hSubmenuB, trkbm, True, mii)
                    trkbm = trkbm + 1
                    
                    If (nObj > 0&) Or (mSFinBKM = True) Then
                        .fMask = MIIM_ID Or MIIM_TYPE
                        .fType = MFT_SEPARATOR
                        .wID = 0
                        Call InsertMenuItemW(hSubmenuB, trkbm, True, mii)
                        trkbm = trkbm + 1
                    End If
                    
                    If mSFinBKM Then
                        .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU
                        .wID = widBkmLBase - 1
                        .dwTypeData = StrPtr(mn_sBkmSpc)
                        .cch = Len(mn_sBkmSpc)
                        .hSubMenu = hBkSubMenu
                        Call InsertMenuItemW(hSubmenuB, trkbm, True, mii)
                        trkbm = trkbm + 1
                    End If
                    
                    If nObj > 0 Then
                        For i = 0 To UBound(arBkms)
                            If arBkms(i) = "0" Then
                                SHGetKnownFolderItem FOLDERID_Desktop, KF_FLAG_DEFAULT, 0&, IID_IShellItem, siBkm
                            Else
                                SHCreateItemFromParsingName StrPtr(arBkms(i)), Nothing, IID_IShellItem, siBkm
                            End If
                            If (siBkm Is Nothing) Then
                                Dim pidlFQ As LongPtr
                                pidlFQ = ILCreateFromPathW(StrPtr(arBkms(i)))
                                If pidlFQ Then
                                    SHCreateItemFromIDList pidlFQ, IID_IShellItem, siBkm
                                    CoTaskMemFree pidlFQ
                                Else
                                    DebugAppend "ShowBookmarkMenu::Alt creation failed for " & arBkms(i)
                                End If
                            End If
                            If (siBkm Is Nothing) = False Then
                                ReDim Preserve hBmpRes(nBmpRes)
                                hBmpRes(nBmpRes) = AddShellItemToMenu(hSubmenuB, siBkm, widBkmLBase + i, trkbm + i)
                                nBmpRes = nBmpRes + 1
                            Else
                                If Left$(arBkms(i), 3) = "::{" Then
                                    Dim sSh As String
                                    sSh = "shell:" & arBkms(i)
                                    SHCreateItemFromParsingName StrPtr(sSh), Nothing, IID_IShellItem, siBkm
                                    If (siBkm Is Nothing) = False Then
                                        ReDim Preserve hBmpRes(nBmpRes)
                                        hBmpRes(nBmpRes) = AddShellItemToMenu(hSubmenuB, siBkm, widBkmLBase + i, 5 + i)
                                        nBmpRes = nBmpRes + 1
                                    Else
                                        DebugAppend "ShowBookmarkMenu::Last fallback failed."
                                    End If
                                End If
                            End If
                        Next i
                    End If
                End With
            End If
        End If
    End If
    Dim lPos As Long
    Dim lPosL As Long
    With mii
    
        .cbSize = LenB(mii)
        
        
        If mUserModeToggle Then
            If (m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_FilesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sCtlBar)
                .dwTypeData = StrPtr(mnv_sCtlBar)
                .fState = IIf((m_Mode = SBCTL_DirAndFiles), MFS_CHECKED, MFS_UNCHECKED)
                .wID = widCtlB
                On Error GoTo e1 'Resume Next
                imlMisc.GetIcon iidxLoBar, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(9).Picture.Handle
                End If
                On Error GoTo e0
                InsertMenuItemW hSubmenuL, lPosL, True, mii
                lPosL = lPosL + 1
                
                .fMask = MIIM_TYPE
                .fType = MFT_SEPARATOR
                InsertMenuItemW hSubmenuL, lPosL, True, mii
                lPosL = lPosL + 1
            End If
        End If
        
        If m_ShellTree Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
            .cch = Len(mnv_sTree)
            .dwTypeData = StrPtr(mnv_sTree)
            .fState = IIf(mShellTreeVis, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widNavTree
            On Error Resume Next
            .fMask = mii.fMask Or MIIM_BITMAP
            imlMisc.GetIcon iidxLoTrv, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        If m_EnablePreview Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
            .cch = Len(mnv_sPV)
            .dwTypeData = StrPtr(mnv_sPV)
            .fState = IIf(m_PvPane, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widShowPV
            On Error GoTo e1 'Resume Next
            imlMisc.GetIcon iidxLoPrv, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = Picture3(8).Picture.Handle
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        If m_EnableDetails Then
            .cch = Len(mnv_sDB)
            .dwTypeData = StrPtr(mnv_sDB)
            .fState = IIf(m_DtPane, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widShowDT
            On Error GoTo e1 'Resume Next
            imlMisc.GetIcon iidxLoDtl, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = Picture3(7).Picture.Handle
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        If m_EnableStatusBar Then
            .cch = Len(mnv_sSB)
            .dwTypeData = StrPtr(mnv_sSB)
            .fState = IIf(m_StatusBar, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widShowSB
            On Error GoTo e1 'Resume Next
            imlMisc.GetIcon iidxLoSta, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = 0&
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        If (m_EnableSearchBox = True) And ((m_Mode = SBCTL_DirAndFiles) Or (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls)) And (m_ControlBox = True) Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
            .cch = Len(mnv_sSX)
            .dwTypeData = StrPtr(mnv_sSX)
            .fState = IIf(mShowSearch, MFS_CHECKED, MFS_UNCHECKED)
            .wID = widShowSX
            On Error GoTo e1 'Resume Next
            imlMisc.GetIcon iidxLoSrch, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = 0&
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        If (m_EnableSearchBox = True) And ((m_Mode = SBCTL_FilesOnly) Or (m_ControlBox = False)) Then
            If mSearchPopupInMenu = False Then 'This would result in an exact duplication of function, so if the popup item is enabled, skip this
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                 .cch = Len(mnv_sSXA)
                .dwTypeData = StrPtr(mnv_sSXA)
                If bFlagSearchDisable Then
                    .fState = MFS_DISABLED
                Else
                    .fState = IIf(pbSearch.Visible, MFS_CHECKED, MFS_UNCHECKED)
                End If
                .wID = widShowSXA
                On Error GoTo e1 'Resume Next
                imlMisc.GetIcon iidxLoSrch, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = 0&
                End If
                On Error GoTo e0
                InsertMenuItemW hSubmenuL, lPosL, True, mii
                lPosL = lPosL + 1
            End If
        End If
        If (mSearchPopupInMenu = True) Then
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
             .cch = Len(mnv_sSXA)
            .dwTypeData = StrPtr(mnv_sSPP)
            If bFlagSearchDisable Then
                .fState = MFS_DISABLED
            Else
                .fState = IIf(pbSearch.Visible, MFS_CHECKED, MFS_UNCHECKED)
            End If
            .wID = widSearchPopup
            On Error GoTo e1 'Resume Next
            imlMisc.GetIcon iidxLoSrch, ILD_TRANSPARENT, hMnIcon
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = 0&
            End If
            On Error GoTo e0
            InsertMenuItemW hSubmenuL, lPosL, True, mii
            lPosL = lPosL + 1
        End If
        DebugAppend "Finished constructing Layout submenu"
    End With
    
    '*******************
    'START BASE MENU
    '*******************
    With mii 'main view menu
        .cbSize = LenB(mii)
        
        If (bk = True) Then
          If m_LockNav = False Then
            If ((pbControlBox.Visible = False) And ((m_NavBtnType = SBNB_Normal) Or (m_NavBtnType = SBNB_ThemeBtnInBox))) Or ((mBkFwInCtx = True) And (m_Mode = SBCTL_FilesOnly)) Then
               Dim bFwEn As Boolean
               If UBound(sHistory) > nHistIdx Then bFwEn = True
               'Back Button
               .cbSize = LenB(mii)
               .fMask = MIIM_ID Or MIIM_STRING Or MIIM_BITMAP Or MIIM_STATE
               .cch = Len(mnv_sBack)
               .dwTypeData = StrPtr(mnv_sBack)
               .wID = widCtxBack
               .fState = IIf(nHistIdx > 0&, MF_ENABLED, MF_DISABLED)
               On Error GoTo e1 'Resume Next
               If (imlMisc Is Nothing) = False Then
               imlMisc.GetIcon iidxMnBack, ILD_TRANSPARENT, hMnIcon
               End If
               If hMnIcon Then
                   .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
               Else
                   .hbmpItem = pbStdBkBtnIco.Picture.Handle
               End If
               On Error GoTo e0
               InsertMenuItemW hMenu, lPos, True, mii
               lPos = lPos + 1
               
               'Forward Button
               .cbSize = LenB(mii)
               .fMask = MIIM_ID Or MIIM_STRING Or MIIM_BITMAP Or MIIM_STATE
               .cch = Len(mnv_sFwd)
               .dwTypeData = StrPtr(mnv_sFwd)
               .wID = widCtxFwd
               .fState = IIf(bFwEn, MF_ENABLED, MF_DISABLED)
               On Error GoTo e1 'Resume Next
               If (imlMisc Is Nothing) = False Then
               imlMisc.GetIcon iidxMnFwd, ILD_TRANSPARENT, hMnIcon
               End If
               If hMnIcon Then
                   .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
               Else
                   .hbmpItem = pbStdBkBtnIco.Picture.Handle
               End If
               On Error GoTo e0
               InsertMenuItemW hMenu, lPos, True, mii
               lPos = lPos + 1
               
               'Seperator
               .fMask = MIIM_TYPE
               .fType = MFT_SEPARATOR
               InsertMenuItemW hMenu, lPos, True, mii
               lPos = lPos + 1
            End If
          End If
        End If
            
        
        If (lPosL > 0) And (mEnableLayout = True) Then 'Hide the Layout menu if it's disabled or there's no items enabled for it
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU Or MIIM_BITMAP
            .dwTypeData = StrPtr(mnv_sLO)
            .cch = Len(mnv_sLO)
            .wID = widLay
            .hSubMenu = hSubmenuL
            On Error GoTo e1 'Resume Next
            If (imlMisc Is Nothing) = False Then
            imlMisc.GetIcon iidxLoTop, ILD_TRANSPARENT, hMnIcon
            End If
            If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
            Else
                .hbmpItem = Picture3(6).Picture.Handle
            End If
            On Error GoTo e0
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            DebugAppend "ShowViewMenu::Inserted Layout Submenu"
            .fMask = MIIM_TYPE
            .fType = MFT_SEPARATOR
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
        End If
        
        If m_LockView = False Then
            'XL Icon
            If IsVMRestricted(SB_VIEW_XLICON) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sXL)
                .dwTypeData = StrPtr(mnv_sXL)
                .fState = IIf(m_ViewModeEx = SB_VIEW_XLICON, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewXL
                On Error Resume Next
                imlMisc.GetIcon iidxThumb, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(5).Picture.Handle
                End If
                On Error GoTo e0
                 InsertMenuItemW hMenu, lPos, True, mii
                 lPos = lPos + 1
            End If
    
            'Large icon
            If IsVMRestricted(SB_VIEW_ICON) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sli)
                .dwTypeData = StrPtr(mnv_sli)
                .fState = IIf(m_ViewModeEx = SB_VIEW_ICON, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewLI
                On Error Resume Next
                imlMisc.GetIcon iidxView, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(0).Picture.Handle
                End If
                On Error GoTo e0
                 InsertMenuItemW hMenu, lPos, True, mii
                 lPos = lPos + 1
            End If
            
            'Medium icon
            If IsVMRestricted(SB_VIEW_MDICON) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sMD)
                .dwTypeData = StrPtr(mnv_sMD)
                .fState = IIf(m_ViewModeEx = SB_VIEW_MDICON, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewMD
                On Error Resume Next
                imlMisc.GetIcon iidxLgIcon, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(0).Picture.Handle
                End If
                On Error GoTo e0
                 InsertMenuItemW hMenu, lPos, True, mii
                 lPos = lPos + 1
            End If
            
            'Small icon
            If IsVMRestricted(SB_VIEW_SMALLICON) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sSM)
                .dwTypeData = StrPtr(mnv_sSM)
                .fState = IIf(m_ViewModeEx = SB_VIEW_SMALLICON, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewSM
                On Error Resume Next
                imlMisc.GetIcon iidxSmIcon, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(1).Picture.Handle
                End If
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            
            'List
            If IsVMRestricted(SB_VIEW_LIST) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sLS)
                .dwTypeData = StrPtr(mnv_sLS)
                .fState = IIf(m_ViewModeEx = SB_VIEW_LIST, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewLS
                On Error Resume Next
                imlMisc.GetIcon iidxList, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(2).Picture.Handle
                End If
            
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            
            'Details
            If IsVMRestricted(SB_VIEW_DETAILS) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sDT)
                .dwTypeData = StrPtr(mnv_sDT)
                .fState = IIf(m_ViewModeEx = SB_VIEW_DETAILS, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewDT
                On Error Resume Next
                imlMisc.GetIcon iidxDetail, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(3).Picture.Handle
                End If
            
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            
           If IsComCtl6 Then
                'Tiles
                If IsVMRestricted(SB_VIEW_TILE) = False Then
    
                    .cbSize = LenB(mii)
                    .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                    .cch = Len(mnv_sTV)
                    .dwTypeData = StrPtr(mnv_sTV)
                    .fState = IIf(m_ViewModeEx = SB_VIEW_TILE, MFS_CHECKED, MFS_UNCHECKED)
                    .wID = widViewTV
                    On Error Resume Next
                    imlMisc.GetIcon iidxTile, ILD_TRANSPARENT, hMnIcon
                    If hMnIcon Then
                        .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                        ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                        DestroyIcon hMnIcon: hMnIcon = 0&
                    Else
                        .hbmpItem = Picture3(4).Picture.Handle
                    End If
                    On Error GoTo e0
                    InsertMenuItemW hMenu, lPos, True, mii
                    lPos = lPos + 1
                End If
                
                'Contents
                If (bHideContentViewMenuItem = False) And (IsVMRestricted(SB_VIEW_CONTENTS) = False) Then
                    .cbSize = LenB(mii)
                    .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                    .cch = Len(mnv_sCT)
                    .dwTypeData = StrPtr(mnv_sCT)
                    .fState = IIf(m_ViewModeEx = SB_VIEW_CONTENTS, MFS_CHECKED, MFS_UNCHECKED)
                    .wID = widViewCT
                    On Error Resume Next
                    imlMisc.GetIcon iidxTile, ILD_TRANSPARENT, hMnIcon
                    If hMnIcon Then
                        .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                        ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                        DestroyIcon hMnIcon: hMnIcon = 0&
                    Else
                        .hbmpItem = Picture3(4).Picture.Handle
                    End If
                    On Error GoTo e0
                    InsertMenuItemW hMenu, lPos, True, mii
                    lPos = lPos + 1
                End If
           End If
        
            'Thumbnails
            If IsVMRestricted(SB_VIEW_THUMBNAIL) = False Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mnv_sJM)
                .dwTypeData = StrPtr(mnv_sJM)
                .fState = IIf(m_ViewModeEx = SB_VIEW_THUMBNAIL, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewJM
                On Error Resume Next
                imlMisc.GetIcon iidxThumb, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(5).Picture.Handle
                End If
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            If mCustomInMenu Then
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE Or MIIM_BITMAP
                .cch = Len(mCustomMenuCap)
                .dwTypeData = StrPtr(mCustomMenuCap)
                .fState = IIf(m_ViewModeEx = SB_VIEW_CUSTOM, MFS_CHECKED, MFS_UNCHECKED)
                .wID = widViewCU
                On Error Resume Next
                imlMisc.GetIcon iidxCust, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                Else
                    .hbmpItem = Picture3(5).Picture.Handle
                End If
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            .fMask = MIIM_TYPE
            .fType = MFT_SEPARATOR
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
        End If
            DebugAppend "ShowViewMenu::Inserted View Modes"
        .hbmpItem = 0&
        
        If m_AllowSorting Then
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU Or MIIM_STATE
            .cch = Len(mnv_sSortHdr)
            .dwTypeData = StrPtr(mnv_sSortHdr)
            .fState = IIf(m_AllowSorting, MF_ENABLED, MF_DISABLED)
            .hSubMenu = hSubmenuS
            .wID = widBaseSort
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
        End If
        
        If mEnableGrp Then
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU
            .cch = Len(mnv_sGrpHdr)
            .dwTypeData = StrPtr(mnv_sGrpHdr)
            .hSubMenu = hSubmenuG
            .wID = widBaseGrp
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
        End If
        
        If bk Then 'folder background click
            Dim bCanPaste As Boolean
            Dim pdo As IDataObject
            OleGetClipboard pdo
            If (pdo Is Nothing) = False Then
                If DataObjSupportsFormat(pdo, CF_HDROP) Then
                    bCanPaste = True
                End If
            End If
            
            .fMask = MIIM_TYPE
            .fType = MFT_SEPARATOR
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            
            If mEnableBookmark Then
                If (pbControlBox.Visible = False) Or ((pbControlBox.Visible = True) And (m_BookmarkButton = False)) Then
                    .fMask = MIIM_ID Or MIIM_STRING Or MIIM_SUBMENU
                    .cch = Len(mnv_sBK)
                    .dwTypeData = StrPtr(mnv_sBK)
                    .wID = wIDBkmVw
                    .hSubMenu = hSubmenuB
                    On Error Resume Next
                    mii.fMask = mii.fMask Or MIIM_BITMAP
                    imlMisc.GetIcon iidxBkm, ILD_TRANSPARENT, hMnIcon
                    If hMnIcon Then
                        .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                        ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                        DestroyIcon hMnIcon: hMnIcon = 0&
                    End If
                    On Error GoTo e0
                    InsertMenuItemW hMenu, lPos, True, mii
                    lPos = lPos + 1
                    
        
                    .fMask = MIIM_TYPE
                    .fType = MFT_SEPARATOR
                    InsertMenuItemW hMenu, lPos, True, mii
                    lPos = lPos + 1
                
                End If
            End If
        'New Folder
            If (mEnableNewFolder = True) And (mFilesOnly = False) Then
                DebugAppend "ShowViewMenu@NewFolderItem"
                If (siCurPath Is Nothing) Then
                    bCanPaste = False
                Else
                    siCurPath.GetAttributes SFGAO_READONLY Or SFGAO_FILESYSANCESTOR Or SFGAO_FILESYSTEM, uAtr
                    If (uAtr And SFGAO_FILESYSTEM) = SFGAO_FILESYSTEM Then
                        bNF = True
                    Else
                        bCanPaste = False 'while we're checking; can't paste either if not file system
                    End If
                End If
                .cbSize = LenB(mii)
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
                .cch = Len(mnv_sNF)
                .dwTypeData = StrPtr(mnv_sNF)
                .wID = widNewFldr
                On Error Resume Next
                mii.fMask = mii.fMask Or MIIM_BITMAP
                imlMisc.GetIcon iidxNewFldr, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                End If
                On Error GoTo e0
                .fState = IIf(bNF, MF_ENABLED, MF_DISABLED)
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            
            'Copy Path
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .cch = Len(mnv_CopyPath)
            .dwTypeData = StrPtr(mnv_CopyPath)
            .wID = widCopyPath
            .fState = IIf(bBlankLoaded, MF_DISABLED, MF_ENABLED)
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
    
            'Paste
            If mEnablePaste Then
                .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
                .cch = Len(mnv_sPS)
                .dwTypeData = StrPtr(mnv_sPS)
                .wID = widBkPaste
                .fState = IIf(bCanPaste, MF_ENABLED, MF_DISABLED)
                On Error Resume Next
                mii.fMask = mii.fMask Or MIIM_BITMAP
                imlMisc.GetIcon iidxPaste, ILD_TRANSPARENT, hMnIcon
                If hMnIcon Then
                    .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                    ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                    DestroyIcon hMnIcon: hMnIcon = 0&
                End If
                On Error GoTo e0
                InsertMenuItemW hMenu, lPos, True, mii
                lPos = lPos + 1
            End If
            
            'Select all
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .cch = Len(mnv_sSA)
            .dwTypeData = StrPtr(mnv_sSA)
            .wID = widSelAll
            .fState = IIf(lCnt > 0, MF_ENABLED, MF_DISABLED)
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
                    
             'Refresh
             .fMask = MIIM_ID Or MIIM_STRING
             .cch = Len(mnv_sRF)
             .dwTypeData = StrPtr(mnv_sRF)
             .wID = widRefresh
             On Error Resume Next
             mii.fMask = mii.fMask Or MIIM_BITMAP
             imlMisc.GetIcon iidxRefresh, ILD_TRANSPARENT, hMnIcon
             If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
             End If
             DestroyIcon hMnIcon: hMnIcon = 0&
             On Error GoTo e0
             InsertMenuItemW hMenu, lPos, True, mii
             lPos = lPos + 1
        
        
            .fMask = MIIM_TYPE
            .fType = MFT_SEPARATOR
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            
            'Properties
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING
            .cch = Len(mnv_sPR)
            .dwTypeData = StrPtr(mnv_sPR)
            .wID = widProps
            InsertMenuItemW hMenu, lPos, True, mii
            
        Else
        
            .fMask = MIIM_TYPE
            .fType = MFT_SEPARATOR
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            
            'Copy Path
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .cch = Len(mnv_CopyPath)
            .dwTypeData = StrPtr(mnv_CopyPath)
            .wID = widCopyPath
            .fState = IIf(bBlankLoaded, MF_DISABLED, MF_ENABLED)
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            
            'Select all
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .cch = Len(mnv_sSA)
            .dwTypeData = StrPtr(mnv_sSA)
            .wID = widSelAll
            .fState = IIf(lCnt > 0, MF_ENABLED, MF_DISABLED)
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
            
            'Invert selection
            .cbSize = LenB(mii)
            .fMask = MIIM_ID Or MIIM_STRING Or MIIM_STATE
            .cch = Len(mnv_sIS)
            .dwTypeData = StrPtr(mnv_sIS)
            .wID = widSelInv
            .fState = IIf(lCnt > 0, MF_ENABLED, MF_DISABLED)
            InsertMenuItemW hMenu, lPos, True, mii
            lPos = lPos + 1
    
             'Refresh
             .fMask = MIIM_ID Or MIIM_STRING
             .cch = Len(mnv_sRF)
             .dwTypeData = StrPtr(mnv_sRF)
             .wID = widRefresh
             On Error Resume Next
             mii.fMask = mii.fMask Or MIIM_BITMAP
             imlMisc.GetIcon iidxRefresh, ILD_TRANSPARENT, hMnIcon
             If hMnIcon Then
                .hbmpItem = HBitmapFromHIcon(hMnIcon, cxyMenuImages, cxyMenuImages)
                ReDim Preserve hBmpRes(nBmpRes): hBmpRes(nBmpRes) = .hbmpItem: nBmpRes = nBmpRes + 1
                DestroyIcon hMnIcon: hMnIcon = 0&
             End If
             DestroyIcon hMnIcon: hMnIcon = 0&
             On Error GoTo e0
             InsertMenuItemW hMenu, lPos, True, mii
             lPos = lPos + 1
             
             DebugAppend "ShowViewMenu::Finished after insert refresh, lPos=" & lPos
        End If
    End With
    
    If bk = True Then
        Call GetCursorPos(PT)
        DebugAppend "PopupViewMenu@" & PT.x & "," & PT.y & ",hMenu=" & hMenu & ",hLVS=" & hLVS
    Else
        PT.x = 0
        PT.y = cyCombo
        ClientToScreen hViewButton, PT
    End If
    Dim hPar As LongPtr
    If hLVS = 0& Then
        hPar = UserControl.hWnd
    Else
        hPar = hLVS
    End If
    
    idCmd = TrackPopupMenu(hMenu, TPM_LEFTBUTTON Or TPM_RIGHTBUTTON Or TPM_LEFTALIGN Or TPM_TOPALIGN Or TPM_VERTICAL Or TPM_VERPOSANIMATION Or TPM_RETURNCMD, PT.x, PT.y, 0, hPar, 0)
    
    If idCmd Then
        Select Case idCmd
        
            Case widCtxBack: DoBack
            Case widCtxFwd: DoForward
            
            Case widCtlB
                If (m_Mode = SBCTL_DirAndFiles) Then
                    Me.ControlType = SBCTL_FilesOnly
                ElseIf (m_Mode = SBCTL_FilesOnly) Then
                    Me.ControlType = SBCTL_DirAndFiles
                End If
                
            Case widViewLI: SwitchView LV_VIEW_ICON: DebugAppend "SwitchIcon"
            Case widViewSM: SwitchView LV_VIEW_SMALLICON: DebugAppend "SwitchSmallIcon"
            Case widViewLS: SwitchView LV_VIEW_LIST: DebugAppend "SwitchList"
            Case widViewDT: SwitchView LV_VIEW_DETAILS: DebugAppend "SwitchDetails"
            Case widViewTV: SwitchView LV_VIEW_TILE: DebugAppend "SwitchTiles"
            Case widViewJM: SwitchView LV_VIEW_THUMBNAIL: DebugAppend "SwitchThumb"
            Case widViewCT: SwitchView LV_VIEW_CONTENTS: DebugAppend "SwitchContent"
            Case widViewXL: SwitchView LV_VIEW_XLICON: DebugAppend "SwitchXLIcon"
            Case widViewMD: SwitchView LV_VIEW_MDICON: DebugAppend "SwitchMDIcon"
            Case widViewCU: SwitchView LV_VIEW_CUSTOM: DebugAppend "SwitchCustom"
            
            Case widBaseS To (widBaseS + 999)
                LVColumnClick idCmd - widBaseS
            
            Case widSortAsc
                If lSortD = 0 Then
                    LVColumnClick lSortK
                    lSortD = 1
                End If
            
            Case widSortDsc
                If lSortD = 1 Then
                    LVColumnClick lSortK
                    lSortD = 0
                End If
                    
            Case widBaseG To (widBaseG + 997)
                lp = GetHDItemlParam(hLVSHdr, idCmd - widBaseG)
                If lp <> lGrpCol Then
                    lGrpCol = CLng(lp)
                    SetGroupModeByCol CLng(lp)
                End If
            Case widGrpNone
                SetGroupMode SBGB_None
                lGrpCol = -1
                bCatGrpActive = False
            
            Case widGrpCat
                SetGroupMode SBGB_Categorizer
                bCatGrpActive = True
                
            Case widRefresh: RefreshView
            
            Case widNewFldr: DoNewFolder
            
            Case widBkPaste: LVDoPaste True
            
            Case widNavTree
                If mShellTreeVis Then
                    mShellTreeVis = False
                Else
                    mShellTreeVis = True
                End If
                RaiseEvent ShowShellTree(mShellTreeVis)
                
            Case widShowSB
                If m_StatusBar Then
                    Me.ShowStatusBar = False
                Else
                    Me.ShowStatusBar = True
                End If
    
            Case widShowPV
                If m_PvPane Then
                    m_PvPane = False
                    fraPreview.Visible = False
                    pbPreviewSizer.Visible = False
                Else
                    m_PvPane = True
                    pbPreviewSizer.Visible = True
                    SetPVInitPos
                    SetLVInitPos
                    If bPvLockCX Then
                        pbPreviewSizer.Visible = False
                    End If
                End If
                RaiseEvent PreviewPaneWidthChanged
                RaiseEvent TogglePreviewPane(m_PvPane)
                UserControl_Resize
            
            Case widShowDT
                If m_DtPane Then
                    m_DtPane = False
                    pbDetailPane.Visible = False
                    pbDetailSizer.Visible = False
                Else
                    m_DtPane = True
                    pbDetailPane.Visible = True
                    pbDetailSizer.Visible = True
                    pbDetailSizer.Top = pbDetailPane.Top
                    pbDetailSizer.Width = pbDetailPane.Width - 10
                    SetWindowPos pbDetailSizer.hWnd, HWND_TOP, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE
                    If bDtLockCY Then
                        pbDetailSizer.Visible = False
                    End If
                    pvCreateDetailPaneBkg
                End If
                RaiseEvent DetailPaneHeightChanged
                RaiseEvent ToggleDetailsPane(m_DtPane)
                UserControl_Resize
            
            Case widShowSX
                If mShowSearch = False Then
                    Me.SearchBox = True
                Else
                    Me.SearchBox = False
                End If
            
            Case widShowSXA
                If pbSearch.Visible = True Then
                    SearchOptionsClose
                Else
                    bSearchAlt = True
                    SearchOptionsPopup
                End If
                
            Case widSearchPopup
                If pbSearch.Visible = True Then
                    SearchOptionsClose
                Else
                    bSearchAlt = True
                    SearchOptionsPopup
                End If
                
                
            Case widCopyPath
                If bDisableCopyPathMenuItem = False Then
                    ClipboardSetText m_sCurPath
                End If
            
            Case widSelAll
                SetFocusOnFiles
                LVSelectAll
            
            Case widSelInv
                SetFocusOnFiles
                LVInvertSel
                         
            Case widProps
                Dim psiItem As IShellItem
                Dim pdo2 As IDataObject
                SHCreateItemFromParsingName StrPtr(m_sCurPath), Nothing, IID_IShellItem, psiItem
                If psiItem Is Nothing Then
                    SHCreateItemFromIDList pidlFQCur, IID_IShellItem, psiItem
                End If
                If psiItem Is Nothing Then
                    If Left$(m_sCurPath, 3) = "::{" Then
                        SHCreateItemFromParsingName StrPtr("shell:" & m_sCurPath), Nothing, IID_IShellItem, psiItem
                    End If
                End If
                If (psiItem Is Nothing) = False Then
                    psiItem.BindToHandler 0&, BHID_DataObject, IID_IDataObject, pdo2
                    If (pdo2 Is Nothing) = False Then
                        SHMultiFileProperties ObjPtr(pdo2), 0&
                    End If
                End If
            
            Case Else 'Run through Bookmarks submenu options
                ProcessBookmarkMenuCmd idCmd, arBkms
        End Select
    End If
    
    DestroyMenu hMenu
    For i = 0 To UBound(hBmpRes)
        If hBmpRes(i) Then DeleteObject hBmpRes(i)
    Next i
    
    Exit Sub
    e0:
    DebugAppend "ShowViewMenu.Error->" & Err.Description & ", 0x" & Hex$(Err.Number)
    Exit Sub
    e1:
    DebugAppend "ShowViewMenu.Warning->" & Err.Description & ", 0x" & Hex$(Err.Number)
    Resume Next
    End Sub
    
    Private Sub ShowSelFileProps()
    Dim pdo As IDataObject
    Dim lSC As Long
    
    lSC = CLng(SendMessage(hLVS, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&))
    If lSC = 0 Then
        'No file selected so show current folder props
         siCurPath.BindToHandler 0&, BHID_DataObject, IID_IDataObject, pdo
    ElseIf lSC = 1 Then
        siFocus.BindToHandler 0&, BHID_DataObject, IID_IDataObject, pdo
    Else 'lSC>1
        SetSelectedItemArray
        siaSelected.BindToHandler 0&, BHID_DataObject, IID_IDataObject, pdo
    End If
    If (pdo Is Nothing) = False Then
        SHMultiFileProperties ObjPtr(pdo), 0&
    End If
    End Sub
    
    Private Function CalcMenuDir() As Long
    Dim cAbv As Long, cBlw As Long
    Dim yUC As Long
    Dim rcuc As RECT
    Dim rcpar As RECT
    GetWindowRect UserControl.hWnd, rcuc
    
    End Function
    Private Function StartNotifyOnCurPath() As Long
    'resets notification for current folder
    If m_Monitor = False Then
      If (m_hSHNotify) Then
        StopNotify
        m_hSHNotify = 0
      End If
      Exit Function
    End If
    Dim tCNE As SHChangeNotifyEntry
    Dim pidl As LongPtr
    
    If (m_hSHNotify) Then
      StopNotify
      m_hSHNotify = 0
    End If   ' (m_hSHNotify = 0) Or SHCNRF_InterruptLevel Or SHCNE_INTERRUPT
    Dim sRegPath As String
    If m_sCurPath = "0" Then 'desktop
        Dim lpcpn As LongPtr
        siCurPath.GetDisplayName SIGDN_FILESYSPATH, lpcpn
        sRegPath = LPWSTRtoStr(lpcpn)
    Else
        sRegPath = m_sCurPath
    End If
    
    If (Left$(sRegPath, 3) = "::{") And (Left$(sRegPath, Len(sComp)) <> sComp) Then Exit Function
    If Left$(sRegPath, 3) = "::{" Then 'This does not consistently work.
        Dim i As Long
        For i = 0 To UBound(uPidlStore)
            If uPidlStore(i).sPath = sRegPath Then
                If uPidlStore(i).pidlFQ Then
                    pidl = uPidlStore(i).pidlFQ
                Else
                    Exit Function
                    'Failed to get a pidl and if we leave it at zero we'll get notifies for the whole filesystem
                End If
            End If
        Next i
    Else
        pidl = ILCreateFromPathW(StrPtr(sRegPath))
    End If
    
    'If TrimBackslash(sRegPath) = sComp Then
    '    StopNotifyOnComp
    'End If
    
    DebugAppend "MonitorPidl=" & pidl & " ForPath=" & sRegPath
    tCNE.pidl = pidl
    
    tCNE.fRecursive = 0
    'mSBCNE = SHCNE_CREATE Or SHCNE_DELETE Or SHCNE_MKDIR Or SHCNE_RENAMEFOLDER Or SHCNE_RENAMEITEM Or SHCNE_RMDIR Or SHCNE_UPDATEITEM
    
    m_hSHNotify = SHChangeNotifyRegister(hLVS, SHCNRF_InterruptLevel Or SHCNRF_ShellLevel Or SHCNRF_NewDelivery, SHCNE_ALLEVENTS, WM_SHNOTIFY, 1, tCNE)
    
    CoTaskMemFree pidl
    StartNotifyOnCurPath = m_hSHNotify
            
    
    End Function
    
    Private Function StartNotifyOnComp() As Long
    'Register a dedicated notification registration for Computer/This PC, so that
    'drive adds can update the dropdown without it being the active folder or
    'having to monitor recursively from root.
    
    Dim tCNE As SHChangeNotifyEntry
    Dim pidl As LongPtr
    Dim pKFM As New KnownFolderManager
    Dim pKNF As IKnownFolder
    
    pKFM.GetFolder FOLDERID_ComputerFolder, pKNF
    pKNF.GetIDList KF_FLAG_DEFAULT, pidl
    
    tCNE.pidl = pidl
    tCNE.fRecursive = 0&
    
    m_hSHSNC = SHChangeNotifyRegister(hLVS, SHCNRF_ShellLevel Or SHCNRF_NewDelivery, SHCNE_ALLEVENTS, WM_SHNOTIFYB, 1, tCNE)
    
    CoTaskMemFree pidl
    StartNotifyOnComp = m_hSHSNC
    End Function
    
    Private Function StopNotify() As Boolean
    If m_hSHNotify Then StopNotify = SHChangeNotifyDeregister(m_hSHNotify)
    End Function
    Private Function StopNotifyOnComp() As Boolean
    If m_hSHSNC Then StopNotifyOnComp = SHChangeNotifyDeregister(m_hSHSNC)
    End Function
    
    Private Sub HandleShellNotify(pidl1 As LongPtr, pidl2 As LongPtr, lEvent As SHCN_Events)
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim siItem1 As IShellItem
    Dim szItem1 As String
    Dim lpName As LongPtr
    Dim siItem2 As IShellItem
    Dim szItem2 As String
    Dim lIdx As Long
    Dim szBug As String
    Dim tcNow As LongLong
    If pidl1 Then
            SHCreateItemFromIDList pidl1, IID_IShellItem, siItem1
            If (siItem1 Is Nothing) = False Then
    '            szItem1 = GetShellItemFileName(siItem1, SIGDN_DESKTOPABSOLUTEPARSING)
                siItem1.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lpName
                szItem1 = LPWSTRtoStr(lpName)
            End If
    End If
    If pidl2 Then
            SHCreateItemFromIDList pidl2, IID_IShellItem, siItem2
            If (siItem2 Is Nothing) = False Then
                szItem2 = GetShellItemFileName(siItem2, SIGDN_DESKTOPABSOLUTEPARSING)
            End If
    End If
    If (mWPCFlag = True) Then
        'For some property writes, windows throws a whole bunch of shit.
        'Create a tmp file, update it, create another tmp file, delete orig, rename tmp file...
        'This code can't keep up. Ignore until the orig is back.
        If lEvent = SHCNE_UPDATEITEM Then
            If Right$(szItem1, Len(sWPCFlag)) = sWPCFlag Then
                mWPCFlag = False
            End If
        End If
        If lEvent = SHCNE_RENAMEITEM Then
            DebugAppend "Set mWPCFlag=False"
            mWPCFlag = False
            Exit Sub
        Else
            DebugAppend "mWPCFlag=True::EXIT"
            Exit Sub
        End If
    End If
    DebugAppend "HandleShellNotify::blockflag=" & mWPCFlag & ",code=" & dbg_LookUpSHCNE(lEvent) & ",itm1=" & szItem1 & ",itm2=" & szItem2
    Select Case lEvent
    
    Case SHCNE_DRIVEADD 'This message is raised regardless of path
        Dim li As Long
        AddStandardFSItem siItem1, li
        If (m_sCurPath = sComp) Or (m_sCurPath = sComp2) Then
            If LVAE_IsDupe(szItem1) = False Then
                lIdx = LVAddEntry(siItem1)
                If lIdx <> -1 Then
                    LVPopulateColsForItem lIdx, True
                End If
            End If
        End If
        
    Case SHCNE_DRIVEREMOVED
        If Left$(szItem1, 3) = "::{" Then
            If LCase$(Left$(szItem1, 40)) = LCase$(Left$(m_sCurPath, 40)) Then
                bUseDrvRemForEM = True
                SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
                SendMessage hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&
                LVMarkAllDel
            End If
        Else
            If LCase$(Left$(szItem1, 3)) = LCase$(Left$(m_sCurPath, 3)) Then
                bUseDrvRemForEM = True
                SendMessage hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&
                SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
                LVMarkAllDel
            End If
        End If
        If CBItemExists(szItem1) Then
            CBRemoveItemAndChildren szItem1
        End If
        If (m_sCurPath = sComp) Or (m_sCurPath = sComp2) Then
            LVRemoveEntry siItem1
        End If
        
    Case SHCNE_CREATE, SHCNE_MKDIR
        If Len(szItem1) > 3 Then
            szBug = Left$(szItem1, InStrRev(szItem1, "\") - 1)
            If (szBug <> m_sCurPath) And (Len(m_sCurPath) > 4) Then
                DebugAppend "HandleShellNotify::Bug alert->Received notice for item in different path."
                Exit Sub
            End If
        End If
        If LVAE_IsDupe(szItem1) = False Then
            lIdx = LVAddEntry(siItem1)
        '     lIdx = LVGetEntryIndexByItem(siItem1)
            If lIdx <> -1 Then
                LVPopulateColsForItem lIdx, True
            End If
        End If
        
    Case SHCNE_DELETE
        LVRemoveEntry siItem1
    Case SHCNE_RMDIR
        LVRemoveEntry siItem1
        If CBItemExists(szItem1) Then
            CBRemoveItemAndChildren szItem1
        End If
            
    Case SHCNE_RENAMEITEM, SHCNE_RENAMEFOLDER
        DebugAppend "SHCNE_RENAMEITEM bRnf=" & bRNf
    '    If bRNf = False Then
            LVRenameEntry siItem1, siItem2, pidl1, pidl2
    '    Else
            bRNf = False
    '    End If
        
    Case SHCNE_UPDATEITEM
            
        lIdx = LVGetEntryIndexByItem(siItem1)
        DebugAppend "SHCNE_UPDATEITEM lIdx=" & lIdx
        If lIdx <> -1 Then
            LVPopulateColsForItem lIdx, True
        End If
        
    Case SHCNE_UPDATEDIR
        'Sometimes individual item adds/removes are not sent and only this message is
        'But it also gets spammed sometimes, so we won't trigger a refresh if it's
        'been less than 5 seconds. You can adjust that time, it's just the # of ms
        
        tcNow = GetTickCount64 '* 10000
        If ((tcNow - tcLastDirUpdate) > 5000) Or (tcLastDirUpdate > tcNow) Then 'greater than = rolled over
            RefreshView
        End If
        tcLastDirUpdate = tcNow
        
    End Select
    '<EhFooter>
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.HandleShellNotify->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Sub HandleShellNotifyB(pidl1 As LongPtr, pidl2 As LongPtr, lEvent As SHCN_Events)
    'This is a separate notification handler for the Computer/This PC, so we can update
    'the dropdown with drive add/remove without having to watch the whole system.
    
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    Dim siItem1 As IShellItem
    Dim szItem1 As String
    Dim lpName As LongPtr
    Dim siItem2 As IShellItem
    Dim szItem2 As String
    Dim li As Long
    Dim lIdx As Long
    If pidl1 Then
        SHCreateItemFromIDList pidl1, IID_IShellItem, siItem1
        If (siItem1 Is Nothing) = False Then
            szItem1 = GetShellItemFileName(siItem1, SIGDN_DESKTOPABSOLUTEPARSING)
        End If
    End If
    If pidl2 Then
        SHCreateItemFromIDList pidl2, IID_IShellItem, siItem2
        If (siItem2 Is Nothing) = False Then
            szItem2 = GetShellItemFileName(siItem2, SIGDN_DESKTOPABSOLUTEPARSING)
        End If
    End If
    DebugAppend "HandleShellNotifyB::code=" & dbg_LookUpSHCNE(lEvent) & ",itm1=" & szItem1 & ",itm2=" & szItem2
    Select Case lEvent
    
    Case SHCNE_DRIVEADD 'This message is raised regardless of path
        AddStandardFSItem siItem1, li
        If (m_sCurPath = sComp) Or (m_sCurPath = sComp2) Then
            If LVAE_IsDupe(szItem1) = False Then
                lIdx = LVAddEntry(siItem1)
                If lIdx <> -1 Then
                    LVPopulateColsForItem lIdx, True
                End If
            End If
        End If
        
    Case SHCNE_DRIVEREMOVED
        If Left$(szItem1, 3) = Left$(m_sCurPath, 3) Then
            bUseDrvRemForEM = True
            SendMessage hLVS, LVM_RESETEMPTYTEXT, 0&, ByVal 0&
            SendMessage hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&
        End If
        If CBItemExists(szItem1) Then
            CBRemoveItemAndChildren szItem1
        End If
        If (m_sCurPath = sComp) Or (m_sCurPath = sComp2) Then
            LVRemoveEntry siItem1
        End If
    '
    'Case SHCNE_RENAMEFOLDER
    '    If szItem1 = szItem2 Then
    '        'We don't get a drive add or media add message when a USB camera or phone is
    '        'connected, but we do get this message with the two identical names. So use
    '        'this to trigger adding it to the dropdown
    '        AddStandardFSItem siItem1, li
    '    End If
    
            
    'Case SHCNE_CREATE, SHCNE_MKDIR
    '
    '    lIdx = LVAddEntry(siItem1)
    ''     lIdx = LVGetEntryIndexByItem(siItem1)
    '    If lIdx <> -1 Then
    '        LVPopulateColsForItem lIdx, True
    '    End If
    '
    'Case SHCNE_DELETE
    '    LVRemoveEntry siItem1
    'Case SHCNE_RMDIR
    '    LVRemoveEntry siItem1
    '    If CBItemExists(szItem1) Then
    '        CBRemoveItemAndChildren szItem1
    '    End If
    '
    'Case SHCNE_RENAMEITEM, SHCNE_RENAMEFOLDER
    '    If bRNf = False Then
    '        LVRenameEntry siItem1, siItem2, pidl1, pidl2
    '    Else
    '        bRNf = False
    '    End If
    'Case SHCNE_UPDATEITEM
    '
    '    lIdx = LVGetEntryIndexByItem(siItem1)
    '    DebugAppend "SHCNE_UPDATEITEM lIdx=" & lIdx
    '    If lIdx <> -1 Then
    '        LVPopulateColsForItem lIdx, True
    '    End If
    '
    Case SHCNE_UPDATEDIR
        'This shouldn't be raised besides add/remove device
        'Normal drives will get added via SHCNE_DRIVEADD
        'UPDATEDIR seems to be the only message we get if phone/camera type devices are
        'connected. So all we should need to do is scan specifically for those with the
        'Portable Device Manager... (Note: They do get SHCNE_DRIVEREMOVE, so we need only
        'worry about adding new ones with this update message).
        ScanDevices
        'If you discover another scenario where you need to go through everything, use
        'instead the routine to enumerate everything under Computer/This PC:
    '    EnumComputerTree
        
    End Select
    '<EhFooter>
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.HandleShellNotify->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Sub
    
    Private Function LVAE_IsDupe(szDAP As String) As Boolean
    'This is primarily to catch SHCNE_MKDIR messages sent for removed devices
    Dim i As Long
    
    For i = 0 To UBound(LVEntries)
        If LVEntries(i).bDeleted = False Then
            If LVEntries(i).sFullPath <> "" Then
                If (LVEntries(i).sFullPath = szDAP) Then
                    LVAE_IsDupe = True
                    Exit Function
                End If
            End If
            If LVEntries(i).sFullPKParse <> "" Then
                If (LVEntries(i).sFullPKParse = szDAP) Then
                    LVAE_IsDupe = True
                    Exit Function
                End If
            End If
        End If
    Next i
    
    End Function
    Private Sub LVMarkAllDel()
    Dim i As Long
    For i = 0 To UBound(LVEntries)
        LVEntries(i).bDeleted = True
    Next i
    End Sub
    Private Sub EnumComputerTree()
    'Backup routine, see above ^
    Dim pKFM As New KnownFolderManager
    Dim pKNF As IKnownFolder
    Dim pParent As IShellItem
    Dim pEnum As IEnumShellItems
    Dim pItem As IShellItem
    Dim li As Long
    Dim pl As Long
    
    pKFM.GetFolder FOLDERID_ComputerFolder, pKNF
    If (pKNF Is Nothing) = False Then
        pKNF.GetShellItem KF_FLAG_DEFAULT, IID_IShellItem, pParent
        If (pParent Is Nothing) = False Then
            pParent.BindToHandler 0&, BHID_EnumItems, IID_IEnumShellItems, pEnum
            If (pEnum Is Nothing) = False Then
                Do While pEnum.Next(1&, pItem, pl) = S_OK
                    AddStandardFSItem pItem, li
                Loop
            End If
        End If
    End If
    
    End Sub
    
    Private Function ScanDevices() As Long
    'Drives are detected via their own message that doesn't apply to devices
    'All devices get are a SHCNE_UPDATEDIR message in Computer/This PC
    'But we don't want to rescan and potentially spin up normal drives, so
    'we'll just scan for portable devices like phones and cameras, because
    'that's what we're really looking for.
    Dim pMgr As PortableDeviceManager
    Set pMgr = New PortableDeviceManager
    Dim nDev As Long, nDevAdded As Long
    Dim lDev() As LongPtr
    Dim sID() As String
    Dim sFN As String
    Dim wch() As Integer
    Dim cchFN As Long
    Dim sParse As String
    Dim psi As IShellItem
    Dim li As Long
    
    pMgr.GetDevices 0&, nDev
    DebugAppend "nDev=" & nDev
    If nDev > 0 Then
        ReDim lDev(nDev - 1)
        pMgr.GetDevices VarPtr(lDev(0)), nDev
        ReDim sID(nDev - 1)
        Dim i As Long
        For i = 0 To UBound(lDev)
            sID(i) = LPWSTRtoStr(lDev(i))
            DebugAppend "Got PortableDevice(" & i & ")=" & sID(i)
    '        pMgr.GetDeviceFriendlyName sID(i), 0&, cchFN
    '        ReDim wch(cchFN)
    '        pMgr.GetDeviceFriendlyName sID(i), VarPtr(wch(0)), cchFN
    '        sFN = WCHARtoSTR(wch)
    '        DebugAppend "devid(" & i & ") Name=" & sFN
            sParse = AddBackslash(sComp) & sID(i)
            SHCreateItemFromParsingName StrPtr(sParse), Nothing, IID_IShellItem, psi
            If (psi Is Nothing) = False Then
                AddStandardFSItem psi, li
                nDevAdded = nDevAdded + 1
            End If
        Next i
        ScanDevices = nDevAdded
    End If
    End Function
    
    Private Sub dbg_analyzestr(sz As String)
    Dim bt() As Byte
    If LenB(sz) = 0& Then
        Debug.Print "nullstr"
        Exit Sub
    End If
    
    ReDim bt(LenB(sz) - 1)
    CopyMemory bt(0), ByVal StrPtr(sz), LenB(sz)
    
    Dim sOut As String
    Dim i As Long
    For i = 0 To UBound(bt)
        sOut = sOut & Hex$(bt(i)) & " "
    Next i
    Debug.Print sOut
    
    End Sub
    Public Sub dbg_hdrheight()
    Dim cx As Long
    cx = CLng(SendMessage(hLVS, LVM_ENSURESUBITEMVISIBLE, 2&, ByVal 2&))
    'If cx < 1& Then
    '    Debug.Print "try lparam " & cx
    '    cx = SendMessage(hLVS, LVM_ORDERTOINDEX, 2&, ByVal 2&)
    'End If
    'If cx < 1 Then
    '    Debug.Print "nope " & cx
    'Else
    ''cx = 2
    '    Dim lp As Long
    '    lp = GetLVItemlParam(hLVS, cx)
    '    Debug.Print "Order 1 idx=" & cx & ", item=" & LVEntries(lp).sName
    'End If
    'Dim rc As RECT
    'GetWindowRect hLVSHdr, rc
    'cx = rc.Right - rc.Left
    'SetWindowPos hLVSHdr, 0&, 0&, 0&, cx, 100, SWP_NOMOVE
    End Sub
    Public Sub dbg_colwidth()
        DebugAppend "ColWidth=" & ListView_GetColumnWidth(hLVS, 0), 1111
    End Sub
    
    Private Sub ReadWindowsVersion()
    'GetVersion[Ex] does not work with Win8 and above, so we'll go by kernel32 version
    'GetFileVersionInfo does not work with some versions of Win10 and above.
    
    Dim hMod As LongPtr
    Dim hRes As LongPtr
    
    hMod = LoadLibraryW(StrPtr("kernel32.dll"))
    If hMod Then
        hRes = FindResourceW(hMod, StrPtr("#1"), RT_VERSION)
        If hRes Then
            Dim hGbl As LongPtr
            hGbl = LoadResource(hMod, hRes)
            If (hGbl) Then
                Dim lpRes As LongPtr
                lpRes = LockResource(hGbl)
                If lpRes Then
                    Dim tVerInfo As VS_VERSIONINFO_FIXED_PORTION
                    CopyMemory tVerInfo, ByVal lpRes, LenB(tVerInfo)
                    If tVerInfo.Value.dwFileVersionMSh >= 6& Then
                        bIsWinVistaOrGreater = True
                        If tVerInfo.Value.dwFileVersionMSl >= 1& Then bIsWin7OrGreater = True
                        If tVerInfo.Value.dwFileVersionMSl >= 2& Then bIsWin8OrGreater = True
                        If (tVerInfo.Value.dwFileVersionMSl = 4&) Or (tVerInfo.Value.dwFileVersionMSh >= 10&) Then bIsWin10OrGreater = True
                    End If
                End If
            End If
        End If
        FreeLibrary hMod
    End If
    End Sub
    
    Private Sub DisableWow64Redir()
    If IsWOW64 = False Then Exit Sub
    On Error Resume Next
    Dim lOld As Long
    Wow64DisableWow64FsRedirection lOld
    On Error GoTo 0
    End Sub
    Private Sub RevertWow64Redir()
    If IsWOW64 = False Then Exit Sub
    On Error Resume Next
    Dim lOld As Long
    Wow64RevertWow64FsRedirection lOld
    On Error GoTo 0
    End Sub
    
    Private Sub txtColCX_Change()
    If CLng(txtColCX.Text) > 0 Then
        If SendMessage(hLVC, LVM_GETSELECTEDCOUNT, 0&, ByVal 0&) = 0& Then Exit Sub
        uColData(GetLVItemlParam(hLVC, ListView_GetSelectedItem(hLVC))).DefWidth = CLng(txtColCX.Text)
        
    End If
    End Sub
    
    Private Sub SetNumbersOnly(hEdit As LongPtr)
    'makes an edit control numbers only
    Dim dwStyle As Long
    
    dwStyle = CLng(GetWindowLong(hEdit, GWL_STYLE))
    dwStyle = dwStyle Or ES_NUMBER
    Call SetWindowLong(hEdit, GWL_STYLE, dwStyle)
    
    End Sub
    
    Private Function SelGetPropAndCache(pk As PROPERTYKEY) As String
    If siFocus Is Nothing Then
        DebugAppend "SelGetPropAndCache->No file selected."
        Exit Function
    End If
    
    If IsEqualPKEY(pk, PKEY_NULL) Then
        DebugAppend "SelGetPropAndCache->Null PROPERTYKEY"
        Exit Function
    End If
    If (pStoreCache Is Nothing) Or (propstoreFile <> sSelectedFile) Then
        propstoreFile = sSelectedFile
        Dim si2 As IShellItem2
        Set si2 = siFocus
        si2.GetPropertyStore GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pStoreCache
    End If
    If (pStoreCache Is Nothing) = False Then
        SelGetPropAndCache = GetPropertyKeyDisplayString(pStoreCache, pk)
    Else
        DebugAppend "SelGetPropAndCache->Could not load property store for selected item."
    End If
    End Function
    
    Public Function SelectedFileGetPropertyByPKEY(pkey_varptr As LongPtr) As String
    Dim pk As PROPERTYKEY
    If pkey_varptr Then
        CopyMemory ByVal VarPtr(pk), ByVal pkey_varptr, LenB(pk)
    Else
        DebugAppend "SelectedFileGetPropertyByPKEY->No pointer for pkey"
        Exit Function
    End If
    SelectedFileGetPropertyByPKEY = SelGetPropAndCache(pk)
    End Function
    'Public Function SelectedFileGetPropertyByPKEY(pk As PROPERTYKEY) As String
    'SelectedFileGetPropertyByPKEY = SelGetPropAndCache(pk)
    'End Function
    Public Function SelectedFileGetProperty(sSystemName As String) As String
    Dim pk As PROPERTYKEY
    pk = GetPKeyFromSysName(sSystemName)
    SelectedFileGetProperty = SelGetPropAndCache(pk)
    End Function
    
    Private Function GetFileRecordFromPos(lPos As Long) As UCSBFile
    Dim lp As LongPtr
    On Error Resume Next
    lp = GetLVItemlParam(hLVS, lPos)
    If lp >= 0 Then
    GetFileRecordFromPos = LVEntries(lp)
    End If
    End Function
    
    Private Function PKeyIsLoaded(sSysName As String) As Boolean
    Dim i As Long
    If sSysName = "" Then Exit Function
    For i = 0 To UBound(uColData)
        If uColData(i).szSystemName = sSysName Then
            PKeyIsLoaded = True
            Exit Function
        End If
    Next i
    End Function
    
    Private Function PropKeyIsLoaded(pkIn As PROPERTYKEY) As Boolean
    Dim i As Long
    If IsEqualPKEY(pkIn, PKEY_NULL) Then Exit Function
    For i = 0 To UBound(uColData)
        If IsEqualPKEY(uColData(i).pKey, pkIn) Then
            PropKeyIsLoaded = True
            Exit Function
        End If
    Next i
    End Function
    
    'Replace09 courtesy of VBSpeed (xbeat.net/vbspeed)
    'This version is 2.5x faster than the native VB Replace()
    Private Function Replace09(ByRef Text As String, _
        ByRef sOld As String, ByRef sNew As String, _
        Optional ByVal Start As Long = 1, _
        Optional ByVal Count As Long = 2147483647, _
        Optional ByVal Compare As VbCompareMethod = vbBinaryCompare _
      ) As String
    ' by Jost Schwider, jost@schwider.de, 20001218
    
      If LenB(sOld) Then
    
        If Compare = vbBinaryCompare Then
          Replace09Bin Replace09, Text, Text, _
              sOld, sNew, Start, Count
        Else
          Replace09Bin Replace09, Text, LCase$(Text), _
              LCase$(sOld), sNew, Start, Count
        End If
    
      Else 'Suchstring ist leer:
        Replace09 = Text
      End If
    End Function
    Private Static Sub Replace09Bin(ByRef result As String, _
        ByRef Text As String, ByRef Search As String, _
        ByRef sOld As String, ByRef sNew As String, _
        ByVal Start As Long, ByVal Count As Long _
      )
    ' by Jost Schwider, jost@schwider.de, 20001218
      Dim TextLen As Long
      Dim OldLen As Long
      Dim NewLen As Long
      Dim ReadPos As Long
      Dim WritePos As Long
      Dim CopyLen As Long
      Dim Buffer As String
      Dim BufferLen As Long
      Dim BufferPosNew As Long
      Dim BufferPosNext As Long
      
      'Ersten Treffer bestimmen:
      If Start < 2 Then
        Start = InStrB(Search, sOld)
      Else
        Start = InStrB(Start + Start - 1, Search, sOld)
      End If
      If Start Then
      
        OldLen = LenB(sOld)
        NewLen = LenB(sNew)
        Select Case NewLen
        Case OldLen 'einfaches berschreiben:
        
          result = Text
          For Count = 1 To Count
            MidB$(result, Start) = sNew
            Start = InStrB(Start + OldLen, Search, sOld)
            If Start = 0 Then Exit Sub
          Next Count
          Exit Sub
        
        Case Is < OldLen 'Ergebnis wird krzer:
        
          'Buffer initialisieren:
          TextLen = LenB(Text)
          If TextLen > BufferLen Then
            Buffer = Text
            BufferLen = TextLen
          End If
          
          'Ersetzen:
          ReadPos = 1
          WritePos = 1
          If NewLen Then
          
            'Einzufgenden Text beachten:
            For Count = 1 To Count
              CopyLen = Start - ReadPos
              If CopyLen Then
                BufferPosNew = WritePos + CopyLen
                MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
                MidB$(Buffer, BufferPosNew) = sNew
                WritePos = BufferPosNew + NewLen
              Else
                MidB$(Buffer, WritePos) = sNew
                WritePos = WritePos + NewLen
              End If
              ReadPos = Start + OldLen
              Start = InStrB(ReadPos, Search, sOld)
              If Start = 0 Then Exit For
            Next Count
          
          Else
          
            'Einzufgenden Text ignorieren (weil leer):
            For Count = 1 To Count
              CopyLen = Start - ReadPos
              If CopyLen Then
                MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
                WritePos = WritePos + CopyLen
              End If
              ReadPos = Start + OldLen
              Start = InStrB(ReadPos, Search, sOld)
              If Start = 0 Then Exit For
            Next Count
          
          End If
          
          'Ergebnis zusammenbauen:
          If ReadPos > TextLen Then
            result = LeftB$(Buffer, WritePos - 1)
          Else
            MidB$(Buffer, WritePos) = MidB$(Text, ReadPos)
            result = LeftB$(Buffer, WritePos + LenB(Text) - ReadPos)
          End If
          Exit Sub
        
        Case Else 'Ergebnis wird lnger:
        
          'Buffer initialisieren:
          TextLen = LenB(Text)
          BufferPosNew = TextLen + NewLen
          If BufferPosNew > BufferLen Then
            Buffer = Space$(BufferPosNew)
            BufferLen = LenB(Buffer)
          End If
          
          'Ersetzung:
          ReadPos = 1
          WritePos = 1
          For Count = 1 To Count
            CopyLen = Start - ReadPos
            If CopyLen Then
              'Positionen berechnen:
              BufferPosNew = WritePos + CopyLen
              BufferPosNext = BufferPosNew + NewLen
              
              'Ggf. Buffer vergrern:
              If BufferPosNext > BufferLen Then
                Buffer = Buffer & Space$(BufferPosNext)
                BufferLen = LenB(Buffer)
              End If
              
              'String "patchen":
              MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
              MidB$(Buffer, BufferPosNew) = sNew
            Else
              'Position bestimmen:
              BufferPosNext = WritePos + NewLen
              
              'Ggf. Buffer vergrern:
              If BufferPosNext > BufferLen Then
                Buffer = Buffer & Space$(BufferPosNext)
                BufferLen = LenB(Buffer)
              End If
              
              'String "patchen":
              MidB$(Buffer, WritePos) = sNew
            End If
            WritePos = BufferPosNext
            ReadPos = Start + OldLen
            Start = InStrB(ReadPos, Search, sOld)
            If Start = 0 Then Exit For
          Next Count
          
          'Ergebnis zusammenbauen:
          If ReadPos > TextLen Then
            result = LeftB$(Buffer, WritePos - 1)
          Else
            BufferPosNext = WritePos + TextLen - ReadPos
            If BufferPosNext < BufferLen Then
              MidB$(Buffer, WritePos) = MidB$(Text, ReadPos)
              result = LeftB$(Buffer, BufferPosNext)
            Else
              result = LeftB$(Buffer, WritePos - 1) & MidB$(Text, ReadPos)
            End If
          End If
          Exit Sub
        
        End Select
      
      Else 'Kein Treffer:
        result = Text
      End If
    End Sub
    
    Private Function GetPIDLFromFolderID(hOwner As LongPtr, nFolder As CSIDLs) As LongPtr
      Dim pidl As LongPtr
      Call SHGetFolderLocation(hOwner, nFolder, 0, 0, pidl)
        GetPIDLFromFolderID = pidl
      
    End Function
    
    Private Function GetFileTypeTextPIDL(pidl As LongPtr) As String
      Dim sfi As SHFILEINFO
      If SHGetFileInfo(pidl, 0, sfi, LenB(sfi), SHGFI_PIDL Or SHGFI_TYPENAME) Then
        
        
        GetFileTypeTextPIDL = StrConv(sfi.szTypeName, vbUnicode)
      End If
    
    End Function
    Private Function GetFileIconIndexPIDL(pidl As LongPtr, uType As Long) As Long
      Dim sfi As SHFILEINFO
      If SHGetFileInfo(pidl, 0, sfi, LenB(sfi), SHGFI_PIDL Or SHGFI_SYSICONINDEX Or uType) Then
        GetFileIconIndexPIDL = sfi.iIcon
      End If
    End Function
    
    Private Function GetFileAtrDirPidl(pidl As LongPtr) As SFGAO_Flags
    Dim sfi As SHFILEINFO
    'sfi.dwAttributes = SFGAO_FOLDER Or SFGAO_STREAM
    If SHGetFileInfo(pidl, 0&, sfi, LenB(sfi), SHGFI_PIDL Or SHGFI_ATTRIBUTES) Then
        GetFileAtrDirPidl = sfi.dwAttributes
    End If
    End Function
    
    Private Function GetFileIconHandlePIDL(pidlFQ As LongPtr, Optional nType As Long = SHGFI_LARGEICON) As LongPtr
    Dim nIcon As Long
    nIcon = GetFileIconIndexPIDL(pidlFQ, nType)
      imlSysJM.GetIcon nIcon, ILD_TRANSPARENT, GetFileIconHandlePIDL 'ImageList_GetIcon(hSysIL256, nIcon, ILD_TRANSPARENT)
    End Function
    
    Private Function GetFolderStdIcon(Optional sPath As String = "C:\FakePath") As Long
    'returns the system image list index of the generic folder icon
    Static bHasRun As Boolean 'since 0 may be a valid index, use alternate check Or SHGFI_PIDL
    Static nFolder As Long
    If bHasRun Then
        GetFolderStdIcon = nFolder
        Exit Function
    End If
    sPath = "C:\FakePath"
    Dim sfi As SHFILEINFO
    Call SHGetFileInfo(ByVal sPath, FILE_ATTRIBUTE_DIRECTORY, sfi, LenB(sfi), SHGFI_SYSICONINDEX Or SHGFI_SMALLICON Or SHGFI_USEFILEATTRIBUTES)
    nFolder = sfi.iIcon
    bHasRun = True
    GetFolderStdIcon = nFolder
    DebugAppend "GenericFolderIcon=" & nFolder & "|" & sPath
    End Function
    
    Private Function GetFileStdIcon(sFile As String) As Long
    'returns the system image list index of the generic icon for a filetype
    Dim sExt As String
    If InStr(sFile, ".") Then
        sExt = Right$(sFile, Len(sFile) - InStrRev(sFile, "."))
        sExt = "." & sExt
        Dim sfi As SHFILEINFO
        Call SHGetFileInfo(sExt, FILE_ATTRIBUTE_NORMAL, sfi, LenB(sfi), SHGFI_SYSICONINDEX Or SHGFI_SMALLICON Or SHGFI_USEFILEATTRIBUTES)
        DebugAppend "GetFileStdIcon for " & sExt & "=" & sfi.iIcon
        GetFileStdIcon = sfi.iIcon
    End If
    End Function
    
    Private Function strarr_Search(ar() As String, sTerm As String) As Long
    strarr_Search = -1
    Dim i As Long
    For i = 0 To UBound(ar)
        If ar(i) = sTerm Then
            strarr_Search = i
            Exit Function
        End If
    Next
    End Function
    
    Public Sub SetAdvancedStringSort(bEnabled As Boolean, Optional dwFlags As ucsb_COMPARE_FLAGS, Optional sLocaleName As String = "", Optional bReSortList As Boolean = False)
    mAdvSortFlags = dwFlags
    mAdvSortLocale = sLocaleName
    If bEnabled <> mUseAdvancedSort Then
        If m_cbSort <> 0& Then
            ' If mUseAdvancedSort Then
            '     scb_ReleaseCallback 20
            ' Else
            '     scb_ReleaseCallback 2
            ' End If
        End If
        mUseAdvancedSort = bEnabled
        If mUseAdvancedSort Then
            m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
        Else
            m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
        End If
        If bReSortList Then
            SendMessage hLVS, LVM_SORTITEMS, mLastSortInfo, ByVal m_cbSort
        End If
    End If
    End Sub
    
    Private Function GetPropertyKeyDisplayString(pps As IPropertyStore, pkProp As PROPERTYKEY, Optional bFixChars As Boolean = True) As String
    'Gets the string value of the given canonical property; e.g. System.Company, System.Rating, etc
    'This would be the value displayed in Explorer if you added the column in details view
    '<EhHeader>
    On Error GoTo e0
    '</EhHeader>
    Dim lpsz As LongPtr
    Dim ppd As IPropertyDescription
    If ((pps Is Nothing) = False) Then
        PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
        If (ppd Is Nothing) Then
    '        DebugAppend "GetPropertyKeyDisplayString->Could not obtain IPropertyDescription, will attempt alternative."
            Dim vrr As Variant, vbr As Variant
            pps.GetValue pkProp, vrr
            PropVariantToVariant vrr, vbr
            If (VarType(vbr) And vbArray) = vbArray Then
                Dim i As Long
                For i = LBound(vbr) To UBound(vbr)
                    GetPropertyKeyDisplayString = GetPropertyKeyDisplayString & CStr(vbr(i)) & "; "
                Next i
                If Len(GetPropertyKeyDisplayString) > 2 Then
                    GetPropertyKeyDisplayString = Left$(GetPropertyKeyDisplayString, Len(GetPropertyKeyDisplayString) - 2)
                End If
            Else
                GetPropertyKeyDisplayString = CStr(vbr)
            End If
        Else
            Dim hr As Long
            hr = PSFormatPropertyValue(ObjPtr(pps), ObjPtr(ppd), PDFF_DEFAULT, lpsz)
    '        DebugAppend "prophr=0x" & Hex$(hr)
            SysReAllocString VarPtr(GetPropertyKeyDisplayString), lpsz
            CoTaskMemFree lpsz
        End If
        If bFixChars Then
            GetPropertyKeyDisplayString = Replace$(GetPropertyKeyDisplayString, ChrW$(&H200E), "")
            GetPropertyKeyDisplayString = Replace$(GetPropertyKeyDisplayString, ChrW$(&H200F), "")
            GetPropertyKeyDisplayString = Replace$(GetPropertyKeyDisplayString, ChrW$(&H202A), "")
            GetPropertyKeyDisplayString = Replace$(GetPropertyKeyDisplayString, ChrW$(&H202C), "")
        End If
        Set ppd = Nothing
    Else
        DebugAppend "GetPropertyKeyDisplayString.Error->PropertyStore is not set."
        
    End If
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.GetPropertyKeyDisplayString->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function GetPropertyDisplayStringByName(pps As IPropertyStore, szProp As String, Optional bFixChars As Boolean = True) As String
    'Gets the string value of the given canonical property; e.g. System.Company, System.Rating, etc
    'This would be the value displayed in Explorer if you added the column in details view
    On Error GoTo e0
    Dim lpsz As LongPtr
    Dim ppd As IPropertyDescription
    Dim pkProp As PROPERTYKEY
    If (pps Is Nothing) = False Then
        PSGetPropertyKeyFromName StrPtr(szProp), pkProp
        PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
        If (ppd Is Nothing) = False Then
            Dim hr As Long
            hr = PSFormatPropertyValue(ObjPtr(pps), ObjPtr(ppd), PDFF_DEFAULT, lpsz)
            SysReAllocString VarPtr(GetPropertyDisplayStringByName), lpsz
            CoTaskMemFree lpsz
        End If
        If bFixChars Then
            GetPropertyDisplayStringByName = Replace$(GetPropertyDisplayStringByName, ChrW$(&H200E), "")
            GetPropertyDisplayStringByName = Replace$(GetPropertyDisplayStringByName, ChrW$(&H200F), "")
            GetPropertyDisplayStringByName = Replace$(GetPropertyDisplayStringByName, ChrW$(&H202A), "")
            GetPropertyDisplayStringByName = Replace$(GetPropertyDisplayStringByName, ChrW$(&H202C), "")
        End If
        Set ppd = Nothing
    Else
        DebugAppend "GetPropertyKeyDisplayString.Error->PropertyStore is not set."
    End If
    Exit Function
    e0:
        DebugAppend "ucShellBrowse.GetPropertyKeyDisplayString->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Function
    
    
    Private Function GetPropertyDisplayString(pps As IPropertyStore, ppd As IPropertyDescription, BackupKey As PROPERTYKEY, Optional bFixChars As Boolean = True) As String
    'Same as above if you already have the IPropertyDescription (caller is responsible for freeing it too)
    Dim lpsz As LongPtr
    On Error GoTo e0
    If (pps Is Nothing) = False Then
        If (ppd Is Nothing) Then
            DebugAppend "GetPropertyDisplayString->Could not obtain IPropertyDescription, will attempt alternative."
            If IsEqualPKEY(BackupKey, PKEY_NULL) = False Then
                Dim vrr As Variant, vbr As Variant
                pps.GetValue BackupKey, vrr
                PropVariantToVariant vrr, vbr
                If (VarType(vbr) And vbArray) = vbArray Then
                    Dim i As Long
                    For i = LBound(vbr) To UBound(vbr)
                        GetPropertyDisplayString = GetPropertyDisplayString & CStr(vbr(i)) & "; "
                    Next i
                    GetPropertyDisplayString = Left$(GetPropertyDisplayString, Len(GetPropertyDisplayString) - 2)
                Else
                    GetPropertyDisplayString = CStr(vbr)
                End If
            End If
        Else
            PSFormatPropertyValue ObjPtr(pps), ObjPtr(ppd), PDFF_DEFAULT, lpsz
            SysReAllocString VarPtr(GetPropertyDisplayString), lpsz
            CoTaskMemFree lpsz
        End If
        If bFixChars Then
            GetPropertyDisplayString = Replace$(GetPropertyDisplayString, ChrW$(&H202A), "")
            GetPropertyDisplayString = Replace$(GetPropertyDisplayString, ChrW$(&H202C), "")
            GetPropertyDisplayString = Replace$(GetPropertyDisplayString, ChrW$(&H200E), "")
            GetPropertyDisplayString = Replace$(GetPropertyDisplayString, ChrW$(&H200F), "")
        End If
    Else
        DebugAppend "GetPropertyDisplayString.Error->PropertyStore or PropertyDescription is not set."
        
    End If
    Exit Function
    e0:
    DebugAppend "GetPropertyDisplayString.Error->" & Err.Description & ", 0x" & Hex$(Err.Number), 3
    End Function
    
    Private Function GetPropertyKeyEditInvite(pkProp As PROPERTYKEY) As String
    Dim ppd As IPropertyDescription
    Dim lpsz As LongPtr
    PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
    ppd.GetEditInvitation lpsz
    GetPropertyKeyEditInvite = LPWSTRtoStr(lpsz)
    End Function
    
    Private Function GetPropertyKeyDataType(pkProp As PROPERTYKEY) As PROPDESC_DISPLAYTYPE
    Dim ppd As IPropertyDescription
    PSGetPropertyDescription pkProp, IID_IPropertyDescription, ppd
    ppd.GetDisplayType GetPropertyKeyDataType
    End Function
    
    Private Function GetShellItemPropString(siItem As IShellItem, tKey As PROPERTYKEY) As String
    Dim si2Item As IShellItem2
    Dim pStore As IPropertyStore
    Set si2Item = siItem
    si2Item.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pStore
    If (pStore Is Nothing) = False Then
        GetShellItemPropString = GetPropertyKeyDisplayString(pStore, tKey)
        Set pStore = Nothing
    Else
        DebugAppend "GetShellItemPropString->Failed to open property store."
    End If
    End Function
    
    Private Function GetFileEffectiveZone(sFile As String) As URLZONE
    'using this method takes into account other factors to determine level MUTZ_ISFILE Or
    Dim pISM As InternetSecurityManager
    Set pISM = New InternetSecurityManager
    On Error GoTo e0
    Dim dwZone As Long
    pISM.MapUrlToZone StrPtr(sFile), dwZone, MUTZ_DONT_UNESCAPE
    Set pISM = Nothing
    GetFileEffectiveZone = dwZone
     Exit Function
    e0:
    DebugAppend "GetFileEffectiveZone.Error->" & Err.Description & ",0x" & Hex$(Err.Number)
    End Function
    
    Private Function StripCommonControlChars(ByVal sIn As String) As String
    StripCommonControlChars = Replace$(sIn, ChrW$(&H202A), "")
    StripCommonControlChars = Replace$(StripCommonControlChars, ChrW$(&H202C), "")
    StripCommonControlChars = Replace$(StripCommonControlChars, ChrW$(&H200E), "")
    StripCommonControlChars = Replace$(StripCommonControlChars, ChrW$(&H200F), "")
    End Function
    
    Private Function GetZoneIdx(zn As URLZONE) As Long
    Dim i As Long
    For i = 0 To UBound(arZones)
        If arZones(i).Zone = zn Then
            GetZoneIdx = i
            Exit Function
        End If
    Next i
    GetZoneIdx = -1
    End Function
    
    Private Sub InitZoneStr()
    On Error GoTo e0
    Dim nZn As Long
    Dim sz() As String
    ReDim sz(0)
    ReDim arZones(0)
    arZones(0).szDisp = "(unknown)" 'In case of error
    
    Dim pZnMgr As IInternetZoneManager
    Dim hr As Long
    Dim dwEnum As Long
    Dim i As Long
    Dim zn As URLZONE
    Dim tZnAtr As ZONEATTRIBUTES
    
    hr = CoCreateInstance(CLSID_InternetZoneManager, 0, CLSCTX_LOCAL_SERVER Or CLSCTX_INPROC_SERVER, IID_IInternetZoneManager, pZnMgr)
    If (pZnMgr Is Nothing) = False Then
        pZnMgr.CreateZoneEnumerator dwEnum, nZn
        If nZn Then
            For i = 0 To nZn - 1
                zn = pZnMgr.GetZoneAt(dwEnum, i)
                tZnAtr.cbSize = LenB(tZnAtr)
                pZnMgr.GetZoneAttributes zn, tZnAtr
                ReDim Preserve arZones(i)
                arZones(i).Zone = zn
                arZones(i).szDisp = WCHARbtarToSTR(tZnAtr.szDisplayName)
                arZones(i).szIcon = WCHARbtarToSTR(tZnAtr.szIconPath)
                LoadZoneIcon arZones(i).szIcon, i
                DebugAppend "Added Zone " & arZones(i).szDisp & ", icon=" & arZones(i).szIcon
                ZeroMemory tZnAtr, LenB(tZnAtr)
            Next i
        Else
            DebugAppend "InitZoneStr::No zones found."
        End If
    Else
        DebugAppend "InitZoneStr::Could not create zone manager."
    End If
    
    Exit Sub
    e0:
        DebugAppend "ucShellBrowse.InitZoneStr->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub LoadZoneIcon(sPath As String, iidx As Long)
    If sPath = "" Then Exit Sub
    Dim dwSizes As Long
    Dim hr As Long
    Dim sSys As String
    Dim nIco As Long
    Dim sFN As String
    Dim sIco As String
    
    If InStr(sPath, "#") Then
        sIco = Mid$(sPath, InStr(sPath, "#") + 1)
        sFN = Left$(sPath, InStr(sPath, "#") - 1)
    ElseIf InStr(sPath, ",") Then
        sIco = Mid$(sPath, InStr(sPath, ",") + 1)
        sFN = Left$(sPath, InStr(sPath, ",") - 1)
    Else
        sFN = sPath
    End If
    If sIco <> "" Then
        nIco = CLng(sIco) - 1
    End If
    
    If m_ScaleX > 1 Then
        dwSizes = PackWords(48, 32)
    Else
        dwSizes = PackWords(32, 16)
    End If
    Dim sFP As String
    If InStr(sPath, "\") Then
        sFP = sFN
    Else
        sSys = ExpandEnvVars("%WINDIR%\")
        sFP = AddBackslash(sSys) & "System32\" & sFN
    End If
    Dim ler As Long
    hr = SHDefExtractIconW(StrPtr(sFP), nIco, GIL_FORSHELL, arZones(iidx).hIcon, arZones(iidx).hIconSm, dwSizes)
    ler = Err.LastDllError 'GetLastError()
    DebugAppend "LastError=0x" & Hex$(hr)
    Dim lr As Long
    If hr <> S_OK Then
        Dim siItem As IShellItem
        Dim pEI As IExtractIconW
        SHCreateItemFromParsingName StrPtr(sFP), Nothing, IID_IShellItem, siItem
        If (siItem Is Nothing) = False Then
            siItem.BindToHandler 0&, BHID_SFUIObject, IID_IExtractIconW, pEI
            If (pEI Is Nothing) = False Then
                pEI.Extract StrPtr(sFP), nIco, arZones(iidx).hIcon, arZones(iidx).hIconSm, dwSizes
                If arZones(iidx).hIconSm Then Exit Sub
            Else
                DebugAppend "LoadZoneIcon alt failed to get iei"
            End If
        End If
        DebugAppend "LoadZoneIcon failed; path=" & sFP & ",idx=" & nIco & ",szLg=" & LoWord(dwSizes) & ",szSm=" & HiWord(dwSizes)
    End If
    End Sub
    
    Private Function INDEXTOOVERLAYMASK(iOverlay As Long) As Long
      INDEXTOOVERLAYMASK = ((iOverlay) << 8)
    End Function
    
    ' Private Function IndexToStateImageMask(ByVal Index As Long) As Long
    ' IndexToStateImageMask = Index * (2 ^ 12)
    ' End Function
    
    Private Function STATEIMAGEMASKTOINDEX(ByVal ImgState As Long) As Long
    STATEIMAGEMASKTOINDEX = ((ImgState) >> 12) 'ImgState / (2 ^ 12)
    End Function
    
    Private Function PackWords(ByVal inLo As Integer, ByVal inHi As Integer) As Long
        PackWords = (CLng(inLo) And &HFFFF&) Or ((inHi And &H7FFF&) * &H10000)
        If (inHi And &H8000&) Then PackWords = PackWords Or &H80000000 ' Append high bit
    End Function
    
    ' Private Function LoWord(ByVal DWord As Long) As Integer
    ' If DWord And &H8000& Then
    '     LoWord = DWord Or &HFFFF0000
    ' Else
    '     LoWord = DWord And &HFFFF&
    ' End If
    ' End Function
    Private Function LoWord_B(ByVal LongVal As Long) As Integer
        LoWord_B = LongVal And &HFFFF&
    End Function
    Private Function LoWord_C(ByVal dwValue As Long) As Integer
      CopyMemory LoWord_C, dwValue, 2
    End Function
    
    Private Function HIWORD_B(ByVal lParam As Long) As Integer
    HIWORD_B = lParam \ &H10000 And &HFFFF&
    End Function
    ' Private Function HiWord(ByVal DWord As Long) As Integer
    ' HiWord = (DWord And &HFFFF0000) \ &H10000
    ' End Function
    'Private Function HiWord(ByVal dwValue As Long) As Integer
    '  CopyMemory HiWord, ByVal VarPtr(dwValue) + 2, 2
    'End Function
    
    Private Function UnsignedAdd(ByVal Start As Long, ByVal Incr As Long) As Long
    UnsignedAdd = ((Start Xor &H80000000) + Incr) Xor &H80000000
    End Function
    
    ' Private Function MakeLong(wLow As Long, wHigh As Long) As Long
    '   MakeLong = LoWord(wLow) Or (&H10000 * LoWord(wHigh))
    ' End Function
    
    ' Private Function MAKELPARAM(wLow As Long, wHigh As Long) As Long
    '   MAKELPARAM = MakeLong(wLow, wHigh)
    ' End Function
    
    Private Function LargeIntToLongLong(pLI As LARGE_INTEGER) As LongLong
	CopyMemory LargeIntToLongLong, pLI, 8
    End Function
    Private Function LargeIntToLongLongB(Low As Long, High As Long) As LongLong
    Dim pli As LARGE_INTEGER
    pli.lowpart = Low: pli.highpart = High
	CopyMemory LargeIntToLongLongB, pli, 8
    End Function
  
    Private Function SpecialFolderPath(tID As UUID) As String
    Dim pkm As New KnownFolderManager
    Dim pkf As IKnownFolder
    Dim lpPath As LongPtr
    
    pkm.GetFolder tID, pkf
    pkf.GetPath 0&, lpPath
    SysReAllocString VarPtr(SpecialFolderPath), lpPath
    
    Call CoTaskMemFree(lpPath)
    
    Set pkf = Nothing
    Set pkm = Nothing
    
    End Function
    
    '***************************************************
    'COMBOBOX
    
    Private Function CBX_InsertItem(hCB As LongPtr, sText As String, Optional iImage As Long = -1, Optional iOverlay As Long = -1, Optional ByVal lParam As LongPtr = 0, Optional iItem As Long = -1, Optional iIndent As Long = 0) As Long
    
    Dim cbxi As COMBOBOXEXITEMW
    
    With cbxi
        .Mask = CBEIF_TEXT Or CBEIF_LPARAM Or CBEIF_IMAGE Or CBEIF_SELECTEDIMAGE Or CBEIF_INDENT Or CBEIF_LPARAM
        .cchTextMax = Len(sText)
        .pszText = StrPtr(sText)
        .iItem = iItem
        .iIndent = iIndent
        .iImage = iImage
        .iSelectedImage = iImage
        .iOverlay = iOverlay
        .lParam = lParam
    End With
    
        CBX_InsertItem = CLng(SendMessageW(hCB, CBEM_INSERTITEMW, 0, cbxi))
        
    End Function
    Private Function CBX_GetItemW(hCBX As LongPtr, i As Long) As COMBOBOXEXITEMW
    Dim cbxi As COMBOBOXEXITEMW
    With cbxi
        .Mask = CBEIF_TEXT Or CBEIF_IMAGE Or CBEIF_SELECTEDIMAGE Or _
                CBEIF_OVERLAY Or CBEIF_INDENT Or CBEIF_LPARAM
        .iItem = i
    End With
    Call SendMessage(hCBX, CBEM_GETITEMW, 0, cbxi)
    CBX_GetItemW = cbxi
    End Function
    Private Function GetCBXItemlParam(hWnd As LongPtr, i As Long) As LongPtr
    Dim cbxi As COMBOBOXEXITEMW
    With cbxi
        .Mask = CBEIF_LPARAM
        .iItem = i
    End With
    Call SendMessage(hWnd, CBEM_GETITEMW, 0, cbxi)
    GetCBXItemlParam = cbxi.lParam
    End Function
    
    
    '******************************************************
    'ListView
    
    Private Function GetLVItemTextW(hWnd As LongPtr, iItem As Long, iSub As Long) As String
    Dim flvi As LVITEM
    With flvi
        Dim Buffer As String
        Buffer = String$(MAX_PATH, vbNullChar)
        .pszText = StrPtr(Buffer)
        .cchTextMax = MAX_PATH
        .iSubItem = iSub
    End With
    SendMessage hWnd, LVM_GETITEMTEXTW, iItem, ByVal VarPtr(flvi)
    If InStr(Buffer, vbNullChar) > 1 Then
        GetLVItemTextW = Left$(Buffer, InStr(Buffer, vbNullChar) - 1) ', vbUnicode)
    End If
    End Function
    
    Private Sub SetTileView(hWnd As LongPtr)
    
    Dim tLVI As LVTILEVIEWINFO
    Dim tsz As SIZE
    Call SendMessage(hWnd, LVM_SETVIEW, LV_VIEW_TILE, ByVal 0&)
    
    tLVI.cbSize = LenB(tLVI)
    tLVI.dwMask = LVTVIM_COLUMNS Or LVTVIM_LABELMARGIN '
    tLVI.dwFlags = LVTVIF_AUTOSIZE
    If mTileWidth > 0& Then
        tLVI.dwMask = tLVI.dwMask Or LVTVIM_TILESIZE
        tLVI.dwFlags = tLVI.dwFlags Or LVTVIF_FIXEDWIDTH
        tsz.cx = mTileWidth * m_ScaleX
        tLVI.SizeTile = tsz
    End If
    tLVI.cLines = 3
    Call SendMessage(hWnd, LVM_SETTILEVIEWINFO, 0, tLVI)
    
    SetTileInfo hWnd
    UserControl.Height = UserControl.Height - 16
    UserControl_Resize
    UserControl.Height = UserControl.Height + 16
    
    If m_cbSort = 0& Then
        If mUseAdvancedSort Then
            m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
        Else
            m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
        End If
    End If
    mLastSortInfo = eSortName
    Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
    
    End Sub
    
    Private Sub SetTileInfo(hWnd As LongPtr)
    Dim tLVT As LVTILEINFO
    Dim lCol() As Long
    If m_SubItemProgress > 0 Then
        ReDim lCol(1)
    '    DebugAppend "SetTileInfo prog=" & m_SubItemProgress & ",spc=" & m_SubItemFreeSpc & ",typ=" & m_SubItemType, 3
        lCol(0) = m_SubItemProgress
        If m_SubItemFreeSpc > 0 Then
            lCol(1) = m_SubItemFreeSpc
            DebugAppend "SetTileInfo::Set decorated free space " & m_SubItemFreeSpc, 3
        Else
            lCol(1) = 2
        End If
    '    If m_SubItemType > 0 Then
    '        lCol(2) = m_SubItemType
    '    Else
    '        lCol(2) = 3
    '    End If
    Else
        DebugAppend "SetTileInfo,typ=" & m_SubItemType, 3
        ReDim lCol(1)
        If m_SubItemType > 0 Then
            lCol(0) = m_SubItemType
        Else
            lCol(0) = 1
        End If
        If m_SubItemSize > 0 Then
            lCol(1) = m_SubItemSize
        Else
            lCol(1) = 2
        End If
    '    lCol(2) = 3
    End If
    Dim ct As Long
    Dim i As Long
    ct = CLng(SendMessage(hWnd, LVM_GETITEMCOUNT, 0, ByVal 0&))
    For i = 0 To ct - 1
        tLVT.cbSize = LenB(tLVT)
        tLVT.iItem = i
        tLVT.cColumns = UBound(lCol) + 1
        tLVT.puColumns = VarPtr(lCol(0))
        Call SendMessage(hWnd, LVM_SETTILEINFO, 0, tLVT)
    Next i
    If (m_SubItemProgress > 0) Or (lvrCol > 0) Then
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
    End If
    End Sub
    
    Private Sub SetTileViewEx(hWnd As LongPtr)
    
    Dim tLVI As LVTILEVIEWINFO
    Dim tsz As SIZE
    mCurCols = Header_GetItemCount(hLVSHdr)
    
    Dim HDI As HDITEM
    HDI.Mask = HDI_WIDTH
    HDI.CXY = 540
    Header_SetItem hLVSHdr, 2, HDI
    HDI.Mask = HDI_WIDTH
    HDI.CXY = 540
    Header_SetItem hLVSHdr, 3, HDI
    Call SendMessage(hWnd, LVM_SETVIEW, LV_VIEW_TILE, ByVal 0&)
    Dim rc As RECT
    rc.Top = 10
    rc.Bottom = 10
    rc.Left = 1
    rc.Right = 1
       tLVI.cbSize = LenB(tLVI)
       tsz.cx = 550
       tsz.cy = 36
       Call SendMessage(hWnd, LVM_GETTILEVIEWINFO, 0, tLVI)
       tLVI.dwMask = LVTVIM_COLUMNS Or LVTVIM_TILESIZE 'Or LVTVIM_LABELMARGIN '
       tLVI.dwFlags = LVTVIF_EXTENDED Or LVTVIF_FIXEDHEIGHT 'LVTVIF_AUTOSIZE ' Or  tLVI.dwFlags   '
       tLVI.cLines = mCurCols
       tLVI.SizeTile = tsz
    '   tLVI.RCLabelMargin = rc
       Call SendMessage(hWnd, LVM_SETTILEVIEWINFO, 0, tLVI)
    
    SetTileInfoEx hWnd
    UserControl.Height = UserControl.Height - 16
    UserControl_Resize
    UserControl.Height = UserControl.Height + 16
    
    End Sub
    
    Private Sub SetTileInfoEx(hWnd As LongPtr)
    Dim tLVT As LVTILEINFO
    Dim lCol() As Long
    ReDim lCol(mCurCols - 1)
    Dim lFmt() As LVCOLUMN_fmt
    ReDim lFmt(mCurCols - 1)
    Dim i As Long, j As Long
    j = 1
    For i = 0 To UBound(lCol)
        lCol(i) = j
        If (i Mod 2) Then
            lFmt(i) = LVCFMT_TILE_PLACEMENTMASK
        End If
        j = j + 1
    Next i
    
    ''The only flag that seems to work is Line Break (also part of placementmask)
    ''If you figure out any of this, contact me
    'lFmt(0) = LVCFMT_NO_TITLE
    'lFmt(1) = LVCFMT_FILL Or LVCFMT_LINE_BREAK
    'lFmt(2) = LVCFMT_WRAP Or LVCFMT_NO_TITLE
    'lFmt(3) = LVCFMT_TILE_PLACEMENTMASK Or LVCFMT_NO_TITLE
    'lFmt(4) = LVCFMT_NO_TITLE
    lFmt(UBound(lFmt)) = LVCFMT_FILL
    Dim ct As Long
    ct = CLng(SendMessage(hWnd, LVM_GETITEMCOUNT, 0, ByVal 0&))
    For i = 0 To ct - 1
        tLVT.cbSize = LenB(tLVT)
        tLVT.iItem = i
        tLVT.cColumns = UBound(lCol) + 1
        tLVT.puColumns = VarPtr(lCol(0))
        tLVT.piColFmt = VarPtr(lFmt(0))
        Call SendMessage(hWnd, LVM_SETTILEINFO, 0, tLVT)
    Next i
    Dim HDI As HDITEM
    HDI.Mask = HDI_WIDTH
    HDI.CXY = 240
    Header_SetItem hLVSHdr, 2, HDI
    HDI.Mask = HDI_WIDTH
    HDI.CXY = 240
    Header_SetItem hLVSHdr, 3, HDI
    End Sub
    
    Private Sub SetSingleTileInfo(hWnd As LongPtr, i As Long)
    Dim tLVT As LVTILEINFO
    Dim lCol() As Long
    
    'lCol(0) = 3
    'lCol(1) = 1
    '    DebugAppend "SetSingleTileInfo prog=" & m_SubItemProgress & ",typ=" & m_SubItemType & ",size=" & m_SubItemSize, 3
    If m_SubItemProgress > 0 Then
        ReDim lCol(1)
        lCol(0) = m_SubItemProgress
        If m_SubItemFreeSpc > 0 Then
            lCol(1) = m_SubItemFreeSpc
        Else
            lCol(1) = 2
        End If
    '    If m_SubItemType > 0 Then
    '        lCol(2) = m_SubItemType
    '    Else
    '        lCol(2) = 3
    '    End If
    'ElseIf lvrCol > 0 Then
    '    ReDim lCol(1)
    '    If m_SubItemType > 0 Then
    '        lCol(0) = m_SubItemType
    '    Else
    '        lCol(0) = 2
    '    End If
    '    lCol(1) = lvrCol
    '    lCol(2) = 3
    Else
        ReDim lCol(1)
        If m_SubItemType > 0 Then
            lCol(0) = m_SubItemType
        Else
            lCol(0) = 1
        End If
        If m_SubItemSize > 0 Then
            lCol(1) = m_SubItemSize
        Else
            lCol(1) = 2
        End If
    '    lCol(2) = 3
    End If
    tLVT.cbSize = LenB(tLVT)
    tLVT.iItem = i
    tLVT.cColumns = UBound(lCol) + 1
    tLVT.puColumns = VarPtr(lCol(0))
    Call SendMessage(hWnd, LVM_SETTILEINFO, 0, tLVT)
    End Sub
    
    Private Sub SetSingleTileInfoEx(hWnd As LongPtr, i As Long)
    Dim tLVT As LVTILEINFO
    Dim lCol() As Long
    ReDim lCol(mCurCols - 1)
    Dim lFmt() As LVCOLUMN_fmt
    ReDim lFmt(mCurCols - 1)
    Dim k As Long, j As Long
    j = 1
    For k = 0 To UBound(lCol)
        lCol(k) = j
        If (k Mod 2) Then
            lFmt(k) = LVCFMT_TILE_PLACEMENTMASK
        End If
        j = j + 1
    Next k
    tLVT.cbSize = LenB(tLVT)
    tLVT.iItem = i
    tLVT.cColumns = UBound(lCol) + 1
    tLVT.puColumns = VarPtr(lCol(0))
    tLVT.piColFmt = VarPtr(lFmt(0))
    Call SendMessage(hWnd, LVM_SETTILEINFO, 0, tLVT)
    
    End Sub
    
    Private Sub SetSortArrowAPI(hWnd As LongPtr, lCol As Long, iSort As Integer)
        '<EhHeader>
        On Error GoTo SetSortArrowAPI_Err
        '</EhHeader>
    Dim HDI As HDITEMW
    Dim bt As String
    Dim i As Long
    Dim lCnt As Long
    Dim lp As LongPtr
    lCnt = Header_GetItemCount(hLVSHdr)
    If lCnt = 0 Then Exit Sub
    For i = 0 To (lCnt - 1)
    '    lp = GetHDItemlParam(hLVSHdr, i)
        HDI.Mask = HDI_FORMAT Or HDI_LPARAM
        Header_GetItemW hLVSHdr, i, HDI
        lp = HDI.lParam
        HDI.Mask = HDI_FORMAT Or HDI_TEXT
        HDI.fmt = HDI.fmt Or HDF_STRING
        HDI.fmt = HDI.fmt And Not HDF_SORTUP 'clear any existing sort arrow
        HDI.fmt = HDI.fmt And Not HDF_SORTDOWN
        If (lCol <> -1) And (iSort <> -1) Then
            If lp = lCol Then
                If iSort = 0 Then
                    HDI.fmt = HDI.fmt Or HDF_SORTUP 'Or HDF_BITMAP_ON_RIGHT
                Else
                    HDI.fmt = HDI.fmt Or HDF_SORTDOWN 'Or HDF_BITMAP_ON_RIGHT
                End If
        
            End If
        End If
    '    bt = sColText(lp)
        bt = uColData(lp).szDisplayName
        DebugAppend "SetArrow(" & lCol & "," & iSort & ")->" & bt & "," & (HDI.fmt And HDF_SORTDOWN) & "," & (HDI.fmt And HDF_SORTUP)
        HDI.cchTextMax = Len(bt)
        HDI.pszText = StrPtr(bt & vbNullChar)
        Call SendMessage(hLVSHdr, HDM_SETITEMW, i, HDI)
    Next i
     '<EhFooter>
     Exit Sub
    
    SetSortArrowAPI_Err:
        DebugAppend "ucShellBrowse.SetSortArrowAPI->" & Err.Description & " (" & Err.Number & ")"
     '</EhFooter>
    End Sub
    
    Private Sub LVCSetSortArrow(lCol As Long, iSort As Integer)
        '<EhHeader>
        On Error GoTo LVCSetSortArrow_Err
        '</EhHeader>
    Dim HDI As HDITEMW
    Dim bt As String
    Dim i As Long
    Dim lCnt As Long
    Dim lp As LongPtr
    lCnt = Header_GetItemCount(hLVCHdr)
    If lCnt = 0 Then Exit Sub
    For i = 0 To (lCnt - 1)
        HDI.Mask = HDI_FORMAT Or HDI_LPARAM Or HDI_TEXT
        Header_GetItemW hLVCHdr, i, HDI
        lp = HDI.lParam
        HDI.Mask = HDI_FORMAT Or HDI_TEXT
        HDI.fmt = HDI.fmt Or HDF_STRING
        HDI.fmt = HDI.fmt And Not HDF_SORTUP 'clear any existing sort arrow
        HDI.fmt = HDI.fmt And Not HDF_SORTDOWN
        If i = lCol Then
            If iSort = 0 Then
                HDI.fmt = HDI.fmt Or HDF_SORTUP
            Else
                HDI.fmt = HDI.fmt Or HDF_SORTDOWN
            End If
        End If
        If lp = 0 Then
            bt = scc_PropCol
        ElseIf lp = 1 Then
            bt = scc_AdvCol
        End If
        HDI.cchTextMax = Len(bt)
        HDI.pszText = StrPtr(bt & vbNullChar)
        Call SendMessage(hLVCHdr, HDM_SETITEMW, i, HDI)
    Next i
     '<EhFooter>
     Exit Sub
    
    LVCSetSortArrow_Err:
        DebugAppend "ucShellBrowse.LVCSetSortArrow->" & Err.Description & " (" & Err.Number & ")"
     '</EhFooter>
    End Sub
    
    Private Sub LVCSortArrowsClear()
        '<EhHeader>
        On Error GoTo LVCSetSortArrow_Err
        '</EhHeader>
    Dim HDI As HDITEMW
    Dim bt As String
    Dim i As Long
    Dim lCnt As Long
    Dim lp As LongPtr
    lCnt = Header_GetItemCount(hLVCHdr)
    If lCnt = 0 Then Exit Sub
    For i = 0 To (lCnt - 1)
        HDI.Mask = HDI_FORMAT Or HDI_LPARAM Or HDI_TEXT
        Header_GetItemW hLVCHdr, i, HDI
        lp = HDI.lParam
        HDI.Mask = HDI_FORMAT Or HDI_TEXT
        HDI.fmt = HDI.fmt Or HDF_STRING
        HDI.fmt = HDI.fmt And Not HDF_SORTUP 'clear any existing sort arrow
        HDI.fmt = HDI.fmt And Not HDF_SORTDOWN
        If lp = 0 Then
            bt = scc_PropCol
        End If
        HDI.cchTextMax = Len(bt)
        HDI.pszText = StrPtr(bt & vbNullChar)
        Call SendMessage(hLVCHdr, HDM_SETITEMW, i, HDI)
    Next i
     '<EhFooter>
     Exit Sub
    
    LVCSetSortArrow_Err:
        DebugAppend "ucShellBrowse.LVCSetSortArrow->" & Err.Description & " (" & Err.Number & ")"
     '</EhFooter>
    End Sub
    
    Private Function GroupDisableGroupView(hWnd As LongPtr) As Long
    GroupDisableGroupView = CLng(SendMessageW(hWnd, LVM_ENABLEGROUPVIEW, 0, ByVal 0&))
    RedrawWindow hWnd, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    UpdateWindow hWnd
    End Function
    
    Private Function GroupUpdateFooter(hWnd As LongPtr, lid As Long, ByVal sNew As String) As Long
    Dim lvg As LVGROUP
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_FOOTER
        .pszFooter = StrPtr(sNew)
        .cchFooter = Len(sNew) + 1
    End With
    GroupUpdateFooter = CLng(SendMessage(hWnd, LVM_SETGROUPINFO, lid, ByVal VarPtr(lvg)))
    
    End Function
    
    Private Function GroupUpdateAllFooters(hWnd As LongPtr) As Long
    Dim lvg As LVGROUP
    Dim i As Long
    Dim ci As Long
    Dim sn As String
    
    For i = 0 To UBound(lGrpIDs())
    '    If lGrpIDs(i) <> 0 Then
            lvg.Mask = LVGF_ITEMS Or LVGF_STATE
            lvg.cbSize = LenB(lvg)
            Call SendMessage(hWnd, LVM_GETGROUPINFO, lGrpIDs(i), lvg)
            ci = lvg.cItems
            
            If ci = 1 Then
                sn = "1 " & mItemStr & "."
    
            Else
                sn = CStr(ci) & " " & mItemsStr & "."
    
            End If
            
            If (m_GroupSubset > 0) Then
                With lvg
                
                    If ci > m_GroupSubset Then
                        .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
                        .StateMask = .StateMask Or LVGS_SUBSETED
                        .State = .State Or LVGS_SUBSETED
                        .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
                        .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
                    Else
                        'Clear; we don't want a Show More link if there is no more
                        .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
                        .StateMask = .StateMask Or LVGS_SUBSETED
                        .State = .State And Not LVGS_SUBSETED
                        .pszSubsetTitle = StrPtr("")
                        .cchSubsetTitle = 0&
                    End If
                End With
                Call SendMessage(hWnd, LVM_SETGROUPINFO, lGrpIDs(i), ByVal VarPtr(lvg))
    
            End If
            Call GroupUpdateFooter(hWnd, lGrpIDs(i), sn)
    '    End If
    Next i
    End Function
    
    Private Function GroupUpdateSubsetText(hWnd As LongPtr) As Long
    If m_GroupMode = SBGB_None Then Exit Function
    If m_GroupSubset = 0 Then Exit Function
    
    Dim lvg As LVGROUP
    Dim i As Long
    
    For i = 0 To UBound(lGrpIDs())
        lvg.cbSize = LenB(lvg)
        lvg.Mask = LVGF_SUBSET Or LVGF_SUBSETITEMS
        lvg.pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
        lvg.cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        SendMessageW hWnd, LVM_SETGROUPINFO, lGrpIDs(i), ByVal VarPtr(lvg)
    Next i
    End Function
    
    Private Function GroupGetIDForAlpha(ByVal sz As String) As Long
    'THIS IS ONLY SEMI-GENERIC
    'This project uses group by alpha 0-9, A-H, etc with standard group ids 100, 101, etc
    Dim cc As String
    If sz = "" Then Exit Function
    cc = Left$(sz, 1)
    cc = LCase$(cc)
    Dim lc As Integer
    lc = Asc(cc)
    Select Case lc
        Case 48 To 57 '0-9
            GroupGetIDForAlpha = 100
        Case 97 To 104 'a-h
            GroupGetIDForAlpha = 101
        Case 105 To 112 'i-p
            GroupGetIDForAlpha = 102
        Case 113 To 122 'q-z
            GroupGetIDForAlpha = 103
        Case Else
            GroupGetIDForAlpha = 104
    End Select
    
    End Function
    
    Private Function GroupGetIDForDate(uDate As Date, iCat As Integer) As Long
    'will also increment counter
    Dim cHours() As LongLong
    Dim i As Long
    Dim k As Long
    k = 101
    Select Case iCat
        Case 0
            ReDim cHours(UBound(arGroupsDates) - 1)
            For i = 0 To (UBound(arGroupsDates) - 1)
                'last group is always all others
                cHours(i) = CLngLng(Left$(arGroupsDates(i), InStr(arGroupsDates(i), ";") - 1))
            Next i
        Case 1
            ReDim cHours(UBound(arGroupsDatesC) - 1)
            For i = 0 To (UBound(arGroupsDatesC) - 1)
                'last group is always all others
                cHours(i) = CLngLng(Left$(arGroupsDatesC(i), InStr(arGroupsDatesC(i), ";") - 1))
            Next i
        Case 2
            ReDim cHours(UBound(arGroupsDatesA) - 1)
            For i = 0 To (UBound(arGroupsDatesA) - 1)
                'last group is always all others
                cHours(i) = CLngLng(Left$(arGroupsDatesA(i), InStr(arGroupsDatesA(i), ";") - 1))
            Next i
    End Select
    
    For i = 0 To UBound(cHours)
        If CCur(DateDiff("h", uDate, Now)) < cHours(i) Then
           GroupGetIDForDate = k + i
            Exit Function
        End If
    Next i
    
    GroupGetIDForDate = k + UBound(cHours) + 1
        
    End Function
    
    Private Function GroupGetIDForSize(ByVal crSize As LongLong) As Long
    Dim lb As LongLong, ub As LongLong
    Dim i As Long, j As Long, k As Long
    Dim nGrp As Long
    nGrp = (UBound(arGroupsSize) + 1) / 2
    k = -1
    For i = 0 To UBound(arGroupsSize) Step 2
        lb = CLngLng(arGroupsSize(i))
        ub = CLngLng(arGroupsSize(i + 1))
        
        If (ub = -1) Then
            k = nGrp - 1
            Exit For
        End If
        
        If (crSize >= lb) And (crSize <= ub) Then
            k = j
            Exit For
        End If
        j = j + 1
    Next i
    
    GroupGetIDForSize = 101 + k
    
    End Function
    
    Private Function GroupGetIDForType(sf As String, Optional lIdx As Long = -1&) As Long
    'allows maintaing group id records for group sets with an arbitrary number of variably named groups
    Dim sType As String
    Dim i As Long, k As Long
    sType = sf
    If gidType(0).sEntry = "" Then
        gidType(0).sEntry = sType
        gidType(0).lGrpID = 101
        GoTo finishup
    End If
    For i = 0 To UBound(gidType)
        If gidType(i).sEntry = sType Then
            GroupGetIDForType = gidType(i).lGrpID
            Exit Function
        End If
    Next i
    k = UBound(gidType) + 1
    ReDim Preserve gidType(k)
    gidType(k).sEntry = sType
    gidType(k).lGrpID = 101 + k
    finishup:
    If bGroupViewUseIconsForType Then
        If lIdx >= 0& Then
            If LVEntries(lIdx).bFolder = True Then
                If LVEntries(lIdx).bZip = True Then
                    gidType(k).dwRefData = GetFileStdIcon(GetFileNameWithExt(lIdx))
                Else
                    gidType(k).dwRefData = GetFolderStdIcon()
                End If
            Else
                gidType(k).dwRefData = GetFileStdIcon(GetFileNameWithExt(lIdx))
            End If
        End If
    End If
    GroupGetIDForType = 101 + k
    End Function
    
    Private Sub GroupSetFooters_Name(hWnd As LongPtr)
    Dim lvg As LVGROUP
    Dim i As Long
    Dim ci As Long
    Dim sn As String
    
    For i = 100 To 104
        lvg.Mask = LVGF_ITEMS
        lvg.cbSize = LenB(lvg)
        Call SendMessage(hWnd, LVM_GETGROUPINFO, i, lvg)
        ci = lvg.cItems
        
        If ci = 1 Then
            sn = "1 " & mItemStr & "."
    
        Else
            sn = CStr(ci) & " " & mItemsStr & "."
    
        End If
        
        Call GroupUpdateFooter(hWnd, i, sn)
        
    Next i
    End Sub
    
    Private Sub GroupSetFooters_SizeType(hWnd As LongPtr)
    Dim lCnt As Long
    Dim lvg As LVGROUP
    Dim i As Long
    Dim ci As Long
    Dim sn As String
    
    lCnt = CLng(SendMessage(hWnd, LVM_GETGROUPCOUNT, 0, ByVal 0&))
    
    
    For i = 0 To (lCnt - 1)
        lvg.Mask = LVGF_ITEMS
        lvg.cbSize = LenB(lvg)
        Call SendMessage(hWnd, LVM_GETGROUPINFO, 101 + i, lvg)
        ci = lvg.cItems
        
        If ci = 1 Then
            sn = "1 " & mItemStr & "."
    
        Else
            sn = CStr(ci) & " " & mItemsStr & "."
    
        End If
        
        Call GroupUpdateFooter(hWnd, 101 + i, sn)
        
    Next i
    End Sub
    
    Private Sub Regroup_Size()
    'change group view to size
    Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
    InsertGroupsForSize
    ReassignGroupIDs 2
    GroupSetFooters_SizeType hLVS
    End Sub
    
    Private Sub Regroup_Alpha()
    Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
    InsertGroupsForAlpha
    ReassignGroupIDs 1
    GroupSetFooters_Name hLVS
    
    End Sub
    
    Private Sub Regroup_Type()
    Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
    InsertGroupRebuildTypes
    ReassignGroupIDs 3
    GroupSetFooters_SizeType hLVS
    
    End Sub
    
    Private Sub Regroup_Date(iCat As Integer)
    Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
    InsertGroupsForDate iCat
    ReassignGroupIDs (4 + iCat)
    GroupSetFooters_SizeType hLVS
    
    End Sub
    
    Private Sub ReassignGroupIDs(iGroupStyle As Integer)
    '0=disable
    '1=by name
    '2=by size
    Dim lCnt As Long
    Dim i As Long
    Dim lp As LongPtr
    Dim lvi As LVITEM
    lCnt = CLng(SendMessageW(hLVS, LVM_GETITEMCOUNT, 0, ByVal 0&))
    
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.iItem = i
        lvi.Mask = LVIF_GROUPID
        Select Case iGroupStyle
            Case 0
                lvi.iGroupId = 0&
            Case 1
                lvi.iGroupId = GroupGetIDForAlpha(LVEntries(lp).sName)
            Case 2
                lvi.iGroupId = GroupGetIDForSize(LVEntries(lp).cSize)
            Case 3
                lvi.iGroupId = LVEntries(lp).lTypeID
            Case 4
                lvi.iGroupId = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateM), 0)
            Case 5
                lvi.iGroupId = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateC), 1)
            Case 6
                lvi.iGroupId = GroupGetIDForDate(FileTimeToDate(LVEntries(lp).ftDateA), 2)
        End Select
        
        Call SendMessage(hLVS, LVM_SETITEMW, 0, lvi)
        
    Next i
    
    End Sub
    
    Private Sub ClearGroupData()
    lGrpCurCnt = 0
    lGrp = 100
    ReDim gidType(0)
    ReDim gidText(0)
    ReDim gidCat(0)
    nGpTxt = 0
    nGpCat = 0
    SendMessageW hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&
    lGrpACnt(0) = 0
    lGrpACnt(1) = 0
    lGrpACnt(2) = 0
    lGrpACnt(3) = 0
    lGrpACnt(4) = 0
    ReDim lGrpSCnt(0)
    ReDim lGrpTCnt(0)
    ReDim lGrpDCnt(0)
    
    End Sub
    
    Private Function GetStrForSizeGroup(n As Long) As String
    Dim sz1 As String, sz2 As String
    Dim sf1 As String
    Dim crs1 As LongLong, crs2 As LongLong
    sz1 = arGroupsSize(n * 2)
    sz2 = arGroupsSize((n * 2) + 1)
    crs1 = CCur(sz1)
    crs2 = CCur(sz2)
    If sz1 = "0" Then
        sf1 = "Smaller than " & FormatFileSizeCurExB(crs2 + 1, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb)
    Else
        sf1 = FormatFileSizeCurExB(crs1, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb) & " to " & FormatFileSizeCurExB(crs2 + 1, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb)
    End If
    If (sz2 = "-1") Or (sz2 = "0") Then
        sf1 = "Larger than " & FormatFileSizeCurExB(crs1, False, sSizeFmt_byte, False, sSizeFmt_kb, _
                                                   False, sSizeFmt_mb, False, sSizeFmt_gb, False, sSizeFmt_tb, False, sSizeFmt_pb)
    End If
    GetStrForSizeGroup = sf1
    End Function
    
Private Function FormatFileSizeCurExB(curB As LongLong, _
                                        bNoBytes As Boolean, sByteFmt As String, _
                                        bNoKilo As Boolean, sKiloFmt As String, _
                                        bNoMega As Boolean, sMegaFmt As String, _
                                        bNoGiga As Boolean, sGigaFmt As String, _
                                        bNoTera As Boolean, sTeraFmt As String, _
                                        bNoPeta As Boolean, sPetaFmt As String) As String ' bNoExa As Boolean, bNoZetta As Boolean, bNoYotta As Boolean) As String
    Dim sName As String
    Dim dblKBs As LongLong
    'cannot currently work with exabytes and above due to limit of currency data type
    On Error GoTo e0

    If (bNoKilo = True) And (bNoMega = True) And (bNoGiga = True) And (bNoTera = True) And (bNoPeta = True) Then
        sName = Format$(curB, sByteFmt)
        GoTo chkunit
    End If

    If (curB < 1024) And (bNoBytes = False) Then
        sName = Format$(curB, sByteFmt)
    Else
        dblKBs = curB / 1024^
        If ((dblKBs > 999999999999^) And (bNoPeta = False)) Or ((bNoTera = True) And (bNoGiga = True) And (bNoMega = True) And (bNoKilo = True) And (bNoBytes = True)) Then
            'file size >1TB and user-pref allows using GB unit
            dblKBs = dblKBs / 1024^ / 1024^ / 1024^ / 1024^
            sName = Format$(dblKBs, sPetaFmt)
        ElseIf ((dblKBs > 999999999^) And (bNoTera = False)) Or ((bNoGiga = True) And (bNoMega = True) And (bNoKilo = True) And (bNoBytes = True)) Then
            'file size >1TB and user-pref allows using GB unit
            dblKBs = dblKBs / 1024^ / 1024^ / 1024^
            sName = Format$(dblKBs, sTeraFmt)
        ElseIf ((dblKBs > 999999^) And (bNoGiga = False)) Or ((bNoMega = True) And (bNoKilo = True) And (bNoBytes = True)) Then
            'file size >1GB and user-pref allows using GB unit
            dblKBs = dblKBs / 1024^ / 1024^
            sName = Format$(dblKBs, sGigaFmt)
        ElseIf ((dblKBs > 999^) And (bNoMega = False)) Or ((bNoKilo = True) And (bNoBytes = True)) Then
            dblKBs = dblKBs / 1024^
            sName = Format$(dblKBs, sMegaFmt)
        ElseIf (bNoKilo = False) Then
            sName = Format$(dblKBs, sKiloFmt)
        Else
            sName = Format$(curB, sByteFmt)
        End If
    End If

    chkunit:

        FormatFileSizeCurExB = sName

    On Error GoTo 0
    Exit Function

    e0:
    DebugAppend "FormatFileSizeCurExB(" & CStr(curB) & ").Error->" & Err.Description & " (" & Err.Number & ")"
    FormatFileSizeCurExB = vbNullString
End Function
    
    Private Sub SetGroupModeByCol(lp As Long)
    Select Case lp
        Case lDefColIdx(0): SetGroupMode SBGB_Name
        Case lDefColIdx(1): SetGroupMode SBGB_Size
        Case lDefColIdx(2): SetGroupMode SBGB_Type
        Case lDefColIdx(3): SetGroupMode SBGB_DateModified
        Case lDefColIdx(4): SetGroupMode SBGB_DateCreated
        Case lDefColIdx(5): SetGroupMode SBGB_DateAccessed
        
        Case Else: SetGroupMode SBGB_Extended
    End Select
    bCatGrpActive = False
    End Sub
    Private Sub SetGroupMode(Index As ShellBrowseGroupBy)
    
    On Error GoTo e0
    Dim lCt As Long
    Dim bFlgRl As Boolean
    lCt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0, ByVal 0&)) 'only want to update group with static sets
                                                           'if a search hasn't been started yet
    
    DebugAppend "SetGroupMode " & Index & "|" & m_GroupMode & ",ct=" & lCt
    If (Index <> SBGB_None) Then
        If (mDispParAndIndt = True) Then
            If (bShowParentItemsInAllViews = False) Then
                RemoveParentsFromLV
            End If
        End If
    End If
    
            
    If Index = SBGB_Categorizer Then
        If bFolderHasCat = False Then Exit Sub
        If bCatGrpActive = False Then
            Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
            GroupByCatInit
            GroupByCatInsertGroups
            GroupByCatSetItems
            GroupUpdateAllFooters hLVS
            m_GroupMode = SBGB_Categorizer
            bCatGrpActive = True
            Exit Sub
        End If
    End If
    If (m_GroupMode <> Index) Or (Index = SBGB_Extended) Then
        bCatGrpActive = False
        If Index > 0 Then
            If bGV = False Then
                DebugAppend "SetGroupMode::Enable GroupView"
                SendMessage hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&
                bFlgRl = True
                bGV = True
            End If
        End If
        If (Index > 0) And (m_GroupMode = 0) Then
            LVReadAllData
        End If
        m_GroupMode = Index
        ReDim lGrpIDs(0&)
        nGrpIDs = 0&
        If nLinks > 0 Then
            Dim L As Long, m As Long
            For L = 0 To UBound(hLinks)
                DestroyWindow hLinks(L)
            Next L
            For L = 0 To UBound(LVEntries)
                If UBound(LVEntries(L).LinkCols) > 0 Then
                    For m = 0 To UBound(LVEntries(L).LinkCols)
                        LVEntries(L).LinkCols(m).hLink = 0&
                        LVEntries(L).LinkCols(m).sLink = ""
                    Next m
                End If
                LVEntries(L).nLinkCols = 0
            Next L
            nLinks = 0
        End If
    
        Select Case Index
            Case 0
                bGV = False
                m_GroupMode = 0
                GroupDisableGroupView hLVS
    
            Case 1: Regroup_Alpha
            Case 2: Regroup_Size
            Case 3: If lCt Then Regroup_Type
            Case 4: If lCt Then Regroup_Date (0)
            Case 5: If lCt Then Regroup_Date (1)
            Case 6: If lCt Then Regroup_Date (2)
            Case 7
                If lCt Then
                    Call SendMessage(hLVS, LVM_REMOVEALLGROUPS, 0, ByVal 0&)
                    GroupByTextInit lGrpCol
                    GroupByTextInsertGroups
                    GroupByTextSetItems
                    GroupUpdateAllFooters hLVS
                End If
        End Select
        Call SendMessage(hLVS, LVM_SETGROUPSUBSETCOUNT, 0&, ByVal m_GroupSubset)
        If m_GroupSubset > 0& Then
            GroupUpdateAllFooters hLVS
        End If
        RedrawList
    End If
    If bFlgRl Then
        'Just switched into GroupMode. If we're also in SmallIcon view, we need to refresh
        If (m_ViewMode = SB_VIEW_SMALLICON) Then
            bInGVSI = True
            SendMessage hLVS, LVM_SETCOLUMNWIDTH, -1&, ByVal CLng(cxSmallIconColumnWidth * m_ScaleX)
            RefreshView
        End If
    End If
    If Index = SBGB_None Then
        If (m_ViewMode = SB_VIEW_SMALLICON) Then
            ExpandNamesEx
            SendMessage hLVS, LVM_ARRANGE, LVA_ALIGNLEFT, ByVal 0&
        End If
    End If
    Exit Sub
    e0:
        DebugAppend "SetGroupMode->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub InsertGroupRebuildTypes()
    Dim i As Long
    For i = 0 To UBound(gidType)
        gidType(i).bInserted = False
        InsertGroupForType gidType(i).sEntry
    Next i
    End Sub
    
    Private Sub InsertGroupForType(sTypeName As String)
    Dim lvg As LVGROUP
    Dim nGrp As Long
    Dim gi As LVGROUPIDS
    Dim i As Long
    Dim sDefFoot As String
    sDefFoot = "0 " & mFilesStr & "."
    
    On Error GoTo e0
    nGrp = UBound(gidType)
    ReDim Preserve lGrpTCnt(nGrp)
    i = GroupGetIDForType(sTypeName)
    gi = gidType(i - 101)
    If gi.bInserted Then Exit Sub
    DebugAppend "InsertGroupForType->New type add: " & sTypeName & ",id=" & i & ",gid=" & i - 101, 2
    
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = i
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        If (bGroupViewUseIconsForType = True) And (bUsedHPFforCD = False) Then
            .Mask = .Mask Or LVGF_TITLEIMAGE
            .iTitleImage = gi.dwRefData
        End If
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(gi.sEntry) + 1
        .pszHeader = StrPtr(gi.sEntry)
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
    
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
    
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg))
        If lGrpIDs(0) = 0 Then
            lGrpIDs(0) = .iGroupId
        Else
            ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
            lGrpIDs(UBound(lGrpIDs)) = .iGroupId
        End If
        gidType(i - 101).bInserted = True
    End With
    
    If bGV = False Then
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
        
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "ucShellBrowse.InsertGroupsForType.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Sub
    
    Private Sub InsertGroupsForSize()
    Dim lvg() As LVGROUP
    Dim nGrp As Long
    Dim i As Long
    Dim sHdr() As String
    Dim sDefFoot As String
    sDefFoot = "0 " & mFilesStr & "."
    
    On Error GoTo e0
    
    nGrp = (UBound(arGroupsSize) + 1) / 2
    If nGrp < 1 Then
        DebugAppend "InsertGroupsForSize::Error with group sizes"
        Exit Sub
    End If
    ReDim sHdr(nGrp - 1)
    ReDim lvg(nGrp - 1)
    ReDim lGrpSCnt(nGrp)
    For i = 0 To UBound(lvg)
        sHdr(i) = GetStrForSizeGroup(i)
        With lvg(i)
            .cbSize = LenB(lvg(i))
            .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
            .iGroupId = 101 + i
            .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
            .StateMask = LVGS_COLLAPSIBLE
            .State = LVGS_COLLAPSIBLE
            If (m_InsColp) Then
                .StateMask = .StateMask Or LVGS_COLLAPSED
                .State = .State Or LVGS_COLLAPSED
            End If
    
            .cchHeader = Len(sHdr(i)) + 1
            .pszHeader = StrPtr(sHdr(i))
            .cchFooter = Len(sDefFoot) + 1
            .pszFooter = StrPtr(sDefFoot)
        
            If (m_GroupSubset > 0) Then
                .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
                .StateMask = .StateMask Or LVGS_SUBSETED
                .State = .State Or LVGS_SUBSETED
                .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
                .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
            End If
            
            Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(i)))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
        End With
    Next i
    If bGV = False Then
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
        
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "ucShellBrowse.InsertGroupsForSize.Error->" & Err.Description & " (" & Err.Number & ")"
    End Sub
    
    Private Sub InsertGroupsForDate(iCat As Integer)
    Dim lvg() As LVGROUP
    Dim nGrp As Long
    Dim i As Long
    Dim sHdr() As String
    Dim cHours() As Currency
    Dim sDefFoot As String
    Dim arGroups() As String
    
    sDefFoot = "0 " & mFilesStr & "."
    
    On Error GoTo e0
    Select Case iCat
        Case 0
            arGroups = arGroupsDates
        Case 1
            arGroups = arGroupsDatesC
        Case 2
            arGroups = arGroupsDatesA
    End Select
    
    nGrp = UBound(arGroups)
    If nGrp < 1 Then
        DebugAppend "InsertGroupsForSize::Error with group dates"
        Exit Sub
    End If
    ReDim sHdr(nGrp)
    ReDim cHours(nGrp)
    ReDim lvg(nGrp)
    ReDim lGrpDCnt(nGrp)
    For i = 0 To UBound(arGroups)
        cHours(i) = CCur(Left$(arGroups(i), InStr(arGroups(i), ";") - 1))
        sHdr(i) = Mid$(arGroups(i), InStr(arGroups(i), ";") + 1)
    Next i
        
    For i = 0 To UBound(lvg)
        With lvg(i)
            .cbSize = LenB(lvg(i))
            .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
            .iGroupId = 101 + i
            .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
            .StateMask = LVGS_COLLAPSIBLE
            .State = LVGS_COLLAPSIBLE
            If (m_InsColp) Then
                .StateMask = .StateMask Or LVGS_COLLAPSED
                .State = .State Or LVGS_COLLAPSED
            End If
            .cchHeader = Len(sHdr(i)) + 1
            .pszHeader = StrPtr(sHdr(i))
            .cchFooter = Len(sDefFoot) + 1
            .pszFooter = StrPtr(sDefFoot)
        
            If (m_GroupSubset > 0) Then
                .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
                .StateMask = .StateMask Or LVGS_SUBSETED
                .State = .State Or LVGS_SUBSETED
                .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
                .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
            End If
        
            Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(i)))
                If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
        End With
    Next i
    If bGV = False Then
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
        
    On Error GoTo 0
    Exit Sub
    
    e0:
    DebugAppend "ucShellBrowse.InsertGroupsForDateM.Error->" & Err.Description & " (" & Err.Number & ")"
    End Sub
    
    Private Sub InsertGroupsForAlpha()
    '0-9, A-H, I-P, Q-Z, Other
    Dim hr As Long
    Dim lvg() As LVGROUP
    ReDim lvg(4)
    Dim sHdr() As String
    ReDim sHdr(4)
    sHdr(0) = "0-9"
    sHdr(1) = "A-H"
    sHdr(2) = "I-P"
    sHdr(3) = "Q-Z"
    sHdr(4) = "Other"
    Dim sDefFoot As String
    sDefFoot = "0 " & mFilesStr & "."
    With lvg(0)
        .cbSize = LenB(lvg(0))
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 100
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(sHdr(0)) + 1
        .pszHeader = StrPtr(sHdr(0))
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(0)))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    With lvg(1)
        .cbSize = LenB(lvg(1))
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 101
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(sHdr(1)) + 1
        .pszHeader = StrPtr(sHdr(1))
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
       hr = CLng(SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(1))))
       DebugAppend "InsertGroupForAlpha hr=" & hr
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    With lvg(2)
        .cbSize = LenB(lvg(2))
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 102
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(sHdr(2)) + 1
        .pszHeader = StrPtr(sHdr(2))
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(2)))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    With lvg(3)
        .cbSize = LenB(lvg(3))
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 103
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(sHdr(3)) + 1
        .pszHeader = StrPtr(sHdr(3))
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        
        If (m_GroupSubset > 0) Then
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(3)))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    With lvg(4)
        .cbSize = LenB(lvg(4))
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE
        .iGroupId = 104
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .StateMask = LVGS_COLLAPSIBLE
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(sHdr(4)) + 1
        .pszHeader = StrPtr(sHdr(4))
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
        
        If (m_GroupSubset > 0) Then
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        Call SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg(4)))
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
    End With
    If bGV = False Then
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
    
    End Sub
    
    Private Function GetSubitemTextW(iItem As Long, iSubitem As Long) As String
    Dim tLVI  As LVITEMW
    Dim sText As String
    Dim lLen  As Long
      
    If hLVS Then
        sText = String$(256, 0)
        With tLVI
            .Mask = LVIF_TEXT
            .iSubItem = iSubitem
            .pszText = StrPtr(sText)
            .cchTextMax = Len(sText)
        End With
        lLen = CLng(SendMessage(hLVS, LVM_GETITEMTEXTW, iItem, tLVI))
        GetSubitemTextW = Left$(sText, lLen)
    End If
    
    End Function
    
    Private Function GroupByCatInit() As Long
    Dim i As Long
    
    ReDim gidCat(0)
    nGpCat = 0
    
    For i = 0 To UBound(LVEntries)
        LVEntries(i).iGrp = GetCatGroupId(sItemCats(LVEntries(i).lCatID).sName)
    Next i
    
    End Function
     
    Private Function GroupByTextInit(iCol As Long) As Long
    'Group by extended property
    Dim i As Long
    Dim pps As IPropertyStore
    Dim sProp As String
    Dim pidlFile As LongPtr
    Dim isi As IShellItem2
    Dim sFP As String
    Dim lptest As LongPtr
    ReDim gidText(0)
    nGpTxt = 0
    For i = 0 To UBound(LVEntries)
    '    pidlFile = ILCreateFromPathW(StrPtr(LVEntries(i).sFullPath))
    '    Call SHCreateItemFromIDList(pidlFile, IID_IShellItem2, isi)
        sProp = ""
        sFP = LVEntries(i).sFullPath
        If (LVEntries(i).sExt = ".lnk") And (Right$(sFP, 3) <> "lnk") Then
            sFP = sFP & ".lnk"
        End If
        If (LVEntries(i).sExt = ".url") And (Right$(sFP, 3) <> "url") Then
            sFP = sFP & ".url"
        End If
        SHCreateItemFromParsingName StrPtr(sFP), Nothing, IID_IShellItem2, isi
        If (isi Is Nothing) Then
            DebugAppend "GroupByTextInit->Failed to get isi"
            Dim pidlFQItem As LongPtr
            DebugAppend "GroupByTextInit->Failed parsing full path " & LVEntries(i).sFullPath & ",Trying pidls, fq=" & pidlFQCur & ",rel=" & LVEntries(i).pidlRel
            pidlFQItem = ILCombine(pidlFQCur, LVEntries(i).pidlRel)
            SHCreateItemFromIDList pidlFQItem, IID_IShellItem2, isi
            If (isi Is Nothing) Then
                DebugAppend "GroupByTextInit->Alternate isi creation failed"
            End If
            isi.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lptest
            DebugAppend "fqcur/rel item=" & LPWSTRtoStr(lptest)
            If pidlFQItem Then CoTaskMemFree pidlFQItem
        End If
        If (isi Is Nothing) = False Then
            isi.GetPropertyStore GPS_DEFAULT Or GPS_BESTEFFORT Or GPS_OPENSLOWITEM, IID_IPropertyStore, pps
            sProp = GetPropertyKeyDisplayString(pps, uColData(iCol).pKey)
            DebugAppend "GroupByTextInit::sProp=" & sProp & ",id=" & LVEntries(i).iGrp
            
        Else
            DebugAppend "GroupByTextInit::No shell item."
        End If
        If sProp = "" Then sProp = mStrUnspc
        LVEntries(i).iGrp = GetTextGroupId(sProp)
        Set pps = Nothing
        Set isi = Nothing
    Next
    
        
    End Function
    
    Private Function GroupByTextSetItems() As Long
    Dim lCnt As Long
    Dim i As Long
    Dim lp As LongPtr
    Dim lvi As LVITEM
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then
        GroupByTextSetItems = -1
        Exit Function
    End If
    
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.Mask = LVIF_GROUPID
        lvi.iItem = i
        lvi.iGroupId = LVEntries(lp).iGrp '- 101
        DebugAppend "SetGroupTextId " & LVEntries(lp).sName & "=" & LVEntries(lp).iGrp ' - 101
        Call SendMessageW(hLVS, LVM_SETITEMW, 0&, ByVal VarPtr(lvi))
    Next
    
    End Function
    
    Private Function GroupByCatSetItems() As Long
    Dim lCnt As Long
    Dim i As Long
    Dim lp As LongPtr
    Dim lvi As LVITEM
    Dim hr As Long
    lCnt = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&))
    If lCnt = 0 Then
        GroupByCatSetItems = -1
        Exit Function
    End If
    
    For i = 0 To (lCnt - 1)
        lp = GetLVItemlParam(hLVS, i)
        lvi.Mask = LVIF_GROUPID
        lvi.iItem = i
        lvi.iGroupId = LVEntries(lp).iGrp '- 101
        DebugAppend "SetGroupCatId " & LVEntries(lp).sName & "=" & LVEntries(lp).iGrp ' - 101
        hr = CLng(SendMessageW(hLVS, LVM_SETITEMW, 0&, ByVal VarPtr(lvi)))
    Next
    End Function
    
    Private Sub GroupByCatInsertGroups()
    Dim i As Long
    On Error GoTo e0
    For i = 0 To UBound(gidCat)
        GroupByCatInsertGroup gidCat(i).lGrpID
    Next i
    
    If bGV = False Then
        DebugAppend "EnableGroupView in GBCIG"
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
        
    On Error GoTo 0
    Exit Sub
    e0:
    DebugAppend "GroupByCatInsertGroups->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Sub
    
    Private Sub GroupByCatInsertGroup(id As Long)
    Dim lvg As LVGROUP
    Dim sDefFoot As String
    Dim hr As Long
    Dim i As Long
    sDefFoot = "0 " & mFilesStr & "."
    For i = 0 To UBound(gidCat)
        If gidCat(i).lGrpID = id Then Exit For
    Next
    DebugAppend "GroupByCatInsertGroup " & gidCat(i).sEntry & ", Inserted=" & CStr(gidCat(i).bInserted)
    If gidCat(i).bInserted = False Then
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE 'Or LVGF_TITLEIMAGE
        .iGroupId = gidCat(i).lGrpID
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(gidCat(i).sEntry) + 1
        .pszHeader = StrPtr(gidCat(i).sEntry)
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
    
        If (m_GroupSubset > 0) Then
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        hr = CLng(SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg)))
        DebugAppend "InsertGroup hr=" & hr & ", " & gidCat(i).sEntry & ",id=" & lvg.iGroupId
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
        gidCat(i).bInserted = True
    End With
    End If
    Exit Sub
    e0:
    DebugAppend "ucShellBrowse.InsertGroupsForCat.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Sub
    
    Private Sub GroupByTextInsertGroups()
    Dim i As Long
    
    On Error GoTo e0
    For i = 0 To UBound(gidText)
        GroupByTextInsertGroup gidText(i).lGrpID
    Next i
    
    If bGV = False Then
        DebugAppend "EnableGroupView in GBTIG"
        Call SendMessageW(hLVS, LVM_ENABLEGROUPVIEW, 1, ByVal 0&)
        RedrawWindow hLVS, 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
        UpdateWindow hLVS
        bGV = True
    End If
        
    On Error GoTo 0
    Exit Sub
    e0:
    DebugAppend "GroupByTextInsertGroups->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    End Sub
    
    Private Sub GroupByTextInsertGroup(id As Long)
    Dim lvg As LVGROUP
    Dim sDefFoot As String
    Dim hr As Long
    Dim i As Long
    sDefFoot = "0 " & mFilesStr & "."
    For i = 0 To UBound(gidText)
        If gidText(i).lGrpID = id Then Exit For
    Next
    If gidText(i).bInserted = False Then
    With lvg
        .cbSize = LenB(lvg)
        .Mask = LVGF_ALIGN Or LVGF_GROUPID Or LVGF_HEADER Or LVGF_FOOTER Or LVGF_STATE 'Or LVGF_TITLEIMAGE
        .iGroupId = gidText(i).lGrpID
        .uAlign = LVGA_HEADER_LEFT Or LVGA_FOOTER_RIGHT
        .State = LVGS_COLLAPSIBLE
        If (m_InsColp) Then
            .StateMask = .StateMask Or LVGS_COLLAPSED
            .State = .State Or LVGS_COLLAPSED
        End If
        .cchHeader = Len(gidText(i).sEntry) + 1
        .pszHeader = StrPtr(gidText(i).sEntry)
        .cchFooter = Len(sDefFoot) + 1
        .pszFooter = StrPtr(sDefFoot)
    
        If (m_GroupSubset > 0) Then
            .StateMask = .StateMask Or LVGS_SUBSETED
            .State = .State Or LVGS_SUBSETED
            .Mask = .Mask Or LVGF_SUBSET Or LVGF_SUBSETITEMS
            .pszSubsetTitle = StrPtr(m_GroupSubsetLinkText)
            .cchSubsetTitle = Len(m_GroupSubsetLinkText) + 1
        End If
        
        hr = CLng(SendMessageW(hLVS, LVM_INSERTGROUP, -1, ByVal VarPtr(lvg)))
        DebugAppend "InsertGroup hr=" & hr & ", " & gidText(i).sEntry & ",id=" & lvg.iGroupId
            If lGrpIDs(0) = 0 Then
                lGrpIDs(0) = .iGroupId
            Else
                ReDim Preserve lGrpIDs(UBound(lGrpIDs) + 1)
                lGrpIDs(UBound(lGrpIDs)) = .iGroupId
            End If
        gidText(i).bInserted = True
    End With
    End If
    Exit Sub
    e0:
    DebugAppend "ucShellBrowse.InsertGroupsForType.Error->" & Err.Description & " (" & Err.Number & ")"
    End Sub
    
    Private Function GetTextGroupId(sVal As String) As Long
    Dim i As Long
    For i = 0 To UBound(gidText)
        If gidText(i).sEntry = sVal Then
            GetTextGroupId = gidText(i).lGrpID
            Exit Function
        End If
    Next
    'Not found; insert
    ReDim Preserve gidText(nGpTxt)
    DebugAppend "AddTextGroup " & sVal
    
    gidText(nGpTxt).sEntry = sVal
    gidText(nGpTxt).lGrpID = 101 + nGpTxt
    GetTextGroupId = gidText(nGpTxt).lGrpID
    nGpTxt = nGpTxt + 1
    
    End Function
    
    Private Function GetCatGroupId(sVal As String) As Long
    Dim i As Long
    For i = 0 To UBound(gidCat)
        If gidCat(i).sEntry = sVal Then
            GetCatGroupId = gidCat(i).lGrpID
            Exit Function
        End If
    Next
    'Not found; insert
    ReDim Preserve gidCat(nGpCat)
    DebugAppend "AddCatGroup " & sVal
    
    gidCat(nGpCat).sEntry = sVal
    gidCat(nGpCat).lGrpID = 101 + nGpCat
    GetCatGroupId = gidCat(nGpCat).lGrpID
    nGpCat = nGpCat + 1
    
    End Function
    
    Private Function GroupFindFolderColumn() As Long
    Dim i As Long
    Dim lp As LongPtr
    Dim lColCnt As Long
    lColCnt = Header_GetItemCount(hLVSHdr)
    GroupFindFolderColumn = -1&
    For i = 0 To lColCnt - 1
        lp = GetHDItemlParam(hLVSHdr, i)
        If uColData(lp).szSystemName = szAutoGroupSearchCat Then
            GroupFindFolderColumn = CLng(lp)
            Exit Function
        End If
    Next i
    End Function
    Private Function IsItemInCollapsedGroup(hLV As LongPtr, nItem As Long) As Boolean
    Dim lvi As LVITEM
    Dim hrg As Long
    
    lvi.iItem = nItem
    lvi.Mask = LVIF_GROUPID
    SendMessage hLV, LVM_GETITEM, 0&, lvi
    
    hrg = CLng(SendMessage(hLV, LVM_GETGROUPSTATE, lvi.iGroupId, ByVal LVGS_COLLAPSED))
    If hrg <> 0 Then IsItemInCollapsedGroup = True
    End Function
    
    Private Function IsItemTruncated(hLV As LongPtr, nItem As Long) As Boolean
    'Determines if an item is hidden because of a group subset
    'GetItemRect by itself returns (invalid) coords for invisible items
    'Also, LVM_ISITEMVISIBLE also returns true even if item is hidden
    'So the best workaround I've found is to verify our RECT contains what
    'it's supposed to by performing a hittest. LMK if you know a better way!
    
    Dim rc As RECT
    ListView_GetItemRect hLVS, nItem, rc, LVIR_ICON
    'DebugAppend "rc=" & rc.Left & "," & rc.Right & "," & rc.Top & "," & rc.Bottom
    rc.Left = Abs(rc.Left) 'We don't care about the x-coord
    Dim lr As Long
    Dim ht As LVHITTESTINFO
    ht.PT.x = rc.Left + 1
    ht.PT.y = rc.Top + 1
    
    ListView_SubItemHitTest hLVS, ht
    'DebugAppend "ht flags=0x" & Hex$(ht.Flags)
    If ((ht.Flags And LVHT_ONITEMLABEL) = LVHT_ONITEMLABEL) Or ((ht.Flags And LVHT_ONITEMICON) = LVHT_ONITEMICON) Then
    
        If ht.iItem <> nItem Then IsItemTruncated = True
    Else
        IsItemTruncated = True
    End If
    End Function
    
    Private Function LVSwitchToLgIcon() As Long
    On Error GoTo e0
    
    DebugAppend "LVSwitchToLgIcon.Entry ViewMode=" & m_ViewMode, 11
    Dim i As Long, j As Long
    Dim nPos As Long
    Dim nOvr As Long
    Dim hIcon As LongPtr
    Dim lObjCnt As Long
    ReDim bOvrAdded(mOvrMax + 1)
    lObjCnt = -1
    On Error Resume Next
    lObjCnt = UBound(LVEntries)
    On Error GoTo e0
    Call SendMessage(hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&)
    
    Call ListView_SetImageList(hLVS, 0, LVSIL_SMALL)
    Call ListView_SetImageList(hLVS, 0, LVSIL_NORMAL)
    
    ImageList_Destroy himlLarge
    DestroyIcon hIcoLnkOvr: hIcoLnkOvr = 0&
    
    If IsComCtl6 = False Then
        himlLarge = ImageList_Create(cxyDispL, cxyDispL, ILC_COLOR32 Or ILC_MASK, 1, 1)
        Dim clbk As Long
        OleTranslateColor clrBack, 0&, clbk
        ImageList_SetBkColor himlLarge, clbk
    Else
        himlLarge = ImageList_Create(cxyDispL, cxyDispL, ILC_COLOR32 Or ILC_MASK Or ILC_HIGHQUALITYSCALE, 1, 1)
    End If
    nCthimlL = 0
    
    Call SendMessage(hLVS, LVM_SETVIEW, LV_VIEW_ICON, ByVal 0&)
    
    Dim dwStyle As Long
    dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
    If ((dwStyle And LVS_SHAREIMAGELISTS) = False) Then
        dwStyle = dwStyle And Not LVS_SHAREIMAGELISTS
    End If
    Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    
    Call ListView_SetImageList(hLVS, himlLarge, LVSIL_NORMAL)
    DebugAppend "LVSwitchToLargeIcon::Setting callbackmask...", 11
    SendMessage hLVS, LVM_SETCALLBACKMASK, LVIS_OVERLAYMASK, ByVal 0&
    DebugAppend "LVSwitchToLargeIcon::Returned from callbackmask", 11
    If lObjCnt = -1 Then Exit Function
    bHoldDI = True
    ReDim Preserve bOvrAdded(20)
    
    ImageList_GetIconSize himlLarge, himlCxActual, himlCyActual
    
    For i = 0 To lObjCnt
    
    If LVEntries(i).bDeleted Then GoTo nxt
        LVEntries(i).nIcon = I_IMAGECALLBACK 'Generated when first actually needed, see LVN_GETDISPINFO
        If (bGV = True) And (bFlagSwitch1 = True) Then
            For j = 0 To UBound(LVEntries(i).ExtColData)
                LVEntries(i).ExtColData(j).bSet = False
            Next j
        End If
        If (LVEntries(i).nOverlay) > 0 Then
    '        DebugAppend "Will set overlay " & LVEntries(i).nOverlay
            If UBound(bOvrAdded) < LVEntries(i).nOverlay Then
                ReDim Preserve bOvrAdded(LVEntries(i).nOverlay)
            End If
            If bOvrAdded(LVEntries(i).nOverlay) = False Then
                'If this file has an overlay image, make sure we've copied it from
                'the system imagelist to our thumbnail imagelist.
                DebugAppend "GetOvr"
                nOvr = -1
                On Error Resume Next
                If (LVEntries(i).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                    If himlCxActual = 0& Then
                        ImageList_GetIconSize himlLarge, himlCxActual, himlCyActual
                    End If
                    If LoadShortcutOverlay(himlCxActual) Then
                        Dim hBmpOvr As LongPtr
                        hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                        nPos = ImageList_Add(himlLarge, hBmpOvr, 0&)
                        DeleteObject hBmpOvr
                        If nPos <> -1& Then
                            ImageList_SetOverlayImage himlLarge, nPos, LVEntries(i).nOverlay
                            bOvrAdded(LVEntries(i).nOverlay) = True
                            GoTo skipovr
                        Else
                            GoTo sysimlovr
                        End If
                    End If
                End If
    sysimlovr:
                imlSysJM.GetOverlayImage LVEntries(i).nOverlay, nOvr
                If nOvr >= 0 Then
                    imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                    nPos = ImageList_AddIcon(himlLarge, hIcon)
                    DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(i).nOverlay
                    Call DestroyIcon(hIcon)
                    ImageList_SetOverlayImage himlLarge, nPos, LVEntries(i).nOverlay
                    bOvrAdded(LVEntries(i).nOverlay) = True
                End If
    skipovr:
    '            DebugAppend "ShowThumbsAPI::Overlay error, item=" & LVEntries(i).sName & ",ovr=" & LVEntries(i).nOverlay
    '            Err.Clear
    '            Err.Number = 0
                On Error GoTo e0
            End If
        End If
        If InsertListItem(LVEntries(i)) < 0& Then
            DebugAppend "LVSwitchToLgIcon InsertListItem.Error"
        End If
    nxt:
    Next i
    DebugAppend "LVSwitchToLgIcon Inserted " & i & " items, ViewMode=" & m_ViewMode, 11
    bHoldDI = False
    If m_cbSort = 0& Then
        If mUseAdvancedSort Then
            m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
        Else
            m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
        End If
    End If
    mLastSortInfo = eSortName
    Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
    
    Dim lFCt As LongPtr
    lFCt = SendMessage(hLVS, LVM_GETITEMCOUNT, 0&, ByVal 0&)
    If lFCt > 0& Then
        Dim lItm As LongPtr
        lItm = LVI_NOITEM
         lItm = SendMessage(hLVS, LVM_GETNEXTITEM, lItm, ByVal LVNI_VISIBLEORDER)
         If lItm = LVI_NOITEM Then
            DebugAppend "LVSwitchToLgIcon::Display item failure, reloading", 11
            RefreshView
    '    Else
    '        DebugAppend "LVSwitchToLgIcon::No display failure detected.", 11
        End If
    End If
    
    Exit Function
    e0:
        DebugAppend "LVSwitchToLgIcon.Error->" & Err.Description & " (0x" & Hex$(Err.Number) & ")", 3
    End Function
    
    Private Function SysImlCacheLookup(nFI As Long) As Long
    Dim i As Long
    For i = 0 To UBound(SysImgCache)
        If SysImgCache(i).sysimlid = nFI Then
            SysImlCacheLookup = SysImgCache(i).limlidx
            Exit Function
        End If
    Next i
    SysImlCacheLookup = -1
    End Function
    
    Private Function ManualLoadIconForLink(himlDest As LongPtr, iLink As Long, pidlFQ As LongPtr, bOnlyFolders As Boolean) As Long
    On Error GoTo e0
    
    Dim pSL As ShellLinkW
    Dim pPF As IPersistFile
    Dim sPath As String
    Dim sTar As String
    Dim sIco As String, nIco As Long
    Dim hIcoS As LongPtr, hIcoL As LongPtr
    Dim wfd As WIN32_FIND_DATAW
    Dim hr As Long
    Dim siTar As IShellItem, siSrc As IShellItem
    Dim ifTar As IShellItemImageFactory
    Dim hBmp As LongPtr
    Dim lAtr As SFGAO_Flags
    
    ManualLoadIconForLink = -1&
    
    sPath = LVEntries(iLink).sFullPath
    If Right$(sPath, 4) <> ".lnk" Then
        sPath = sPath & ".lnk"
    End If
    
    Set pSL = New ShellLinkW
    Set pPF = pSL
    pPF.Load sPath, STGM_READ
    
    sTar = String$(MAX_PATH, 0&)
    pSL.GetPath sTar, MAX_PATH, wfd, SLGP_RAWPATH
    sTar = TrimNullW(sTar)
    If sTar = "" Then
        DebugAppend "ManualLoadIconForLink::Failed to load link target.", 3
        Exit Function
    End If
    
    If bOnlyFolders = True Then
        SHCreateItemFromIDList pidlFQ, IID_IShellItem, siSrc
        If (siSrc Is Nothing) = False Then
            Dim si2 As IShellItem2
            Set si2 = siSrc
            On Error Resume Next
            si2.GetUInt32 PKEY_Link_TargetSFGAOFlags, lAtr
            Err.Clear
            On Error GoTo e0
            If lAtr = 0 Then
                siSrc.BindToHandler 0&, BHID_LinkTargetItem, IID_IShellItem, siTar
                If (siTar Is Nothing) = False Then
                    siTar.GetAttributes SFGAO_FOLDER, lAtr
                End If
            End If
            
            If (lAtr And SFGAO_FOLDER) <> SFGAO_FOLDER Then
                ManualLoadIconForLink = -2
                Exit Function
            End If
        End If
    End If
    
    sIco = String$(MAX_PATH, 0&)
    pSL.GetIconLocation sIco, MAX_PATH, nIco
    sIco = TrimNullW(sIco)
    
    If sIco <> "" Then
        DebugAppend "ManualLoadIconForLink::Loading custom source..." ', 3
        hr = SHDefExtractIconW(StrPtr(sIco), nIco, 0&, hIcoL, hIcoS, PackWords(256, 16)) 'Ask for max possible size
        If hIcoL Then
            DebugAppend "ManualLoadIconForLink::Got large hIcon" ', 3
            ManualLoadIconForLink = ImageList_AddIcon(himlDest, hIcoL)
            DestroyIcon hIcoL
            Exit Function
        End If
    Else
        DebugAppend "ManualLoadIconForLink::Falling back to target icon" ', 3
        If siSrc Is Nothing Then SHCreateItemFromIDList pidlFQ, IID_IShellItem, siSrc
        If (siSrc Is Nothing) = False Then
            If siTar Is Nothing Then siSrc.BindToHandler 0&, BHID_LinkTargetItem, IID_IShellItem, siTar
            If (siTar Is Nothing) = False Then
                Set ifTar = siTar
                Dim sztmp As SIZE, ullSize As LongLong
                sztmp.cx = cxyDispL: sztmp.cy = cxyDispL
                CopyMemory ullSize, sztmp, 8
                hr = ifTar.GetImage(ullSize, SIIGBF_ICONONLY, hBmp)
                If hr = S_OK Then
                   Dim clrMsk As Long
                   If IsComCtl6 = False Then
                       OleTranslateColor clrFore, 0&, clrMsk
                       ManualLoadIconForLink = ImageList_AddMasked(himlDest, hBmp, clrMsk)
                   Else
                       ManualLoadIconForLink = ImageList_Add(himlDest, hBmp, clrMsk)
                   End If
                   DeleteObject hBmp
                Else
                    DebugAppend "ManualLoadIconForLink::GetImage failed.", 3
                End If
            Else
                DebugAppend "ManualLoadIconForLink::Failed to bind to target item.", 3
            End If
        Else
            DebugAppend "ManualLoadIconForLink::Failed to bind to link item.", 3
        End If
    End If
    
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.ManualLoadIconForLink->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 3
    End Function
    
    Private Function LVGetThumbIdxLarge(i As Long, cxy As Long) As Long
    On Error GoTo e0
    
    If (LVEntries(i).nIcon = I_IMAGECALLBACK) Or (LVEntries(i).nFileIcon = I_IMAGECALLBACK) Then
        If LVEntries(i).nFileIcon = I_IMAGECALLBACK Then
            LVSetStdIcon i
        End If
        Dim lIdx As Long
        lIdx = SysImlCacheLookup(LVEntries(i).nFileIcon)
        If lIdx > -1 Then
            LVEntries(i).nIcon = lIdx
            LVGetThumbIdxLarge = LVEntries(i).nIcon
    '        DebugAppend "LVGetThumbIdxLarge return cache=" & lIdx
            Exit Function
        End If
        Dim nid As Long
        Dim pidlFQ As LongPtr
    '        pidlFQ = ILCombine(pidlFQCur, LVEntries(i).pidlRel)
        If pidlFQ = 0& Then
            'use alt method
            Dim sFP As String
            sFP = AddBackslash(LVEntries(i).sParentFull) & LVEntries(i).sNameParsing
    '        DebugAppend "pidlFQCur=" & pidlFQCur & ",pidlRel=" & LVEntries(i).pidlRel & ";sFP=" & sFP & ",sFullPath=" & LVEntries(i).sFullPath
            pidlFQ = ILCreateFromPathW(StrPtr(sFP))
            If pidlFQ = 0 Then
                pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(i).sFullPath))
                If pidlFQ = 0 Then
                   pidlFQ = ILCombine(pidlFQCur, LVEntries(i).pidlRel)
                End If
            End If
        End If
        If pidlFQ Then
            nid = -1&
            If nManualLinkIconLoadingMode > 0& Then
                If (LVEntries(i).dwAttrib And SFGAO_LINK) = SFGAO_LINK Then
        '           So... there's some weird glitches involving certain shortcuts to folders causing the icon loads for them
        '           and then other files to be botched, loading the default document icon, that's a truly bizarre bug I can't
        '           even remotely figure out. Somehow hitting 'Refresh', which does nothing but re-run the EXACT SAME CODE,
        '           then loads the proper icons. But to avoid the bug entirely, I wrote a function to handle links manually.
        '           The function called below loads a custom icon if present, or looks up the target item's icon if not.
                    Dim bFld As Boolean
    '                DebugAppend "LVGetThumbIdxLarge LinkBlock " & LVEntries(i).sName
                    bFld = (nManualLinkIconLoadingMode = 1)
                    nid = ManualLoadIconForLink(himlLarge, i, pidlFQ, bFld)
                End If
            End If
            If nid < 0& Then 'nid will be -1 if it wasn't a link or an error occured in ManualLoadIconForLink, -2 if it was but the OnlyFolders flag was set and it was a folder, and >=0 if link and added
    '            If (LVEntries(i).sExt = ".ico") Or (LVEntries(i).sExt = ".exe") Then 'Bug: Small icons return blank file type icon. Since there's no difference between regular and thumbnail icons, use that.
    '                nid = AddThumbView2(himlLarge, cxy, cxy, pidlFQ, LVEntries(i).pidlRel, LVEntries(i).sFullPath, False, i)
    '            Else
    '                DebugAppend "pidlFQ=" & pidlFQ & ",pidlFQCur=" & pidlFQCur
                    nid = AddToHIMLNoDLLForIco(himlLarge, Nothing, pidlFQ, cxy, cxy, SIIGBF_ICONONLY)
    '            End If
                'Using a cache of system image list number pegged to index in imlLarge lets us only load a given file
                'type icon once, instead of a unique copy for each item. Major performance and memory benefit.
                ReDim Preserve SysImgCache(nSysImgCache)
                SysImgCache(nSysImgCache).sysimlid = LVEntries(i).nFileIcon
                SysImgCache(nSysImgCache).limlidx = nid
                nSysImgCache = nSysImgCache + 1
            End If
    
    '         DebugAppend "id=" & i & ",ico=" & nid, 11
            LVEntries(i).nIcon = nid
            LVGetThumbIdxLarge = nid
            nCthimlL = nCthimlL + 1
        Else
            DebugAppend "No pidl for " & i & "; rel=" & LVEntries(i).pidlRel & ",cur=" & pidlFQCur, 11
        End If
            
    Else
        LVGetThumbIdxLarge = LVEntries(i).nIcon
    '    DebugAppend "LVGetThumbIdxLarge return already set=" & LVEntries(i).nIcon
    End If
    
    If (LVEntries(i).nOverlay) > 0 Then
        Dim nOvr As Long
        Dim hIcon As LongPtr
        Dim nPos As Long
        Dim vcx As Long, vcy As Long
        ImageList_GetIconSize himlLarge, vcx, vcy
        
    '        DebugAppend "Will set overlay " & LVEntries(i).nOverlay
        If UBound(bOvrAdded) < LVEntries(i).nOverlay Then
            ReDim Preserve bOvrAdded(LVEntries(i).nOverlay)
        End If
        If bOvrAdded(LVEntries(i).nOverlay) = False Then
            'If this file has an overlay image, make sure we've copied it from
            'the system imagelist to our thumbnail imagelist.
            nOvr = -1
            On Error Resume Next
            If (LVEntries(i).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                If himlCxActual = 0& Then
                    ImageList_GetIconSize himlLarge, himlCxActual, himlCyActual
                End If
                If LoadShortcutOverlay(himlCxActual) Then
                    Dim hBmpOvr As LongPtr
                    hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                    nPos = ImageList_Add(himlLarge, hBmpOvr, 0&)
                    DeleteObject hBmpOvr
                    If nPos <> -1& Then
                        ImageList_SetOverlayImage himlLarge, nPos, LVEntries(i).nOverlay
                        bOvrAdded(LVEntries(i).nOverlay) = True
                        GoTo skipovr
                    Else
                        GoTo sysimlovr
                    End If
                End If
            End If
    sysimlovr:
            imlSysJM.GetOverlayImage LVEntries(i).nOverlay, nOvr
            If nOvr >= 0 Then
                imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                nPos = ImageList_AddIcon(himlLarge, hIcon)
    '            DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(i).nOverlay
                Call DestroyIcon(hIcon)
                ImageList_SetOverlayImage himlLarge, nPos, LVEntries(i).nOverlay
                bOvrAdded(LVEntries(i).nOverlay) = True
            End If
    skipovr:
        On Error GoTo e0
        End If
    End If
    
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.LVGetThumbIdxLarge->Error: " & Err.Description & ", 0x" & Hex$(Err.Number), 11
    End Function
    
    Private Function LVGetThumbIdx(i As Long, himl As LongPtr, cxy As Long) As Long
    
    If LVEntries(i).nIcon = I_IMAGECALLBACK Then
        Dim pidlFQ As LongPtr
        Dim hr As Long
        pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(i).sFullPath))
        If pidlFQ = 0& Then
            'use alt method
        pidlFQ = ILCombine(pidlFQCur, LVEntries(i).pidlRel)
        End If
    '    DebugAppend "Starting AddThumbView for " & LVEntries(i).sNameFull & ",pidlFQ=" & pidlFQ & ",pidlRel=" & LVEntries(i).pidlRel & ",sFP=" & LVEntries(i).sFullPath & ",bF=" & LVEntries(i).bFolder, 11
    '    hr = -1&
    '    If nManualLinkIconLoadingMode > 0& Then
    '        If (LVEntries(i).dwAttrib And SFGAO_LINK) = SFGAO_LINK Then
    '            Dim bFld As Boolean
    '            bFld = (nManualLinkIconLoadingMode = 1)
    '            hr = ManualLoadIconForLink(himl_Thumb, i, pidlFQ, bFld)
    '        End If
    '    End If
    '    If hr < 0& Then
             If mUsingCustomIcons Then
                Dim hImg As LongPtr, hCIco As LongPtr, bFree As Boolean
                hImg = -1: hCIco = -1
                RaiseEvent QueryCustomIcon(LVEntries(i).sNameFull, LVEntries(i).sParentFull, LVEntries(i).sFullPath, LVEntries(i).bFolder, pidlFQ, mcxyCustom * m_ScaleX, hImg, hCIco, bFree)
                If hCIco > 0& Then
                    hr = AddThumbCustom(himl_Thumb, hCIco, True, bFree)
                ElseIf hImg > 0& Then
                    hr = AddThumbCustom(himl_Thumb, hImg, False, bFree)
                End If
                If hr < 0& Then GoTo atv
            Else
    atv:
                hr = AddThumbView2(himl, cxy, cxy, pidlFQ, LVEntries(i).pidlRel, LVEntries(i).sFullPath, LVEntries(i).bFolder, i)
            End If
    '    End If
    '    DebugAppend "AddThumbView2(ASYNC) hr=" & hr
        Call CoTaskMemFree(pidlFQ)
        LVEntries(i).nIcon = hr
        LVGetThumbIdx = hr
    Else
        LVGetThumbIdx = LVEntries(i).nIcon
    End If
    If (LVEntries(i).nOverlay) > 0 Then
        Dim nOvr As Long
        Dim hIcon As LongPtr
        Dim nPos As Long
        Dim vcx As Long, vcy As Long
        ImageList_GetIconSize himl_Thumb, vcx, vcy
        
    '        DebugAppend "Will set overlay " & LVEntries(i).nOverlay
        If UBound(bOvrAdded) < LVEntries(i).nOverlay Then
            ReDim Preserve bOvrAdded(LVEntries(i).nOverlay)
        End If
        If bOvrAdded(LVEntries(i).nOverlay) = False Then
            'If this file has an overlay image, make sure we've copied it from
            'the system imagelist to our thumbnail imagelist.
            If mUsingCustomIcons Then
                Dim hBmpO As LongPtr, hIcoO As LongPtr, bRls As Boolean
                hBmpO = -1&: hIcoO = -1&
                RaiseEvent QueryCustomIconOverlay(LVEntries(i).nOverlay, mcxyCustom * m_ScaleX, hBmpO, hIcoO, bRls)
                If hIcoO <> -1& Then
                    nPos = ImageList_AddIcon(himl_Thumb, hIcoO)
                    If bRls Then DestroyIcon hIcoO
                ElseIf hBmpO <> -1& Then
                    nPos = AddThumbCustom(himl_Thumb, hBmpO, False, bRls)
                Else
                    GoTo getsysovr
                End If
                ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                bOvrAdded(LVEntries(i).nOverlay) = True
            Else
    getsysovr:
                nOvr = -1
                On Error Resume Next
                If (LVEntries(i).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                    If himlCxActual = 0& Then
                        ImageList_GetIconSize himl_Thumb, himlCxActual, himlCyActual
                    End If
                    If LoadShortcutOverlay(himlCxActual) Then
                        Dim hBmpOvr As LongPtr
                        hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                        nPos = ImageList_Add(himl_Thumb, hBmpOvr, 0&)
                        DeleteObject hBmpOvr
                        If nPos <> -1& Then
                            ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                            bOvrAdded(LVEntries(i).nOverlay) = True
                            GoTo skipovr
                        Else
                            GoTo sysimlovr
                        End If
                    End If
                End If
    sysimlovr:
                imlSysJM.GetOverlayImage LVEntries(i).nOverlay, nOvr
                If nOvr >= 0 Then
                    imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                    nPos = ImageList_AddIcon(himl_Thumb, hIcon)
    '                DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(i).nOverlay
                    Call DestroyIcon(hIcon)
                    ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                    bOvrAdded(LVEntries(i).nOverlay) = True
                End If
            End If
    skipovr:
    '            DebugAppend "ShowThumbsAPI::Overlay error, item=" & LVEntries(i).sName & ",ovr=" & LVEntries(i).nOverlay
    '            Err.Clear
    '            Err.Number = 0
            On Error GoTo e0
        End If
    End If
    
    Exit Function
    e0:
    DebugAppend "LVGetThumbIdx.Error->" & Err.Description & "," & Err.Number
    End Function
    
    Private Sub ShowThumbsAPI()
    Dim lObjCnt As Long
    Dim pidlFQ As LongPtr, pidlRel As LongPtr
    Dim xt1 As Long, xt2 As Long
    Dim lLVCnt As Long
    Dim hr As Long
    Dim bDrawLock As Boolean
    Dim dwStyle As Long
    Dim i As Long
    Dim hIcon As LongPtr
    Dim nOvr As Long
    Dim nPos As Long
    ReDim bOvrAdded(mOvrMax + 1)
    
    On Error GoTo e0
    
    DebugAppend "ShowThumbsAPI.entry->Size=" & m_ThumbCXY
    
    xt1 = GetTickCount()
    
    bThumbsActive = True
    
    Call SendMessage(hLVS, LVM_DELETEALLITEMS, 0&, ByVal 0&)
    
    lLVCnt = 0
    
    DebugAppend "Clear imagelists"
    Call ListView_SetImageList(hLVS, 0, LVSIL_SMALL)
    Call ListView_SetImageList(hLVS, 0, LVSIL_NORMAL)
     
    lObjCnt = UBound(LVEntries)
    
    
    
    If himl_Thumb Then Call ImageList_Destroy(himl_Thumb)
    ImageList_Destroy himlLarge
    DestroyIcon hIcoLnkOvr: hIcoLnkOvr = 0&
    
    If IsComCtl6 = False Then
        If mUsingCustomIcons Then
            If mcxyCustom < 16 Then mcxyCustom = 48
            himl_Thumb = ImageList_Create(mcxyCustom * m_ScaleX, mcxyCustom * m_ScaleX, ILC_COLOR32 Or ILC_MASK, lObjCnt, 0)
        Else
            himl_Thumb = ImageList_Create(m_ThumbCXY, m_ThumbCXY, ILC_COLOR32 Or ILC_MASK, lObjCnt, 0)
        End If
        Dim clbk As Long
        OleTranslateColor clrBack, 0&, clbk
        ImageList_SetBkColor himl_Thumb, clbk
    Else
        If mUsingCustomIcons Then
            If mcxyCustom < 16 Then mcxyCustom = 48
            himl_Thumb = ImageList_Create(mcxyCustom * m_ScaleX, mcxyCustom * m_ScaleX, ILC_COLOR32 Or ILC_MASK Or ILC_HIGHQUALITYSCALE, lObjCnt, 0)
        Else
            himl_Thumb = ImageList_Create(m_ThumbCXY, m_ThumbCXY, ILC_COLOR32 Or ILC_MASK Or ILC_HIGHQUALITYSCALE, lObjCnt, 0)
        End If
    End If
    
    ImageList_GetIconSize himl_Thumb, himlCxActual, himlCyActual
    
    Call SendMessage(hLVS, LVM_SETVIEW, LV_VIEW_ICON, ByVal 0&)
    
    If Not mUsingCustomIcons Then
    Dim dwSpc As Long, dwOldSpc As Long
    dwSpc = CLng(SendMessage(hLVS, LVM_GETITEMSPACING, -1, ByVal 0&))
    DebugAppend "x=" & LoWord(dwSpc) & ",y=" & HiWord(dwSpc)
        dwOldSpc = CLng(SendMessage(hLVS, LVM_SETICONSPACING, 0&, ByVal PackWords(m_ThumbCXY + 6, m_ThumbCXY + (LVFontHeight() * 3))))
    End If
    DebugAppend "Old y=" & HiWord(dwOldSpc)
    'DebugAppend ""
    
    dwStyle = CLng(GetWindowLong(hLVS, GWL_STYLE))
    'dwStyle = dwStyle Or LVS_NOLABELWRAP
    If ((dwStyle And LVS_SHAREIMAGELISTS) = False) Then
        dwStyle = dwStyle And Not LVS_SHAREIMAGELISTS
    End If
    Call SetWindowLong(hLVS, GWL_STYLE, dwStyle)
    
    DebugAppend "Set thumb imagelist"
    Call ListView_SetImageList(hLVS, himl_Thumb, LVSIL_NORMAL)
    SendMessage hLVS, LVM_SETCALLBACKMASK, LVIS_OVERLAYMASK, ByVal 0&
    
    If m_ThumbExt Then
        UpdateStatus mProcExThumbStr
    Else
        UpdateStatus mProcThumbStr
    End If
    
    For i = 0 To lObjCnt
    
    If LVEntries(i).bDeleted Then GoTo nxt
        If m_ThumbPreload Then
            pidlFQ = ILCombine(pidlFQCur, LVEntries(i).pidlRel)
            If pidlFQ = 0& Then
                'use alt method
                pidlFQ = ILCreateFromPathW(StrPtr(LVEntries(i).sFullPath))
            End If
    '        DebugAppend "Starting AddThumbView for " & LVEntries(i).sNameFull
    '        hr = -1&
    '        If nManualLinkIconLoadingMode > 0& Then
    '            If (LVEntries(i).dwAttrib And SFGAO_LINK) = SFGAO_LINK Then
    '                Dim bFld As Boolean
    '                bFld = (nManualLinkIconLoadingMode = 1)
    '                hr = ManualLoadIconForLink(himl_Thumb, i, pidlFQ, bFld)
    '            End If
    '        End If
    '        If hr < 0& Then 'nid will be -1 if it wasn't a link or an error occured in ManualLoadIconForLink, -2 if it was but the OnlyFolders flag was set and it was a folder, and >=0 if link and added
                If mUsingCustomIcons Then
                    Dim hImg As LongPtr, hCIco As LongPtr, bFree As Boolean
                    hImg = -1: hCIco = -1
                    RaiseEvent QueryCustomIcon(LVEntries(i).sNameFull, LVEntries(i).sParentFull, LVEntries(i).sFullPath, LVEntries(i).bFolder, pidlFQ, mcxyCustom * m_ScaleX, hImg, hCIco, bFree)
                    If hCIco Then
                        hr = AddThumbCustom(himl_Thumb, hCIco, True, bFree)
                    ElseIf hImg Then
                        hr = AddThumbCustom(himl_Thumb, hImg, False, bFree)
                    End If
                    If hr < 0& Then GoTo atv
                Else
    atv:
                    hr = AddThumbView2(himl_Thumb, m_ThumbCXY, m_ThumbCXY, pidlFQ, LVEntries(i).pidlRel, LVEntries(i).sFullPath, LVEntries(i).bFolder, i)
                End If
    '        End If
    '        DebugAppend "AddThumbView2 for " & LVEntries(i).sNameParsing & " hr=" & hr, 11
             Call CoTaskMemFree(pidlFQ)
            LVEntries(i).nIcon = hr
        Else
    '        DebugAppend "Set I_IMAGECALLBACK " & LVEntries(i).sName
            LVEntries(i).nIcon = I_IMAGECALLBACK 'Generated when first actually needed, see LVN_GETDISPINFO
        End If
        If (LVEntries(i).nOverlay) > 0 Then
    '        DebugAppend "Will set overlay " & LVEntries(i).nOverlay
            If UBound(bOvrAdded) < LVEntries(i).nOverlay Then
                ReDim Preserve bOvrAdded(LVEntries(i).nOverlay)
            End If
            If bOvrAdded(LVEntries(i).nOverlay) = False Then
                'If this file has an overlay image, make sure we've copied it from
                'the system imagelist to our thumbnail imagelist.
                If mUsingCustomIcons Then
                    Dim hBmpO As LongPtr, hIcoO As LongPtr, bRls As Boolean
                    hBmpO = -1&: hIcoO = -1&
                    RaiseEvent QueryCustomIconOverlay(LVEntries(i).nOverlay, mcxyCustom * m_ScaleX, hBmpO, hIcoO, bRls)
                    If hIcoO <> -1& Then
                        nPos = ImageList_AddIcon(himl_Thumb, hIcoO)
                        If bRls Then DestroyIcon hIcoO
                    ElseIf hBmpO <> -1& Then
                        nPos = AddThumbCustom(himl_Thumb, hBmpO, False, bRls)
                    Else
                        GoTo getsysovr
                    End If
                    ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                    bOvrAdded(LVEntries(i).nOverlay) = True
                Else
    getsysovr:
                    nOvr = -1
                    On Error Resume Next
                    If (LVEntries(i).nOverlay = 2) And (bUseCustomShortcutOverlay = True) Then
                        If himlCxActual = 0& Then
                            ImageList_GetIconSize himl_Thumb, himlCxActual, himlCyActual
                        End If
                        If LoadShortcutOverlay(himlCxActual) Then
                            
                            Dim hBmpOvr As LongPtr
                            hBmpOvr = GetOverlayExpanded(hIcoLnkOvr, himlCyActual)
                            nPos = ImageList_Add(himl_Thumb, hBmpOvr, 0&)
                            DeleteObject hBmpOvr
                            If nPos <> -1& Then
                                ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                                bOvrAdded(LVEntries(i).nOverlay) = True
                                GoTo skipovr
                            Else
                                GoTo sysimlovr
                            End If
                        End If
                    End If
    sysimlovr:
                    imlSysJM.GetOverlayImage LVEntries(i).nOverlay, nOvr
                    If nOvr >= 0 Then
                        imlSysJM.GetIcon nOvr, ILD_TRANSPARENT, hIcon
                        nPos = ImageList_AddIcon(himl_Thumb, hIcon)
        '                DebugAppend "nPos=" & nPos & ",hIcon=" & hIcon & ",nOvr=" & nOvr & ",idx=" & LVEntries(i).nOverlay
                        Call DestroyIcon(hIcon)
                        ImageList_SetOverlayImage himl_Thumb, nPos, LVEntries(i).nOverlay
                        bOvrAdded(LVEntries(i).nOverlay) = True
                    End If
                End If
    skipovr:
    '            DebugAppend "ShowThumbsAPI::Overlay error, item=" & LVEntries(i).sName & ",ovr=" & LVEntries(i).nOverlay
    '            Err.Clear
    '            Err.Number = 0
                On Error GoTo e0
            End If
        End If
        InsertListItem LVEntries(i)
    If m_ThumbExt Then
        UpdateStatus mThumbExStatusStr & CStr(i + 1) & mOfStr & lObjCnt
    Else
        UpdateStatus mThumbStatusStr & CStr(i + 1) & mOfStr & lObjCnt
    End If
    
    nxt:
    Next i
    
    
    If m_cbSort = 0& Then
        If mUseAdvancedSort Then
            m_cbSort = AddressOf LVSortProcAdv ' scb_SetCallbackAddr(3, 20)
        Else
            m_cbSort = AddressOf LVSortProc ' scb_SetCallbackAddr(3, 2)
        End If
    End If
    mLastSortInfo = eSortName
    Call SendMessage(hLVS, LVM_SORTITEMS, eSortName, ByVal m_cbSort)
    
    xt2 = GetTickCount()
    Dim sFinish As String
    sFinish = mThumbFinishStr
    sFinish = Replace$(sFinish, "%1", CStr(UBound(LVEntries) + 1))
    sFinish = Replace$(sFinish, "%2", CStr(Round((xt2 - xt1) / 1000, 2)))
    UpdateStatus sFinish
    
    If pidlFQ Then Call CoTaskMemFree(pidlFQ)
    If pidlRel Then Call CoTaskMemFree(pidlRel)
    
       On Error GoTo 0
       Exit Sub
    
    e0:
    
        DebugAppend "ShowThumbsAPI.Error->" & Err.Description & " (" & Err.Number & ")"
    End Sub
    
    Private Function AddThumbView2(himl_Add As LongPtr, cxUS As Long, cyUS As Long, pidlFQ As LongPtr, pidlRel As LongPtr, sFullPath As String, bIsFolder As Boolean, nEntry As Long) As Long
    'adds the thumbnail for the current file into the thumbnail imagelist
    'If Win7 or greater, IShellItemImageFactory is used
    'Earlier versions fall back to IExtractImage or the system image list
    'DebugAppend "ThumbGeneratorEntry::AddThumbView2(" & CStr(himl_Add) & ", " & CStr(cxAdd) & ", " & CStr(cyAdd) & ", " & CStr(pidlFQ) & ", " & CStr(pidlRel) & ", " & sFullPath & ", " & CStr(bIsFolder) & ")"
    Dim lIdx As Long
    Dim j As Long
    Dim pidlPar As LongPtr
    Dim isfParent As IShellFolder
    Dim nPType As ucsb_PERCEIVED
    Dim bImgFacFail As Boolean 'on thumbnail failure, set to indicate ISIIF ICONONLY should be tried
    Dim clrMsk As Long
    Dim isi As IShellItem
    Dim hThumb As LongPtr
    Dim cxAdd As Long, cyAdd As Long
    cxAdd = cxUS: cyAdd = cyUS
    'cxAdd = cxUS * m_ScaleX: cyAdd = cyUS * m_ScaleY
    Call SHCreateItemFromIDList(pidlFQ, IID_IShellItem, isi)
            
    If bIsFolder Then
        lIdx = AddToHIMLNoDLL(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_ICONONLY)
        If lIdx = -1 Then GoTo fb2
        AddThumbView2 = lIdx
        Exit Function
    End If
    '        If lIdx <> -1 Then
    '            AddThumbView2 = lIdx
    '            Exit Function
    '        End If
    '    End If
    'End If
    'If (IsWinVistaPlus = True) Then 'Major refactoring would be required to continue to support this option
    If True Then
    '    If m_ThumbExt Then 'attempt to get extended thumbnail stream
    '        Dim hThumbVid As Long
    '        nPType = FilePtypeL(sFullPath)
    '        If (nPType = PERCEIVED_TYPE_VIDEO) Or (nPType = PERCEIVED_TYPE_AUDIO) Then
    '            'Cover art in ID3 tags is supported; future Windows versions may support others
    ''            DebugAppend "vidthumb->Attempting to get video thumbnail for " & sFullPath
    '            hThumbVid = AddThumbviewVideoISI(pidlFQ, cxAdd, cyAdd)
    '        End If
    '''        If LCase$(Right$(sFullPath, 4)) = ".mp3" Then
    '''            'Album cover art in mp3 is supported.
    '''            hThumbVid = AddThumbviewVideoISI(pidlFQ, cxAdd, cyAdd)
    '''        End If
    '        If hThumbVid Then
    ''            DebugAppend "vidthumb->valid hthumb", 3
    '            If IsComCtl6 = False Then
    '                OleTranslateColor clrFore, 0&, clrMsk
    '                lIdx = ImageList_AddMasked(himl_Add, hThumbVid, clrMsk)
    ''                DebugAppend "IsComCtl6=False; lIdx=" & lIdx
    '            Else
    '                lIdx = ImageList_Add(himl_Add, hThumbVid, 0)
    ''                DebugAppend "IsComCtl6=True; lIdx=" & lIdx
    '            End If
    '            Call DeleteObject(hThumbVid)
    '            If (lIdx >= 0) And (lIdx < 999999) Then
    ''                DebugAppend "vidthumb->valid lIdx return, exiting", 3
    '                AddThumbView2 = lIdx
    '                Exit Function
    '            End If
    '        Else
    ''            DebugAppend "vidthumb->failed to get hthumb for " & sFullPath, 2
    '        End If
    '    End If
    '    DebugAppend "isifthumb->Sending DLL pidl for " & pidlFQ & "@" & CStr(himl_Add) & "," & cxAdd & "," & cyAdd
            If Len(LVEntries(nEntry).sName) > 3 Then
                If Right$(LVEntries(nEntry).sName, 4) = ".ico" Then
                    GoTo skipprov
                End If
            End If
            nPType = FilePtypeL(sFullPath)
            If nPType = PERCEIVED_TYPE_IMAGE Then GoTo skipprov
        If (m_ThumbExt = True) Or (bUseThumbProvAndCacheWhenNotExtended = True) Then
            If bExtendedThumbsLimitToMedia Or bUseThumbProvAndCacheWhenNotExtended Then
                If (bUseThumbProvAndCacheWhenNotExtended = True) And ((nPType = PERCEIVED_TYPE_VIDEO) Or (nPType = PERCEIVED_TYPE_AUDIO)) Then GoTo skipprov
                If (bExtendedThumbsLimitToMedia = True) And ((nPType <> PERCEIVED_TYPE_VIDEO) And (nPType <> PERCEIVED_TYPE_AUDIO)) Then GoTo skipprov
            End If
                
            On Error GoTo skipprov
            If (pThumbFact Is Nothing) Then
                Dim pUnkTH As IUnknownUnrestricted
                Set pUnkTH = psfCur
                Dim hrqi As Long
                hrqi = pUnkTH.QueryInterface(IID_IThumbnailHandlerFactory, pThumbFact)
            End If
            If (pThumbFact Is Nothing) = False Then
                Dim pTH As IThumbnailProvider
                pThumbFact.GetThumbnailHandler pidlRel, 0&, IID_IThumbnailProvider, pTH
                pTH.GetThumbnail cxAdd, hThumb, WTSAT_ARGB
                If hThumb Then
                    Dim ts As SIZE
                    GetImageWH2 hThumb, ts
                    DebugAppend "AddThumbView2::pThumbFact hThumb=" & hThumb & ",cxy=" & ts.cx & "," & ts.cy, 22
                    lIdx = ImageList_Add(himl_Add, hThumb, 0)
                    If lIdx <> -1 Then
    '                If (lIdx >= 0) And (lIdx < 999999) Then
                        DebugAppend "AddThumbView2::Used IThumbnailHanderFactory/IThumbnailProvider, lIdx=" & lIdx, 22
                        AddThumbView2 = lIdx
                        DeleteObject hThumb
                        Exit Function
                    Else
                        lIdx = AddToImageListEx(himl_Add, hThumb, cxAdd, cyAdd)
                        If lIdx <> -1 Then
                            AddThumbView2 = lIdx
                            DeleteObject hThumb
                            Exit Function
                        End If
                    End If
                End If
                DeleteObject hThumb
            End If
            Dim pThumb As ISharedBitmap
            Dim tID As WTS_THUMBNAILID
            Dim tcFlags As WTS_CACHEFLAGS
    '        'We clear item data on changedir, so I don't think there will be a circumstance where we have an id?
    '        If ThumbIDisNull(LVEntries(nEntry).tThumbID) = False Then
    '            pThumbCache.GetThumbnailByID LVEntries(nEntry).tThumbID, cxAdd, pThumb, tcFlags
    '        Else
    '            Call SHCreateItemFromIDList(pidlFQ, IID_IShellItem, isi)
                pThumbCache.GetThumbnail isi, cxAdd, WTS_EXTRACT Or WTS_SLOWRECLAIM, pThumb, tcFlags, tID
    '        End If
            If (pThumb Is Nothing) = False Then
                LVEntries(nEntry).tThumbID = tID
                pThumb.GetSharedBitmap hThumb
                DebugAppend "AddThumbView2::pThumbCache.GetThumb ok, hThumb=" & hThumb, 22
                If hThumb Then
                    lIdx = ImageList_Add(himl_Add, hThumb, 0)
                    If lIdx > -1 Then
    '                If (lIdx >= 0) And (lIdx < 999999) Then
                        DebugAppend "AddThumbView2::Used IThumbnailCache, lIdx=" & lIdx, 22
                        AddThumbView2 = lIdx
                        DeleteObject hThumb
                        Exit Function
                    End If
                End If
                DeleteObject hThumb
            Else
                DebugAppend "AddThumbView2::pThumbCache returned null", 33
            End If
    '
        End If
    skipprov:
            
        If FileSupportsThumbView(sFullPath) Then
            If Len(LVEntries(nEntry).sName) > 3 Then
                If Right$(LVEntries(nEntry).sName, 4) = ".ico" Then
                    lIdx = AddToHIMLNoDLLForIco(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_THUMBNAILONLY Or SIIGBF_RESIZETOFIT, pidlRel)
                Else
                    lIdx = AddToHIMLNoDLL(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_THUMBNAILONLY Or SIIGBF_RESIZETOFIT, pidlRel)
                End If
            Else
                lIdx = AddToHIMLNoDLL(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_THUMBNAILONLY Or SIIGBF_RESIZETOFIT, pidlRel)
            End If
    '        DebugAppend "isifthumb->DLL Thumb from SupportedType return::" & lIdx & ", lFlags=" & j, 33
        Else
            lIdx = AddToHIMLNoDLL(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_ICONONLY, pidlRel)
    '        DebugAppend "isifthumb->DLL Thumb from Non-Image return::" & lIdx & ", lFlags=" & j, 3
            bImgFacFail = True
        End If
        If (lIdx < 0) Or (lIdx > 999999) Then
            DebugAppend "AddThumbView2::vidthumb/isifthumb failed, sending to gdip/iei"
            GoTo useiei
        End If
    '    DebugAppend "VidThumb or DLL appears to have succeeded: thumb return::" & lIdx
        If lIdx < 0 Then
            DebugAppend "AddTohIML failed completely, sending to defthumb"
            GoTo defthumb
        End If
        AddThumbView2 = lIdx
    Else
    useiei:
        Dim uThumbSize As SIZE
        uThumbSize.cx = cxAdd * m_ScaleX
        uThumbSize.cy = cyAdd * m_ScaleY
        Dim iei As IExtractImage
        Dim sRet As String
        Dim uThumbFlags As IEIFlags
        If FileSupportsThumbView(sFullPath) Then
    '        DebugAppend "AddThumbView2::Trying GDIP"
            hThumb = hBitmapFromFile(sFullPath, cxAdd, cyAdd, &HFF000000, True)
            If IsComCtl6 = False Then
                OleTranslateColor clrFore, 0&, clrMsk
                lIdx = ImageList_AddMasked(himl_Add, hThumb, clrMsk)
            Else
                lIdx = ImageList_Add(himl_Add, hThumb, 0)
            End If
            
            Call DeleteObject(hThumb)
            If lIdx > -1 Then
    '            DebugAppend "gdipthumb->Got valid thumb, exiting"
                AddThumbView2 = lIdx
                Exit Function
            Else
    '            DebugAppend "AddThumbView2::GDIP failed, will try IEI", 2
    
            End If 'lIdx > -1
    '        DebugAppend "Attempting to get IEI thumbnail for " & sFullPath
            If (isi Is Nothing) Then
                Call SHCreateItemFromIDList(pidlFQ, IID_IShellItem, isi)
            End If
            isi.BindToHandler ByVal 0&, BHID_ThumbnailHandler, IID_IExtractImage, iei
    
            If (iei Is Nothing) = False Then
                uThumbFlags = IEIFLAG_ASPECT Or IEIFLAG_SCREEN
                sRet = String$(MAX_PATH, 0)
                iei.GetLocation StrPtr(sRet), MAX_PATH, 0&, uThumbSize, 32, uThumbFlags
                hThumb = iei.Extract()
    '            DebugAppend "ieithumb->iei.Extract=" & hThumb, 3
                
                If hThumb Then
                    'we now have an hBitmap that we can add to a standard api imagelist
                    
                    lIdx = AddToImageListEx(himl_Add, hThumb, cxAdd, cyAdd)
                    Call DeleteObject(hThumb)
                    If lIdx > -1 Then
                        DebugAppend "ieithumb->Got valid thumb add, exiting", 2
                        AddThumbView2 = lIdx
                        Exit Function
                    Else
    '                    DebugAppend "ieithumb->Failed to add hThumb to hIML_Add, ret=" & lIdx
    '                    DebugAppend "Imagewidth=" & GetImageWH(hThumb, 1) & ",h=" & GetImageWH(hThumb, 2)
                        GoTo defthumb
                    End If
                Else
                    'DebugAppend "Failed to get hThumb from IEI, falling back to defthumb", 2
                    GoTo defthumb
                End If 'hThumb
            Else
                'DebugAppend "Could not create iei, falling back to defthumb", 2
                GoTo defthumb
            End If 'iei is nothing
        Else
    defthumb:
            'can't get a thumbnail of this file
            'so we'll need to get it's associated icon from the system image list,
            'and then copy it to our image list
            Dim hIcon As LongPtr
    '        DebugAppend "defthumb fallback", 2
    
            If FileSupportsThumbView(sFullPath) Then
                If bImgFacFail = False Then
                    'the file supports thumbnail view but all attempts to generate it
                    'have failed. first attempt to use ISIIF if it didn't already fail
                            lIdx = AddToHIMLNoDLL(himl_Add, isi, pidlFQ, cxAdd, cyAdd, SIIGBF_ICONONLY)
    
                            If (lIdx < 0) Or (lIdx > 999999) Then
    '                            DebugAppend "Fallback to DLL/ICONONLY failed, sending to GetAssocIco"
                                GoTo fb2
                            Else
    '                            DebugAppend "Fallback to DLL/ICONONLY succeeded"
                                AddThumbView2 = lIdx
                                Exit Function
                            End If
                End If
            End If
    fb2:
            hIcon = GetFileIconHandlePIDL(pidlFQ)
            If hIcon = 0 Then
                DebugAppend "Failed to get associated icon. Alternate method returned hIcon=" & hIcon
            End If
            
            If hIcon = 0 Then
                DebugAppend "AddThumbView2::Final fallbacks to SHGetFileInfo/SHGetImageList system icons have failed. Something weird is going on..."
            Else
                lIdx = ImageList_AddIcon(himl_Add, hIcon)
                Call DestroyIcon(hIcon)
                DebugAppend "lIdx on version fallback,==" & lIdx, 2
                AddThumbView2 = lIdx
                Exit Function
            End If
        End If
    End If
    'DebugAppend "AddThumbView2 last exit point,rtn=" & AddThumbView2
    Call CoTaskMemFree(pidlPar)
    Set isfParent = Nothing
    
    End Function
    
    Private Function GetImageWH(hBmp As LongPtr, iWhich As Integer) As Long
    Dim lSize As Long
    Dim gimg As LongPtr
    GdipCreateBitmapFromHBITMAP hBmp, ByVal 0&, gimg
    
    If iWhich = 1 Then
        GdipGetImageWidth gimg, lSize
        GetImageWH = lSize
    Else
        GdipGetImageHeight gimg, lSize
        GetImageWH = lSize
    End If
    GdipDisposeImage gimg
    End Function
    Private Sub GetImageWH2(hBmp As LongPtr, tsz As SIZE)
    Dim lSize As Long
    Dim gimg As LongPtr
    GdipCreateBitmapFromHBITMAP hBmp, ByVal 0&, gimg
    GdipGetImageWidth gimg, tsz.cx
    GdipGetImageHeight gimg, tsz.cy
    GdipDisposeImage gimg
    End Sub
    
    Private Function ThumbShouldFrame(hBmp As LongPtr) As Boolean
    Dim lSize As Long
    Dim gimg As LongPtr
    GdipCreateBitmapFromHBITMAP hBmp, ByVal 0&, gimg
    
        GdipGetImageWidth gimg, lSize
        If lSize < (m_ThumbCXY) Then
            ThumbShouldFrame = True
        End If
        
        GdipGetImageHeight gimg, lSize
        If lSize < (m_ThumbCXY) Then
            ThumbShouldFrame = True
        End If
    GdipDisposeImage gimg
    
    End Function
    
    Private Function AddToHIMLNoDLLForIco(himl As LongPtr, si As IShellItem, pidlFQ As LongPtr, cx As Long, cy As Long, lFlags As SIIGBF, Optional pidlRel As LongPtr = 0, Optional bFlag1 As Boolean = False) As Long
    Dim isiif As IShellItemImageFactory
    Dim hr As Long
    Dim pidlcr As LongPtr
    Dim hBmp As LongPtr
    On Error GoTo e0
    If (si Is Nothing) Then
        If (pidlFQ = 0&) And (pidlRel <> 0&) Then
            'Virtual object; try to recreate pidl
            pidlcr = ILCombine(pidlFQCur, pidlRel)
        Else
            pidlcr = pidlFQ
        End If
        hr = SHCreateItemFromIDList(pidlcr, IID_IShellItemImageFactory, isiif)
    Else
        Set isiif = si
    End If
    
    Dim tsz As SIZE, ullsz As LongLong
    tsz.cx = cx: tsz.cy = cy
    CopyMemory ullsz, tsz, 8
    hr = isiif.GetImage(ullsz, lFlags, hBmp)
    If hr = S_OK Then
        Dim clrMsk As Long
        If IsComCtl6 = False Then
            OleTranslateColor clrFore, 0&, clrMsk
            AddToHIMLNoDLLForIco = ImageList_AddMasked(himl, hBmp, clrMsk)
        Else
            AddToHIMLNoDLLForIco = ImageList_Add(himl, hBmp, clrMsk)
        End If
        DeleteObject hBmp
    Else
        AddToHIMLNoDLLForIco = -1
    End If
    
    Set isiif = Nothing
    
    Exit Function
    e0:
    DebugAppend "AddToHIMLNoDLLForIco Error, 0x" & Hex$(Err.Number) & "=" & Err.Description, 11
    End Function
    
    Private Function AddToHIMLNoDLL(himl As LongPtr, si As IShellItem, pidlFQ As LongPtr, cx As Long, cy As Long, lFlags As SIIGBF, Optional pidlRel As LongPtr = 0) As Long
    Dim isiif As IShellItemImageFactory
    Dim hr As Long
    Dim pidlcr As LongPtr
    Dim hBmp As LongPtr
    If (si Is Nothing) Then
        If (pidlFQ = 0&) And (pidlRel <> 0&) Then
            'Virtual object; try to recreate pidl
            pidlcr = ILCombine(pidlFQCur, pidlRel)
        Else
            pidlcr = pidlFQ
        End If
        hr = SHCreateItemFromIDList(pidlcr, IID_IShellItemImageFactory, isiif)
    Else
        Set isiif = si
    End If
    
    Dim tsz As SIZE, ull As LongLong
    tsz.cx = cx: tsz.cy = cy
    CopyMemory ull, tsz, 8
    hr = isiif.GetImage(ull, lFlags, hBmp)
    If hr = S_OK Then
    '    If ThumbShouldFrame(hBmp) Then
    '        hr = E_FAIL 'This manual checking should only be needed for IL_AddMasked
                        'But it can't hurt to verify anyway; when a fail is returned
                        'from this function it goes to the GDIP scaler/framer.
    '    End If
    End If
        
    If hr = S_OK Then
        Dim clrMsk As Long
        If IsComCtl6 = False Then
            OleTranslateColor clrFore, 0&, clrMsk
            AddToHIMLNoDLL = ImageList_AddMasked(himl, hBmp, clrMsk)
        Else
            AddToHIMLNoDLL = ImageList_Add(himl, hBmp, 0&)
            If (AddToHIMLNoDLL = -1) And (hBmp <> 0) And (hBmp <> -1) Then
                AddToHIMLNoDLL = AddToImageListEx(himl, hBmp, cx, cy)
            End If
                
        End If
        DeleteObject hBmp
    Else
        AddToHIMLNoDLL = -1
    End If
    
    Set isiif = Nothing
    
    End Function
    
    Private Function AddThumbCustom(himl As LongPtr, hBmp As LongPtr, bIcon As Boolean, bDestroy As Boolean) As Long
    Dim lIdx As Long
    If bIcon Then
        lIdx = ImageList_AddIcon(himl, hBmp)
        If bDestroy Then DestroyIcon hBmp
    Else
        Dim clrMsk As Long
        If IsComCtl6 = False Then
            OleTranslateColor clrFore, 0&, clrMsk
            lIdx = ImageList_AddMasked(himl, hBmp, clrMsk)
        Else
            lIdx = ImageList_Add(himl, hBmp, clrMsk)
        End If
        If bDestroy Then DeleteObject hBmp
    End If
    AddThumbCustom = lIdx
    End Function
    
    Private Function AddThumbviewVideoISI(pidl As LongPtr, cx As Long, cy As Long) As LongPtr
    'This method is deprecated in favor of a newer way in AddThumbView2; but the old block
    'is still present in that function in case someone wants to convert back; so recommend
    'leaving this routine present.
    Dim psi As IShellItem2
    Dim vProp As Variant, vrProp As Variant
    
    
    Call SHCreateItemFromIDList(pidl, IID_IShellItem2, psi)
    If (psi Is Nothing) = False Then
        psi.GetProperty PKEY_ThumbnailStream, vProp
    '    PropVariantToVariant vProp, vrProp
    
        If VarType(vProp) = VT_STREAM Then 'vbDataObject Then
                Dim vt As Integer
            vt = VT_UNKNOWN
            CopyMemory ByVal VarPtr(vProp), ByVal VarPtr(vt), 2&
    
            AddThumbviewVideoISI = ResizeThumbFromGDIP(hBitmapFromStream(vProp), cx, cy)
        Else
            DebugAppend "No thumbstream found, VT=" & VarType(vrProp), 2
        End If
    Else
        DebugAppend "Failed to create IShellItem2", 2
    End If
    End Function
    
    Private Function ResizeThumbFromGDIP(hBmp As LongPtr, cx As Long, cy As Long) As LongPtr
    If hBmp Then
    ResizeThumbFromGDIP = ResizeImageGDIP(hBmp, &HFF000000, cx, cy, True)
    End If
    End Function
    
    Private Sub BMP2Array(bmp As IPicture, data() As Byte)
    'Courtesy of The_trick. Decodes binary data stored as a bitmap.
        Dim bi  As BITMAPINFO
        Dim L   As Long
        
        bi.bmiHeader.biSize = LenB(bi.bmiHeader)
        GetDIBits UserControl.hDC, bmp.Handle, 0, 0, ByVal 0, bi, 0
        
        ReDim data(bi.bmiHeader.biWidth * Abs(bi.bmiHeader.biHeight) * 3 - 1)
        bi.bmiHeader.biBitCount = 24
        bi.bmiHeader.biCompression = 0
        bi.bmiHeader.biSizeImage = 0
        
        GetDIBits UserControl.hDC, bmp.Handle, 0, Abs(bi.bmiHeader.biHeight), data(0), bi, 0
        
        CopyMemory L, data(0), 4
        CopyMemory data(0), data(4), L
        
        ReDim Preserve data(L - 1)
        
    End Sub
    
    Private Function PBEncodedPNGtoHIML(pbidx As Long, himl As LongPtr) As Boolean
    Dim hBitmap As LongPtr, hBmp As LongPtr
    Dim Stream() As Byte
    Dim pStream As IStream 'IUnknown
    Dim hr As Long
    
    On Error GoTo e0
    BMP2Array pbIconData(pbidx).Picture, Stream
    Set pStream = pvStreamFromArray(VarPtr(Stream(0)), UBound(Stream) + 1&)
    If Not pStream Is Nothing Then
        If GdipLoadImageFromStream(pStream, hBitmap) = 0& Then
            If hBitmap Then
                GdipCreateHBITMAPFromBitmap hBitmap, hBmp, vbWhite
                If hBmp Then
                    hr = ImageList_Add(himl, hBmp, 0)
                    DebugAppend "PBEncodedPNGtoHIML hr=" & hr
                    PBEncodedPNGtoHIML = True
                Else
                    DebugAppend "PBEncodedPNGtoHIML No hbmp"
                End If
                If hr <> -1 Then PBEncodedPNGtoHIML = True
                GdipDisposeImage hBitmap
            Else
                DebugAppend "PBEncodedPNGtoHIML::Failed to create hBitmap"
            End If
        End If
    End If
    
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "PBEncodedPNGtoHIML.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function PBEncodedIconTohIcon(pbidx As Long, Optional cx As Long = 24, Optional cy As Long = 24) As LongPtr
    'returns an hIcon from an icon in the resource file
    'For unknown reasons, this will not work with the 'Icon' group in the res file
    'Icons must be added as a custom resource
    
    Dim tIconHeader     As IconHeader
    Dim tIconEntry()    As IconEntry
    Dim MaxBitCount     As Long
    Dim MaxSize         As Long
    Dim Aproximate      As Long
    Dim IconID          As Long
    Dim hIcon           As LongPtr
    Dim i               As Long
    Dim bytIcoData() As Byte
        
    On Error GoTo e0
        BMP2Array pbIconData(pbidx).Picture, bytIcoData
        Call CopyMemory(tIconHeader, bytIcoData(0), LenB(tIconHeader))
    
        If tIconHeader.ihCount >= 1 Then
        
            ReDim tIconEntry(tIconHeader.ihCount - 1)
            
            Call CopyMemory(tIconEntry(0), bytIcoData(LenB(tIconHeader)), LenB(tIconEntry(0)) * tIconHeader.ihCount)
            
            IconID = -1
               
            For i = 0 To tIconHeader.ihCount - 1
                If tIconEntry(i).ieBitCount > MaxBitCount Then MaxBitCount = tIconEntry(i).ieBitCount
            Next
    
           
            For i = 0 To tIconHeader.ihCount - 1
                If MaxBitCount = tIconEntry(i).ieBitCount Then
                    MaxSize = CLng(tIconEntry(i).ieWidth) + CLng(tIconEntry(i).ieHeight)
                    If MaxSize > Aproximate And MaxSize <= (cx + cy) Then
                        Aproximate = MaxSize
                        IconID = i
                    End If
                End If
            Next
                       
            If IconID = -1 Then Exit Function
           
            With tIconEntry(IconID)
                hIcon = CreateIconFromResourceEx(bytIcoData(.ieImageOffset), .ieBytesInRes, 1&, &H30000, cx, cy, &H0)
                If hIcon <> 0& Then
                    PBEncodedIconTohIcon = hIcon
                End If
            End With
           
        End If
    
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "PBEncodedIconTohIcon.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function ResIconTohIcon(id As String, Optional cx As Long = 24, Optional cy As Long = 24) As LongPtr
    'returns an hIcon from an icon in the resource file
    'For unknown reasons, this will not work with the 'Icon' group in the res file
    'Icons must be added as a custom resource
    
    Dim tIconHeader     As IconHeader
    Dim tIconEntry()    As IconEntry
    Dim MaxBitCount     As Long
    Dim MaxSize         As Long
    Dim Aproximate      As Long
    Dim IconID          As Long
    Dim hIcon           As LongPtr
    Dim i               As Long
    Dim bytIcoData() As Byte
        
    On Error GoTo e0
        bytIcoData = LoadResData(id, "CUSTOM")
        Call CopyMemory(tIconHeader, bytIcoData(0), LenB(tIconHeader))
    
        If tIconHeader.ihCount >= 1 Then
        
            ReDim tIconEntry(tIconHeader.ihCount - 1)
            
            Call CopyMemory(tIconEntry(0), bytIcoData(LenB(tIconHeader)), LenB(tIconEntry(0)) * tIconHeader.ihCount)
            
            IconID = -1
               
            For i = 0 To tIconHeader.ihCount - 1
                If tIconEntry(i).ieBitCount > MaxBitCount Then MaxBitCount = tIconEntry(i).ieBitCount
            Next
    
           
            For i = 0 To tIconHeader.ihCount - 1
                If MaxBitCount = tIconEntry(i).ieBitCount Then
                    MaxSize = CLng(tIconEntry(i).ieWidth) + CLng(tIconEntry(i).ieHeight)
                    If MaxSize > Aproximate And MaxSize <= (cx + cy) Then
                        Aproximate = MaxSize
                        IconID = i
                    End If
                End If
            Next
                       
            If IconID = -1 Then Exit Function
           
            With tIconEntry(IconID)
                hIcon = CreateIconFromResourceEx(bytIcoData(.ieImageOffset), .ieBytesInRes, 1&, &H30000, cx, cy, &H0)
                If hIcon <> 0& Then
                    ResIconTohIcon = hIcon
                End If
            End With
           
        End If
    
    On Error GoTo 0
    Exit Function
    
    e0:
    DebugAppend "ResIconTohIcon.Error->" & Err.Description & " (" & Err.Number & ")"
    
    End Function
    
    Private Function pvStreamFromArray(ArrayPtr As LongPtr, ByVal Length As LongPtr) As IStream
    
    Dim o_hMem As LongPtr
    Dim o_lpMem  As LongPtr
         
    On Error GoTo e0
    
        If ArrayPtr = 0& Then
            CreateStreamOnHGlobal ByVal 0&, 1&, pvStreamFromArray
        ElseIf Length <> 0& Then
            o_hMem = GlobalAlloc(&H2&, Length)
            If o_hMem <> 0 Then
                o_lpMem = GlobalLock(o_hMem)
                If o_lpMem <> 0 Then
                    CopyMemory ByVal o_lpMem, ByVal ArrayPtr, Length
                    Call GlobalUnlock(o_hMem)
                    Call CreateStreamOnHGlobal(ByVal o_hMem, 1&, pvStreamFromArray)
                End If
            End If
        End If
    
    On Error GoTo 0
    Exit Function
    e0:
    DebugAppend "pvStreamFromArray.Error->" & Err.Description & " (" & Err.Number & ")"
       
    End Function
    
    Private Function FilePtypeL(sFileOrExt As String) As ucsb_PERCEIVED
    'Pass a full path, file name, or extension
    Dim sEx As String
    
    Dim lType As ucsb_PERCEIVED
    Dim hr As Long
    Dim lFlag As ucsb_PERCEIVEDFLAG
    Dim lpsz As LongPtr
    'DebugAppend "FilePtypeL sFileOrExt=" & sFileOrExt
    Dim sFN As String, lpfnm As LongPtr
    If InStr(sFileOrExt, "\") Then
        lpfnm = PathFindFileNameW(StrPtr(sFileOrExt))
        sFN = LPWSTRtoStr(lpfnm)
    Else
        sFN = sFileOrExt
    End If
    
    If InStr(sFN, ".") Then
        sEx = Right$(sFN, (Len(sFN) - InStrRev(sFN, ".")) + 1)
    Else
        sEx = "." & sFN
    End If
    
    hr = AssocGetPerceivedType(StrPtr(sEx), lType, lFlag, lpsz)
    If hr <> S_OK Then
        DebugAppend "FilePtypeL->AssocGetPerceivedType failed on ext=" & sEx & ", hr=0x" & Hex$(hr)
        FilePtypeL = -1
        Exit Function
    End If
    'DebugAppend "hr=" & hr & ",lType=" & lType & ",lFlag=" & lFlag
    FilePtypeL = lType
    Call CoTaskMemFree(lpsz)
        
    End Function
    
    Private Function FileSupportsThumbView(sFullPath As String) As Boolean
    
    Dim lType As ucsb_PERCEIVED
    lType = FilePtypeL(sFullPath)
    If (lType = PERCEIVED_TYPE_IMAGE) Or (lType = PERCEIVED_TYPE_APPLICATION) Then
        FileSupportsThumbView = True
    Else
        FileSupportsThumbView = False
    End If
    Exit Function
    End Function
    
    Private Function DeleteFile(siFile() As String) As Long
    Dim shfos As SHFILEOPSTRUCT
    Dim sList As String
    Dim i As Long
    
    For i = 0 To UBound(siFile)
        If siFile(i) <> "" Then
            sList = sList & siFile(i) & vbNullChar
        End If
    Next i
    sList = sList & vbNullChar
    DebugAppend "DeleteToBinW->" & sList
    With shfos
        .hWnd = hLVS
        .wFunc = FO_DELETE
        .pFrom = StrPtr(sList)
    '    .fFlags = FOF_ALLOWUNDO
    '    If bDeletePrompt Then
    '        .fFlags = .fFlags Or FOF_NOCONFIRMATION
    '    End If
    End With
    
    DeleteFile = SHFileOperationW(shfos)
    End Function
    
    Private Function ValidateName(tFile As UCSBFile) As Long
    'For a final check if the filename is valid.
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    
    If (Right$(tFile.sNameFull, 1) = " ") Or (Right$(tFile.sNameFull, 1) = ".") Then
        'These are invalid names but we'll mimic Explorer behavior and correct them rather than error out
        If (tFile.sName) = (tFile.sNameFull) Then
            tFile.sName = Left$(tFile.sName, Len(tFile.sName) - 1)
        End If
        tFile.sNameFull = Left$(tFile.sNameFull, Len(tFile.sNameFull) - 1)
    End If
    If (Right$(tFile.sFullPath, 1) = " ") Or (Right$(tFile.sFullPath, 1) = ".") Then
        tFile.sFullPath = Left$(tFile.sFullPath, Len(tFile.sFullPath) - 1)
    End If
    
    If InStr(tFile.sNameFull, "*") Or InStr(tFile.sNameFull, "<") Or InStr(tFile.sNameFull, ">") Or InStr(tFile.sNameFull, "|") Or InStr(tFile.sNameFull, Chr$(34)) Or InStr(tFile.sNameFull, Chr(&H3F)) Then
        ValidateName = -1
        Exit Function
    End If
    
    If Len(tFile.sFullPath) > MAX_PATH Then
        ValidateName = -2
        Exit Function
    End If
    
    Dim stest As String
    If InStr(tFile.sNameFull, ".") Then
        stest = Left$(tFile.sNameFull, InStr(tFile.sNameFull, ".") - 1)
    Else
        stest = tFile.sNameFull
    End If
    stest = UCase$(stest)
    If (stest = "CON") Or (stest = "PRN") Or (stest = "AUX") Or (stest = "NUL") Or (stest = "COM1") Or (stest = "COM2") Or _
        (stest = "COM3") Or (stest = "COM4") Or (stest = "COM5") Or (stest = "COM6") Or (stest = "COM7") Or (stest = "COM8") Or _
        (stest = "COM9") Or (stest = "LPT1") Or (stest = "LPT2") Or (stest = "LPT3") Or (stest = "LPT4") Or (stest = "LPT5") Or _
        (stest = "LPT6") Or (stest = "LPT7") Or (stest = "LPT8") Or (stest = "LPT9") Then
            ValidateName = -3
            Exit Function
    End If
    If stest = " " Then 'Can't name it space .ext either; surprising though ..ext is valid
        ValidateName = -6
        Exit Function
    End If
    
    If (Len(tFile.sNameFull) = 1) Then
        If ((tFile.sNameFull = Chr$(0)) Or (tFile.sNameFull = ".")) Then
            ValidateName = -4
            Exit Function
        End If
    End If
    
    'Test for all nulls
    stest = Replace$(tFile.sNameFull, Chr$(0), "")
    If stest = "" Then
        ValidateName = -5
        Exit Function
    End If
    
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.ValidateName->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function GetRenameErrorDesc(hr As Long) As String
    'Return a description for failures in ValidateName
        Select Case hr
            Case 0: GetRenameErrorDesc = RnErDsc1
            Case -1: GetRenameErrorDesc = RnErDsc2
            Case -2: GetRenameErrorDesc = RnErDsc3
            Case -3: GetRenameErrorDesc = RnErDsc4
            Case -4: GetRenameErrorDesc = RnErDsc5
            Case -5: GetRenameErrorDesc = RnErDsc6
            Case -6: GetRenameErrorDesc = RnErDsc7
            Case Else: GetRenameErrorDesc = Replace$(RnErDsc8, "%1", CStr(hr))
        End Select
    End Function
    
    Private Function RenameFile(sOld As String, sNewName As String, Optional OldIdx As Long) As Long
    DebugAppend "Rename::Enter,old=" & sOld & ",new=" & sNewName
    Dim cFO2 As FileOperation
    Set cFO2 = New FileOperation
    Dim siItem As IShellItem
    
    SHCreateItemFromParsingName StrPtr(sOld), Nothing, IID_IShellItem, siItem
    If siItem Is Nothing Then
        If OldIdx Then
            Dim pidl As LongPtr
            pidl = ILCombine(pidlFQCur, LVEntries(OldIdx).pidlRel)
            SHCreateItemFromIDList pidl, IID_IShellItem, siItem
            CoTaskMemFree pidl
        End If
    End If
    
    If (siItem Is Nothing) = False Then
        cFO2.RenameItem siItem, StrPtr(sNewName), Nothing ' ByVal 0&
        DebugAppend "Rename::SetOps"
        cFO2.SetOperationFlags IFO_ALLOWUNDO
        cFO2.SetOwnerWindow hLVS
        DebugAppend "Rename::Exec"
        cFO2.PerformOperations
        DebugAppend "Rename::CheckAbort"
        cFO2.GetAnyOperationsAborted RenameFile
    End If
    Set cFO2 = Nothing
    Set siItem = Nothing
    
    End Function
    
    Private Function RenameItem(siItem As IShellItem, sNewName As String, Optional OldIdx As Long) As Long
    'DebugAppend "Rename::Enter,old=" & sOld & ",new=" & sNewName
    Dim cFO2 As FileOperation
    Set cFO2 = New FileOperation
    
    If (siItem Is Nothing) = False Then
        cFO2.RenameItem siItem, StrPtr(sNewName), Nothing 'ByVal 0&
        DebugAppend "Rename::SetOps"
        cFO2.SetOperationFlags IFO_ALLOWUNDO
        cFO2.SetOwnerWindow hLVS
        DebugAppend "Rename::Exec"
        cFO2.PerformOperations
        DebugAppend "Rename::CheckAbort"
        cFO2.GetAnyOperationsAborted RenameItem
    End If
    Set cFO2 = Nothing
    
    End Function
    
    Private Function InvokeVerb(pCtxMenu As IContextMenu, ByVal pszVerb As String, Optional lFlags As InvokeCommandMask = 0&) As Long
        '<EhHeader>
        On Error GoTo InvokeVerb_Err
        '</EhHeader>
    
    Dim hMenu As LongPtr
    Dim tCmdInfo As CMINVOKECOMMANDINFO
    Dim tCmdInfoEx As CMINVOKECOMMANDINFOEX
    hMenu = CreatePopupMenu()
    Dim sVerb As String
    Dim pCtxMenu2 As IContextMenu2
    sVerb = pszVerb
    Dim lpCtxMenud As Long
    Dim PT As POINT
    Dim nItems As Long
    Dim sDesc As String
    Dim i As Long
    Dim bGo As Boolean
    lpCtxMenud = -1
    If hMenu Then
    '    Set pCtxMenu2 = pCtxMenu
        If (pCtxMenu Is Nothing) = False Then
            DebugAppend "Got pCtxMenu"
            pCtxMenu.QueryContextMenu hMenu, 0&, 1&, &H7FFF, CMF_EXPLORE Or CMF_OPTIMIZEFORINVOKE
            nItems = GetMenuItemCount(hMenu)
            DebugAppend "InvokeVerb nItems=" & nItems
            For i = 0 To nItems - 1
                lpCtxMenud = GetMenuItemID(hMenu, i)
                DebugAppend "i=" & i & ", lpCtxMenud=" & lpCtxMenud
                If lpCtxMenud <= 0 Then GoTo nxt
                On Error Resume Next
                sVerb = String$(MAX_PATH, 0&)
                pCtxMenu.GetCommandString lpCtxMenud - 1, GCS_VERBW, 0&, StrPtr(sVerb), Len(sVerb)
                On Error GoTo InvokeVerb_Err
                If (Err.Number = 0&) Then
                    sVerb = TrimNullW(sVerb)
                    DebugAppend "CmdStr=" & sVerb
                    DebugAppend "InvokeVerb hMenu=" & hMenu
                    On Error Resume Next
                    sDesc = String$(MAX_PATH, 0&)
                    pCtxMenu.GetCommandString lpCtxMenud - 1, GCS_HELPTEXTW, 0&, StrPtr(sDesc), Len(sDesc)
                    sDesc = TrimNullW(sDesc)
                    On Error GoTo InvokeVerb_Err
                    DebugAppend "HelpStr=" & sDesc
                    If LCase$(sVerb) = LCase$(pszVerb) Then
                        DebugAppend "InvokeVerb go on " & sVerb
                        bGo = True
                        Exit For
                    End If
                    If (sVerb = "") And (LCase$(pszVerb) = "undo") Then
                        'This verb is a standard, normal verb, but was coming up blank for me.
                        'Adding a workaround, but won't work in non-english Windows, not sure if bug effects everyone
                        If Left$(LCase$(sDesc), 4) = "undo" Then
                            DebugAppend "InvokeVerb undo workaround"
                            bGo = True
                            Exit For
                        End If
                    End If
                Else
                    DebugAppend "InvokeVerb.GetCommandString Error::" & Err.Description
                    Err.Clear
                End If
    nxt:
            Next i
            If bGo Then
                tCmdInfo.cbSize = LenB(tCmdInfo)
                tCmdInfo.hwnd = hLVS
                tCmdInfo.lpVerb = lpCtxMenud - 1&
                tCmdInfo.fMask = lFlags
                tCmdInfo.nShow = SW_SHOWNORMAL
                pCtxMenu.InvokeCommand VarPtr(tCmdInfo)
                DebugAppend "command invoked"
            End If
            Call DestroyMenu(hMenu)
        End If
    End If
    
     '<EhFooter>
     Exit Function
    
    InvokeVerb_Err:
        DebugAppend "InvokeVerb->" & Err.Description & " (" & Err.Number & ")"
     '</EhFooter>
    End Function
    
    Private Function DivideUp(lVal1 As Long, lVal2 As Long) As Long
    'Any remainder rounds up to the next integer
    Dim lRes As Long
    lRes = lVal1 \ lVal2
    If (lVal1 Mod lVal2) Then
        lRes = lRes + 1
    End If
    DivideUp = lRes
    End Function
    
    Private Sub FastDoEvents()
        Dim uMsg As MSG
        Do While PeekMessage(uMsg, 0&, 0&, 0&, PM_REMOVE)   ' Reads and deletes message from queue.
            TranslateMessage uMsg                           ' Translates virtual-key messages into character messages.
            DispatchMessage uMsg                            ' Dispatches a message to a window procedure.
        Loop
    End Sub
    
    Private Function CloneOLEFont(ByVal Font As IFont) As StdFont
    Font.Clone CloneOLEFont
    End Function
    
    Private Function GetEditWindowTextW(hWnd As LongPtr) As String
    DebugAppend "GetEditWindowTextW.Entry()"
    If hWnd Then
        DebugAppend "GetEditWindowTextW hWnd=" & hWnd
        Dim lLen As Long
        Dim sText As String
        Dim lRtn As Long
        Dim lErr As Long
        lLen = CLng(SendMessageW(hWnd, WM_GETTEXTLENGTH, 0, ByVal 0&))
        DebugAppend "GetEditWindowTextW len=" & lLen
        sText = String$(lLen, 0)
        lRtn = CLng(SendMessageW(hWnd, WM_GETTEXT, lLen + 1, ByVal StrPtr(sText)))
        lErr = Err.LastDllError ' GetLastError()
        DebugAppend "GetEditWindowTextW return=0x" & Hex$(lRtn) & ",err=0x" & Hex$(lErr) & ",text=" & sText
        dbg_stringbytes sText
        GetEditWindowTextW = sText
    End If
    End Function

    Public Sub GroupCollapseGroups(idx As Long, fCollapsed As Long)
    'sets whether or not a groups is collapsed
    'fCollapsed=0 -> group will be expanded
    'fCollapsed<>0 -> group will be collapsed
    'idx=-1 applies it to all groups
    
    Dim nCnt As Long
    Dim i As Long
    Dim lState As Long
    Dim tGrp As LVGROUP
    Dim lid As Long
     
     If fCollapsed Then lState = LVGS_COLLAPSED
    
    nCnt = CLng(SendMessage(hLVS, LVM_GETGROUPCOUNT, 0&, ByVal 0&))
    For i = 0 To nCnt
        tGrp.cbSize = LenB(tGrp)
        tGrp.Mask = LVGF_GROUPID
        If ((idx >= 0&) And (idx = i)) Or (idx = -1) Then
            SendMessage hLVS, LVM_GETGROUPINFOBYINDEX, i, tGrp 'there's no SetByIndex
            ListView_SetGroupState hLVS, tGrp.iGroupId, LVGS_COLLAPSED, lState
            
        End If
    Next i
    
    End Sub
    
    Public Sub GroupSetIcon(GroupIndex As Long, nIcon As Long)
    'Sets the header icon of a group..
    'Set groupindex=-1 to set the same icon for all groups
    
    Dim nCnt As Long
    Dim i As Long
    Dim tGrp As LVGROUP
    
    nCnt = CLng(SendMessage(hLVS, LVM_GETGROUPCOUNT, 0&, ByVal 0&))
    For i = 0 To nCnt
        tGrp.cbSize = LenB(tGrp)
        tGrp.Mask = LVGF_GROUPID
        If ((GroupIndex >= 0&) And (GroupIndex = i)) Or (GroupIndex = -1) Then
            SendMessage hLVS, LVM_GETGROUPINFOBYINDEX, i, tGrp 'there's no SetByIndex
            tGrp.Mask = LVGF_GROUPID Or LVGF_TITLEIMAGE
            tGrp.iTitleImage = nIcon
            SendMessage hLVS, LVM_SETGROUPINFO, tGrp.iGroupId, tGrp
        End If
    Next i
    End Sub
    
    'Call FillRect(hDC, RC, hbr_bk)
    Private Sub PaintIcon(hWnd As LongPtr)
    
    Dim hDC As LongPtr
    Dim rc As RECT
    Call GetClientRect(hWnd, rc)
    DebugAppend "PaintIcon btm=" & rc.Bottom & ",icons=" & hIcoSearchBox16 & "," & hIcoSearchBox20 & "," & hIcoSearchBox24
    hDC = GetDC(hWnd)
    If bFlagSearchDisable Then
        If rc.Bottom < 20 Then
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBoxDis16, 16, 16, 0, 0, DI_NORMAL) '17
        ElseIf rc.Bottom < 24 Then
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBoxDis20, 20, 20, 0, 0, DI_NORMAL) '21
        Else
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBoxDis24, 24, 24, 0, 0, DI_NORMAL) '25
        End If
    Else
        If rc.Bottom < 20 Then
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBox16, 16, 16, 0, 0, DI_NORMAL) '17
        ElseIf rc.Bottom < 24 Then
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBox20, 20, 20, 0, 0, DI_NORMAL) '21
        Else
            Call DrawIconEx(hDC, rc.Left, 1, hIcoSearchBox24, 24, 24, 0, 0, DI_NORMAL) '25
        End If
    End If
    Call ReleaseDC(hWnd, hDC)
    End Sub
    
    
    Private Sub StringFromPointer(pOLESTR As LongPtr, strOut As String)
        
        Dim ByteArray(255) As Byte
        Dim intTemp As Integer
        Dim intCount As Integer
        Dim i As Integer
        
        intTemp = 1
        
        'Walk the string and retrieve the first byte of each WORD.
        While intTemp <> 0
            CopyMemory intTemp, ByVal pOLESTR + i, 2
            ByteArray(intCount) = intTemp
            intCount = intCount + 1
            i = i + 2
        Wend
        
        'Copy the byte array to our string.
        CopyMemory ByVal strOut, ByteArray(0), intCount
        
    End Sub
    
    Private Function dbg_SWP_FlagsStr(lVal As Long) As String
    Dim sRet As String
     If (lVal And SWP_NOSIZE) = SWP_NOSIZE Then sRet = sRet & "SWP_NOSIZE Or "
     If (lVal And SWP_NOMOVE) = SWP_NOMOVE Then sRet = sRet & "SWP_NOMOVE Or "
     If (lVal And SWP_NOZORDER) = SWP_NOZORDER Then sRet = sRet & "SWP_NOZORDER Or "
     If (lVal And SWP_NOREDRAW) = SWP_NOREDRAW Then sRet = sRet & "SWP_NOREDRAW Or "
     If (lVal And SWP_NOACTIVATE) = SWP_NOACTIVATE Then sRet = sRet & "SWP_NOACTIVATE Or "
     If (lVal And SWP_FRAMECHANGED) = SWP_FRAMECHANGED Then sRet = sRet & "SWP_FRAMECHANGED Or "
     If (lVal And SWP_DRAWFRAME) = SWP_DRAWFRAME Then sRet = sRet & "SWP_DRAWFRAME Or "
     If (lVal And SWP_SHOWWINDOW) = SWP_SHOWWINDOW Then sRet = sRet & "SWP_SHOWWINDOW Or "
     If (lVal And SWP_HIDEWINDOW) = SWP_HIDEWINDOW Then sRet = sRet & "SWP_HIDEWINDOW Or "
     If (lVal And SWP_NOCOPYBITS) = SWP_NOCOPYBITS Then sRet = sRet & "SWP_NOCOPYBITS Or "
     If (lVal And SWP_NOREPOSITION) = SWP_NOREPOSITION Then sRet = sRet & "SWP_NOREPOSITION Or "
     If (lVal And SWP_NOSENDCHANGING) = SWP_NOSENDCHANGING Then sRet = sRet & "SWP_NOSENDCHANGING Or "
     If (lVal And SWP_DEFERERASE) = SWP_DEFERERASE Then sRet = sRet & "SWP_DEFERERASE Or "
     If (lVal And SWP_ASYNCWINDOWPOS) = SWP_ASYNCWINDOWPOS Then sRet = sRet & "SWP_ASYNCWINDOWPOS Or "
    If sRet = "" Then sRet = "(unknown)"
    dbg_SWP_FlagsStr = sRet
    End Function
    
    Private Sub dbg_OpenCommonFileDialogTo(psi As IShellItem)
    Dim pDlg As FileOpenDialog
    Set pDlg = New FileOpenDialog
    If (psi Is Nothing) Then
        DebugAppend "psi Is Nothing", 11
    Else
        DebugAppend "psi valid", 11
        DebugAppend GetShellItemFileName(psi, SIGDN_FILESYSPATH), 11
    End If
    pDlg.SetFolder psi
    pDlg.Show UserControl.hWnd
    
    End Sub
    
    Private Function dbg_PKEYToString(tpk As PROPERTYKEY) As String
    Dim sGID As String
    
    sGID = dbg_GUIDToString(tpk.fmtid, False)
    dbg_PKEYToString = "{" & sGID & ", " & tpk.pid & "}"
    End Function
    Private Function dbg_SHCToString(tpk As SHCOLUMNID) As String
    Dim sGID As String
    
    sGID = dbg_GUIDToString(tpk.fmtid, False)
    dbg_SHCToString = "{" & sGID & ", " & tpk.pid & "}"
    End Function
    Private Function dbg_GetCDISStr(lVal As Long) As String
    Dim sRet As String
     If lVal = CDIS_SELECTED Then sRet = "CDIS_SELECTED"
     If lVal = CDIS_GRAYED Then sRet = "CDIS_GRAYED"
     If lVal = CDIS_DISABLED Then sRet = "CDIS_DISABLED"
     If lVal = CDIS_CHECKED Then sRet = "CDIS_CHECKED"
     If lVal = CDIS_FOCUS Then sRet = "CDIS_FOCUS"
     If lVal = CDIS_DEFAULT Then sRet = "CDIS_DEFAULT"
     If lVal = CDIS_HOT Then sRet = "CDIS_HOT"
     If lVal = CDIS_MARKED Then sRet = "CDIS_MARKED"
     If lVal = CDIS_INDETERMINATE Then sRet = "CDIS_INDETERMINATE"
     If lVal = CDIS_SHOWKEYBOARDCUES Then sRet = "CDIS_SHOWKEYBOARDCUES"
     If lVal = CDIS_NEARHOT Then sRet = "CDIS_NEARHOT"
     If lVal = CDIS_OTHERSIDEHOT Then sRet = "CDIS_OTHERSIDEHOT"
     If lVal = CDIS_DROPHILITED Then sRet = "CDIS_DROPHILITED"
    If sRet = "" Then sRet = "(unknown)"
    dbg_GetCDISStr = sRet
    End Function
    Public Function dbg_LVITEM_stateStr(lVal As Long) As String
    Dim sRet As String
     If (lVal And LVIS_FOCUSED) = LVIS_FOCUSED Then sRet = sRet & "LVIS_FOCUSED Or "
     If (lVal And LVIS_SELECTED) = LVIS_SELECTED Then sRet = sRet & "LVIS_SELECTED Or "
     If (lVal And LVIS_CUT) = LVIS_CUT Then sRet = sRet & "LVIS_CUT Or "
     If (lVal And LVIS_DROPHILITED) = LVIS_DROPHILITED Then sRet = sRet & "LVIS_DROPHILITED Or "
     If (lVal And LVIS_GLOW) = LVIS_GLOW Then sRet = sRet & "LVIS_GLOW Or "
     If (lVal And LVIS_ACTIVATING) = LVIS_ACTIVATING Then sRet = sRet & "LVIS_ACTIVATING Or "
     If (lVal And LVIS_OVERLAYMASK) = LVIS_OVERLAYMASK Then sRet = sRet & "LVIS_OVERLAYMASK Or "
     If (lVal And LVIS_STATEIMAGEMASK) = LVIS_STATEIMAGEMASK Then sRet = sRet & "LVIS_STATEIMAGEMASK Or "
    If sRet = "" Then sRet = "(unknown)"
    dbg_LVITEM_stateStr = sRet
    End Function
    
    Private Function dbg_GUIDToString(tg As UUID, Optional bBrack As Boolean = True) As String
    'StringFromGUID2 never works, even "working" code from vbaccelerator AND MSDN
    dbg_GUIDToString = Right$("00000000" & Hex$(tg.Data1), 8) & "-" & Right$("0000" & Hex$(tg.Data2), 4) & "-" & Right$("0000" & Hex$(tg.Data3), 4) & _
    "-" & Right$("00" & Hex$(CLng(tg.Data4(0))), 2) & Right$("00" & Hex$(CLng(tg.Data4(1))), 2) & "-" & Right$("00" & Hex$(CLng(tg.Data4(2))), 2) & _
    Right$("00" & Hex$(CLng(tg.Data4(3))), 2) & Right$("00" & Hex$(CLng(tg.Data4(4))), 2) & Right$("00" & Hex$(CLng(tg.Data4(5))), 2) & _
    Right$("00" & Hex$(CLng(tg.Data4(6))), 2) & Right$("00" & Hex$(CLng(tg.Data4(7))), 2)
    If bBrack Then dbg_GUIDToString = "{" & dbg_GUIDToString & "}"
    End Function
    
    Private Sub dbg_linkinfo(pLNK As IShellLinkW)
    Dim psdi As IShellLinkDataList
    Dim pPF As IPersistFile
    Set psdi = pLNK
    Dim dwFlg As SHELL_LINK_DATA_FLAGS
    psdi.GetFlags dwFlg
    DebugAppend "flags=" & Hex$(dwFlg)
    
    'If (dwFlg And SLDF_HAS_EXP_SZ) Then
        DebugAppend "isdl check special folder info"
        Dim tEXP As EXP_SPECIAL_FOLDER
        Dim ltPtr As LongPtr
        psdi.CopyDataBlock EXP_SPECIAL_FOLDER_SIG, ltPtr
        If ltPtr Then
            DebugAppend "got non-zero ptr"
            CopyMemory tEXP, ByVal ltPtr, LenB(tEXP)
            
            DebugAppend "struct size=" & tEXP.cbSize & ",sig=" & Hex$(tEXP.dwSignature)
            DebugAppend "id=" & tEXP.idSpecialFolder & ",offset=" & tEXP.cbOffset
        Else
            DebugAppend "no ptr to tEXP"
        End If
    'Else
    '    Debug.Print "no flag match"
    'End If
    End Sub
    
    Private Function LoadShortcutOverlay(cxy As Long) As Long
        '<EhHeader>
        On Error GoTo e0
        '</EhHeader>
    If hIcoLnkOvr Then
        LoadShortcutOverlay = 1
        Exit Function
    End If
    Dim sPath As String
    Dim sIco As String, sIdx As String, nIco As Long
    
    sPath = GetCustomOverlayPath()
    If Len(sPath) > 3 Then
        sIdx = Right$(sPath, Len(sPath) - InStrRev(sPath, ","))
        sIco = Left$(sPath, Len(sPath) - (Len(sIdx) + 1))
        nIco = CLng(sIdx)
        
        Dim hr As Long
    '    hr = ExtractIconEx(StrPtr(sIco), nIco, hIcoLnkOvr, hIcoLnkOvrSm, 1&)
        Dim dwSizes As Long
        If cxy >= 64 Then
            dwSizes = PackWords(64, 32)
        ElseIf cxy < 32 Then
            dwSizes = PackWords(16, 16)
        Else
            dwSizes = PackWords(32, 16)
        End If
        hr = SHDefExtractIconW(StrPtr(sIco), nIco, 0&, hIcoLnkOvr, hIcoLnkOvrSm, dwSizes)
        
        DebugAppend "LoadShortcutOverlay.SHDefExtractIconW hr=0x" & Hex$(hr)
    '    hIcoLnkOvr = ExtractIcon(0&, StrPtr(sIco), nIco)
        If hIcoLnkOvr Then
            LoadShortcutOverlay = 1
            Exit Function
        End If
    End If
    
    '<EhFooter>
    Exit Function
    
    e0:
        DebugAppend "ucShellBrowse.LoadShortcutOverlay->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    '</EhFooter>
    End Function
    
    Private Function GetCustomOverlayPath() As String
    Dim hKey As LongPtr
    Dim R As Long
    Dim sRes As String
    Dim lDataLen As Long
    Dim lType As Long
    Dim sPath As String, sPath2 As String
    Dim sRegCmp As String
    Dim sKey As String
    Dim dwFlag As Long
    sKey = "29"
    sPath = "SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons"
    #If Win64 Then
        dwFlag = KEY_QUERY_VALUE
    #Else
        If IsWOW64 Then
            dwFlag = KEY_QUERY_VALUE Or KEY_WOW64_64KEY
        Else
            dwFlag = KEY_QUERY_VALUE
        End If
    #End If
    
    R = RegOpenKeyExW(HKEY_LOCAL_MACHINE, StrPtr(sPath), 0&, dwFlag, hKey)
    If hKey Then
        R = RegQueryValueExW(hKey, StrPtr(sKey), 0, lType, 0, lDataLen)
        sRes = String$(lDataLen, 0)
        R = RegQueryValueExW(hKey, StrPtr(sKey), 0, REG_SZ, StrPtr(sRes), lDataLen)
        sRes = TrimNullW(sRes)
        GetCustomOverlayPath = sRes
        RegCloseKey hKey
    End If
    
    End Function
    
    Private Sub dbg_EnumVerbs(pCtxMenu As IContextMenu)
    Dim hMenu As LongPtr
    Dim tCmdInfo As CMINVOKECOMMANDINFO
    Dim tCmdInfoEx As CMINVOKECOMMANDINFOEX
    hMenu = CreatePopupMenu()
    Dim sVerb As String
    Dim pCtxMenu2 As IContextMenu2
    'sVerb = pszVerb
    Dim lpCtxMenud As Long
    Dim PT As POINT
    Dim nItems As Long
    Dim sDesc As String
    Dim i As Long
    Dim bGo As Boolean
    lpCtxMenud = -1
    If hMenu Then
    '    Set pCtxMenu2 = pCtxMenu
        If (pCtxMenu Is Nothing) = False Then
            DebugAppend "Got pCtxMenu", 11
            pCtxMenu.QueryContextMenu hMenu, 0&, 1&, &H7FFF, CMF_NORMAL
            nItems = GetMenuItemCount(hMenu)
            DebugAppend "InvokeVerb nItems=" & nItems, 11
            For i = 0 To nItems - 1
                Err.Clear
                Err.Number = 0
                lpCtxMenud = GetMenuItemID(hMenu, i)
                DebugAppend "i=" & i & ", lpCtxMenud=" & lpCtxMenud, 11
                If lpCtxMenud <= 0 Then GoTo nxt
                On Error Resume Next
                sVerb = String$(MAX_PATH, 0&)
                pCtxMenu.GetCommandString lpCtxMenud - 1, GCS_VERBW, 0&, StrPtr(sVerb), Len(sVerb)
                On Error GoTo InvokeVerb_Err
                If (Err.Number = 0&) Then
                    sVerb = TrimNullW(sVerb)
                    DebugAppend "CmdStr=" & sVerb, 11
                    DebugAppend "InvokeVerb hMenu=" & hMenu, 11
                    On Error Resume Next
                    sDesc = String$(MAX_PATH, 0&)
                    pCtxMenu.GetCommandString lpCtxMenud - 1, GCS_HELPTEXTW, 0&, StrPtr(sDesc), Len(sDesc)
                    sDesc = TrimNullW(sDesc)
                    On Error GoTo InvokeVerb_Err
                    DebugAppend "HelpStr=" & sDesc, 11
    '                If LCase$(sVerb) = LCase$(pszVerb) Then
    '                    DebugAppend "InvokeVerb go on " & sVerb
    '                    bGo = True
    '                    Exit For
    '                End If
                Else
                    DebugAppend "InvokeVerb.GetCommandString Error::" & Err.Description, 11
                    Err.Clear
                End If
    nxt:
            Next i
        End If
    End If
    Exit Sub
    InvokeVerb_Err:
    DebugAppend "dbg_EnumVerbs.Error->" & Err.Description, 11
    End Sub
    
    Private Sub dbg_dumpsinames(si As IShellItem)
    DebugAppend "dbg_dumpsinames.Entry"
    Dim lp As LongPtr
    Dim sz As String
    
    si.GetDisplayName SIGDN_DESKTOPABSOLUTEEDITING, lp
    DebugAppend "SIGDN_DESKTOPABSOLUTEEDITING::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_DESKTOPABSOLUTEPARSING, lp
    DebugAppend "SIGDN_DESKTOPABSOLUTEPARSING::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_FILESYSPATH, lp
    DebugAppend "SIGDN_FILESYSPATH::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_NORMALDISPLAY, lp
    DebugAppend "SIGDN_NORMALDISPLAY::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_PARENTRELATIVE, lp
    DebugAppend "SIGDN_PARENTRELATIVE::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_PARENTRELATIVEEDITING, lp
    DebugAppend "SIGDN_PARENTRELATIVEEDITING::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_PARENTRELATIVEFORADDRESSBAR, lp
    DebugAppend "SIGDN_PARENTRELATIVEFORADDRESSBAR::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_PARENTRELATIVEFORUI, lp
    DebugAppend "SIGDN_PARENTRELATIVEFORUI::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_PARENTRELATIVEPARSING, lp
    DebugAppend "SIGDN_PARENTRELATIVEPARSING::" & LPWSTRtoStr(lp)
    si.GetDisplayName SIGDN_URL, lp
    DebugAppend "SIGDN_URL::" & LPWSTRtoStr(lp)
    End Sub
    
    Private Function dbg_sfgao_tostring(atr As SFGAO_Flags) As String
    Dim sOut As String
    If (atr And SFGAO_BROWSABLE) = SFGAO_BROWSABLE Then sOut = sOut & "SFGAO_BROWSEABLE,"
    If (atr And SFGAO_CANCOPY) = SFGAO_CANCOPY Then sOut = sOut & "SFGAO_CANCOPY,"
    If (atr And SFGAO_CANDELETE) = SFGAO_CANDELETE Then sOut = sOut & "SFGAO_CANDELETE,"
    If (atr And SFGAO_CANLINK) = SFGAO_CANLINK Then sOut = sOut & "SFGAO_CANLINK,"
    If (atr And SFGAO_CANMONIKER) = SFGAO_CANMONIKER Then sOut = sOut & "SFGAO_CANMONIKER,"
    If (atr And SFGAO_CANMOVE) = SFGAO_CANMOVE Then sOut = sOut & "SFGAO_CANMOVE,"
    If (atr And SFGAO_CANRENAME) = SFGAO_CANRENAME Then sOut = sOut & "SFGAO_CANRENAME,"
    If (atr And SFGAO_COMPRESSED) = SFGAO_COMPRESSED Then sOut = sOut & "SFGAO_COMPRESSED,"
    If (atr And SFGAO_DROPTARGET) = SFGAO_DROPTARGET Then sOut = sOut & "SFGAO_DROPTARGET,"
    If (atr And SFGAO_ENCRYPTED) = SFGAO_ENCRYPTED Then sOut = sOut & "SFGAO_ENCRYPTED,"
    If (atr And SFGAO_FILESYSANCESTOR) = SFGAO_FILESYSANCESTOR Then sOut = sOut & "SFGAO_FILESYSANCESTOR,"
    If (atr And SFGAO_FILESYSTEM) = SFGAO_FILESYSTEM Then sOut = sOut & "SFGAO_FILESYSTEM,"
    If (atr And SFGAO_FOLDER) = SFGAO_FOLDER Then sOut = sOut & "SFGAO_FOLDER,"
    If (atr And SFGAO_GHOSTED) = SFGAO_GHOSTED Then sOut = sOut & "SFGAO_GHOSTED,"
    If (atr And SFGAO_HASPROPSHEET) = SFGAO_HASPROPSHEET Then sOut = sOut & "SFGAO_HASPROPSHEET,"
    If (atr And SFGAO_HASSTORAGE) = SFGAO_HASSTORAGE Then sOut = sOut & "SFGAO_HASSTORAGE,"
    If (atr And SFGAO_HASSUBFOLDER) = SFGAO_HASSUBFOLDER Then sOut = sOut & "SFGAO_HASSUBFOLDER,"
    If (atr And SFGAO_HIDDEN) = SFGAO_HIDDEN Then sOut = sOut & "SFGAO_HIDDEN,"
    If (atr And SFGAO_ISSLOW) = SFGAO_ISSLOW Then sOut = sOut & "SFGAO_ISSLOW,"
    If (atr And SFGAO_LINK) = SFGAO_LINK Then sOut = sOut & "SFGAO_LINK,"
    If (atr And SFGAO_NEWCONTENT) = SFGAO_NEWCONTENT Then sOut = sOut & "SFGAO_NEWCONTENT,"
    If (atr And SFGAO_NONENUMERATED) = SFGAO_NONENUMERATED Then sOut = sOut & "SFGAO_NONENUMERATED,"
    If (atr And SFGAO_READONLY) = SFGAO_READONLY Then sOut = sOut & "SFGAO_READONLY,"
    If (atr And SFGAO_REMOVABLE) = SFGAO_REMOVABLE Then sOut = sOut & "SFGAO_REMOVABLE,"
    If (atr And SFGAO_SHARE) = SFGAO_SHARE Then sOut = sOut & "SFGAO_SHARE,"
    If (atr And SFGAO_STORAGE) = SFGAO_STORAGE Then sOut = sOut & "SFGAO_STORAGE,"
    If (atr And SFGAO_STORAGEANCESTOR) = SFGAO_STORAGEANCESTOR Then sOut = sOut & "SFGAO_STORAGEANCESTOR,"
    If (atr And SFGAO_STREAM) = SFGAO_STREAM Then sOut = sOut & "SFGAO_STREAM,"
    If (atr And SFGAO_SYSTEM) = SFGAO_SYSTEM Then sOut = sOut & "SFGAO_SYSTEM,"
    If (atr And SFGAO_VALIDATE) = SFGAO_VALIDATE Then sOut = sOut & "SFGAO_VALIDATE,"
    dbg_sfgao_tostring = sOut
    End Function
    
    Private Function dbg_GetWindowStylesStr(lVal As WindowStyles) As String
    Dim sRet As String
     If (lVal And WS_OVERLAPPED) = WS_OVERLAPPED Then sRet = sRet & "WS_OVERLAPPED Or "
     If (lVal And WS_POPUP) = WS_POPUP Then sRet = sRet & "WS_POPUP Or "
     If (lVal And WS_CHILD) = WS_CHILD Then sRet = sRet & "WS_CHILD Or "
     If (lVal And WS_MINIMIZE) = WS_MINIMIZE Then sRet = sRet & "WS_MINIMIZE Or "
     If (lVal And WS_VISIBLE) = WS_VISIBLE Then sRet = sRet & "WS_VISIBLE Or "
     If (lVal And WS_DISABLED) = WS_DISABLED Then sRet = sRet & "WS_DISABLED Or "
     If (lVal And WS_CLIPSIBLINGS) = WS_CLIPSIBLINGS Then sRet = sRet & "WS_CLIPSIBLINGS Or "
     If (lVal And WS_CLIPCHILDREN) = WS_CLIPCHILDREN Then sRet = sRet & "WS_CLIPCHILDREN Or "
     If (lVal And WS_MAXIMIZE) = WS_MAXIMIZE Then sRet = sRet & "WS_MAXIMIZE Or "
     If (lVal And WS_BORDER) = WS_BORDER Then sRet = sRet & "WS_BORDER Or "
     If (lVal And WS_DLGFRAME) = WS_DLGFRAME Then sRet = sRet & "WS_DLGFRAME Or "
     If (lVal And WS_VSCROLL) = WS_VSCROLL Then sRet = sRet & "WS_VSCROLL Or "
     If (lVal And WS_HSCROLL) = WS_HSCROLL Then sRet = sRet & "WS_HSCROLL Or "
     If (lVal And WS_SYSMENU) = WS_SYSMENU Then sRet = sRet & "WS_SYSMENU Or "
     If (lVal And WS_THICKFRAME) = WS_THICKFRAME Then sRet = sRet & "WS_THICKFRAME Or "
     If (lVal And WS_GROUP) = WS_GROUP Then sRet = sRet & "WS_GROUP Or "
     If (lVal And WS_TABSTOP) = WS_TABSTOP Then sRet = sRet & "WS_TABSTOP Or "
     If (lVal And WS_MINIMIZEBOX) = WS_MINIMIZEBOX Then sRet = sRet & "WS_MINIMIZEBOX Or "
     If (lVal And WS_MAXIMIZEBOX) = WS_MAXIMIZEBOX Then sRet = sRet & "WS_MAXIMIZEBOX Or "
     If (lVal And WS_CAPTION) = WS_CAPTION Then sRet = sRet & "WS_CAPTION Or "
     If (lVal And WS_TILED) = WS_TILED Then sRet = sRet & "WS_TILED Or "
     If (lVal And WS_ICONIC) = WS_ICONIC Then sRet = sRet & "WS_ICONIC Or "
     If (lVal And WS_SIZEBOX) = WS_SIZEBOX Then sRet = sRet & "WS_SIZEBOX Or "
     If (lVal And WS_TILEDWINDOW) = WS_TILEDWINDOW Then sRet = sRet & "WS_TILEDWINDOW Or "
     If (lVal And WS_OVERLAPPEDWINDOW) = WS_OVERLAPPEDWINDOW Then sRet = sRet & "WS_OVERLAPPEDWINDOW Or "
     If (lVal And WS_POPUPWINDOW) = WS_POPUPWINDOW Then sRet = sRet & "WS_POPUPWINDOW Or "
     If (lVal And WS_CHILDWINDOW) = WS_CHILDWINDOW Then sRet = sRet & "WS_CHILDWINDOW Or "
    If sRet = "" Then sRet = "(unknown)"
    If Right$(sRet, 4) = " Or " Then
        sRet = Left$(sRet, Len(sRet) - 4)
    End If
    dbg_GetWindowStylesStr = sRet
    End Function
    
    Private Function dbg_LookUpSHCNE(uMsg As Long) As String
    Dim bFlagI As Boolean
    If (uMsg And SHCNE_INTERRUPT) = SHCNE_INTERRUPT Then
        bFlagI = True
        uMsg = uMsg And Not SHCNE_INTERRUPT
    End If
    Select Case uMsg
    Case &H1: dbg_LookUpSHCNE = "SHCNE_RENAMEITEM"
    Case &H2: dbg_LookUpSHCNE = "SHCNE_CREATE"
    Case &H4: dbg_LookUpSHCNE = "SHCNE_DELETE"
    Case &H8: dbg_LookUpSHCNE = "SHCNE_MKDIR"
    Case &H10: dbg_LookUpSHCNE = "SHCNE_RMDIR"
    Case &H20: dbg_LookUpSHCNE = "SHCNE_MEDIAINSERTED"
    Case &H40: dbg_LookUpSHCNE = "SHCNE_MEDIAREMOVED"
    Case &H80: dbg_LookUpSHCNE = "SHCNE_DRIVEREMOVED"
    Case &H100: dbg_LookUpSHCNE = "SHCNE_DRIVEADD"
    Case &H200: dbg_LookUpSHCNE = "SHCNE_NETSHARE"
    Case &H400: dbg_LookUpSHCNE = "SHCNE_NETUNSHARE"
    Case &H800: dbg_LookUpSHCNE = "SHCNE_ATTRIBUTES"
    Case &H1000: dbg_LookUpSHCNE = "SHCNE_UPDATEDIR"
    Case &H2000: dbg_LookUpSHCNE = "SHCNE_UPDATEITEM"
    Case &H4000: dbg_LookUpSHCNE = "SHCNE_SERVERDISCONNECT"
    Case &H8000&: dbg_LookUpSHCNE = "SHCNE_UPDATEIMAGE"
    Case &H10000: dbg_LookUpSHCNE = "SHCNE_DRIVEADDGUI"
    Case &H20000: dbg_LookUpSHCNE = "SHCNE_RENAMEFOLDER"
    Case &H40000: dbg_LookUpSHCNE = "SHCNE_FREESPACE"
    Case &H4000000: dbg_LookUpSHCNE = "SHCNE_EXTENDED_EVENT"
    Case &H8000000: dbg_LookUpSHCNE = "SHCNE_ASSOCCHANGED"
    Case &H2381F: dbg_LookUpSHCNE = "SHCNE_DISKEVENTS"
    Case &HC0581E0: dbg_LookUpSHCNE = "SHCNE_GLOBALEVENTS"
    Case &H7FFFFFFF: dbg_LookUpSHCNE = "SHCNE_ALLEVENTS"
    Case &H80000000: dbg_LookUpSHCNE = "SHCNE_INTERRUPT"
    End Select
    If bFlagI Then dbg_LookUpSHCNE = dbg_LookUpSHCNE & " Or SHCNE_INTERRUPT"
    End Function
    
    Private Sub dbg_chkdupes(sz As String, i As Long)
    Dim j As Long
    For j = 0 To UBound(uColData)
        If j <> i Then
            If (uColData(j).szDisplayName = sz) And (uColData(j).NoList = False) Then
                DebugAppend "Dupe of " & sz & "," & i & ": " & uColData(j).szSystemName & "," & j
            End If
        End If
    Next j
    End Sub
    Private Function dbg_sfromlarray(ar() As LongPtr) As String
    Dim sz As String
    Dim i As Long
    For i = LBound(ar) To UBound(ar)
        sz = sz & ar(i) & ","
    Next i
    sz = Left$(sz, Len(sz) - 1)
    sz = "{" & sz & "}"
    dbg_sfromlarray = sz
    End Function
    Private Sub dbg_stringbytes(s As String, Optional bOut As Boolean = False)
    Dim i As Long
    Dim z As String
    For i = 1 To Len(s)
        z = z & Format$(Hex$(AscW(Mid(s, i, 1))), "00") & " "
    Next i
    'If bOut Then
        DebugAppend "StringBytes(" & s & ")", 9
        DebugAppend z, 9
    'Else
    '    Debug.Print "StringBytes(" & s & ")"
    '    Debug.Print z
    'End If
    End Sub
    
    Private Sub dbg_printbytes(bt() As Byte, Optional nMax As Long = 0)
    Dim i As Long
    Dim sOut As String
    Dim nLim As Long
    If nMax Then
        nLim = nMax
    Else
        nLim = UBound(bt)
    End If
    For i = LBound(bt) To nLim
        sOut = sOut & Hex$(bt(i)) & " "
    Next i
    DebugAppend "bytes=" & sOut, 22
    End Sub
    
    Private Sub dbg_printwchar(wc() As Integer)
    Dim i As Long
    Dim sOut As String
    For i = 0 To UBound(wc)
        sOut = sOut & Format(CStr(wc(i)), "00")
    Next i
    DebugAppend sOut
    End Sub
    
    Private Function pvShiftState() As Integer
      Dim lS As Integer
        If (GetAsyncKeyState(vbKeyShift) < 0) Then lS = lS Or vbShiftMask
        If (GetAsyncKeyState(vbKeyMenu) < 0) Then lS = lS Or vbAltMask
        If (GetAsyncKeyState(vbKeyControl) < 0) Then lS = lS Or vbCtrlMask
        pvShiftState = lS
    End Function
    
 
    
    Private Sub pvSetIPAO()
    DebugAppend "pvSetIPAO", 3
    ActivateIPAO Me

    End Sub
    
    Private Sub IOleInPlaceActiveObjectVB_TranslateAccelerator(ByRef Handled As Boolean, ByRef RetVal As Long, ByVal hwnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal Shift As Long) Implements IOleInPlaceActiveObjectVB.TranslateAccelerator

    Dim pMsg As MSG
    pMsg.hWnd = hwnd
    pMsg.wParam = wParam
    pMsg.lParam = lParam
    pMsg.message = wMsg
    Handled = pvTranslateAccel(pMsg)

    End Sub
    
    Private Function pvTranslateAccel(pMsg As MSG) As Boolean
        DebugAppend "pvTranslateAccel", 2
        Const IOleObject_GetClientSite As Long = 4 ' 2 From IUnknown + 2 Ordinal
        Dim pOleObject      As Long 'IOleObject
        Dim pOleControlSite As Long 'IOleControlSite
        Dim uiid As UUID
        
        On Error Resume Next
        Select Case pMsg.message
            Case WM_KEYDOWN, WM_KEYUP
                Select Case pMsg.wParam
                    Case vbKeyTab
                        If pMsg.message = WM_KEYDOWN Then
                        bFlagTabProc = False
                        DebugAppend "pvTranslateAccel->vbKeyTab", 2
                        Dim hNext As LongPtr
                        Dim bkds As Boolean
                        bkds = ((GetKeyState(VK_SHIFT) And &H80) = &H80)
                        hNext = GetNextTabHandle(hFocused, bkds)
                        DebugAppend "hLast=" & dbg_lkuph(hFocused) & ",hNext=" & dbg_lkuph(hNext) & ",hLVS=" & hLVS, 3
                        If hNext <> -1& Then
                            DebugAppend "Send focus to: " & hNext & " from " & hFocused, 2
    '                        SetFocusAPI UserControl.ContainerHwnd
                            hFocusFwd = hNext
                            SetFocusAPI hNext
                            pvTranslateAccel = True
                            bFlagTabProc = True
                            Exit Function
                        End If
                        End If
                        If bFlagTabProc = True Then Exit Function
    '                    Debug.Print "Proceed to control site"
    '                    If (pvShiftState() And vbCtrlMask) Then
    '                        Call IIDFromString(StrPtr(sIID_IOleObject), uiid)
    '                        Call CallInterface(ptrMe, IUnknown_Exports.QueryInterface, 2, VarPtr(uiid), VarPtr(pOleObject))
    '                        Call CallInterface(pOleObject, IOleObject_GetClientSite, 1, VarPtr(pOleControlSite))
    '                        If pOleControlSite Then
    '                            Call IIDFromString(StrPtr(sIID_IOleControlSite), uiid)
    '                            Call CallInterface(pOleControlSite, IUnknown_Exports.QueryInterface, 2, VarPtr(uiid), VarPtr(pOleControlSite))
    '                            Call CallInterface(pOleControlSite, 7, 2, VarPtr(pMsg), pvShiftState() And vbShiftMask)
    '                        End If
    '                    End If
    '                    pvTranslateAccel = False
                    Case vbKeyUp, vbKeyDown, vbKeyLeft, vbKeyRight, vbKeyHome, vbKeyEnd, vbKeyPageDown, vbKeyPageUp
                        DebugAppend "ArrowKey hFocused=" & hFocused & ",hLVC=" & hLVC & ",hEd=" & txtColCX.hWnd, 2
                        Call SendMessage(hFocused, pMsg.message, pMsg.wParam, ByVal pMsg.lParam)
                        pvTranslateAccel = True
                End Select
        End Select
        On Error GoTo 0
    End Function
    
    
    #End Region

    #Region "WndProcs"
    
    
    '=======================================================================================
    'SUBCLASSING PROCEDURES AND IPAO CODE
    'WARNING: Do not add any additional procedures or otherwise alter the order of the following
    '         34 ordinals, as they're used with self-subclass/self-callback code-- order dependent!
    'The following procedures must be at the end, in this order:
    '@1: ucWndProc - ListView and UserControl subclass
    '@2: LVSortProc - Main ListView sort callback
    '@3: LabelEditWndProc - ListView LabelEdit edit control subclass
    '@4: CBWndProc - ComboBoxEx subclass
    '@5: DetailHeaderWndProc - Detail Pane static control subclass
    '@6: DetailBoxWndProc - Common subclass for all edit controls in Detail Pane
    '@7: LVColSortProc - Column Select ListView sort callback
    '@8: ColWndProc - Column Select frame subclass
    '@9: BKWndProc - Back ThemeButton subclass
    '@10: FWWndProc - Forward ThemeButton subclass
    '@11: FocusTimerProc - SetFocusOnFiles/SetFocusOnDropdown timer callback.
    '@12: SearchBoxWndProc - The search textbox in the control box.
    '@13: FocusTimerProc2 - Search box focus timer callback.
    '@14: SearchDTWndProc - Search options date/time notify subclass
    '@15: AltSearchBoxWndProc - Textbox when searching with navbar disabled
    '@16: SearchEditBkWndProc - Keep search box backgrounds white
    '@17: ProgWndProc - Draws the text and icon on the progress bar
    '@18: AddColTimerProc - Allows adding a custom column to return the proper id
    '@19: LVCWndProc - Proc for the main hWnd messages of the Column List View; for re-ordering items
    '@20: LVSortProcAdv - Advanced sorting callback
    '@21: HdrWndProc - ListView Header, for focus
    '@22: CBDTWndProc - Details Combobox, for focus
    '@23: DTSWndProc - Detail Sizer proc, to restrict to y-axis movement only
    '@24: CtlBoxWndProc - Control box proc for Up/View/Bkm/StdBackFwd button notifications
    
    'If you subclass something else or create a new callback, add it above @20 as ordinal 21, not
    'at the bottom after @1. The sequence in place must not be changed.
    '--------
    
    'Note: This twinBASIC port is not sensitive to the order or location at this time, but best not
    '      to change it or add code after it for future compatibility reasons.
    
    
    
    '@24
    Private Function CtlBoxWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    Select Case uMsg
        Case WM_COMMAND
            Dim lCode As Long
            lCode = HiWord(CLng(wParam))
            Select Case lCode
                Case BN_CLICKED
                    Select Case lParam
                        Case hUpButton: If m_LockNav = False Then OpenParent
                        Case hViewButton: ShowViewMenu
                        Case hBkmButton: ShowBookmarkMenu
                        Case hStdBackButton: DoBack
                        Case hStdFwdButton: DoForward
                    End Select
                    
                Case BN_SETFOCUS
                    If (lParam = hUpButton) Or (lParam = hViewButton) Or (lParam = hBkmButton) Or (lParam = hStdBackButton) Or (lParam = hStdFwdButton) Then
                        DebugAppend "CBoxBtnSetFocus", 2
                        hFocused = lParam
                        Dim dwStyle As Long
                        dwStyle = CLng(GetWindowLong(lParam, GWL_STYLE))
                        dwStyle = dwStyle Or BS_DEFPUSHBUTTON
                        SetWindowLong lParam, GWL_STYLE, dwStyle
                    End If
                    
                Case BN_KILLFOCUS
                    If (lParam = hUpButton) Or (lParam = hViewButton) Or (lParam = hBkmButton) Or (lParam = hStdBackButton) Or (lParam = hStdFwdButton) Then
                        DebugAppend "CBoxBtnKillFocus", 2
                        SendMessage lParam, BM_SETSTATE, 0, ByVal 0&
                        Dim dwStyle2 As Long
                        dwStyle2 = CLng(GetWindowLong(lParam, GWL_STYLE))
                        dwStyle2 = dwStyle2 And Not BS_DEFPUSHBUTTON
                        SetWindowLong lParam, GWL_STYLE, dwStyle2
                    End If
            End Select
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf CtlBoxWndProc, uIdSubclass)
    End Select
    CtlBoxWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@23
    Private Function DTSWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    If uMsg = WM_MOVING Then
        Dim tPos As RECT
        CopyMemory tPos, ByVal lParam, LenB(tPos)
        Dim bHd As Boolean
        If tPos.Left <> mDTSLeft Then
            tPos.Left = mDTSLeft
            bHd = True
        End If
        If tPos.Right <> mDTSRight Then
            tPos.Right = mDTSRight
            bHd = True
        End If
        If bHd Then
            CopyMemory ByVal lParam, ByVal VarPtr(tPos), LenB(tPos)
            ' lReturn = 1
            ' bHandled = True
            DTSWndProc = 1
            Exit Function
        End If
    End If
    
    If uMsg = WM_DESTROY Then
        Call UnSubclass2(lng_hWnd, AddressOf DTSWndProc, uIdSubclass)
    End If
    DTSWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@22
    Private Function CBDTWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    If uMsg = WM_SETFOCUS Then
        hFocused = lng_hWnd
        pvSetIPAO
    End If
    
    If uMsg = WM_DESTROY Then
        Call UnSubclass2(lng_hWnd, AddressOf CBDTWndProc, uIdSubclass)
    End If
    CBDTWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@21
    Private Function HdrWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    If uMsg = WM_KEYDOWN Then
        If wParam = vbKeyTab Then
            DoCBFocus
        End If
    End If
    If uMsg = WM_SETFOCUS Then
    '    DebugAppend "HdrWndProc WM_SETFOCUS"
        hFocused = lng_hWnd
    End If
    If uMsg = WM_DESTROY Then
        Call UnSubclass2(lng_hWnd, AddressOf HdrWndProc, uIdSubclass)
    End If
    HdrWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@20
    Private Function LVSortProcAdv(ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal lParamSort As LongPtr) As Long
    On Error GoTo e0
    Dim hr As Long
    'Sort routine utilizing the IShellFolder interface:
    If ((bColIsMapped = True) And (mAlwaysSortWithISF = True)) Then  'Or ((lParamSort And eSortName) = eSortName)Or ((lParamSort And eSortType) = eSortType) Then  'Or ((lParamSort And eSortDateM) = eSortDateM) Then
        
        Dim pidlRel1 As LongPtr, pidlRel2 As LongPtr
        pidlRel1 = LVEntries(lParam1).pidlRel
        pidlRel2 = LVEntries(lParam2).pidlRel
        ' If (lParamSort And eSortName) = eSortName Then
        '    hr = psfCur.CompareIDs(0&, pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortSize) = eSortSize) And (lDefColISF(1) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortType) = eSortType) And (lDefColISF(2) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2) '
        ' ElseIf ((lParamSort And eSortDateM) = eSortDateM) And (lDefColISF(3) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(3), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortDateC) = eSortDateC) And (lDefColISF(4) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(4), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortDateA) = eSortDateA) And (lDefColISF(5) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(5), pidlRel1, pidlRel2)
        ' Else
        '     If bColIsMapped Then
        '       hr = psfCur.CompareIDs(nSFColComp, pidlRel1, pidlRel2)
        '     Else
        '       GoTo stdsort
        '     End If
        ' End If
        If (lParamSort And eSortName) = eSortName Then
           hr = psfCur.CompareIDs(0&, pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortSize) = eSortSize) And (lDefColISF(1) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortType) = eSortType) And (lDefColISF(2) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2) '
        ElseIf ((lParamSort And eSortDateM) = eSortDateM) And (lDefColISF(3) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(3), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortDateC) = eSortDateC) And (lDefColISF(4) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(4), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortDateA) = eSortDateA) And (lDefColISF(5) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(5), pidlRel1, pidlRel2)
        Else
            If bColIsMapped Then
              hr = psfCur.CompareIDs(nSFColComp, pidlRel1, pidlRel2)
            Else
              GoTo stdsort
            End If
        End If
        If (hr >= NOERROR) Then
          If (lParamSort And SORT_ASCENDING) = 0 Then
            LVSortProcAdv = LoWord(hr)
          Else
            LVSortProcAdv = LoWord(hr) * -1
          End If
        End If
    Else
    'Standard sorting routine:
    stdsort:
        If (mDispParAndIndt = True) And (lCurMaxInd > 0&) Then
            If (LVEntries(lParam1).lIndent < lCurMaxInd) Or (LVEntries(lParam2).lIndent < lCurMaxInd) Then
                If LVEntries(lParam1).lIndent < LVEntries(lParam2).lIndent Then
                    LVSortProcAdv = 0
                ElseIf LVEntries(lParam1).lIndent = LVEntries(lParam2).lIndent Then
                    LVSortProcAdv = 1
                Else
                    LVSortProcAdv = 2
                End If
                Exit Function
            End If
        End If
        
        Dim i1f As Boolean, i2f As Boolean
        i1f = LVEntries(lParam1).bFolder
        i2f = LVEntries(lParam2).bFolder
        If m_BrowseZip Then
            If LVEntries(lParam1).bZip = True Then i1f = False
            If LVEntries(lParam2).bZip = True Then i2f = False
        End If
    
        If (i1f = True) Xor (i2f = True) Then 'When comparing a folder to a file, fix the outcome to keep folders separated.
                                              'But, when it's two folders, we do want to sort them among eachother.
    
    '        DebugAppend LVEntries(lParam1).sName & "?" & LVEntries(lParam1).bFolder
    '        DebugAppend LVEntries(lParam2).sName & "?" & LVEntries(lParam2).bFolder
            If (i1f = True) Then
                If LVEntries(lParam1).bZip = False Then
                    hr = 1
                    GoTo postcmp
                End If
            End If
            If (i2f = True) Then
                If LVEntries(lParam2).bZip = False Then
                    hr = -1
                    GoTo postcmp
                End If
            End If
        End If
        
        If (lParamSort And eSortExtNum) = eSortExtNum Then
            Dim db1 As Double, db2 As Double
            db1 = LVEntries(lParam1).ExtColData(ecdKey).vRaw
            db2 = LVEntries(lParam2).ExtColData(ecdKey).vRaw
            If db1 > db2 Then
                hr = -1
            ElseIf db1 = db2 Then
                hr = 0
            Else
                hr = 1
            End If
        ElseIf (lParamSort And eSortExtDate) = eSortExtDate Then
            Dim ft1 As FILETIME, ft2 As FILETIME
            Call VariantToFileTime(LVEntries(lParam1).ExtColData(ecdKey).vRaw, 0&, ft1)
            Call VariantToFileTime(LVEntries(lParam2).ExtColData(ecdKey).vRaw, 0&, ft2)
            hr = CompareFileTime(VarPtr(ft2), VarPtr(ft1))
        Else
            Dim s1 As String, s2 As String
            s1 = LVEntries(lParam1).ExtColData(ecdKey).sDisp
            If s1 = "" Then s1 = " "
            If s1 = vbNullChar Then s1 = " "
            s2 = LVEntries(lParam2).ExtColData(ecdKey).sDisp
            If s2 = "" Then s2 = " "
            If s2 = vbNullChar Then s2 = " "
            hr = CompareStringEx(StrPtr(mAdvSortLocale), mAdvSortFlags, StrPtr(s1), Len(s1), StrPtr(s2), Len(s2), 0&, 0&, 0&)
            hr = hr - 2
        End If
    postcmp:
        If (lParamSort And SORT_ASCENDING) Then
            Select Case hr
                Case -1: LVSortProcAdv = 0
                Case 0: LVSortProcAdv = 1
                Case 1: LVSortProcAdv = 2
            End Select
        Else
            Select Case hr
                Case -1: LVSortProcAdv = 2
                Case 0: LVSortProcAdv = 1
                Case 1: LVSortProcAdv = 0
            End Select
        End If
    End If
    Exit Function
    
    e0:
    DebugAppend "LVSortProcAdv->Error: " & Err.Description & ", 0x" & Hex$(hr)
    End Function
    
    '@19
    Private Function LVCWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
                          
    Select Case uMsg
    
        Case WM_SETFOCUS
            If lng_hWnd = hLVC Then
                'If hFocused <> hLVC Then
                    DebugAppend "SetFocus hLVC", 2
                    hFocused = hLVC
                    Call pvSetIPAO
                'End If
            Else
                DebugAppend "SetFocus LVCWndProc " & lng_hWnd, 2
            End If
            
        Case WM_KILLFOCUS
            If IsVBCtl(hFocusFwd) Then hFocused = hFocusFwd
            
        Case WM_KEYDOWN
            If wParam = vbKeyTab Then
                DebugAppend "Tab hLVC to ColCX", 2
                SetFocusAPI txtColCX.hWnd
            End If
            
        Case WM_MOUSELEAVE
            If bLVCDragging Then
                bLVCDragging = False
                LVSetInsertMark hLVC, -1&
            End If
    '
        Case WM_MOUSEMOVE
            If bLVCDragging Then
                Dim ppt As POINT
                GetCursorPos ppt
                Call ScreenToClient(hLVC, ppt)
                Dim LVHTI As LVHITTESTINFO
                LVHTI.PT.x = ppt.x
                LVHTI.PT.y = ppt.y
                ListView_HitTestEx hLVC, LVHTI
                If LVHTI.iItem <> lvcCurDragLoc Then
                    If (LVHTI.Flags And LVHT_ONITEM) Then
                        Dim lp As LongPtr
                        lp = GetLVItemlParam(hLVC, LVHTI.iItem)
                        DebugAppend "OnItem " & uColData(lp).szDisplayName
                        LVSetInsertMark hLVC, LVHTI.iItem
                    Else
                        LVSetInsertMark hLVC, -1&
                    End If
                    lvcCurDragLoc = LVHTI.iItem
                End If
            End If
            
        Case WM_LBUTTONUP
            If bLVCDragging = True Then
                LVSetInsertMark hLVC, -1&
                bLVCDragging = False
                LVMoveItem hLVC, lvcCurSel, IIf(lvcCurSel < lvcCurDragLoc, lvcCurDragLoc - 1&, lvcCurDragLoc)
            End If
            
    '    Case WM_NOTIFY
    '        Dim NM As NMHDR
    '        CopyMemory NM, ByVal lParam, LenB(NM)
    '        Select Case NM.Code
    '            Case NM_SETFOCUS
    '                hFocused = NM.hWndFrom
    '                pvSetIPAO
    '        End Select
            
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf LVCWndProc, uIdSubclass)
    End Select
    LVCWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@18
    Private Sub AddColTimerProc(ByVal hWnd As LongPtr, ByVal uMsg As Long, ByVal TimerID As LongPtr, ByVal Tick As Long)
        KillTimer hWnd, TimerID
        ExecCustomCol
    End Sub
    
    '@17
    Private Function ProgWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    If uMsg = WM_DESTROY Then
            Call UnSubclass2(lng_hWnd, AddressOf ProgWndProc, uIdSubclass)
    End If
    ProgWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    Select Case uMsg
    
        Case WM_PAINT
            Dim hDC As LongPtr
            Dim lScale As Long, ny As Long
            hDC = GetDC(hLoadMarq)
            Dim rc As RECT
            SelectObject hDC, m_hFontDtTxt
            
            GetClientRect hLoadMarq, rc
            rc.Left = rc.Left + (2 * m_ScaleX)
            SetBkMode hDC, TRANSPARENT
            If himlPtr16 Then
                lScale = (16 * m_ScaleX)
                ny = (rc.Bottom - lScale) / 2
                ImageList_Draw himlPtr16, nIcoForMq, hDC, rc.Left, ny, ILD_TRANSPARENT
                rc.Left = rc.Left + lScale
            End If
            DrawText hDC, StrPtr(sMarqText), -1, rc, DT_LEFT Or DT_VCENTER Or DT_SINGLELINE
            ReleaseDC hLoadMarq, hDC
    

    End Select

    End Function
    
    '@16
    Private Function SearchEditBkWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    
    If bFlagSearchDisable = False Then
    If (lParam = hSearchBox) Or (lParam = hSearchBoxAlt) Then
        If (uMsg = WM_CTLCOLOREDIT) Or (uMsg = WM_CTLCOLORSTATIC) Then
            Dim clrb As Long, clrf As Long
            OleTranslateColor clrSbBack, 0&, clrb
            OleTranslateColor clrSbFore, 0&, clrf
            SetBkMode wParam, TRANSPARENT
            SetBkColor wParam, clrb
            SetTextColor wParam, clrf
            ' lReturn = CreateSolidBrush(clrb)
            ' bHandled = True
            SearchEditBkWndProc = CreateSolidBrush(clrb)
            Exit Function
        End If
    End If
    End If
    
    If uMsg = WM_DESTROY Then
        Call UnSubclass2(lng_hWnd, AddressOf SearchEditBkWndProc, uIdSubclass)
    End If
    SearchEditBkWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
           
    
    End Function
    
    '@15
    Private Function AltSearchBoxWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    '    If uMsg = WM_SETFOCUS Then
    '                DebugAppend "AltSearchBox WM_SETFOCUS"
    '    End If
    '
    Select Case uMsg
         Case WM_SETFOCUS
            DebugAppend "SearchBoxAltSetFoccus " & hSearchBox, 2
            hFocused = hSearchBoxAlt
            pvSetIPAO
        
        Case WM_NOTIFYFORMAT
            'If bBefore = True Then
                DebugAppend "WM_NOTIFYFORMAT on AltSearchBoxWndProc", 9
                ' lReturn = NFR_UNICODE
                ' bHandled = True
                AltSearchBoxWndProc = NFR_UNICODE
                Exit Function
            'End If
            
        Case WM_KILLFOCUS
            bSbAltHasFocus = False
            
             
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf AltSearchBoxWndProc, uIdSubclass)
    End Select
    AltSearchBoxWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
            
    End Function
    
    '@14
    Private Function SearchDTWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
                          
    Select Case uMsg
        Case WM_SETFOCUS
                hFocused = lng_hWnd
                pvSetIPAO
            
        Case WM_NOTIFY
            Dim NM As NMHDR
            CopyMemory NM, ByVal lParam, LenB(NM)
            Select Case NM.code
                Case DTN_DATETIMECHANGE
                    Dim nmdtc As NMDATETIMECHANGE
                    CopyMemory ByVal VarPtr(nmdtc), ByVal lParam, LenB(nmdtc)
                    If dwRefData = 1& Then
                        stShLast1 = nmdtc.ST
                        DebugAppend "SetLastSearchDT1 " & CStr(SystemTimeToDate(stShLast1))
                    ElseIf dwRefData = 2& Then
                        stShLast2 = nmdtc.ST
                        DebugAppend "SetLastSearchDT2 " & CStr(SystemTimeToDate(stShLast2))
                    End If
                Case NM_SETFOCUS
                    hFocused = NM.hWndFrom
                    pvSetIPAO
            End Select
             
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf SearchDTWndProc, uIdSubclass)
    End Select
    SearchDTWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
            
    
    End Function
    
    '@13
    Private Sub FocusTimerProc2(ByVal hWnd As LongPtr, ByVal uMsg As Long, ByVal TimerID As LongPtr, ByVal Tick As Long)
        KillTimer hWnd, TimerID
        'Not currently used
    End Sub
    
    '@12 - This procedure must be twelfth to last in this control.
    Private Function SearchBoxWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    Dim nDP As Long

    'before: WM_NOTIFYFORMAT, WM_LBUTTONDOWN, WM_LBUTTONUP
    Select Case uMsg
        Case WM_NOTIFYFORMAT 'Don't believe this is needed but not 100% sure
            DebugAppend "WM_NOTIFYFORMAT on SearchBoxWndProc", 9
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            SearchBoxWndProc = NFR_UNICODE
            Exit Function
            
            
        Case WM_CTLCOLOREDIT
            If bFlagSearchDisable = False Then
                Dim clrt As Long, clrn As Long
                OleTranslateColor clrSbBack, 0&, clrt
                OleTranslateColor clrSbFore, 0&, clrn
                SetBkMode wParam, OPAQUE
                SetBkColor wParam, clrt
                SetTextColor wParam, clrn
                ' lReturn = CreateSolidBrush(clrn)
                ' bHandled = True
                SearchBoxWndProc = CreateSolidBrush(clrn)
                Exit Function
            End If
        
          Case WM_LBUTTONDBLCLK
                If bBlankLoaded = True Then
                    If mPlaySnd Then
                        If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                    End If
                    UpdateStatus mStrBlankNoOp
                    Exit Function
                End If
                SearchOptionsPopup
            
        Case WM_KILLFOCUS
            DebugAppend "SearchBox->WM_KILLFOCUS", 3
            bSbHasFocus = False
            If IsVBCtl(hFocusFwd) Then hFocused = hFocusFwd
            
        Case WM_PAINT
            SearchBoxWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
            PaintIcon lng_hWnd
            Exit Function
            
        Case WM_MOUSEMOVE
            UpdateStatus mSrchTip
            If wParam Then
                PaintIcon lng_hWnd
            End If
        
        Case WM_KEYDOWN, WM_KEYUP, WM_CHAR
            PaintIcon lng_hWnd
            SetFocusAPI hSearchBox
            If uMsg = WM_KEYUP Then
                If wParam = VK_RETURN Then
    ''Old search:
    '                Dim sText As String
    '                Dim lLen As Long
    '                lLen = SendMessageW(lng_hWnd, WM_GETTEXTLENGTH, 0, ByVal 0&)
    '                sText = String$(lLen, 0)
    '                Call SendMessageW(lng_hWnd, WM_GETTEXT, lLen + 1, ByVal StrPtr(sText))
    '                dbg_stringbytes sText
    '                DebugAppend "SearchBox::Exec search, spec=" & sText
    '                mSpec = sText
    '                DoFileSearch
    'New Search
    '                bSearchExt = False 'Simple text search; ignore options pane
                    If bBlankLoaded = True Then
                        If mPlaySnd Then
                            If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                        End If
                        UpdateStatus mStrBlankNoOp
                        Exit Function
                    End If
                    
                    UpdateStatus mSearchCD & m_sCurPathDisp
                    mFlagActiveSearch = True
                    If m_sCurPath = sLibRoot2 Then
                        Call ExecSearch(True)
                    Else
                        Call ExecSearch 'Will grab text in condition configure (GetCondition)
                    End If
                    mFlagActiveSearch = False
                    UpdateStatus mSearchDone
    
                End If
            End If
            
        Case WM_LBUTTONDOWN
                SetFocusAPI UserControl.ContainerHwnd
    
        Case WM_LBUTTONUP
            'DebugAppend "Search lbu|chk " & hSearchBox & "=" & lng_hWnd
            SetFocusAPI hSearchBox 'Setting focus at this point lets arrow keys work
           
                    
                    
         Case WM_SETFOCUS
            DebugAppend "SearchBoxSetFoccus " & hSearchBox, 2
            hFocused = hSearchBox
            pvSetIPAO
            
         Case WM_UNICHAR
            If wParam = UNICODE_NOCHAR Then
                ' lReturn = 1
                ' bHandled = True
                SearchBoxWndProc = 1
                Exit Function
            Else
                SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
                ' bHandled = True
                Exit Function
            End If
        
        Case WM_IME_CHAR
            SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
            ' bHandled = True
             Exit Function
             
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf SearchBoxWndProc, uIdSubclass)
    End Select
    SearchBoxWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
            
    End Function
    
    '@11
    Private Sub FocusTimerProc(ByVal hWnd As LongPtr, ByVal uMsg As Long, ByVal TimerID As LongPtr, ByVal Tick As Long)
        KillTimer hWnd, TimerID
        If hWnd = hLVS Then DoSetFocus
        If hWnd = hCombo Then DoCBFocus
    End Sub
    
    '@10 - This procedure must be tenth to last in this control.
    Private Function FWWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
                          
    If bEnableFwd = True Then
        Select Case uMsg
        
            Case WM_MOUSELEAVE
                    pvDrawFwd NAV_FB_NORMAL
            
            Case WM_MOUSEMOVE
                If Not bFwBtnDown Then
                    pvDrawFwd NAV_FB_HOT
                    SetTrackMouseLeave lng_hWnd
                End If
            
            Case WM_LBUTTONDOWN
                pvDrawFwd NAV_FB_PRESSED
                bFwBtnDown = True
            
            Case WM_LBUTTONUP
                pvDrawFwd NAV_FB_NORMAL
                bFwBtnDown = False
                DoForward
            
            Case WM_RBUTTONUP
                ShowHistoryMenu
            Case WM_DESTROY
                Call UnSubclass2(lng_hWnd, AddressOf FWWndProc, uIdSubclass)
        End Select
        FWWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    Else
        If uMsg = WM_DESTROY Then Call UnSubclass2(lng_hWnd, AddressOf FWWndProc, uIdSubclass)
        FWWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End If
    
    End Function
    
    '@9 - This procedure must be ninth to last in this control.
    Private Function BKWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
                          
    If bBackEnable = True Then
        Select Case uMsg
        
            Case WM_MOUSELEAVE
                    pvDrawBack NAV_BB_NORMAL
            
            Case WM_MOUSEMOVE
                If Not bBkBtnDown Then
                    pvDrawBack NAV_BB_HOT
                    SetTrackMouseLeave lng_hWnd
                End If
            
            Case WM_LBUTTONDOWN
                pvDrawBack NAV_BB_PRESSED
                bBkBtnDown = True
            
            Case WM_LBUTTONUP
                pvDrawBack NAV_BB_NORMAL
                bBkBtnDown = False
                DoBack
            Case WM_KEYDOWN
                If (wParam = vbKeySpace) Or (wParam = vbKeyReturn) Then
                    pvDrawBack NAV_BB_PRESSED
                    bBkBtnDown = True
                End If
            Case WM_LBUTTONUP
                pvDrawBack NAV_BB_NORMAL
                bBkBtnDown = False
                DoBack
            Case WM_KEYUP
                If (wParam = vbKeySpace) Or (wParam = vbKeyReturn) Then
                    pvDrawBack NAV_BB_PRESSED
                    bBkBtnDown = True
                    DoBack
                End If
            Case WM_SETFOCUS
                pvDrawBack NAV_BB_HOT
            Case WM_KILLFOCUS
                pvDrawBack NAV_BB_NORMAL
            Case WM_RBUTTONUP
                ShowHistoryMenu
            Case WM_DESTROY
                Call UnSubclass2(lng_hWnd, AddressOf BKWndProc, uIdSubclass)
        End Select
        BKWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    Else
        If uMsg = WM_DESTROY Then Call UnSubclass2(lng_hWnd, AddressOf BKWndProc, uIdSubclass)
        BKWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End If
    End Function
    
    '@8 - This procedure must be eigth to last in this control.
    Private Function ColWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    Select Case uMsg
    
        Case WM_NOTIFYFORMAT
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            ColWndProc = NFR_UNICODE
            Exit Function
        Case WM_SETFOCUS
            hFocused = lng_hWnd
    
        'The following aren't hWnd checked because no other windows should be sending these msgs to this proc
        Case WM_GETMINMAXINFO
            Dim mmi As MINMAXINFO
            Call CopyMemory(mmi, ByVal lParam, LenB(mmi))
    
            mmi.ptMinTrackSize.x = cxMinColWin * m_ScaleX
            mmi.ptMinTrackSize.y = cyMinColWin * m_ScaleY
            mmi.ptMaxSize = mmi.ptMaxTrackSize
    
            Call CopyMemory(ByVal lParam, mmi, LenB(mmi))
        
            ' bHandled = True
            Exit Function
            
        Case WM_SIZE
            Dim cx As Integer, cy As Integer
            Dim rcx As RECT
            cx = LoWord(CLng(lParam))
            cy = HiWord(CLng(lParam))
            DebugAppend "ColWndProc WM_SIZE lParam=" & lParam & ",cx=" & cx & ",cy=" & cy
            DoColSelectResize CLng(cx), CLng(cy)
                
        Case WM_NOTIFY
            If bLoadDone Then
            Dim NM As NMHDR
            CopyMemory NM, ByVal lParam, LenB(NM)
            Select Case NM.code
                Case LVN_ITEMCHANGING
                    If bLVCFlagLoad = False Then
                        Dim nmlv As NMLISTVIEW
                        CopyMemory ByVal VarPtr(nmlv), ByVal lParam, LenB(nmlv)
                        If nmlv.lParam = lDefColIdx(0) Then
                            If nmlv.uChanged <> LVIF_GROUPID Then 'The filter may need to include it... blocked if we don't check
                                If (nmlv.uNewState And LVIS_STATEIMAGEMASK) = 4096 Then
                                
                                DebugAppend "change intercept " & uColData(GetLVItemlParam(hLVC, 0)).szDisplayName & "=" & (nmlv.uNewState And LVIS_STATEIMAGEMASK)
                                ' lReturn = 1
                                ' bHandled = True
                                ColWndProc = 1
                                Exit Function
                                End If
                            End If
                        End If
                    End If
                    
                Case LVN_ITEMCHANGED
                    CopyMemory ByVal VarPtr(nmlv), ByVal lParam, LenB(nmlv)
                    If (nmlv.uNewState And LVIS_SELECTED) = LVIS_SELECTED Then
    '                    Dim iIdx As Long
    '                    iIdx = ListView_GetSelectedItem(hLVC)
    '                    lp = GetLVItemlParam(hLVC, iIdx)
                        txtColCX.Text = uColData(nmlv.lParam).DefWidth
                        DebugAppend "XDefWidth " & uColData(nmlv.lParam).szDisplayName & "=" & uColData(nmlv.lParam).DefWidth
                    End If
                    
                Case LVN_COLUMNCLICK
                    If bLVCAdv Then
                        Dim nCol As Long
                        CopyMemory nmlv, ByVal lParam, LenB(nmlv)
                        nCol = CLng(GetHDItemlParam(hLVCHdr, nmlv.iSubItem))
                        DebugAppend "LVC ColClick " & nCol
                        If nCol = 1 Then
                            mLVCColSort = 1
                        Else
                            mLVCColSort = 0
                        End If
                        If m_ColSortCallback = 0& Then m_ColSortCallback = AddressOf LVColSortProc 'scb_SetCallbackAddr(3&, 7&)
                        Call SendMessage(hLVC, LVM_SORTITEMS, mLVCSort, ByVal m_ColSortCallback)
                        
                        Call LVCSetSortArrow(nCol, CInt(mLVCSort))
                        If mLVCSort = 1 Then
                            mLVCSort = 0
                        Else
                            mLVCSort = 1
                        End If
                    End If
                    
                Case LVN_BEGINDRAG
                    If NM.hWndFrom = hLVC Then
                        lvcCurSel = ListView_GetSelectedItem(hLVC)
                        If lvcCurSel <> LVI_NOITEM Then
                            bLVCDragging = True
                        End If
                    End If
                    
                Case NM_RCLICK
                    If NM.hWndFrom = hLVCHdr Then
                        If IsComCtl6 = False Then LVCColMenu 'The Dropdown button isn't supported without cc6
                        Exit Function
                    End If
                    If NM.hWndFrom = hLVC Then
                        lvcCurSel = ListView_GetSelectedItem(hLVC)
                        If lvcCurSel <> LVI_NOITEM Then
                            LVCColMenu
                            Exit Function
                        End If
                    End If
                    
                Case HDN_FILTERBTNCLICK
                    If Ambient.UserMode Then
                        If lng_hWnd = hLVC Then
                            DebugAppend "LVCFilterButtonClick"
                            Dim tFBC As NMHDFILTERBTNCLICK
                            CopyMemory tFBC, ByVal lParam, LenB(tFBC)
                            LVCApplyFilterbar tFBC.iItem
                        End If
                    End If
                
                Case HDN_BEGINFILTEREDIT
                    DebugAppend "BeginFilterEdit", 2
                        Dim tNMHEADER2 As NMHEADER
                        CopyMemory tNMHEADER2, ByVal lParam, LenB(tNMHEADER2)
                        hFocused = tNMHEADER2.hdr.hWndFrom
                        pvSetIPAO
                        
                Case HDN_FILTERCHANGE
                    If Ambient.UserMode Then
                        DebugAppend "LVCFilterBarChange", 2
                        Dim tNMHEADER As NMHEADER
                        CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                        hFocused = tNMHEADER.hdr.hWndFrom
                        LVCApplyFilterbar tNMHEADER.iItem
                    End If
                    
                Case HDN_DROPDOWN
                    LVCColMenu
                    
                Case UDN_DELTAPOS
                    DebugAppend "DeltaPos"
                    Dim nmud As NMUPDOWN
                    CopyMemory nmud, ByVal lParam, LenB(nmud)
                    
                    Dim lSel As Long
                    lSel = ListView_GetSelectedItem(hLVC)
                    If lSel <> LVI_NOITEM Then
                        Dim lslp As LongPtr
                        Dim lcs As Long
                        lslp = GetLVItemlParam(hLVC, lSel)
                        lcs = ListView_GetCheckState(hLVC, lSel)
                        SendMessage hLVC, LVM_DELETEITEM, lSel, ByVal 0&
                        Dim np As Long
                        
                        If nmud.iDelta > 0 Then
                            np = lSel - 1
                        Else
                            np = lSel + 1
                        End If
                        Dim lNew As Long
                        lNew = InsertLVColItem(uColData(lslp).szDisplayName, lslp, , uColData(lslp).szSystemName, np)
                        If lcs = 1 Then
                            ListView_SetCheckState hLVC, lNew, 1
                        End If
                        ListView_SetSelectedItem hLVC, lNew
                    End If
                        
                    
                End Select
            End If
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf ColWndProc, uIdSubclass)
    End Select
    ColWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@7 - This procedure must be seventh to last in this control.
    Private Function LVColSortProc(ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal lParamSort As LongPtr) As Long
    On Error GoTo e0
    Dim hr As Long
    Dim s1 As String, s2 As String
    
    If mLVCColSort Then
        s1 = uColData(lParam1).szSystemName
        s2 = uColData(lParam2).szSystemName
    Else
        s1 = uColData(lParam1).szDisplayName
        s2 = uColData(lParam2).szDisplayName
    End If
    
    hr = StrCmpLogicalW(StrPtr(s1), StrPtr(s2))
    
    If (lParamSort = 0) Then ' lvwAscending
        Select Case hr
            Case -1: LVColSortProc = 0
            Case 0: LVColSortProc = 1
            Case 1: LVColSortProc = 2
        End Select
    Else
        Select Case hr
            Case -1: LVColSortProc = 2
            Case 0: LVColSortProc = 1
            Case 1: LVColSortProc = 0
        End Select
    End If
        
    Exit Function
    
    e0:
    DebugAppend "LVColSortProc->Error: " & Err.Description & ", 0x" & Hex$(hr)
    End Function
    
    '@6 - This procedure must be sixth to last in this control.
    Private Function DetailBoxWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    Dim nDP As Long
    Dim dwStyle As Long
    
    Select Case uMsg
        Case WM_NOTIFYFORMAT
            DebugAppend "WM_NOTIFYFORMAT on DetailBoxWndProc", 9
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            DetailBoxWndProc = NFR_UNICODE
            Exit Function
        Case WM_MOUSEMOVE
            If lng_hWnd <> hDetailName Then
                nDP = PropDispByHandle(lng_hWnd)
                If tDispProps(nDP).fReadOnly = S_OK Then
                If tDispProps(nDP).bHighlight = False Then
                    dwStyle = CLng(GetWindowLong(lng_hWnd, GWL_STYLE))
                    dwStyle = dwStyle Or WS_BORDER
                    SetWindowLong lng_hWnd, GWL_STYLE, dwStyle
                    SetWindowPos lng_hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
                    tDispProps(nDP).bHighlight = True
                End If
                SetTrackMouseLeave lng_hWnd
                End If
            End If
        
        Case WM_MOUSELEAVE
            If lng_hWnd <> hDetailName Then
                nDP = PropDispByHandle(lng_hWnd)
                If (lng_hWnd <> hDtFocus) And (tDispProps(nDP).bHighlight = True) Then
                    dwStyle = CLng(GetWindowLong(lng_hWnd, GWL_STYLE))
                    dwStyle = dwStyle And Not WS_BORDER
                    SetWindowLong lng_hWnd, GWL_STYLE, dwStyle
                    SetWindowPos lng_hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
                    tDispProps(nDP).bHighlight = False
                End If
            End If
                    
        Case WM_CHAR
            
            If lng_hWnd <> hDetailName Then
                nDP = PropDispByHandle(lng_hWnd)
                If (tDispProps(nDP).bWrite = False) And (tDispProps(nDP).fReadOnly = S_OK) Then
                    DebugAppend "FlagSave " & tDispProps(nDP).sSysName
                    tDispProps(nDP).bWrite = True
                    ShowDtSave
                End If
            End If
         
         Case WM_UNICHAR
            If wParam = UNICODE_NOCHAR Then
                ' lReturn = 1
                ' bHandled = True
                DetailBoxWndProc = 1
                Exit Function
            Else
                SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
                ' bHandled = True
                Exit Function
            End If
        
        Case WM_IME_CHAR
            SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
            ' bHandled = True
            Exit Function
        Case WM_NOTIFY
            Dim NM As NMHDR
            CopyMemory NM, ByVal lParam, LenB(NM)
            Select Case NM.code
                Case WM_NOTIFYFORMAT
                    DebugAppend "NFonDBWndProc.WMN", 9
                Case NM_CLICK
                    DebugAppend "nm_click on DtWndProc; h=" & lng_hWnd
            End Select
        
        Case WM_SETFOCUS
            DebugAppend "DetailBoxSetFocus " & lng_hWnd, 2
            hDtFocus = lng_hWnd
            hFocused = lng_hWnd
            If lng_hWnd <> hDetailName Then
                nDP = PropDispByHandle(lng_hWnd)
                If (tDispProps(nDP).dwDispType = PDDT_DATETIME) And (tDispProps(nDP).fReadOnly = S_OK) Then
                    If tDispProps(nDP).hAlt = 0 Then
                        tDispProps(nDP).hAlt = pvCreateDateTimeCtl(lng_hWnd, nDP)
                        hFocused = tDispProps(nDP).hAlt
                        ShowDtSave
                    End If
                End If
                If (tDispProps(nDP).dwDispType = PDDT_ENUMERATED) And (tDispProps(nDP).fReadOnly = S_OK) Then
                    If tDispProps(nDP).hAlt = 0 Then
                        tDispProps(nDP).hAlt = pvCreatePropComboCtl(lng_hWnd, nDP)
                        hFocused = tDispProps(nDP).hAlt
                        ShowDtSave
                    End If
                End If
                If (tDispProps(nDP).dwDispType = PDDT_NUMBER) And (tDispProps(nDP).fReadOnly = S_OK) Then
                    If tDispProps(nDP).bUnformatNum = False Then
                        'Remove formatting strings... like ISO speed is a number, but shows
                        'as e.g. ISO-550; we need to collapse to just 550
                        Dim sNum As String
                        sNum = CStr(tDispProps(nDP).vNumberValue)
                        SendMessageW tDispProps(nDP).hEdit, WM_SETTEXT, 0&, ByVal StrPtr(sNum)
                        tDispProps(nDP).bUnformatNum = True
                    End If
                End If
            End If
            
            pvSetIPAO
    
        
        Case WM_KILLFOCUS
            If lng_hWnd <> hDetailName Then
                nDP = PropDispByHandle(lng_hWnd)
                If tDispProps(nDP).bHighlight Then
                    dwStyle = CLng(GetWindowLong(lng_hWnd, GWL_STYLE))
                    dwStyle = dwStyle And Not WS_BORDER
                    SetWindowLong lng_hWnd, GWL_STYLE, dwStyle
    '                SetWindowPos lng_hWnd, 0&, 0&, 0&, 0&, 0&, SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
                    tDispProps(nDP).bHighlight = False
                End If
            End If
            hDtFocus = 0&
            If IsVBCtl(hFocusFwd) Then hFocused = hFocusFwd
    
        Case WM_LBUTTONUP
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf DetailBoxWndProc, uIdSubclass)
    End Select
    DetailBoxWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
       
    End Function
    
    '@5 - This procedure must be fifth to last in this control.
    Private Function DetailHeaderWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    Dim nDP As Long
    
    Select Case uMsg
        Case WM_NOTIFYFORMAT
    '        DebugAppend "WM_NOTIFYFORMAT on DTHWndProc", 9
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            DetailHeaderWndProc = NFR_UNICODE
            Exit Function
        Case WM_NOTIFY
            Dim NM As NMHDR
            CopyMemory NM, ByVal lParam, LenB(NM)
            Select Case NM.code
                Case WM_NOTIFYFORMAT
                    'Probably not needed here too but I'm never sure
                    DebugAppend "NFonDBHWndProc.WMN", 9
                    ' lReturn = NFR_UNICODE
                    ' bHandled = True
                    DetailHeaderWndProc = NFR_UNICODE
                    Exit Function
                Case DTN_DATETIMECHANGE
                    DebugAppend "DTN_DTC on dbh/ntf"
                     nDP = PropDispByAlt(NM.hWndFrom)
                    If nDP <> -1 Then
                        Dim stVal As SYSTEMTIME
                        SendMessage tDispProps(nDP).hAlt, DTM_GETSYSTEMTIME, GDT_VALID, ByVal VarPtr(stVal)
                        tDispProps(nDP).stNewForDT = stVal
                        tDispProps(nDP).bUseNewST = True
                    End If
    
            End Select
        
        Case WM_COMMAND
            Dim lCode As Long
            lCode = HiWord(CLng(wParam))
            Select Case lCode
                Case CBN_SELCHANGE
                    DebugAppend "CBN_SELCHANGE on DbxWndProc.WM_COMMAND"
                    nDP = PropDispByAlt(lParam)
                    If nDP <> -1 Then
                        tDispProps(nDP).lEnumeratedNewIndex = CLng(SendMessage(tDispProps(nDP).hAlt, CB_GETCURSEL, 0&, ByVal 0&))
                        tDispProps(nDP).bEnumeratedUseNewIndex = True
                        DebugAppend "initial=" & tDispProps(nDP).sEnumerated(tDispProps(nDP).lEnumeratedInitialIndex) & ",new=" & tDispProps(nDP).sEnumerated(SendMessage(tDispProps(nDP).hAlt, CB_GETCURSEL, 0&, ByVal 0&))
                    End If
            End Select
        
        
        Case WM_CTLCOLORDLG, WM_CTLCOLORSTATIC, WM_CTLCOLOREDIT
            Dim clrt As Long, clrn As Long
            OleTranslateColor clrDtBack, 0&, clrt
            OleTranslateColor clrDtName, 0&, clrn
            If lParam = hDetailName Then
                SetBkMode wParam, TRANSPARENT
                SetBkColor wParam, clrt 'pbDetailPane.BackColor 'RGB(0, 255, 0)
                SetTextColor wParam, clrn 'RGB(12, 0, 0)
                ' lReturn = CreateSolidBrush(clrt) 'pbDetailPane.BackColor) '1
                ' bHandled = True
                DetailHeaderWndProc = CreateSolidBrush(clrt)
                Exit Function
            Else
                If uMsg = WM_CTLCOLOREDIT Then
                    If lParam = hDtFocus Then
                        nDP = PropDispByHandle(lParam)
                        If tDispProps(nDP).fReadOnly = S_OK Then
                            PropDispDestroyPrevAlt
                            SetBkMode wParam, TRANSPARENT
                            SetBkColor wParam, vbWhite
                            ' lReturn = CreateSolidBrush(vbWhite)
                            ' bHandled = True
                            DetailHeaderWndProc = CreateSolidBrush(vbWhite)
                            Exit Function
                       End If
                    Else
                        SetBkMode wParam, TRANSPARENT
                        SetBkColor wParam, clrt 'pbDetailPane.BackColor
                        ' lReturn = CreateSolidBrush(clrt) 'pbDetailPane.BackColor)
                        ' bHandled = True
                        DetailHeaderWndProc = CreateSolidBrush(clrt)
                        Exit Function
                    End If
                End If
            End If
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf DetailHeaderWndProc, uIdSubclass)
    End Select
    DetailHeaderWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    Exit Function
       
    End Function
    
    '@4 - This procedure must be fourth to last in this control.
    Private Function CBWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    
    On Error GoTo e0
    If hLoadMarq Then
     CBWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
     Exit Function
    End If
    Dim sCbText As String
    Dim lSel As Long
    
      Select Case uMsg
        Case WM_NOTIFYFORMAT
            DebugAppend "Got NFMT on CBWndProc"
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            CBWndProc = NFR_UNICODE
            Exit Function
        Case WM_LBUTTONDOWN
    '        If lng_hWnd = hCBEd Then
    '            SetFocusAPI UserControl.ContainerHwnd
    '        End If
        
        Case WM_LBUTTONUP
            If lng_hWnd = hCBEd Then
    '            SetFocusAPI hCBEd
    
                If (m_CbType = SBCT_Dropdown) And (m_EditCB = True) Then
        '            SetFocusAPI hCBEd
                    If bCbEditFocus = False Then
    '                    DebugAppend "CB LBU SETTEXT"
                        SendMessageW hCBEd, WM_SETTEXT, 0, ByVal StrPtr(m_sCurPath)
                        SendMessageW hCBEd, EM_SETSEL, 0&, ByVal Len(m_sCurPath)
                        bCbEditFocus = True
                        ' bHandled = True
                        CBWndProc = 1
                    End If
                End If
            End If
            If (lng_hWnd = hCBEd) Or (lng_hWnd = hCombo) Then
                hFocused = lng_hWnd
            End If
            
        Case WM_SETFOCUS
    '        If (hCBEd <> 0&) And (lng_hWnd = hCBEd) Then
                DebugAppend "CBE SetFocus " & lng_hWnd, 2
                hFocused = lng_hWnd
                pvSetIPAO
    '        End If
            
    
            
        Case WM_KILLFOCUS
            If IsVBCtl(hFocusFwd) Then hFocused = hFocusFwd
            DebugAppend "Got Combo KillFocus, bCbEditFocus=" & bCbEditFocus, 4
            If bCbEditFocus Then
                bCbEditFocus = False
                lSel = CLng(SendMessageW(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                SendMessageW hCombo, CB_SETCURSEL, lSel, ByVal 0&
            End If
            
    
        Case WM_KEYUP
            If lng_hWnd = hCBEd Then
              If (m_CbType = SBCT_Dropdown) And (m_EditCB = True) Then
                If wParam = VK_RETURN Then
                    sCbText = GetComboTextW(hCBEd)
                    RaiseEvent ValidateTextNavigate(sCbText)
                    Me.BrowserPath = sCbText
                ElseIf wParam = VK_ESCAPE Then
                    SendMessageW hCombo, CB_SETCURSEL, nOldCbSel, ByVal 0&
                   
                End If
                
              End If
            End If
            Dim lSelKU As Long
            If (wParam = VK_DOWN) Then
                If bComboOpen = False Then
                    SendMessageW hCombo, CB_SHOWDROPDOWN, 1&, ByVal 0&
                Else
                    Dim lCntCB As Long
                    lCntCB = CLng(SendMessage(hCombo, CB_GETCOUNT, 0&, ByVal 0&))
                    lSelKU = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                    lSelKU = lSelKU + 1&
                    If lSelKU = lCntCB Then
                        lSelKU = lSelKU - 1&
                    End If
                    SendMessage hCombo, CB_SETCURSEL, lSelKU, ByVal 0&
                End If
            End If
            If (wParam = VK_UP) Then
                If bComboOpen = True Then
                    lSelKU = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                    lSelKU = lSelKU - 1&
                    If lSelKU = -1& Then
                        lSelKU = 0&
                    End If
                    SendMessage hCombo, CB_SETCURSEL, lSelKU, ByVal 0&
                End If
            End If
            
        Case WM_COMMAND
            Dim lCode As Long
            lCode = HiWord(CLng(wParam))
            Select Case lCode
                Case CBN_SELCHANGE
                    Dim gcs As Long, gcs2 As Long
                    gcs = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                    nLastCbxSelChg = gcs
                    DebugAppend "CBWndProc::GetCurSel=" & gcs, 4
                    If (m_Mode <> SBCTL_DrivesOnly) Then
                        DirNavigate gcs
                    Else
                        DirSelForDrivesOnly gcs
                    End If
                    gcs2 = CLng(SendMessage(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                    If gcs <> gcs2 Then
    '                If ((m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls)) And ((nExpandSelectedFolderInDropdown < 2)) Then GoTo skpthis
                        DebugAppend "CBWndProc::Correct selchange fail bug, " & gcs & " <> " & gcs2, 4
                        SendMessage hCombo, CB_SETCURSEL, gcs, ByVal 0&
    skpthis:
                    End If
                Case CBN_SETFOCUS
    '                DebugAppend "CBN_SETFOCUS " & dbg_lkuph(lng_hWnd)
                    hFocused = lng_hWnd
                    If m_CbType = SBCT_DropdownList Then
                        pvSetIPAO
                    End If
                Case CBN_KILLFOCUS
    '                DebugAppend "CBN_KILLFOCUS", 4
                    If bCbEditFocus Then
                        DebugAppend "CBN_KILLFOCUS->bCbEditFocus Block", 4
                        bCbEditFocus = False
                        Dim lSel2 As Long
                        lSel2 = CLng(SendMessageW(hCombo, CB_GETCURSEL, 0&, ByVal 0&))
                        SendMessageW hCombo, CB_SETCURSEL, lSel2, ByVal 0&
                    End If
                
                Case CBN_EDITCHANGE
                    Dim sOrTx As String
                    sCbText = GetComboTextW(hCBEd)
                    sOrTx = sCbText
                    RaiseEvent ComboEditChange(sCbText)
                    If sCbText <> sOrTx Then
                        Call SendMessageW(hCBEd, WM_SETTEXT, 0&, ByVal StrPtr(sCbText))
                    End If
    
                Case CBN_DROPDOWN
                    cbSanityCheck1 = GetTickCount()
                    bComboOpen = True
                    RaiseEvent ComboDropdown
                
                Case CBN_CLOSEUP
                    cbSanityCheck2 = GetTickCount()
                    If Abs(cbSanityCheck2 - cbSanityCheck1) < 10 Then
                        DebugAppend "CDB::SC Fail", 4
                        SendMessageW hCombo, CB_SHOWDROPDOWN, 1&, ByVal 0&
                        Exit Function
                    Else
                        bComboOpen = False
                    End If
                    RaiseEvent ComboCloseUp
            End Select
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf CBWndProc, uIdSubclass)
    End Select
    CBWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    Exit Function
    e0:
    DebugAppend "CBWndProc->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    
    End Function
    
    '@3 - This procedure must be third to last in this control.
    Private Function LabelEditWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    'Label Edit handler
    'Label edits are used to rename files, so the in-place edit control is subclassed here
    'to check whether an invalid character has been entered, and if so block it
    
    Dim iCheck As Integer
    Select Case uMsg
        Case WM_NOTIFYFORMAT
        '    lReturn = NFR_UNICODE
        '    bHandled = True
        '    DebugAppend "NFR on LEWndProc", 3
        '    Exit Sub
            LabelEditWndProc = NFR_UNICODE
            DebugAppend "NFR on LEWndProc", 3
            Exit Function
        Case WM_SETFOCUS
            hFocused = lng_hWnd
            If bFlagNewFldr = False Then
                pvSetIPAO
            Else
                bFlagNewFldr = False
            End If
        Case WM_KILLFOCUS
            hFocused = hLVS
            
        Case WM_CHAR
          Select Case wParam
             Case VK_LEFT
                 DebugAppend "LeftArrow"
             Case 47, 92, 60, 62, 58, 42, 124, 63, 34 'Illegal chars /\<>:*|?"
                If mPlaySnd Then
                    If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                End If
                 Call ShowBalloonTipEx(lng_hWnd, "", mRenameIlgChr, TTI_NONE) ' TTI_ERROR)
                 wParam = 0
                '  bHandled = True
                Exit Function
          End Select
        
        Case WM_UNICHAR
            If wParam = UNICODE_NOCHAR Then
                ' lReturn = 1
                ' bHandled = True
                LabelEditWndProc = 1
                Exit Function
            Else
                SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
                ' bHandled = True
                Exit Function
            End If
        
        Case WM_IME_CHAR
            SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
            ' bHandled = True
            Exit Function
        Case WM_PASTE
             iCheck = IsClipboardValidFileName()
             If iCheck = -1 Then
                If mPlaySnd Then
                    If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                End If
                 Call ShowBalloonTipEx(lng_hWnd, "", mRenameIlgChr, TTI_NONE) ' TTI_ERROR)
                '  bHandled = True
                '  Exit Sub
                LabelEditWndProc = 1
                Exit Function
             ElseIf iCheck = -2 Then
                If mPlaySnd Then
                    If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                End If
                 Call ShowBalloonTipEx(lng_hWnd, "", Replace$(mRenameChrLim, "%n", CStr(MAX_PATH)), TTI_NONE) ' TTI_ERROR)
                '  bHandled = True
                '  Exit Sub
                LabelEditWndProc = 1
                Exit Function
             End If
         
         Case WM_NOTIFY
             Dim NM As NMHDR
             CopyMemory NM, ByVal lParam, LenB(NM)
             Select Case NM.code
                 Case WM_NOTIFYFORMAT
                    ' lReturn = NFR_UNICODE
                    ' bHandled = True
                    DebugAppend "NFR on LEWndProc@WM_NOTIFY", 3
                LabelEditWndProc = NFR_UNICODE
                Exit Function
    '             Case EN_CHANGE
    '                 DebugAppend "EN_CHANGE on LEWndProc"
             End Select
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf LabelEditWndProc, uIdSubclass)
    End Select
    
    LabelEditWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    End Function
    
    '@2 - This procedure must be second to last in this control.
    Private Function LVSortProc(ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal lParamSort As LongPtr) As Long
    On Error GoTo e0
    Dim hr As Long
    'Sort routine utilizing the IShellFolder interface:
    If ((bColIsMapped = True) And (mAlwaysSortWithISF = True)) Then  'Or ((lParamSort And eSortName) = eSortName)Or ((lParamSort And eSortType) = eSortType) Then  'Or ((lParamSort And eSortDateM) = eSortDateM) Then
        
        Dim pidlRel1 As LongPtr, pidlRel2 As LongPtr
        pidlRel1 = LVEntries(lParam1).pidlRel
        pidlRel2 = LVEntries(lParam2).pidlRel
        ' If (lParamSort And eSortName) = eSortName Then
        '    hr = psfCur.CompareIDs(0&, pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortSize) = eSortSize) And (lDefColISF(1) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortType) = eSortType) And (lDefColISF(2) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2) '
        ' ElseIf ((lParamSort And eSortDateM) = eSortDateM) And (lDefColISF(3) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(3), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortDateC) = eSortDateC) And (lDefColISF(4) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(4), pidlRel1, pidlRel2)
        ' ElseIf ((lParamSort And eSortDateA) = eSortDateA) And (lDefColISF(5) >= 0&) Then
        '    hr = psfCur.CompareIDs(lDefColISF(5), pidlRel1, pidlRel2)
        ' Else
        '     If bColIsMapped Then
        '       hr = psfCur.CompareIDs(nSFColComp, pidlRel1, pidlRel2)
        '     Else
        '       GoTo stdsort
        '     End If
        ' End If
        If (lParamSort And eSortName) = eSortName Then
           hr = psfCur.CompareIDs(0&, pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortSize) = eSortSize) And (lDefColISF(1) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortType) = eSortType) And (lDefColISF(2) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(2), pidlRel1, pidlRel2) '
        ElseIf ((lParamSort And eSortDateM) = eSortDateM) And (lDefColISF(3) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(3), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortDateC) = eSortDateC) And (lDefColISF(4) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(4), pidlRel1, pidlRel2)
        ElseIf ((lParamSort And eSortDateA) = eSortDateA) And (lDefColISF(5) >= 0&) Then
           hr = psfCur.CompareIDs(lDefColISF(5), pidlRel1, pidlRel2)
        Else
            If bColIsMapped Then
              hr = psfCur.CompareIDs(nSFColComp, pidlRel1, pidlRel2)
            Else
              GoTo stdsort
            End If
        End If
        If (hr >= NOERROR) Then
          If (lParamSort And SORT_ASCENDING) = 0 Then
            LVSortProc = LoWord(hr)
          Else
            LVSortProc = LoWord(hr) * -1
          End If
        End If
    Else
    'Standard sorting routine:
    stdsort:
        If (mDispParAndIndt = True) And (lCurMaxInd > 0&) Then
            If (LVEntries(lParam1).lIndent < lCurMaxInd) Or (LVEntries(lParam2).lIndent < lCurMaxInd) Then
                If LVEntries(lParam1).lIndent < LVEntries(lParam2).lIndent Then
                    LVSortProc = 0
                ElseIf LVEntries(lParam1).lIndent = LVEntries(lParam2).lIndent Then
                    LVSortProc = 1
                Else
                    LVSortProc = 2
                End If
                Exit Function
            End If
        End If
        
        Dim i1f As Boolean, i2f As Boolean
        i1f = LVEntries(lParam1).bFolder
        i2f = LVEntries(lParam2).bFolder
        If m_BrowseZip Then
            If LVEntries(lParam1).bZip = True Then i1f = False
            If LVEntries(lParam2).bZip = True Then i2f = False
        End If
    
        If (i1f = True) Xor (i2f = True) Then 'When comparing a folder to a file, fix the outcome to keep folders separated.
                                              'But, when it's two folders, we do want to sort them among eachother.
    
    '        DebugAppend LVEntries(lParam1).sName & "?" & LVEntries(lParam1).bFolder
    '        DebugAppend LVEntries(lParam2).sName & "?" & LVEntries(lParam2).bFolder
            If (i1f = True) Then
                If LVEntries(lParam1).bZip = False Then
                    hr = 1
                    GoTo postcmp
                End If
            End If
            If (i2f = True) Then
                If LVEntries(lParam2).bZip = False Then
                    hr = -1
                    GoTo postcmp
                End If
            End If
        End If
        
        If (lParamSort And eSortExtNum) = eSortExtNum Then
            Dim db1 As Double, db2 As Double
            db1 = LVEntries(lParam1).ExtColData(ecdKey).vRaw
            db2 = LVEntries(lParam2).ExtColData(ecdKey).vRaw
            If db1 > db2 Then
                hr = -1
            ElseIf db1 = db2 Then
                hr = 0
            Else
                hr = 1
            End If
        ElseIf (lParamSort And eSortExtDate) = eSortExtDate Then
            Dim ft1 As FILETIME, ft2 As FILETIME
            Call VariantToFileTime(LVEntries(lParam1).ExtColData(ecdKey).vRaw, 0&, ft1)
            Call VariantToFileTime(LVEntries(lParam2).ExtColData(ecdKey).vRaw, 0&, ft2)
            hr = CompareFileTime(VarPtr(ft2), VarPtr(ft1))
        Else
            Dim s1 As String, s2 As String
            s1 = LVEntries(lParam1).ExtColData(ecdKey).sDisp
            If s1 = "" Then s1 = " "
            If s1 = vbNullChar Then s1 = " "
            s2 = LVEntries(lParam2).ExtColData(ecdKey).sDisp
            If s2 = "" Then s2 = " "
            If s2 = vbNullChar Then s2 = " "
            hr = StrCmpLogicalW(StrPtr(s2), StrPtr(s1))
        End If
    postcmp:
        If (lParamSort And SORT_ASCENDING) Then
            Select Case hr
                Case -1: LVSortProc = 0
                Case 0: LVSortProc = 1
                Case 1: LVSortProc = 2
            End Select
        Else
            Select Case hr
                Case -1: LVSortProc = 2
                Case 0: LVSortProc = 1
                Case 1: LVSortProc = 0
            End Select
        End If
    End If
    Exit Function
    
    e0:
    DebugAppend "LVSortProc->Error: " & Err.Description & ", 0x" & Hex$(hr)
    End Function
    
    '@1 - This procedure must be the last in this control.
    '*3
    Private Function ucWndProc(ByVal lng_hWnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal uIdSubclass As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
    
    If (lng_hWnd = hCombo) And (hLoadMarq <> 0) Then Exit Function
    'ucWndProc::Main control WndProc, UserControl.hWnd and ListView hWnd are subclassed to here
    Dim tNMHEADER As NMHEADER
    Dim HDI As HDITEMW, hdlp As Long
    Dim nmlv As NMLISTVIEW
    Dim nCol As Long
    Dim lCnt As Long
    Dim ulAtrrs As Long
    Dim lLen As Long, lSel As Long
    Dim sText As String
    Dim lp As LongPtr
    Dim i As Long, j As Long
    Dim lpCol As Long
    Dim bFound As Boolean
    Dim sColTxt As String
    Static hMenu As LongPtr
    
    On Error GoTo e0
    If lng_hWnd = hLVC Then
        'Not processing the Details enum LV
        Exit Function
    End If
    
    Select Case uMsg
        Case WM_DESTROY
            Call UnSubclass2(lng_hWnd, AddressOf ucWndProc, uIdSubclass)
                        
        Case WM_NOTIFYFORMAT
            'Enable Unicode support
            DebugAppend "Got NFMT on ucWndProc main"
            ' lReturn = NFR_UNICODE
            ' bHandled = True
            ' Exit Sub
            ucWndProc = NFR_UNICODE
            Exit Function
        
        Case WM_MOUSEACTIVATE
    '        If lng_hWnd = UserControl.hWnd Then
                'DebugAppend "WM_MA UC.hWnd", 2
                Call pvSetIPAO
    '            bFirstIPAOEvt = True
    '        End If
        
        Case WM_SETFOCUS
            If lng_hWnd = hLVS Then
    '            If bFirstIPAOEvt = True Then
                If hFocused <> hLVS Then
                    DebugAppend "SetFocus hLVS", 2
                    hFocused = hLVS
                    Call pvSetIPAO
                End If
    '            End If
            End If
        
        
        Case WM_VSCROLL
    '       The best way to do this is still in active development. Some code
    '       I've tried is commented out, if you want to try to improve on it.
            If nLinks > 0 Then
                Dim lkct As Long, nlki As Long
                Dim nTop As Long
                nTop = CLng(SendMessage(hLVS, LVM_GETTOPINDEX, 0&, ByVal 0&))
    '            DebugAppend "TopIndex=" & nTop, 11
    '            If nTop > 0 Then
    '                For lkct = 0 To (nTop - 1)
    '                    DebugAppend "Hide " & lkct & " as below topidx", 11
    '                    ShowWindow hLinks(lkct), SW_HIDE
    '                Next lkct
    '            End If
    '            ShowWindow hLinks(nTop), SW_SHOW
    '            DebugAppend "hLinks(" & nTop & ")=" & hLinks(nTop), 11
    '            For lkct = (nTop) To nLinks - 1
                For lkct = 0 To nLinks - 1
                    nlki = CLng(GetWindowLong(hLinks(lkct), GWL_USERDATA))
                    If (SendMessage(hLVS, LVM_ISITEMVISIBLE, nlki, ByVal 0&) <> 0) And (nlki >= nTop) Then
    '                    DebugAppend "Item " & nlki & " visible", 11
                        ShowWindow hLinks(nlki), SW_SHOW
    '                    UpdateWindow hLinks(lkct)
                        RedrawWindow hLinks(nlki), 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    
                    Else
    '                    DebugAppend "Item " & nlki & " not visible", 11
                        ShowWindow hLinks(nlki), SW_HIDE
    '                    UpdateWindow hLinks(lkct)
                        RedrawWindow hLinks(nlki), 0, 0, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
    
                    End If
                Next lkct
    '            If nTop > 0 Then ShowWindow hLinks(nTop - 2), SW_SHOW
            End If
                              
        Case WM_SHOWWINDOW
            If lng_hWnd = UserControl.hWnd Then
                If Ambient.UserMode Then
                    If wParam = 1 Then
                        If (m_DDMode = SBDD_DragDrop) Or (m_DDMode = SBDD_DragOnly) Then
                            If hLVS Then Attach hLVS
                        End If
                    Else
                        If hLVS Then Detach
                    End If
    
                End If
            End If
            
        Case WM_SIZE
            Call MoveWindow(m_hStatusBar, 0, 0, UserControl.ScaleWidth, cyStatusBar, 0)
            Call pvResizePanels
    
        Case WM_LBUTTONUP
            If lng_hWnd = hLVS Then
    
                Dim nmcht As LVHITTESTINFO
                nmcht.PT.x = LoWord(CLng(lParam))
                nmcht.PT.y = HiWord(CLng(lParam))
                ListView_HitTestEx hLVS, nmcht
    '            DebugAppend "htflags=0x" & Hex$(nmcht.FLAGS) & ",grpid=" & nmcht.iGroup
                If (nmcht.Flags And LVHT_EX_GROUP_SUBSETLINK) = LVHT_EX_GROUP_SUBSETLINK Then
                    DebugAppend "Got subset link click"
                    LVSetSubsetLabel
                    Exit Function
                End If
                bTmrFlag = False
                tmrChangeSet.Enabled = False
                tct1 = 0
            End If
           
        Case WM_KEYDOWN
            If wParam = vbKeyTab Then
                DebugAppend "KD tab", 2
            End If
            
        Case WM_KEYUP, WM_SYSKEYUP, WM_KEYDOWN, WM_SYSKEYDOWN
            Dim bkdA As Boolean, bkds As Boolean, bkdC As Boolean, bCA As Boolean
            bkdA = ((GetKeyState(VK_MENU) And &H80) = &H80)
            bkds = ((GetKeyState(VK_SHIFT) And &H80) = &H80)
            bkdC = ((GetKeyState(VK_CONTROL) And &H80) = &H80)
            If lng_hWnd = hLVS Then
                If (uMsg = WM_KEYUP) Or (uMsg = WM_SYSKEYUP) Then
                    RaiseEvent ListKeyUp(CLng(wParam), bkds, bkdC, bkdA, lParam)
                End If
            End If
            If lng_hWnd = UserControl.hWnd Then
                If (uMsg = WM_KEYDOWN) Or (uMsg = WM_SYSKEYDOWN) Then
                    RaiseEvent BackgroundKeyDown(CLng(wParam), bkds, bkdC, bkdA, lParam)
                End If
                If (uMsg = WM_KEYUP) Or (uMsg = WM_SYSKEYUP) Then
                    RaiseEvent BackgroundKeyUp(CLng(wParam), bkds, bkdC, bkdA, lParam)
                End If
            End If
            
        Case WM_SYSCOLORCHANGE
            If hThemeNav Then Call CloseThemeData(hThemeNav)
            hThemeNav = OpenThemeData(UserControl.hWnd, StrPtr("NAVIGATION"))
            If mExplorerStyle Then
                If lng_hWnd = hLVS Then
                    If Not (m_SubItemProgress = 0) Then
                        If hThemeProg Then Call CloseThemeData(hThemeProg)
                        hThemeProg = OpenThemeData(hLVS, StrPtr("Progress"))
                    End If
                End If
                SetWindowTheme hLVS, StrPtr("explorer"), 0&
            End If
        
        Case WM_SHNOTIFY
            Dim lEvent As Long
            Dim pInfo As LongPtr
            Dim tInfo As SHNOTIFYSTRUCT
            Dim hNotifyLock As LongPtr
            hNotifyLock = SHChangeNotification_Lock(wParam, CLng(lParam), pInfo, lEvent)
            If hNotifyLock Then
                CopyMemory tInfo, ByVal pInfo, LenB(tInfo)
                HandleShellNotify tInfo.dwItem1, tInfo.dwItem2, lEvent
                Call SHChangeNotification_Unlock(hNotifyLock)
            End If
        Case WM_SHNOTIFYB
            Dim lEventB As Long
            Dim pInfoB As LongPtr
            Dim tInfoB As SHNOTIFYSTRUCT
            Dim hNotifyLockB As LongPtr
            hNotifyLockB = SHChangeNotification_Lock(wParam, CLng(lParam), pInfoB, lEventB)
            If hNotifyLockB Then
                CopyMemory tInfoB, ByVal pInfoB, LenB(tInfoB)
                HandleShellNotifyB tInfoB.dwItem1, tInfoB.dwItem2, lEventB
                Call SHChangeNotification_Unlock(hNotifyLockB)
            End If
        
        
        Case WM_MENUSELECT
            If m_StatusBar Then
                Dim szt As String
                Dim lw As Integer
                On Error Resume Next
                
                lw = LoWord_C(CLng(wParam))
    '            DebugAppend "WM_MENUSELECT " & lw
                If lw = 0 Then
                    If mLastSelStr <> "" Then
                        UpdateStatus mLastSelStr
                    Else
                        UpdateStatus mReadyStr
                    End If
                ElseIf lw > 0 Then
                    szt = String$(MAX_PATH, 0&)
                    If (pcm Is Nothing) = False Then
                        If lw = wIDSel Then
                            szt = mSelFileStr
                        ElseIf lw = widBrowse Then
                            szt = mBrowseFileStr
                        ElseIf lw = widCpyNames Then
                            szt = mstrCpyNm
                        ElseIf lw = widCpyPaths Then
                            szt = mstrCpyPth
                        Else
                            Call pcm.GetCommandString(CLng(lw - 1), GCS_HELPTEXTW, 0&, StrPtr(szt), Len(szt))
                            szt = TrimNullW(szt)
                        End If
                    Else
                        szt = QueryMenuTip(CLng(lw))
                    End If
                    UpdateStatus szt
                End If
            End If
     
        Case WM_INITMENUPOPUP, WM_DRAWITEM, WM_MEASUREITEM
          Dim lResult As Long
          If (ICtxMenu3 Is Nothing) = False Then
            On Error GoTo e1
            Dim lRs3 As LongPtr
            Call ICtxMenu3.HandleMenuMsg2(uMsg, wParam, lParam, lRs3)
            'lReturn = lRs3
            ucWndProc = lRs3
            Exit Function
          ElseIf (ICtxMenu2 Is Nothing) = False Then
            On Error GoTo e2
            Call ICtxMenu2.HandleMenuMsg(uMsg, wParam, lParam)
          End If
          On Error GoTo e0
        
        Case WM_WINDOWPOSCHANGED
    '        DebugAppend "WM_WPC flags=" & dbg_SWP_FlagsStr(tWPOS.dwFlags)
            If bwpFlag = False Then
              If lng_hWnd = UserControl.hWnd Then
                Dim tWPOS As WINDOWPOS
                Dim bNoRz As Boolean
                CopyMemory tWPOS, ByVal lParam, LenB(tWPOS)
                If (tWPOS.cx < (cxMinUC * m_ScaleX)) Then
                    SetWindowPos lng_hWnd, 0&, 0&, 0&, cxMinUC * m_ScaleX, tWPOS.cy, SWP_NOMOVE Or SWP_NOZORDER
                    bNoRz = True
                End If
                Dim cym As Long
                If (m_Mode = SBCTL_DirOnly) Or (m_Mode = SBCTL_DrivesOnly) Or (m_Mode = SBCTL_DirOnlyWithCtls) Then
                    cym = cyMinUCD
                Else
                    cym = cyMinUC
                End If
                If (tWPOS.cy < (cym * m_ScaleY)) Then
                    SetWindowPos lng_hWnd, 0&, 0&, 0&, tWPOS.cx, cym * m_ScaleY, SWP_NOMOVE Or SWP_NOZORDER
                    bNoRz = True
                End If
                If bNoRz = False Then
                    If (tWPOS.dwFlags And SWP_NOREPOSITION) = SWP_NOREPOSITION Then
                        bwpFlag = True
                        UserControl_Resize
                        bwpFlag = False
                    End If
                End If
              End If
            End If
            
         Case WM_UNICHAR
            If wParam = UNICODE_NOCHAR Then
                ' lReturn = 1
                ' bHandled = True
                ucWndProc = 1
                Exit Function
            Else
                SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
                ' bHandled = True
                Exit Function
            End If
        
        Case WM_IME_CHAR
            SendMessage lng_hWnd, WM_CHAR, wParam, ByVal lParam
            ' bHandled = True
            Exit Function
        Case WM_NOTIFY
            Dim tNMH As NMHDR
            CopyMemory tNMH, ByVal lParam, LenB(tNMH)
    '        DebugAppend "Notify 0x" & Hex$(tNMH.Code)
                    
            Select Case tNMH.code
                Case WM_NOTIFYFORMAT
                    DebugAppend "Got NFMT on ucWndProc->WM_NOTIFY"
                    ' lReturn = NFR_UNICODE
                    ' bHandled = True
                   ucWndProc = NFR_UNICODE
                   Exit Function
                Case LVN_GETDISPINFOW
                    Dim ecdIdx As Long
                    
                    'SB_VIEW_CONTENTS is handled with the same block as Tiles and Details now; seems to work ok
                    'but I'm leaving this block here for now in case an issue comes up.
    '                If m_ViewMode = SB_VIEW_CONTENTS Then
    '                    Dim LVDI As NMLVDISPINFO
    '                    CopyMemory ByVal VarPtr(LVDI), ByVal lParam, LenB(LVDI)
    '                        If bGV Then 'Only need to read detailed data if we need Group IDs
    '                            If LVEntries(LVDI.Item.lParam).ExtColData(ecdIdx).bSet = False Then
    '        '                        DebugAppend "LVN_GETDISPINFO SetCols " & LVEntries(LVDI4.Item.lParam).sName
    '                                LVPopulateColsForItem LVDI.Item.iItem, , True
    '                            End If
    '                        End If
    '                        With LVDI.Item
    '                        If (.Mask And LVIF_TEXT) = LVIF_TEXT Then
    '                            Select Case .iSubitem
    '                                Case 0
    '                                    .pszText = StrPtr(LVEntries(.lParam).sName)
    '                                Case Else
    '                                    Dim lprp As Long
    '                                    lprp = GetHDItemlParam(hLVSHdr, .iSubitem)
    '                                    sVax = LVGetPropCache(.lParam, lprp) & vbNullChar
    '                                    If sVax <> "" Then
    '                                        .cchTextMax = Len(sVax) '+ 1
    '                                        .pszText = StrPtr(sVax)
    '                                    Else
    '                                        .cchTextMax = 0
    '                                        .pszText = 0
    '                                    End If
    '                             End Select
    '                        End If
    '                        If (.Mask And LVIF_GROUPID) = LVIF_GROUPID Then
    '                            LVDI.Item.iGroupId = LVEntries(LVDI.Item.lParam).iGrp
    '                        End If
    '                        CopyMemory ByVal lParam, ByVal VarPtr(LVDI), LenB(LVDI)
    '                    End With
    '                    Exit Sub
    '                 End If
                     If (m_ViewMode = SB_VIEW_THUMBNAIL) Or (m_ViewMode = SB_VIEW_CUSTOM) Then
                         If m_ThumbPreload = False Then
                            Dim LVDI2 As NMLVDISPINFO
                            CopyMemory ByVal VarPtr(LVDI2), ByVal lParam, LenB(LVDI2)
                            If (m_ThumbExt = True) Or (bGV = True) Then
                                'The column populator also sets the child pidl, which we need for extended thumbs, and sets group id
                                If LVEntries(LVDI2.Item.lParam).ExtColData(ecdIdx).bSet = False Then
            '                        DebugAppend "LVN_GETDISPINFO SetCols " & LVEntries(LVDI4.Item.lParam).sName
                                    LVPopulateColsForItem LVDI2.Item.iItem, , True
                                End If
                            End If
                            With LVDI2.Item
                                If (.Mask And LVIF_IMAGE) = LVIF_IMAGE Then
                                    .iImage = LVGetThumbIdx(CLng(.lParam), himl_Thumb, m_ThumbCXY)
    '                                DebugAppend "ThumbDispInfoReq i=" & .lParam & ",img=" & .iImage, 3
                                End If
                                If (.Mask And LVIF_GROUPID) = LVIF_GROUPID Then
                                    LVDI2.Item.iGroupId = LVEntries(LVDI2.Item.lParam).iGrp
                                End If
                                If (.Mask And LVIF_STATE) = LVIF_STATE Then
                                    .State = INDEXTOOVERLAYMASK(LVEntries(.lParam).nOverlay)
                                End If
                            End With
                            CopyMemory ByVal lParam, ByVal VarPtr(LVDI2), LenB(LVDI2)
                         End If
                        Exit Function
                     End If
                     If (m_ViewMode = SB_VIEW_ICON) Or (m_ViewMode = SB_VIEW_MDICON) Or (m_ViewMode = SB_VIEW_XLICON) Then
    '                     If m_ThumbPreload = False Then
    '                    If bHoldDI = False Then
                            Dim LVDI3 As NMLVDISPINFO
                            CopyMemory ByVal VarPtr(LVDI3), ByVal lParam, LenB(LVDI3)
                            If bGV Then 'Only need to read detailed data if we need Group IDs
                                If LVEntries(LVDI3.Item.lParam).ExtColData(ecdIdx).bSet = False Then
                                    LVPopulateColsForItem LVDI3.Item.iItem, , True
                                End If
                            End If
                            With LVDI3.Item
                                If (.Mask And LVIF_IMAGE) = LVIF_IMAGE Then
                                    .iImage = LVGetThumbIdxLarge(CLng(.lParam), cxyDispL)
    '                            If .iImage = 1 Then
    '                                DebugAppend "3.SET ICON = 1"
    '                                DebugAppend ""
    '                            End If
    '                                  DebugAppend "ThumbDispInfoReq i=" & .lParam & ",img=" & .iImage & ",idx=" & LVEntries(.lParam).nFileIcon & ",grp=" & LVEntries(LVDI3.Item.lParam).iGrp, 11
                                End If
                                If (.Mask And LVIF_GROUPID) = LVIF_GROUPID Then
                                    LVDI3.Item.iGroupId = LVEntries(LVDI3.Item.lParam).iGrp
                                End If
                                If (.Mask And LVIF_STATE) = LVIF_STATE Then
                                    .State = INDEXTOOVERLAYMASK(LVEntries(LVDI3.Item.lParam).nOverlay)
                                End If
                                    
                            End With
                            CopyMemory ByVal lParam, ByVal VarPtr(LVDI3), LenB(LVDI3)
    '                    End If
                        Exit Function
                     End If
                     If (m_ViewMode = SB_VIEW_DETAILS) Or (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS) Then
                        If (mExtColPreload = False) And (bSupDisp = False) Then
                        Dim LVDI4 As NMLVDISPINFO
                        CopyMemory ByVal VarPtr(LVDI4), ByVal lParam, LenB(LVDI4)
                        Dim colprm As Long
                        Dim looct As Long
                        colprm = CLng(GetHDItemlParam(hLVSHdr, LVDI4.Item.iSubItem))
                        For looct = 0 To UBound(LVEntries(LVDI4.Item.lParam).ExtColData)
                            If LVEntries(LVDI4.Item.lParam).ExtColData(looct).cdid = colprm Then
                                ecdIdx = looct
                                Exit For
                            End If
                        Next looct
                        If LVEntries(LVDI4.Item.lParam).ExtColData(ecdIdx).bSet = False Then
    '                        DebugAppend "LVN_GETDISPINFO SetCols " & LVEntries(LVDI4.Item.lParam).sName
                            LVPopulateColsForItem LVDI4.Item.iItem, , True
                        End If
                        
                        With LVDI4.Item
                            If (.Mask And LVIF_TEXT) = LVIF_TEXT Then
                                sVax = ""
                                Select Case .iSubItem
                                    Case 0
                                        LVDI4.Item.pszText = StrPtr(LVEntries(LVDI4.Item.lParam).sName)
                                    Case Else
                                        
                                        sVax = LVEntries(LVDI4.Item.lParam).ExtColData(ecdIdx).sDisp
                                        If sVax = "" Then
                                            sVax = " "
                                        End If
                                        LVDI4.Item.pszText = StrPtr(sVax)
                                        LVDI4.Item.cchTextMax = Len(sVax)
                                 End Select
                            End If
                            If (.Mask And LVIF_GROUPID) = LVIF_GROUPID Then
                                LVDI4.Item.iGroupId = LVEntries(LVDI4.Item.lParam).iGrp
    '                            DebugAppend "SetGroupId " & LVDI4.Item.iGroupId
                            End If
                            If (.Mask And LVIF_IMAGE) = LVIF_IMAGE Then
                                If LVEntries(LVDI4.Item.lParam).nIcon = I_IMAGECALLBACK Then
                                    LVSetStdIcon LVDI4.Item.lParam
                                End If
                                If .iSubItem = 0& Then
                                    .iImage = LVEntries(LVDI4.Item.lParam).nIcon
                                Else
                                    .iImage = -1
                                End If
    '                                If uColData(colprm).bFlagManHasImg Then
    '                                    RaiseEvent CustomColumnQueryData(colprm, isi, pidlFQItem, LVEntries(llp).sName, LVEntries(llp).sParentFull, i, sTmp, nCIImg)
    
    '                            If .iImage = 1 Then
    '                                DebugAppend "4.SET ICON = 1"
    '                                DebugAppend ""
    '                            End If
                            End If
                            If (.Mask And LVIF_STATE) = LVIF_STATE Then
                                .State = INDEXTOOVERLAYMASK(LVEntries(LVDI4.Item.lParam).nOverlay)
                            End If
                            CopyMemory ByVal lParam, ByVal VarPtr(LVDI4), LenB(LVDI4)
                        End With
                    End If
                    Exit Function
                    End If
                      If bSupDisp = False Then
                        Dim LVDI5 As NMLVDISPINFO
                        CopyMemory ByVal VarPtr(LVDI5), ByVal lParam, LenB(LVDI5)
                            If bGV Then 'Only need to read detailed data if we need Group IDs
                                If LVEntries(LVDI5.Item.lParam).ExtColData(ecdIdx).bSet = False Then
            '                        DebugAppend "LVN_GETDISPINFO SetCols " & LVEntries(LVDI4.Item.lParam).sName
                                    LVPopulateColsForItem LVDI5.Item.iItem, , True
                                End If
                            End If
                            With LVDI5.Item
                            If (.Mask And LVIF_IMAGE) = LVIF_IMAGE Then
                                If LVEntries(LVDI5.Item.lParam).nIcon = I_IMAGECALLBACK Then
                                    LVSetStdIcon LVDI5.Item.lParam
                                End If
                                .iImage = LVEntries(LVDI5.Item.lParam).nIcon
    '                            If .iImage = 1 Then
    '                                DebugAppend "5.SET ICON = 1"
    '                                DebugAppend ""
    '                            End If
                            End If
                            If (.Mask And LVIF_STATE) = LVIF_STATE Then
                                .State = INDEXTOOVERLAYMASK(LVEntries(LVDI5.Item.lParam).nOverlay)
                            End If
                            If (.Mask And LVIF_GROUPID) = LVIF_GROUPID Then
                                LVDI5.Item.iGroupId = LVEntries(LVDI5.Item.lParam).iGrp
                            End If
                            CopyMemory ByVal lParam, ByVal VarPtr(LVDI5), LenB(LVDI5)
                        End With
                        Exit Function
                      End If
                      
                Case LVN_GETINFOTIPW
                        Dim nmlvgit As NMLVGETINFOTIP
                        CopyMemory nmlvgit, ByVal lParam, LenB(nmlvgit)
                        With nmlvgit
                            If .iItem > -1 And .pszText <> 0 Then
                                Dim sInfoTip As String
                                Dim nTipItem As Long
                                If .iSubItem = 0 Then
                                    nTipItem = CLng(GetLVItemlParam(hLVS, .iItem))
                                    If mInfoTipMode = SBITM_Extended Then
                                        If (bGV = True) And (m_ViewMode = SB_VIEW_SMALLICON) Then
                                            If Len(LVEntries(nTipItem).sNameReduced) > 3 Then
                                                If Right$(LVEntries(nTipItem).sNameReduced, 3) = "..." Then
                                                    sInfoTip = LVEntries(nTipItem).sName & vbCrLf & GenerateInfoTip(nTipItem)
                                                    GoTo gottip
                                                End If
                                            End If
                                        End If
                                        If .dwFlags = LVGIT_UNFOLDED Then
    '                                        DebugAppend "LVGIT_UNFOLDED " & SendMessage(hLVS, LVM_GETCOLUMNWIDTH, -1&, ByVal 0&)
                                            sInfoTip = GenerateInfoTip(nTipItem)
                                        Else
    '                                        DebugAppend "LVGIT_FOLDED " & SendMessage(hLVS, LVM_GETCOLUMNWIDTH, -1&, ByVal 0&)
                                            sInfoTip = LVEntries(nTipItem).sName & vbCrLf & GenerateInfoTip(nTipItem)
                                        End If
                                    ElseIf mInfoTipMode = SBITM_Custom Then
                                        Dim pidlFQTip As LongPtr
                                        pidlFQTip = ILCombine(pidlFQCur, LVEntries(nTipItem).pidlRel)
                                        RaiseEvent QueryCustomInfoTip(.dwFlags, LVEntries(nTipItem).sName, LVEntries(nTipItem).sFullPath, pidlFQTip, sInfoTip)
                                        CoTaskMemFree pidlFQTip
                                    End If
    gottip:
                                    If Not sInfoTip = vbNullString Then
                                        sInfoTip = Left$(sInfoTip, .cchTextMax - 1) & vbNullChar
                                        CopyMemory ByVal .pszText, ByVal StrPtr(sInfoTip), LenB(sInfoTip)
                                    Else
                                        CopyMemory ByVal .pszText, 0&, 4&
                                    End If
                                End If
                            End If
                        End With
                                  
                Case LVN_KEYDOWN
                    
                    Dim nmkd As NMLVKEYDOWN
                    CopyMemory ByVal VarPtr(nmkd), ByVal lParam, LenB(nmkd)
                    Dim bCn As Boolean
                    Dim blvkdA As Boolean, blvkdS As Boolean, blvkdC As Boolean
                    blvkdA = ((GetKeyState(VK_MENU) And &H80) = &H80)
                    blvkdS = ((GetKeyState(VK_SHIFT) And &H80) = &H80)
                    blvkdC = ((GetKeyState(VK_CONTROL) And &H80) = &H80)
                    RaiseEvent ListKeyDown(nmkd.wVKey, blvkdS, blvkdC, blvkdA, bCn)
                    If bCn = True Then Exit Function
                    LVHandleKeypress lng_hWnd, CLng(nmkd.wVKey), blvkdA, blvkdS, blvkdC
                
                
                Case LVN_GETEMPTYMARKUP
    
                    DebugAppend "LVN_GETEMPTYMARKUP on DoLVNotify"
                    Dim nmlvem As NMLVEMPTYMARKUP
                    Dim sEMText As String
                    If bUseDrvRemForEM Then
                        sEMText = mLVEMDrvRem
                    ElseIf bUseSearchMarkup Then
                        sEMText = mSrchNoRes
    '                    bUseSearchMarkup = False
                    ElseIf bBlankLoaded Then
                        sEMText = mStrStartBlank
                    Else
                        sEMText = mEmptyFolderStr
                    End If
                    CopyMemory ByVal VarPtr(nmlvem), ByVal lParam, LenB(nmlvem)
                    CopyMemory nmlvem.szMarkup(0), ByVal StrPtr(sEMText), LenB(sEMText)
                    nmlvem.dwFlags = EMF_CENTERED
                    CopyMemory ByVal lParam, ByVal VarPtr(nmlvem), LenB(nmlvem)
                    ' lReturn = 1
                    ' bHandled = True
                    ucWndProc = 1
                    Exit Function
                    
                Case LVN_COLUMNCLICK
                    CopyMemory nmlv, ByVal lParam, LenB(nmlv)
                    nCol = CLng(GetHDItemlParam(SendMessage(tNMH.hWndFrom, LVM_GETHEADER, 0&, ByVal 0&), nmlv.iSubItem))
                    DebugAppend "Column click " & nCol & ",si=" & nmlv.iSubItem
                    LVColumnClick nmlv.iSubItem
                    
                Case LVN_BEGINDRAG, LVN_BEGINRDRAG
                    DebugAppend "LVN_BEGINDRAG"
                    If (m_DDMode = SBDD_DragDrop) Or (m_DDMode = SBDD_DragOnly) Then
                       Dim hr0 As Long
                       Dim iData As IDataObject
                       Dim apidl() As LongPtr
                       Dim cpidl As Long
                       'Dim rpidl As Long
                       Dim pidlDesk As LongPtr
                       Dim lRetDD As Long
                       
                       Dim AllowedEffects As DROPEFFECTS
                       LVSetSelection
                       SHGetSpecialFolderLocation(0, CSIDL_DESKTOP, pidlDesk) ', pidlDeskwe support multiple paths by creating an IDataObject with the desktop as the root and then supplying fully qualified pidls rather than child pidls
                       
                       ReDim apidl(UBound(sSelectedFiles)) 'sSelFullPath would then contain the full path to the file, C:\folder\file.ext, //Computer/folder/file.ext
                       For i = 0 To UBound(apidl)
                              apidl(i) = ILCreateFromPathW(StrPtr(sSelectedFiles(i))) 'support function to return fully qualified pidls for each file, see below
                              If apidl(i) = 0& Then 'try another way to get pidl
                                apidl(i) = ILCombine(pidlFQCur, tSelectedFiles(i).pidlRel)
                              End If
                       Next i
                       cpidl = UBound(apidl) + 1
                       Dim psia As IShellItemArray
                       SHCreateShellItemArrayFromIDLists cpidl, VarPtr(apidl(0)), psia
                       If (psia Is Nothing) Then
                           DebugAppend "tvdrag->no psia"
                           Exit Function
                       End If
                       DebugAppend "Drag->Set psia"
                       psia.BindToHandler 0&, BHID_DataObject, IID_IDataObject, iData
            
                       AllowedEffects = DROPEFFECT_COPY Or DROPEFFECT_MOVE Or DROPEFFECT_LINK
                       Dim lBtnPD As Long
                       If (GetKeyState(VK_MBUTTON) And &H80) = &H80 Then
                         lBtnPD = VK_MBUTTON
                       End If
                       If (GetKeyState(VK_LBUTTON) And &H80) = &H80 Then
                         lBtnPD = VK_LBUTTON
                       End If
                       If (GetKeyState(VK_RBUTTON) And &H80) = &H80 Then
                         lBtnPD = VK_RBUTTON
                       End If
                       If (GetKeyState(VK_CONTROL) And &H80) = &H80 Then
                        lBtnPD = lBtnPD Or VK_CONTROL
                       End If
                       If (GetKeyState(VK_SHIFT) And &H80) = &H80 Then
                        lBtnPD = lBtnPD Or VK_SHIFT
                       End If
                       If (GetKeyState(VK_MENU) And &H80) = &H80 Then
                        lBtnPD = lBtnPD Or VK_MENU
                       End If
                       RaiseEvent DragStart(sSelectedFiles, psia, iData, lBtnPD)
                       hr0 = SHDoDragDrop(0&, ObjPtr(iData), 0&, AllowedEffects, lRetDD) 'theoretically you can supply your own IDropSource implementation, but I never got it working
                       
                       DebugAppend "hr0=" & hr0 & ",lRet=" & lRetDD 'hr0 contains the HRESULT of the call, and lRetDD is the result of the operation, see the full DROPEFFECT description for all possible values
                       Call CoTaskMemFree(pidlDesk)
                       For i = 0 To UBound(apidl)
                           Call CoTaskMemFree(apidl(i))
                       Next i
                       Set iData = Nothing
                   End If
                   
                Case LVN_BEGINLABELEDITW
                    DebugAppend "ucWndProc@BgLabelEditW"
                    Dim nmbledi As NMLVDISPINFO
                    CopyMemory nmbledi, ByVal lParam, LenB(nmbledi)
                    DebugAppend "BeginLabelEdit::i=" & nmbledi.Item.iItem & ",si=" & nmbledi.Item.iSubItem
                    
                    i = ListView_GetSelectedItem(hLVS)
                    'DebugAppend "DoLVNotify: i=" & i
                    'pidlRel = glb_resGetLVItemlParam(hLVS, i)
                    Dim ni5 As LongPtr
                    ni5 = GetLVItemlParam(hLVS, i)
                    ulAtrrs = LVEntries(ni5).dwAttrib
                    If (ulAtrrs And SFGAO_CANRENAME) = SFGAO_CANRENAME Then
        
                    'deselect the file name extension by default when renaming by label edit, like in explorer.
        
                        hLEEdit = SendMessage(hLVS, LVM_GETEDITCONTROL, 0, ByVal 0&)
                        If hLEEdit Then
                            'SendMessage hLEEdit, WM_SETTEXT, 0&, ByVal StrPtr(LVEntries(ni5).sName)+
                            SendMessage hLEEdit, EM_LIMITTEXT, MAX_PATH, ByVal 0&
                            SetWindowTextW hLEEdit, StrPtr(LVEntries(ni5).sName)
                            Sleep 10
                            lLen = CLng(SendMessageW(hLEEdit, WM_GETTEXTLENGTH, 0, ByVal 0&))
                            sText = String$(lLen, 0)
                            Call SendMessageW(hLEEdit, WM_GETTEXT, lLen + 1, ByVal StrPtr(sText))
    '                        dbg_stringbytes sText
    '                        dbg_stringbytes LVEntries(ni5).sName
                            DebugAppend "LabelEdit:Orig text=" & sText & ",len=" & lLen
                            sOldLEText = sText
                            If m_sCurPath = sComp Then
                                If InStr(sText, "(") Then
                                    mStrVolOld = Left$(sText, (InStrRev(sText, "(") - 2))
                                    SendMessageW hLEEdit, WM_SETTEXT, 0&, ByVal StrPtr(mStrVolOld)
                                    SendMessageW hLEEdit, EM_SETSEL, 0&, ByVal Len(mStrVolOld)
                                Else
                                    mStrVolOld = sText
                                End If
                            Else
                                If LVEntries(ni5).bFolder = False Then
                                    If InStr(sText, ".") Then
                                        lSel = InStrRev(sText, ".") - 1
                                        If lSel > 0 Then
                                            DebugAppend "LabelEdit:EM_SETSEL=" & lSel
                                            Call SendMessage(hLEEdit, EM_SETSEL, 0, ByVal lSel)
                                        End If
                                    End If
                                End If
                            End If
                            'We also want to detect invalid characters, to do it properly we need to
                            'subclass the edit control- where the WM_CHAR message is sent
    '                        Call Subclass2(hEdit, AddressOf LEWndProc, hEdit)
                            ' If ssc_Subclass(hLEEdit, , 3, , , True, True) Then
                            '     Call ssc_AddMsg(hLEEdit, MSG_BEFORE, ALL_MESSAGES)
                            ' End If
                            Subclass2 hLEEdit, AddressOf LabelEditWndProc, hLEEdit
                            Exit Function
                        End If
        
                    Else 'cannot rename
            
                        DebugAppend "LVN_BEGINLABELEDIT: Cancelling, SFGAO_CANRENAME=False"
                        If mPlaySnd Then
                            If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                        End If
                        ' lReturn = 1
                        ' bHandled = True
                        ucWndProc = 1
                        Exit Function
                    End If
                    
                Case LVN_ENDLABELEDITW
                    DebugAppend "ucWndProc@EndLabelEditW"
                    'Call zUnThunk(hLEEdit, SubclassThunk)
                    UnSubclass2 hLEEdit, AddressOf LabelEditWndProc, hLEEdit
                    hLEEdit = 0
                    Dim NMLVDI As NMLVDISPINFO
                    CopyMemory NMLVDI, ByVal lParam, LenB(NMLVDI)
                    Dim lSL As Long
                    Dim sBuf As String
                    Dim sNewText As String
                    lLen = 0
                    i = NMLVDI.Item.iItem 'ListView_GetSelectedItem(hLVS)
                    hLEEdit = SendMessage(hLVS, LVM_GETEDITCONTROL, 0, ByVal 0)
                    If hLEEdit Then
                        lLen = CLng(SendMessageW(hLEEdit, WM_GETTEXTLENGTH, 0, ByVal 0))
                        sBuf = String$(lLen, 20)
        '                        Dim byt() As Byte
        '                        ReDim byt(1 To lLen)
                        Call SendMessageW(hLEEdit, WM_GETTEXT, lLen + 1, ByVal StrPtr(sBuf))
                        lSL = lstrlenW(ByVal StrPtr(sBuf))
                        DebugAppend "buflen=" & lSL & ",len=" & lLen
                        sBuf = Left$(sBuf, lSL)
    '                    dbg_stringbytes sBuf
        '                        dbg_printbytes byt
        '                        MessageBoxW hLVS, StrPtr(sOldLEText), StrPtr("wm_gettext"), 0&
                    Else
                        DebugAppend "No edit control @EndLabelEdit"
                    End If
                    Dim lvif As LVITEM
                    Dim sBuf2 As String
                    Dim idx As Long
                    idx = CLng(GetLVItemlParam(hLVS, i))
                    sBuf2 = LPWSTRtoStr(NMLVDI.Item.pszText, False)
                    If m_sCurPath = sComp Then
                        DebugAppend "LVN_ENDLABELEDIT::VolumeLabel->" & mStrVolOld & " to " & sBuf2
                        If (sBuf2 <> "") And (sBuf2 <> CStr(vbNullChar)) And (sBuf <> mStrVolOld) Then
                            Dim svlRes As Long, svlError As Long, svlNew As String, svlOld As String
                            Dim svlPrc As Boolean
                            svlOld = LVEntries(idx).sNameFull
                            DebugAppend "LVN_ENDLABELEDIT->Target=" & svlOld
                            If Len(svlOld) > 3 Then
                                'Attached device without a drive letter
                                svlRes = RenameDevice(svlOld, sBuf)
                                svlError = svlRes
                                If svlRes = S_OK Then svlPrc = True
                            Else
                                Dim lDrvT As ucsb_GDT_Types
                                lDrvT = GetDriveType(StrPtr(svlOld))
                                If lDrvT = DRIVE_FIXED Then
                                    svlRes = SetVolumeLabelW(StrPtr(svlOld), StrPtr(sBuf))
                                    svlError = GetLastError()
                                    If svlRes Then svlPrc = True
                                Else
                                    Dim newpidl As LongPtr
    '                                svlRes = psfCur.SetNameOf(hLVS, LVEntries(idx).pidlRel, StrConv(sBuf, vbUnicode), SHGDN_NORMAL, newpidl) 'Call changed in oleexp 4.61
                                    svlRes = psfCur.SetNameOf(hLVS, LVEntries(idx).pidlRel, StrPtr(sBuf), SHGDN_NORMAL, newpidl)
                                    If newpidl Then
                                        If newpidl <> LVEntries(idx).pidlRel Then
                                            LVEntries(idx).pidlRel = newpidl
                                        End If
                                    End If
                                    If svlRes = S_OK Then svlPrc = True
                                End If
                            End If
                            If svlPrc Then
                                If Len(LVEntries(idx).sNameFull) = 3 Then
                                    svlNew = sBuf & " (" & LVEntries(idx).sNameFull & ")"
                                    LVEntries(idx).sName = Replace$(svlNew, "\)", ")")
                                Else
                                    LVEntries(idx).sName = sBuf
                                End If
                                lvif.Mask = LVIF_TEXT
                                lvif.iItem = i
                                lvif.pszText = StrPtr(LVEntries(idx).sName)
                                SendMessageW hLVS, LVM_SETITEMW, 0&, lvif
                                If m_DtPane Then 'Update label in details pane as well
                                    If hDetailName Then
                                        SetWindowTextW hDetailName, StrPtr(LVEntries(idx).sName)
                                    End If
                                End If
                                ' lReturn = 1
                                ' Exit Sub
                                ucWndProc = 1
                                Exit Function
                            Else
                                DebugAppend "LVN_ENDLABELEDIT::SetVolumeLabel->Error: 0x" & Hex$(svlError) & "; RootPathName=" & svlOld & ",VolumeName=" & sBuf
                                Exit Function
                            End If
                        Else
                            DebugAppend "LVN_EDITLABELEDIT::VolumeLabel->Error: Null string or no change"
                            Exit Function
                        End If
                    End If
                                
                                    
                    If (sBuf2 <> "") And (sBuf2 <> CStr(vbNullChar)) And (sBuf <> sOldLEText) Then
                        Dim tOld As UCSBFile, tNew As UCSBFile
                        Dim sOld As String, sNew As String
                        tOld = LVEntries(idx)
        '                        dbg_stringbytes tOld.sName, True
                        If (Right$(sBuf, 1) = " ") Or (Right$(sBuf, 1) = ".") Then
                            sBuf = Left$(sBuf, Len(sBuf) - 1)
                        End If
                        If tOld.sName <> sBuf Then
                            tNew = tOld
                            tNew.sName = sBuf
                            If tOld.sName <> tOld.sNameExt Then 'hidden extension
                                sOld = AddBackslash(tOld.sParentFull) & tOld.sNameExt
                                sNew = tNew.sName & tOld.sExt
                                tNew.sNameFull = sNew
                                tNew.sFullPath = AddBackslash(tNew.sParentFull) & tNew.sNameFull
                            Else
                                sOld = tOld.sFullPath
                                sNew = tNew.sName
                                tNew.sNameFull = tNew.sName
                                tNew.sFullPath = AddBackslash(tNew.sParentFull) & tNew.sNameFull
                            End If
                            If (tOld.sExt = ".lnk") And (Right$(tNew.sFullPath, 3) <> "lnk") Then
                                tNew.sFullPath = tNew.sFullPath & ".lnk"
                            End If
                            If Len(sNew) > 3 Then
                                If (tOld.sExt = ".lnk") And (Right$(sNew, 3) <> "lnk") Then
                                    sNew = sNew & ".lnk"
                                End If
                            End If
        '                        RenameFile sOld, sNew
                            DebugAppend "idx=" & LVEntries(idx).sName & ",sBuf=" & sBuf
                            DebugAppend "Name " & sOld & " As " & tNew.sFullPath
                            Dim hrrf As Long
                            hrrf = ValidateName(tNew)
                            
                            If hrrf <> S_OK Then
                                bRNf = False
                                If mPlaySnd Then
                                    If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                                End If
                                Dim sNmErr As String
                                sNmErr = GetRenameErrorDesc(hrrf)
                                If IsComCtl6 Then
                                    Call SimpleDialog(sNmErr, TDCBF_OK_BUTTON, , "Could not rename file.", TD_ERROR_ICON, hLVS)
                                Else
                                    Call MsgBox(sNmErr, vbCritical + vbOKOnly, "Could not rename file.")
                                End If
                                DebugAppend "Rename::Fail, 0x" & Hex$(hrrf)
                                UpdateStatus mRenameFailStr ', IconWarn
                                Exit Function
                            End If
        '                        hrrf = RenameFile2(sOld, tNew.sFullPath)
                            bRNf = True
                            hrrf = RenameFile(sOld, sNew, idx)
                            
                            If PathFileExistsW(StrPtr(tNew.sFullPath)) Then
                                DebugAppend "Rename::Notify"
                                'notify the shell that we have renamed the item
                                'This is commented out only because we're using Explorer itself through IFileOperation
                                'to do the rename. Any other API or rename method, uncomment this call.
        '                            Call SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATHW, StrPtr(tOld.sFullPath), StrPtr(tNew.sFullPath))
        '                            bRNf = False
                                LVEntries(idx) = tNew
                                Dim pidlNew As LongPtr, pidlRel As LongPtr
                                pidlNew = ILCreateFromPathW(StrPtr(tNew.sFullPath))
                                pidlRel = ILFindLastID(pidlNew)
                                If pidlRel Then
                                    LVEntries(idx).pidlRel = pidlRel
                                End If
                                DebugAppend "Setting icon..."
                                Dim nIcoOld As Long
                                lvif.Mask = LVIF_TEXT
                                lvif.iItem = i
                                lvif.pszText = StrPtr(tNew.sName) 'StrPtr(sNew)
                                nIcoOld = LVEntries(idx).nIcon
                                LVSetStdIcon idx
                                If (LVEntries(idx).nIcon = 0&) And (nIcoOld > 0&) Then
                                    LVEntries(idx).nIcon = nIcoOld
                                End If
                                If (LVEntries(idx).nIcon <> -1&) Then ' And (LVEntries(idx).nIcon <> nIcoOld) Then
                                    lvif.Mask = lvif.Mask Or LVIF_IMAGE
                                    lvif.iImage = LVEntries(idx).nIcon
                                End If
                                If pidlNew Then Call CoTaskMemFree(pidlNew)
                                
                                SendMessageW hLVS, LVM_SETITEMW, 0&, lvif
                                
        '                            ListView_Update hLVS, i
                                DebugAppend "Setting other cols... " & LVEntries(idx).sName
                                LVPopulateColsForItem i, True
                                DebugAppend "Rename::Out"
                                If m_DtPane Then
                                    LVSetSelection
                                    pvCreateItemDetailPane
                                End If
                                dbg_stringbytes sNew
                                RaiseEvent FileRenamed(sOld, tNew.sFullPath)
        '                         lReturn = 1
        ' '                            bHandled = True
                                  ucWndProc = 1
                            Else
                                bRNf = False
                                If mPlaySnd Then
                                    If bSoundDefBeep Then DoSound SND_DEFAULTBEEP
                                End If
                                DebugAppend "Rename::Fail, 0x" & Hex$(hrrf)
                                UpdateStatus mRenameFailStr ', IconWarn
                            End If
                        End If
                    End If
                    
                Case LVN_ITEMCHANGED
                    CopyMemory ByVal VarPtr(nmlv), ByVal lParam, LenB(nmlv)
    '                DebugAppend "LVN_ITEMCHANGED " & nmlv.iItem
                    If m_Checkboxes Then
                        Dim sim As Long
                        sim = STATEIMAGEMASKTOINDEX(nmlv.uNewState)
                        lp = GetLVItemlParam(hLVS, nmlv.iItem)
                        If (sim = 1&) Then
                            LVEntries(lp).fChecked = 0&
                            RaiseEvent FileCheck(nmlv.iItem, LVEntries(lp).sFullPath, 0)
                        ElseIf (sim = 2&) Then
                            LVEntries(lp).fChecked = 1&
                            RaiseEvent FileCheck(nmlv.iItem, LVEntries(lp).sFullPath, 1)
                        End If
                        Dim lSelCnt As Long
                        lSelCnt = GetCheckedCount()
                        If lSelCnt = 0& Then
                            UpdateStatus mNoCheckStr
                        ElseIf lSelCnt = 1& Then
                            UpdateStatus mFileCheckStr
                        Else
                            UpdateStatus lSelCnt & mFilesCheckStr
                        End If
                    End If
                    If bICFlag = False Then
    '                    DebugAppend "LVN_ITEMCHANGED Set IC flag = TRUE, item=" & nmlv.iItem, 9
                        bICFlag = True
                    End If
                    If bHoldSS = False Then
                    If bTmrFlag Then
    '                    DebugAppend "LVN_ITEMCHANGED bTmrFlag=True"
                        tct1 = 0 'reset time since item change to 0
                        MIDPSetCount 'don't lag with count
                    Else
    '                    DebugAppend "LVN_ITEMCHANGED bTmrFlag=False"
                        If bChangeQueued = False Then
                            nmiclv = nmlv
                            bChangeQueued = True
                            tcHoldTime1 = GetTickCount()
                            tmrChangeQueue.Enabled = True
                        Else
                            tcHoldTime1 = GetTickCount()
                        End If
                    End If
                    
                    End If
                    
                Case LVN_MARQUEEBEGIN
                    DebugAppend "Setting item change timer " & bICFlag, 9
                    bICFlag = False
                    bTmrFlag = True
                    tmrChangeSet.Enabled = True
                    tct1 = 0
    
                Case NM_DBLCLK, NM_RETURN
                    If tNMH.hWndFrom = hLVS Then
                        DebugAppend "Got dblclk/ret", 2
                        If (GetKeyState(VK_MENU) And &H80) = &H80 Then
                            DebugAppend "ucWndProc::Alt+Enter/Alt+DblClk->Launch props"
                            ShowSelFileProps
                        Else
                            LVDoubleClick ListView_GetSelectedItem(hLVS)
                        End If
                    ElseIf tNMH.hWndFrom = m_hStatusBar Then
                        Dim nmm As NMMOUSE
                        CopyMemory nmm, ByVal lParam, LenB(nmm)
                        If nmm.dwItemSpec = 1 Then
                            DebugAppend "DblClk SecZone"
                        End If
                    End If
                    
                Case NM_CLICK
                    DebugAppend "NM_CLICK on ucWndProc", 2
                    Dim nIdxClk As Long
                    If tNMH.hWndFrom = hLVS Then
                        If m_OneClickAct Then
                            LVDoubleClick ListView_GetSelectedItem(hLVS)
                        Else
    '                        SetFocusAPI UserControl.ContainerHwnd
    '                        SetFocusAPI hLVS
                            nIdxClk = ListView_GetSelectedItem(hLVS)
                            If nIdxClk >= 0& Then
                                LVItemClick nIdxClk
                                RaiseEvent FileClick(sSelectedFile, siFocus, MK_LBUTTON)
                            End If
                        End If
                    ElseIf ((tNMH.hWndFrom <> hLVSHdr) And (tNMH.hWndFrom <> m_hStatusBar)) Then
                        If nLinks Then
                            For i = 0 To nLinks - 1
                                If hLinks(i) = tNMH.hWndFrom Then
                                    bFound = True
                                    Exit For
                                End If
                            Next i
                            If bFound Then
                                Dim nml As NMLINK
                                CopyMemory nml, ByVal lParam, LenB(nml)
                                Dim sLnkUrl As String, fExec As Long
                                sLnkUrl = Left$(nml.Item.szURL, InStr(nml.Item.szURL, vbNullChar) - 1)
                                DebugAppend "LinkUrl=" & sLnkUrl
                                RaiseEvent ItemLinkClick(sLnkUrl, fExec)
                                If fExec = S_OK Then ShellExecute hLVS, StrPtr("open"), StrPtr(sLnkUrl), 0&, 0&, SW_SHOW
                            End If
                        End If
                    End If
                    
                Case NM_RCLICK, NM_RDBLCLK
                    DebugAppend "NM_RCLICK id=" & tNMH.idFrom & ",hFrom=" & tNMH.hWndFrom & ",hLVS=" & hLVS
                    If tNMH.hWndFrom = hLVSHdr Then
                        
    '                    If bInMenu = False Then
                            bInMenu = True
                            ShowColMenu
                            bInMenu = False
                            ' lReturn = 1
                            ' bHandled = True
                            ucWndProc = 1
                            Exit Function
    '                    End If
                    ElseIf tNMH.hWndFrom = hLVS Then
                        nIdxClk = ListView_GetSelectedItem(hLVS)
                        If nIdxClk >= 0& Then
                            LVItemClick ListView_GetSelectedItem(tNMH.hWndFrom)
                            RaiseEvent FileClick(sSelectedFile, siFocus, MK_RBUTTON)
                        End If
                        ShowShellContextMenu
                    End If
                    
    
                Case NM_CUSTOMDRAW
                    'This section handles all custom draws besides Rating:
                    '-As in Explorer, show encrypted filenames in green, compressed in blue
                    '-Draws progress bars for drive space in Computer/This PC and attached devices like phones with SD cards
                    '-Draws hyperlinks in a couple special folders that use them
                    '-Applies all font settings
                    Dim NMLVCD As NMLVCUSTOMDRAW
                    Dim hFont As LongPtr
                    Dim cl1 As Long, cl2 As Long
                    CopyMemory NMLVCD, ByVal lParam, LenB(NMLVCD)
                    If tNMH.hWndFrom = hLVS Then 'can also come from hLVSHdr(NMLVCD.iSubItem = 2) And
                        With NMLVCD.NMCD
                            Select Case .dwDrawStage
                                Case CDDS_PREPAINT
                                    ' lReturn = CDRF_NOTIFYITEMDRAW
                                    ' bHandled = True
                                    ucWndProc = CDRF_NOTIFYITEMDRAW
                                    Exit Function
                                Case CDDS_ITEMPREPAINT
                                    NMLVCD.ClrText = LVItemGetDispColor(CLng(.dwItemSpec))
                                    cl1 = CLR_NONE: cl2 = CLR_NONE
                                     'If (NMLVCD.iStateId And LVIS_FOCUSED) = LVIS_FOCUSED Then
    '                                    Debug.Print "Draw " & LVEntries(GetLVItemlParam(hLVS, .dwItemSpec)).sName & "=" & dbg_LVITEM_stateStr(CLng(NMLVCD.iStateId)) & ",innmcd=" & dbg_GetCDISStr(.uItemState)
                                    'End If
                                    RaiseEvent CustomColor(CLng(.dwItemSpec), LVEntries(GetLVItemlParam(hLVS, CLng(.dwItemSpec))).sName, 0&, uColData(GetHDItemlParam(hLVSHdr, 0&)).szSystemName, .uItemState, NMLVCD.iStateId, cl1, cl2)
                                    If cl1 <> CLR_NONE Then NMLVCD.ClrText = cl1
                                    If cl2 <> CLR_NONE Then NMLVCD.ClrTextBk = cl2
                                    hFont = hFontLVMain
                                    SelectObject .hDC, hFont
                                    CopyMemory ByVal lParam, NMLVCD, LenB(NMLVCD)
                                    ' lReturn = CDRF_NOTIFYSUBITEMDRAW Or CDRF_NEWFONT
                                    ' bHandled = True
                                    ucWndProc = CDRF_NOTIFYSUBITEMDRAW Or CDRF_NEWFONT
                                    Exit Function
                                Case CDDS_ITEMPREPAINT Or CDDS_SUBITEM
    '                                DebugAppend CStr(m_SubItemProgress)
    '                                DebugAppend "ITEMPREPAINT " & NMLVCD.NMCD.dwItemSpec & "," & NMLVCD.iSubitem, 11
    '                                    Debug.Print "SubItem(" & NMLVCD.iSubitem & ")Draw " & LVEntries(GetLVItemlParam(hLVS, .dwItemSpec)).sName & "= " & dbg_LVITEM_stateStr(CLng(NMLVCD.iStateId)) & ",innmcd=" & dbg_GetCDISStr(.uItemState)
    '                                If NMLVCD.iStateId = CDIS_SELECTED Then
    '                                    Debug.Print "DrawSelectedItem"
    '                                End If
                                    hFont = hFontLVMain
                                    Dim cllp As LongPtr
                                    cllp = GetLVItemlParam(hLVS, CLng(.dwItemSpec))
                                    If (NMLVCD.iSubItem = 0) Then
                                        'Reserved for special handling of item name
                                    Else
                                        If (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS) Then
                                            NMLVCD.ClrText = m_SysClrGray ' &H6D6D6D
                                        Else
    '                                        NMLVCD.ClrText = clrFore 'm_SysClrText 'vbBlack
                                            OleTranslateColor clrForeSubitem, 0&, NMLVCD.ClrText
                                        End If
                                        OleTranslateColor clrBack, 0&, NMLVCD.ClrTextBk
                                        cl1 = CLR_NONE: cl2 = CLR_NONE
                                        RaiseEvent CustomColor(CLng(.dwItemSpec), LVEntries(cllp).sName, NMLVCD.iSubItem, uColData(GetHDItemlParam(hLVSHdr, CLng(NMLVCD.iSubItem))).szSystemName, .uItemState, NMLVCD.iStateId, cl1, cl2)
                                        If cl1 <> CLR_NONE Then NMLVCD.ClrText = cl1
                                        If cl2 <> CLR_NONE Then NMLVCD.ClrTextBk = cl2
    
                                        If NMLVCD.iSubItem <> lvrCol Then 'Placeholder exception for custom rendered column
                                            CopyMemory ByVal lParam, NMLVCD, LenB(NMLVCD)
                                        End If
                                    End If
    
                                    If NMLVCD.iSubItem <> lvrCol Then
                                        SelectObject .hDC, hFont
                                    End If
    
                                    '------------------------------
                                    'Code for subitem progressbars in Computer (and if you ever see them in another folder, let me know, very curious!)
                                    If bDisableProgressItems = False Then
    '                                    DebugAppend "ucWndProc.DrawProgressBlock lvrCol=" & lvrCol & ",subitem=" & m_SubItemProgress & ",sub=" & NMLVCD.iSubitem
                                            Dim pitemvalue       As Long
                                            Dim pitemrect        As RECT
                                            Dim progrect        As RECT
                                            Dim offRC As Long
                                        If Not (m_SubItemProgress = 0) And NMLVCD.iSubItem = m_SubItemProgress Then ' Or m_ViewMode <> SB_VIEW_DETAILS
                                            offRC = 2 * m_ScaleX
                                            pitemrect = GetItemRec(hLVS, m_SubItemProgress, CLng(NMLVCD.NMCD.dwItemSpec))
                                            If m_ViewMode = SB_VIEW_CONTENTS Then
                                                pitemrect.Right = pitemrect.Right + 100 'No idea how to get the proper rect, but this renders ok
                                            End If
                                            Call SetRect(progrect, pitemrect.Left - offRC, pitemrect.Top - offRC, pitemrect.Right - offRC, pitemrect.Bottom - offRC)
                                            progrect.Top = progrect.Top + 3
                                            progrect.Bottom = progrect.Bottom + 3
    
                                            pitemvalue = LVEntries(cllp).lPercent
                                            If pitemvalue <> -1 Then
                                                If pitemvalue < 0 Then pitemvalue = 0
                                                If pitemvalue > 100 Then pitemvalue = 100
                                                Call DrawProgressTheme(NMLVCD.NMCD.hDC, hLVS, progrect, pitemvalue)
                                            End If
                                            ' lReturn = CDRF_SKIPDEFAULT
                                            ' bHandled = True
                                            ' Exit Sub
                                            ucWndProc = CDRF_SKIPDEFAULT
                                            Exit Function
                                        End If
                                    End If
    
                                    If bDisableHyperlinkItems = False Then
                                    lpCol = CLng(GetHDItemlParam(hLVSHdr, CLng(NMLVCD.iSubItem)))
                                    If uColData(lpCol).bFlagIsLink Then
                                        If NMLVCD.iSubItem = mLinkCol Then 'COMMENT OUT TO REMOVE SINGLE LINK COLUMN RESTRICTION. However, you'll need to address the endless redraw bug.
                                        pitemrect = GetItemRec2(hLVS, NMLVCD.iSubItem, CLng(NMLVCD.NMCD.dwItemSpec))
                                        offRC = 2 * m_ScaleX
                                        If m_ViewMode = SB_VIEW_CONTENTS Then
                                            pitemrect.Right = pitemrect.Right + 100 'No idea how to get the proper rect, but this renders ok
                                        End If
                                        Call SetRect(progrect, pitemrect.Left - offRC, pitemrect.Top - offRC, pitemrect.Right - offRC, pitemrect.Bottom - offRC)
                                        progrect.Top = progrect.Top + 3
                                        progrect.Bottom = progrect.Bottom + 3
                                        If LVEntries(cllp).nLinkCols > 0& Then
                                            For j = 0 To UBound(LVEntries(cllp).LinkCols)
                                                If LVEntries(cllp).LinkCols(j).hLink Then 'Already exists, just adjust size
                                                    SetWindowPos LVEntries(cllp).LinkCols(j).hLink, 0&, progrect.Left, progrect.Top, progrect.Right - progrect.Left, progrect.Bottom - progrect.Top - 2, SWP_NOZORDER 'Or SWP_NOREDRAW
                                                    bFound = True
                                                    Exit For
                                                End If
                                            Next j
                                        End If
                                        If bFound = False Then
                                            sColTxt = GetLVItemTextW(hLVS, CLng(NMLVCD.NMCD.dwItemSpec), CLng(NMLVCD.iSubItem))
                                            If Len(sColTxt) > 1 Then
                                                LVEntries(cllp).nLinkCols = LVEntries(cllp).nLinkCols + 1
                                                ReDim Preserve LVEntries(cllp).LinkCols(LVEntries(cllp).nLinkCols - 1)
                                                LVEntries(cllp).LinkCols(LVEntries(cllp).nLinkCols - 1).hLink = DrawLink(NMLVCD.NMCD.hDC, hLVS, progrect, "<a href=" & Chr$(34) & sColTxt & Chr$(34) & ">" & sColTxt & "</a>", CLng(NMLVCD.NMCD.dwItemSpec), CLng(NMLVCD.iSubItem))
                                                ReDim Preserve hLinks(nLinks) 'We need to determine if an hWnd is a link for NM_CLICK; much faster to just have a list
                                                hLinks(nLinks) = LVEntries(cllp).LinkCols(LVEntries(cllp).nLinkCols - 1).hLink
                                                nLinks = nLinks + 1
                                            End If
                                        End If
                                        ' lReturn = CDRF_SKIPDEFAULT
                                        ' bHandled = True
                                        ' Exit Sub
                                        ucWndProc = CDRF_SKIPDEFAULT
                                        Exit Function
                                        End If
                                    End If 'CDRF_NOTIFYSUBITEMDRAW 'Or CDRF_NEWFONT
    '                                        DebugAppend "cxSubItem(" & NMLVCD.iSubitem & ")=" & (pitemrect.Right - pitemrect.Left), 11
                                    End If
    
    
                                    'Note: To implment a static rating display, uncomment this section, comment out the one below, and uncomment
                                    '      related sections in SetTileInfo and SetSingleTileInfo. Advantage is static will show in Tile and Content
                                    '      modes, disadvantage, no editing, but editing can still be done by the combobox on the details pane.
    '                                    lvrCol = 1
    '                                    If Not (lvrCol = 0) And NMLVCD.iSubitem = lvrCol Then ' Or m_ViewMode <> SB_VIEW_DETAILS
    '                                        Dim pitemvalueR       As Long
    '                                        Dim pitemrectR        As RECT
    '                                        Dim progrectR       As RECT
    '                                        Dim offRCR As Long
    '                                        offRCR = 2 * m_ScaleX
    '                                        pitemrectR = GetItemRec(hLVS, lvrCol, NMLVCD.NMCD.dwItemSpec)
    '                                        If m_ViewMode = SB_VIEW_CONTENTS Then
    '                                            pitemrectR.Right = pitemrectR.Right + 100 'No idea how to get the proper rect, but this renders ok
    '                                        End If
    '                                        Call SetRect(progrectR, pitemrectR.Left - offRCR, pitemrectR.Top - offRCR, pitemrectR.Right - offRCR, pitemrectR.Bottom - offRCR)
    '                                        progrectR.Top = progrectR.Top + 3
    '                                        progrectR.Bottom = progrectR.Bottom + 3
    '
    ''                                        pitemvalue = LVEntries(cllp).lPercent
    ''                                        If pitemvalue <> -1 Then
    ''                                            If pitemvalue < 0 Then pitemvalue = 0
    ''                                            If pitemvalue > 100 Then pitemvalue = 100
    ''                                            Call DrawProgressTheme(NMLVCD.NMCD.hDC, hLVS, progrect, pitemvalue)
    ''                                        End If
    '                                        pitemvalueR = LVEntries(cllp).lRating
    '                                        DebugAppend "DrawRating lvrCol=" & lvrCol & ",val=" & pitemvalueR
    '                                        Call PaintRating(NMLVCD.NMCD.hDC, 18, 18, ID_Disable, ID_Selected, pitemvalueR, progrectR)
    '                                        lReturn = CDRF_SKIPDEFAULT
    '                                        bHandled = True
    '                                        Exit Sub
    '                                    End If
                                    'End code for subitem progressbars
                                    '------------------------------
    
                                    ' lReturn = CDRF_NOTIFYSUBITEMDRAW
                                    ' bHandled = True
                                    ucWndProc = CDRF_NOTIFYSUBITEMDRAW
                                    Exit Function
                            End Select
                        End With
                    ElseIf tNMH.hWndFrom = hLVSHdr Then
                        Dim NMCD As NMCUSTOMDRAW
                        CopyMemory NMCD, ByVal lParam, LenB(NMCD)
                        Select Case NMCD.dwDrawStage
                            Case CDDS_PREPAINT
                                ' lReturn = CDRF_NOTIFYITEMDRAW
                                ' bHandled = True
                                ucWndProc = CDRF_NOTIFYITEMDRAW
                                Exit Function
                            Case CDDS_ITEMPREPAINT
                                hFont = hFontLVHdrMain
                                SelectObject NMCD.hDC, hFont
                                ' lReturn = CDRF_NEWFONT
                                ' bHandled = True
                                ucWndProc = CDRF_NEWFONT
                                Exit Function
                        End Select
                    End If
            
                Case HDN_DROPDOWN
                    If lng_hWnd = hLVS Then
                        CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                        Dim hdilp As Long
                        hdilp = CLng(GetHDItemlParam(hLVSHdr, tNMHEADER.iItem))
                        If hdilp = lRTColIdx Then
                            RatingColumnPopup
                        End If
                    End If
                    
                Case HDN_ITEMSTATEICONCLICK
                    If lng_hWnd = hLVS Then
                        CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                        DebugAppend "HDN_ISIC v=" & tNMHEADER.iButton & ",i=" & tNMHEADER.iItem
                        CopyMemory HDI, ByVal tNMHEADER.lPtrHDItem, LenB(HDI)
                        If (HDI.fmt And HDF_CHECKED) = HDF_CHECKED Then
                            DebugAppend "ColumnHeaderChecked"
                            bHoldSS = True
                            DebugAppend "Setting item change timer " & bICFlag, 9
                            bICFlag = False
                            bTmrFlag = True
                            tmrChangeSet.Enabled = True
                            tct1 = 0
                            ListView_SetCheckState hLVS, -1, 0
                            bHoldSS = False
                        Else
                            DebugAppend "ColumnHeaderUnchecked"
                            bHoldSS = True
                            DebugAppend "Setting item change timer " & bICFlag, 9
                            bICFlag = False
                            bTmrFlag = True
                            tmrChangeSet.Enabled = True
                            tct1 = 0
                            ListView_SetCheckState hLVS, -1, 1
                            bHoldSS = False
                        End If
                    End If
    
                Case HDN_BEGINFILTEREDIT
                    DebugAppend "BeginFilterEdit", 2
                        Dim tNMHEADERb As NMHEADER
                        CopyMemory tNMHEADERb, ByVal lParam, LenB(tNMHEADERb)
                        hFocused = tNMHEADERb.hdr.hWndFrom
                        pvSetIPAO
    
                Case HDN_FILTERBTNCLICK
                    If Ambient.UserMode Then
                        If lng_hWnd = hLVS Then
                            DebugAppend "FilterButtonClick"
                            Dim tFBC As NMHDFILTERBTNCLICK
                            CopyMemory tFBC, ByVal lParam, LenB(tFBC)
                            LVApplyFilterbar tFBC.iItem
                        End If
                    End If
    
                Case HDN_FILTERCHANGE
                    If Ambient.UserMode Then
                        DebugAppend "FilterChange"
                        CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                        LVApplyFilterbar tNMHEADER.iItem
                    End If
    
                Case HDN_ENDTRACKW
                    If m_HdrMinCX Then
                        CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                        CopyMemory HDI, ByVal tNMHEADER.lPtrHDItem, LenB(HDI)
                        If HDI.CXY < m_HdrMinCX Then
                            Dim hda As HDITEMW
                            hda.Mask = HDI_WIDTH
                            hda.CXY = m_HdrMinCX
                            Header_SetItemW hLVSHdr, tNMHEADER.iItem, hda
                            ' lReturn = 1
                            ' bHandled = True
                            ucWndProc = 1
                            Exit Function
                        End If
                    End If
                    
                Case HDN_OVERFLOWCLICK
                    CopyMemory tNMHEADER, ByVal lParam, LenB(tNMHEADER)
                    HDI.Mask = HDI_WIDTH
                    Header_GetItemW hLVSHdr, tNMHEADER.iItem, HDI
                    SendMessage hLVS, LVM_SCROLL, HDI.CXY \ 2, ByVal 0&
            End Select
     
    End Select
    '--------START CODE FOR RATING COLUMN-----------------------------------------------------------------------------
    handlelvr:
    ucWndProc = DefSubclassProc(lng_hWnd, uMsg, wParam, lParam)
    'If bBefore Then Exit Function
    If lng_hWnd = hLVS Then
        If (lvrCol > 0) And ((m_ViewMode = SB_VIEW_DETAILS)) Then ' Or (m_ViewMode = SB_VIEW_TILE) Or (m_ViewMode = SB_VIEW_CONTENTS)) Then 'check if column is there, but only show in details view
            DebugAppend "RatingCol is ACTIVE"
              Dim PT              As POINT
            ' HitTestInfo     As HD_HITTESTINFO
            Dim Count           As Long
            Dim itemrect        As RECT
            Dim WinRect         As RECT
            Dim itemvalue       As Long
            Dim TopIndex        As Long
            Dim lhti As LVHITTESTINFO
    
            Dim llp As LongPtr
            Const PicWidth = 18&
            Const PicHeight = 18&
            Dim ptt As LongLong
            
            If uMsg = WM_NCMOUSELEAVE And bLockRating = False Then
                lrLastIndex = -1
                uMsg = WM_PAINT
            End If
    
            If uMsg = WM_VSCROLL Then
                lrLastIndex = -1
                RedrawWindow hLVSHdr, 0&, 1&, 1
                uMsg = WM_PAINT
            End If
    lbu:
            If uMsg = WM_LBUTTONUP Or uMsg = WM_MOUSEMOVE Or uMsg = WM_PAINT Then
                TopIndex = CLng(SendMessage(hLVS, LVM_GETTOPINDEX, 0, 0))
                Call GetCursorPos(PT)
                Call ScreenToClient(hLVS, PT)
                Count = CLng(SendMessage(hLVS, LVM_GETITEMCOUNT, 0, 0))
                GetClientRect hLVS, WinRect
             End If
    
    
            If uMsg = WM_LBUTTONUP And bLockRating = False Then
                    DebugAppend "WM_LBUTTONUP"
                For i = TopIndex To Count - 1
                    itemrect = GetItemRec(hLVS, lvrCol, i)
                    
                    CopyMemory ptt, PT, 8
                    If PtInRect(itemrect, ptt) Then
                        itemvalue = Int((PT.x - itemrect.Left) / PicWidth) + 1
                        llp = GetLVItemlParam(hLVS, i)
    '                        If GetAsyncKeyState(VK_SHIFT) Then
                        If (GetKeyState(VK_SHIFT) And &H80) = &H80 Then
                            itemvalue = 0
                        End If
                        DebugAppend "Set rating=" & itemvalue & " for " & LVEntries(llp).sName
                        If LVEntries(llp).bRatingSupport = True Then
                            If SetFileRating2(llp, itemvalue) = S_OK Then
                                LVEntries(llp).lRating = itemvalue
                            End If
                            UpdateStatus mRatingTipStr
                        End If
    '                    bHandled = True
                        Exit Function
                    End If
    
                    If WinRect.Bottom < itemrect.Bottom Then Exit For
                Next
            End If
    
            If uMsg = WM_MOUSEMOVE And bLockRating = False Then
                    If lrLastIndex > -1 Then
                        itemrect = GetItemRec(lng_hWnd, lvrCol, lrLastIndex)
                        If (itemrect.Right = 0) Then DebugAppend "zero rect"
                            CopyMemory ptt, PT, 8
                            If PtInRect(itemrect, ptt) Then
                                itemvalue = Int((PT.x - itemrect.Left) / PicWidth) + 1
                                If ((IsItemInCollapsedGroup(hLVS, lrLastIndex) = False)) And (IsItemTruncated(hLVS, lrLastIndex) = False) Then
                                    lhti.PT.x = itemrect.Left
                                    lhti.PT.y = itemrect.Top
        '                            Call ListView_HitTest(hLVS, lhti)
        '                            If (lhti.Flags And LVHT_ABOVE) = 0 Then
        
                                        llp = GetLVItemlParam(hLVS, lrLastIndex)
                                        If LVEntries(llp).bRatingSupport Then
                                        Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Hot, itemvalue, itemrect)
                                        End If
        '                            End If
                                End If
        '                        bHandled = True
                                Exit Function
                            Else
                                llp = GetLVItemlParam(hLVS, lrLastIndex)
                                itemvalue = LVEntries(llp).lRating
                                If ((IsItemInCollapsedGroup(hLVS, lrLastIndex) = False)) And (IsItemTruncated(hLVS, lrLastIndex) = False) Then
    
                                    Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Selected, itemvalue, itemrect)
                                End If
                                lrLastIndex = -1
                            End If
                    End If
    
                    itemrect = GetItemRec(hLVS, lvrCol, 0)
                    If PT.x < itemrect.Left Or PT.x > itemrect.Left + PicWidth * 5 Then
        '                bHandled = True
                        Exit Function
                    End If
    
                    For i = TopIndex To Count - 1
                        itemrect = GetItemRec(hLVS, lvrCol, i)
                        CopyMemory ptt, PT, 8
                        If PtInRect(itemrect, ptt) Then
                            lrLastIndex = i
                            itemvalue = Int((PT.x - itemrect.Left) / PicWidth) + 1
                            If ((IsItemInCollapsedGroup(hLVS, lrLastIndex) = False)) And (IsItemTruncated(hLVS, lrLastIndex) = False) Then
                                llp = GetLVItemlParam(hLVS, lrLastIndex)
    
                                If LVEntries(llp).bRatingSupport Then
                                    Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Hot, itemvalue, itemrect)
                                End If
                            End If
        '                    bHandled = True
                            Exit Function
                        End If
                        If WinRect.Bottom + 10 < itemrect.Bottom Then Exit For
                    Next
            End If
    
            If uMsg = WM_PAINT Then
    
                For i = TopIndex To Count - 1
                    itemrect = GetItemRec(hLVS, lvrCol, i)
                    If (itemrect.Right = 0) Then DebugAppend "ucWndProc Rating WM_PAINT Warning: ItemRect.Right = 0"
                    If ((IsItemInCollapsedGroup(hLVS, i) = False)) And (IsItemTruncated(hLVS, i) = False) Then
                            llp = GetLVItemlParam(hLVS, i)
    
                        If lrLastIndex <> i Then
                            itemvalue = LVEntries(llp).lRating
    '                        DebugAppend LVEntries(llp).sName & ".bRatingSupport=" & LVEntries(llp).bRatingSupport
    '                        DebugAppend "PaintRating " & itemvalue
                            If LVEntries(llp).bRatingSupport Then
                                Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Selected, itemvalue, itemrect)
                            Else
                                Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Disable, itemvalue, itemrect)
                            End If
                        Else
                            itemvalue = Int((PT.x - itemrect.Left) / PicWidth) + 1
                            If LVEntries(llp).bRatingSupport Then
                                Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Hot, itemvalue, itemrect)
                            Else
                                Call PaintRating(hLVS, PicWidth, PicHeight, ID_Disable, ID_Disable, itemvalue, itemrect)
                            End If
                        End If
                        If WinRect.Bottom < itemrect.Bottom Then Exit For
                    End If
                Next i
            End If
        '  bHandled = True
            Exit Function
        End If '
    End If
    '--------END CODE FOR RATING COLUMN-----------------------------------------------------------------------------
    
    Exit Function
    
    e0:
    DebugAppend "ucWndProc->Error: " & Err.Description & ", 0x" & Hex$(Err.Number)
    Exit Function
    e1:
    DebugAppend "ucWndProc->Warning(1): " & Err.Description & ", 0x" & Hex$(Err.Number)
    Resume Next
    e2:
    DebugAppend "ucWndProc->Warning(2): " & Err.Description & ", 0x" & Hex$(Err.Number)
    Resume Next
    
    End Function
            
    #End Region
    

End Class



Module modIPAO
#Region "modIPAO"
Option Explicit
'From Krool's comctls:

#If False Then
Private VTableInterfaceInPlaceActiveObject, VTableInterfaceControl, VTableInterfacePerPropertyBrowsing
#End If
Public Enum VTableInterfaceConstants
VTableInterfaceInPlaceActiveObject = 1
VTableInterfaceControl = 2
VTableInterfacePerPropertyBrowsing = 3
End Enum
Private Type VTableIPAODataStruct
VTable As LongPtr
RefCount As Long
OriginalIOleIPAO As IOleInPlaceActiveObject
IOleIPAO As IOleInPlaceActiveObjectVB
End Type
Private Type VTableEnumVARIANTDataStruct
VTable As LongPtr
RefCount As Long
Enumerable As Object
Index As Long
Count As Long
End Type
Public Const CTRLINFO_EATS_RETURN As Long = 1
Public Const CTRLINFO_EATS_ESCAPE As Long = 2
Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As LongPtr)
Private Declare PtrSafe Sub SetLastError Lib "kernel32" (ByVal dwErrCode As Long)
' Private Declare PtrSafe Function CoTaskMemAlloc Lib "ole32" (ByVal cBytes As LongPtr) As LongPtr
' Private Declare PtrSafe Function SysAllocString Lib "oleaut32" (ByVal lpString As LongPtr) As LongPtr
' Private Declare PtrSafe Function DispCallFunc Lib "oleaut32" (ByVal lpvInstance As Long, ByVal oVft As Long, ByVal CallConv As Long, ByVal vtReturn As Integer, ByVal cActuals As Long, ByVal prgvt As Long, ByVal prgpvarg As Long, ByRef pvargResult As Variant) As Long
' Private Declare PtrSafe Function VariantCopyToPtr Lib "oleaut32" Alias "VariantCopy" (ByVal pvargDest As Long, ByRef pvargSrc As Variant) As Long
' Private Declare PtrSafe Function CLSIDFromString Lib "ole32" (ByVal lpszProgID As Long, ByRef pCLSID As Any) As Long
Private Const CC_STDCALL As Long = 4
Private Const E_OUTOFMEMORY As Long = &H8007000E
Private Const E_INVALIDARG As Long = &H80070057
Private Const E_NOTIMPL As Long = &H80004001
Private Const E_NOINTERFACE As Long = &H80004002
Private Const E_POINTER As Long = &H80004003
Private Const S_FALSE As Long = &H1
Private Const S_OK As Long = &H0
Private VTableIPAO(0 To 9) As LongPtr, VTableIPAOData As VTableIPAODataStruct
' Private VTableControl(0 To 6) As Long, OriginalVTableControl As Long
' Private VTablePPB(0 To 6) As Long, OriginalVTablePPB As Long, StringsOutArray() As String, CookiesOutArray() As Long
' Private VTableEnumVARIANT(0 To 6) As Long

Public Function SetVTableHandling(ByVal This As Object, ByVal OLEInterface As VTableInterfaceConstants) As Boolean
Select Case OLEInterface
    Case VTableInterfaceInPlaceActiveObject
        If VTableHandlingSupported(This, VTableInterfaceInPlaceActiveObject) = True Then
            VTableIPAOData.RefCount = VTableIPAOData.RefCount + 1
            SetVTableHandling = True
        End If
'    Case VTableInterfaceControl
'        If VTableHandlingSupported(This, VTableInterfaceControl) = True Then
'            Call ReplaceIOleControl(This)
'            SetVTableHandling = True
'        End If
'    Case VTableInterfacePerPropertyBrowsing
'        If VTableHandlingSupported(This, VTableInterfacePerPropertyBrowsing) = True Then
'            Call ReplaceIPPB(This)
'            SetVTableHandling = True
'        End If
End Select
End Function

Public Function RemoveVTableHandling(ByVal This As Object, ByVal OLEInterface As VTableInterfaceConstants) As Boolean
Select Case OLEInterface
    Case VTableInterfaceInPlaceActiveObject
        If VTableHandlingSupported(This, VTableInterfaceInPlaceActiveObject) = True Then
            VTableIPAOData.RefCount = VTableIPAOData.RefCount - 1
            RemoveVTableHandling = True
        End If
'    Case VTableInterfaceControl
'        If VTableHandlingSupported(This, VTableInterfaceControl) = True Then
'            Call RestoreIOleControl(This)
'            RemoveVTableHandling = True
'        End If
'    Case VTableInterfacePerPropertyBrowsing
'        If VTableHandlingSupported(This, VTableInterfacePerPropertyBrowsing) = True Then
'            Call RestoreIPPB(This)
'            RemoveVTableHandling = True
'        End If
End Select
End Function
Private Function VTableHandlingSupported(ByRef This As Object, ByVal OLEInterface As VTableInterfaceConstants) As Boolean
On Error GoTo CATCH_EXCEPTION
Select Case OLEInterface
    Case VTableInterfaceInPlaceActiveObject
        Dim ShadowIOleIPAO As IOleInPlaceActiveObject
        Dim ShadowIOleInPlaceActiveObjectVB As IOleInPlaceActiveObjectVB
        Set ShadowIOleIPAO = This
        Set ShadowIOleInPlaceActiveObjectVB = This
        VTableHandlingSupported = Not CBool(ShadowIOleIPAO Is Nothing Or ShadowIOleInPlaceActiveObjectVB Is Nothing)
'    Case VTableInterfaceControl
'        Dim ShadowIOleControl As OLEGuids.IOleControl
'        Dim ShadowIOleControlVB As OLEGuids.IOleControlVB
'        Set ShadowIOleControl = This
'        Set ShadowIOleControlVB = This
'        VTableHandlingSupported = Not CBool(ShadowIOleControl Is Nothing Or ShadowIOleControlVB Is Nothing)
'    Case VTableInterfacePerPropertyBrowsing
'        Dim ShadowIPPB As OLEGuids.IPerPropertyBrowsing
'        Dim ShadowIPerPropertyBrowsingVB As OLEGuids.IPerPropertyBrowsingVB
'        Set ShadowIPPB = This
'        Set ShadowIPerPropertyBrowsingVB = This
'        VTableHandlingSupported = Not CBool(ShadowIPPB Is Nothing Or ShadowIPerPropertyBrowsingVB Is Nothing)
End Select
CATCH_EXCEPTION:
End Function

Public Sub ActivateIPAO(ByVal This As Object)
On Error GoTo CATCH_EXCEPTION
Dim PropOleObject As IOleObject
Dim PropOleInPlaceSite As IOleInPlaceSite
Dim PropOleInPlaceFrame As IOleInPlaceFrame
Dim PropOleInPlaceUIWindow As IOleInPlaceUIWindow
Dim PropOleInPlaceActiveObject As IOleInPlaceActiveObject
Dim PosRect As OLERECT
Dim ClipRect As OLERECT
Dim FrameInfo As OLEINPLACEFRAMEINFO
Set PropOleObject = This
If VTableIPAOData.RefCount > 0 Then
    With VTableIPAOData
    .VTable = GetVTableIPAO()
    Set .OriginalIOleIPAO = This
    Set .IOleIPAO = This
    End With
    CopyMemory ByVal VarPtr(PropOleInPlaceActiveObject), VarPtr(VTableIPAOData), LenB(VTableIPAOData.VTable)
    PropOleInPlaceActiveObject.AddRef
Else
    Set PropOleInPlaceActiveObject = This
End If
Set PropOleInPlaceSite = PropOleObject.GetClientSite
PropOleInPlaceSite.GetWindowContext PropOleInPlaceFrame, PropOleInPlaceUIWindow, VarPtr(PosRect), VarPtr(ClipRect), VarPtr(FrameInfo)
PropOleInPlaceFrame.SetActiveObject PropOleInPlaceActiveObject, vbNullString
If Not PropOleInPlaceUIWindow Is Nothing Then PropOleInPlaceUIWindow.SetActiveObject PropOleInPlaceActiveObject, vbNullString
CATCH_EXCEPTION:
End Sub

Public Sub DeActivateIPAO()
On Error GoTo CATCH_EXCEPTION
If VTableIPAOData.OriginalIOleIPAO Is Nothing Then Exit Sub
Dim PropOleObject As IOleObject
Dim PropOleInPlaceSite As IOleInPlaceSite
Dim PropOleInPlaceFrame As IOleInPlaceFrame
Dim PropOleInPlaceUIWindow As IOleInPlaceUIWindow
Dim PosRect As OLERECT
Dim ClipRect As OLERECT
Dim FrameInfo As OLEINPLACEFRAMEINFO
Set PropOleObject = VTableIPAOData.OriginalIOleIPAO
Set PropOleInPlaceSite = PropOleObject.GetClientSite
PropOleInPlaceSite.GetWindowContext PropOleInPlaceFrame, PropOleInPlaceUIWindow, VarPtr(PosRect), VarPtr(ClipRect), VarPtr(FrameInfo)
PropOleInPlaceFrame.SetActiveObject Nothing, vbNullString
If Not PropOleInPlaceUIWindow Is Nothing Then PropOleInPlaceUIWindow.SetActiveObject Nothing, vbNullString
CATCH_EXCEPTION:
Set VTableIPAOData.OriginalIOleIPAO = Nothing
Set VTableIPAOData.IOleIPAO = Nothing
End Sub

Private Function GetVTableIPAO() As LongPtr
If VTableIPAO(0) = 0 Then
    VTableIPAO(0) = ProcPtr(AddressOf IOleIPAO_QueryInterface)
    VTableIPAO(1) = ProcPtr(AddressOf IOleIPAO_AddRef)
    VTableIPAO(2) = ProcPtr(AddressOf IOleIPAO_Release)
    VTableIPAO(3) = ProcPtr(AddressOf IOleIPAO_GetWindow)
    VTableIPAO(4) = ProcPtr(AddressOf IOleIPAO_ContextSensitiveHelp)
    VTableIPAO(5) = ProcPtr(AddressOf IOleIPAO_TranslateAccelerator)
    VTableIPAO(6) = ProcPtr(AddressOf IOleIPAO_OnFrameWindowActivate)
    VTableIPAO(7) = ProcPtr(AddressOf IOleIPAO_OnDocWindowActivate)
    VTableIPAO(8) = ProcPtr(AddressOf IOleIPAO_ResizeBorder)
    VTableIPAO(9) = ProcPtr(AddressOf IOleIPAO_EnableModeless)
End If
GetVTableIPAO = VarPtr(VTableIPAO(0))
End Function

Private Function IOleIPAO_QueryInterface(ByRef This As VTableIPAODataStruct, ByRef IID As OLECLSID, ByRef pvObj As LongPtr) As Long
If VarPtr(pvObj) = 0 Then
    IOleIPAO_QueryInterface = E_POINTER
    Exit Function
End If
' IID_IOleInPlaceActiveObject = {00000117-0000-0000-C000-000000000046}
If IID.Data1 = &H117 And IID.Data2 = &H0 And IID.Data3 = &H0 Then
    If IID.Data4(0) = &HC0 And IID.Data4(1) = &H0 And IID.Data4(2) = &H0 And IID.Data4(3) = &H0 _
    And IID.Data4(4) = &H0 And IID.Data4(5) = &H0 And IID.Data4(6) = &H0 And IID.Data4(7) = &H46 Then
        pvObj = VarPtr(This)
        IOleIPAO_AddRef This
        IOleIPAO_QueryInterface = S_OK
    Else
        This.OriginalIOleIPAO.QueryInterface(IID, pvObj)
        IOleIPAO_QueryInterface = Err.LastHResult
    End If
Else
    This.OriginalIOleIPAO.QueryInterface(IID, pvObj)
    IOleIPAO_QueryInterface = Err.LastHResult
End If
End Function

Private Function IOleIPAO_AddRef(ByRef This As VTableIPAODataStruct) As Long
This.OriginalIOleIPAO.AddRef
IOleIPAO_AddRef = Err.LastHResult
End Function

Private Function IOleIPAO_Release(ByRef This As VTableIPAODataStruct) As Long
This.OriginalIOleIPAO.Release
IOleIPAO_Release = Err.LastHResult
End Function

Private Function IOleIPAO_GetWindow(ByRef This As VTableIPAODataStruct, ByRef hWnd As LongPtr) As Long
This.OriginalIOleIPAO.GetWindow(hWnd)
IOleIPAO_GetWindow = Err.LastHResult
End Function

Private Function IOleIPAO_ContextSensitiveHelp(ByRef This As VTableIPAODataStruct, ByVal EnterMode As Long) As Long
This.OriginalIOleIPAO.ContextSensitiveHelp(EnterMode)
IOleIPAO_ContextSensitiveHelp = Err.LastHResult
End Function

Private Function IOleIPAO_TranslateAccelerator(ByRef This As VTableIPAODataStruct, ByRef Msg As MSG) As Long
If VarPtr(Msg) = 0 Then
    IOleIPAO_TranslateAccelerator = E_INVALIDARG
    Exit Function
End If
On Error GoTo CATCH_EXCEPTION
Dim Handled As Boolean
IOleIPAO_TranslateAccelerator = S_OK
This.IOleIPAO.TranslateAccelerator Handled, IOleIPAO_TranslateAccelerator, Msg.hWnd, Msg.message, Msg.wParam, Msg.lParam, GetShiftStateFromMsg()
If Handled = False Then
    This.OriginalIOleIPAO.TranslateAccelerator(VarPtr(Msg))
    IOleIPAO_TranslateAccelerator = Err.LastHResult
End If
Exit Function
CATCH_EXCEPTION:
    This.OriginalIOleIPAO.TranslateAccelerator(VarPtr(Msg))
    IOleIPAO_TranslateAccelerator = Err.LastHResult
End Function

Private Function IOleIPAO_OnFrameWindowActivate(ByRef This As VTableIPAODataStruct, ByVal Activate As Long) As Long
This.OriginalIOleIPAO.OnFrameWindowActivate(Activate)
IOleIPAO_OnFrameWindowActivate = Err.LastHResult
End Function

Private Function IOleIPAO_OnDocWindowActivate(ByRef This As VTableIPAODataStruct, ByVal Activate As Long) As Long
This.OriginalIOleIPAO.OnDocWindowActivate(Activate)
IOleIPAO_OnDocWindowActivate = Err.LastHResult
End Function

Private Function IOleIPAO_ResizeBorder(ByRef This As VTableIPAODataStruct, ByRef RC As OLERECT, ByVal UIWindow As IOleInPlaceUIWindow, ByVal FrameWindow As Long) As Long
This.OriginalIOleIPAO.ResizeBorder(VarPtr(RC), UIWindow, FrameWindow)
IOleIPAO_ResizeBorder = Err.LastHResult
End Function

Private Function IOleIPAO_EnableModeless(ByRef This As VTableIPAODataStruct, ByVal Enable As Long) As Long
This.OriginalIOleIPAO.EnableModeless(Enable)
IOleIPAO_EnableModeless = Err.LastHResult
End Function


Public Function ProcPtr(ByVal Address As LongPtr) As LongPtr
ProcPtr = Address
End Function
Public Function GetShiftStateFromMsg() As ShiftConstants
If GetKeyState(vbKeyShift) < 0 Then GetShiftStateFromMsg = vbShiftMask
If GetKeyState(vbKeyControl) < 0 Then GetShiftStateFromMsg = GetShiftStateFromMsg Or vbCtrlMask
If GetKeyState(vbKeyMenu) < 0 Then GetShiftStateFromMsg = GetShiftStateFromMsg Or vbAltMask
End Function
#End Region
End Module